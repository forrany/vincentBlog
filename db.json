{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/jupyter-toolbar.png","path":"images/jupyter-toolbar.png","modified":1,"renderable":0},{"_id":"source/images/move-box.gif","path":"images/move-box.gif","modified":1,"renderable":0},{"_id":"themes/next/source/manifest.json","path":"manifest.json","modified":1,"renderable":1},{"_id":"source/images/tween-letter.gif","path":"images/tween-letter.gif","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/VK-inverted.svg","path":"images/VK-inverted.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/VK.svg","path":"images/VK.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon16.ico","path":"images/favicon16.ico","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon32.ico","path":"images/favicon32.ico","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/vk.png","path":"images/vk.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/icons/android-icon-144x144.png","path":"images/icons/android-icon-144x144.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/icons/android-icon-192x192.png","path":"images/icons/android-icon-192x192.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/icons/android-icon-36x36.png","path":"images/icons/android-icon-36x36.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/icons/android-icon-48x48.png","path":"images/icons/android-icon-48x48.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/icons/android-icon-72x72.png","path":"images/icons/android-icon-72x72.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/icons/android-icon-96x96.png","path":"images/icons/android-icon-96x96.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/icons/apple-icon-114x114.png","path":"images/icons/apple-icon-114x114.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/icons/apple-icon-120x120.png","path":"images/icons/apple-icon-120x120.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/icons/apple-icon-144x144.png","path":"images/icons/apple-icon-144x144.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/icons/apple-icon-152x152.png","path":"images/icons/apple-icon-152x152.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/icons/apple-icon-180x180.png","path":"images/icons/apple-icon-180x180.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/icons/apple-icon-57x57.png","path":"images/icons/apple-icon-57x57.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/icons/apple-icon-60x60.png","path":"images/icons/apple-icon-60x60.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/icons/apple-icon-72x72.png","path":"images/icons/apple-icon-72x72.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/icons/apple-icon-76x76.png","path":"images/icons/apple-icon-76x76.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/icons/browserconfig.xml","path":"images/icons/browserconfig.xml","modified":1,"renderable":1},{"_id":"themes/next/source/images/icons/favicon-16x16.png","path":"images/icons/favicon-16x16.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/icons/apple-icon-precomposed.png","path":"images/icons/apple-icon-precomposed.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/icons/apple-icon.png","path":"images/icons/apple-icon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/icons/favicon-32x32.png","path":"images/icons/favicon-32x32.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/icons/favicon-96x96.png","path":"images/icons/favicon-96x96.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/icons/favicon.ico","path":"images/icons/favicon.ico","modified":1,"renderable":1},{"_id":"themes/next/source/images/icons/ms-icon-70x70.png","path":"images/icons/ms-icon-70x70.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/icons/ms-icon-144x144.png","path":"images/icons/ms-icon-144x144.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/icons/ms-icon-150x150.png","path":"images/icons/ms-icon-150x150.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/icons/ms-icon-310x310.png","path":"images/icons/ms-icon-310x310.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"source/images/text-transition.gif","path":"images/text-transition.gif","modified":1,"renderable":0},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"source/images/letter-transition-no-down.gif","path":"images/letter-transition-no-down.gif","modified":1,"renderable":0},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"source/images/complete-transition.gif","path":"images/complete-transition.gif","modified":1,"renderable":0},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/images/taka.png","path":"images/taka.png","modified":1,"renderable":1},{"_id":"source/images/bar-transition.gif","path":"images/bar-transition.gif","modified":1,"renderable":0}],"Cache":[{"_id":"source/manifest.json","hash":"fec1db3c1681dfb9965ff785e7c1ad6f5d5e1d9f","modified":1660722801244},{"_id":"themes/next/LICENSE.md","hash":"fc7227c508af3351120181cbf2f9b99dc41f063e","modified":1660722801252},{"_id":"themes/next/README.md","hash":"b4f780a96b0e5d3737eb93bc00da6de91f042c4b","modified":1660722801252},{"_id":"themes/next/_config.yml","hash":"8a7527615af0c5807c97f12b0f4fcd88a69e6c9e","modified":1660722801252},{"_id":"themes/next/bower.json","hash":"1c22c2003163799cb919f8e9dc1e3d20bd79151d","modified":1660722801252},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1660722801252},{"_id":"themes/next/gulpfile.coffee","hash":"48d2f9fa88a4210308fc41cc7d3f6d53989f71b7","modified":1660722801252},{"_id":"themes/next/package.json","hash":"f86ddeeddc0b5c6aff7de1e0101b1f64e7f29476","modified":1660722801256},{"_id":"source/_posts/2018-08-10-VK-mistake(1).md","hash":"da3d21e326082ece272c1f8743f53fa5b77c2faf","modified":1660722801232},{"_id":"source/_posts/2018-08-11-VK-mistake(2).md","hash":"060cd5b6adead31c953efee5da456b039c0e13ee","modified":1660722801232},{"_id":"source/_posts/2018-08-12-VK-mistake(3).md","hash":"ea34d2d54e04bca67692fc0d2f9d284ebf656b20","modified":1660722801232},{"_id":"source/_posts/2018-08-15-regular-expression.md","hash":"67bd0716ce89e9e3ede1433589ea0434999a84ea","modified":1660722801232},{"_id":"source/_posts/2018-08-21-front end interview algorithm.md","hash":"c2b06006be9fb6e2c30635b392c99d963b1eff50","modified":1660722801232},{"_id":"source/_posts/2018-08-22-how react works.md","hash":"d0cd47b17a932549ea36f5492915c78957da4cfc","modified":1660722801232},{"_id":"source/_posts/2018-08-28-How generator works.md","hash":"03950b91c0fcaa05868ce7688276a8ae53aea9c7","modified":1660722801232},{"_id":"source/_posts/2018-09-04-Tasks, microtasks, queues and schedules.md","hash":"522de45d1e5dbfefd9b3979f35d7461707d479b0","modified":1660722801232},{"_id":"source/_posts/2018-09-04-VK-mistake(4).md","hash":"95f85673c4860c4474af4c23b56a60c518d0de50","modified":1660722801232},{"_id":"source/_posts/2018-09-06-Class vs Factory function.md","hash":"3140acfec44b3cb259370fdcbeaa27c5999f56b1","modified":1660722801232},{"_id":"source/_posts/2018-09-10-Teachers' day.md","hash":"4cd09fdb5dddef1de68f15f4e9757250ec7f78ac","modified":1660722801232},{"_id":"source/_posts/2018-10-09-Better understand Buffer in Node.js.md","hash":"964efe3f0bc5fcea7c7b7b9d0744854189767f68","modified":1660722801232},{"_id":"source/_posts/2018-12-16-inherit in javascript.md","hash":"f6c419084496adee03c66a66e6afc04999bd5fa7","modified":1660722801232},{"_id":"source/_posts/Jupyter Notebook 前端二次开发初探.md","hash":"02bf7d119431feffdd220da1277f8890d7d9f0aa","modified":1660722801232},{"_id":"source/_posts/Most useful git commands.md","hash":"bf3851d95235eda07a4b360a286b05cb1065d622","modified":1660722801232},{"_id":"source/_posts/year-01-14-折腾路由-Padavan私有云.md","hash":"967da4e16ce561721a1211555ae660da2a2cf902","modified":1660722801232},{"_id":"source/_posts/year-02-16-D3可视化之初印象.md","hash":"a1300c8ff9e5a0d584a41f36340f2b83dd50bab6","modified":1660722801232},{"_id":"source/_posts/year-03-09-基于Mjpg-Streamer与树莓派的监控与拍照.md","hash":"1897e0ed4f138ad465d9b693add29fc8e20044e9","modified":1660722801232},{"_id":"source/_posts/year-03-13-D3 Transition with update pattern.md","hash":"67892e0709bf5f5e10bdafcd7e6e28f7944c6452","modified":1660722801232},{"_id":"source/_posts/year-03-20-D3数据可视化柱状图.md","hash":"947bc0a0f759bb15d464ef9ea6f02f43b93ead67","modified":1660722801232},{"_id":"source/_posts/year-03-23-PipeRobot-串口传输协议说明.md","hash":"272447deb9f28e2936fe5b711ca51d064805cea6","modified":1660722801232},{"_id":"source/_posts/year-03-23-树莓派创建热点与node脚本自动启动.md","hash":"cacb963433bd790e0dbd969332e5b35bc8be7185","modified":1660722801232},{"_id":"source/_posts/year-12-20-小米路由器R3G刷机指南.md","hash":"b080a1488ae1e115c25adf1db4293d99abc8c774","modified":1660722801232},{"_id":"source/about/index.md","hash":"8d6091e5fcdee751497b6791309615a0226bda13","modified":1660722801232},{"_id":"source/gallery/index.md","hash":"9aa20f7f0fb94af8a1ffb176492aa4ff874b8459","modified":1660722801232},{"_id":"source/images/jupyter-toolbar.png","hash":"596e9c313a4bb8b8ce6c6152a787b36f14e22b26","modified":1660722801240},{"_id":"source/images/move-box.gif","hash":"deba9ef8960a3fdbc97a10984473d2c0c59ebebb","modified":1660722801244},{"_id":"source/tags/index.md","hash":"590be540d0993303840643dab74e1ad60c435f82","modified":1660722801244},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1660722801252},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"141e989844d0b5ae2e09fb162a280715afb39b0d","modified":1660722801252},{"_id":"themes/next/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1660722801252},{"_id":"themes/next/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1660722801252},{"_id":"themes/next/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1660722801252},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"120750c03ec30ccaa470b113bbe39f3d423c67f0","modified":1660722801252},{"_id":"themes/next/docs/LICENSE","hash":"fe607fe22fc9308f6434b892a7f2d2c5514b8f0d","modified":1660722801252},{"_id":"themes/next/docs/MATH.md","hash":"e6023505dcccaef0b856102543585a13fc6af0b1","modified":1660722801252},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1660722801252},{"_id":"themes/next/languages/de.yml","hash":"fb478c5040a4e58a4c1ad5fb52a91e5983d65a3a","modified":1660722801252},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1660722801252},{"_id":"themes/next/languages/en.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1660722801252},{"_id":"themes/next/languages/fr.yml","hash":"0162a85ae4175e66882a9ead1249fedb89200467","modified":1660722801252},{"_id":"themes/next/languages/id.yml","hash":"e7fb582e117a0785036dcdbb853a6551263d6aa6","modified":1660722801252},{"_id":"themes/next/languages/it.yml","hash":"62ef41d0a9a3816939cb4d93a524e6930ab9c517","modified":1660722801252},{"_id":"themes/next/languages/ja.yml","hash":"e331b15b1fda0f2285d25853f834682ab8dc3c39","modified":1660722801252},{"_id":"themes/next/languages/ko.yml","hash":"fae155018ae0efdf68669b2c7dd3f959c2e45cc9","modified":1660722801252},{"_id":"themes/next/languages/nl.yml","hash":"bb9ce8adfa5ee94bc6b5fac6ad24ba4605d180d3","modified":1660722801252},{"_id":"themes/next/languages/pt-BR.yml","hash":"bfc80c8a363fa2e8dde38ea2bc85cd19e15ab653","modified":1660722801252},{"_id":"themes/next/languages/pt.yml","hash":"3cb51937d13ff12fcce747f972ccb664840a9ef3","modified":1660722801252},{"_id":"themes/next/languages/ru.yml","hash":"db0644e738d2306ac38567aa183ca3e859a3980f","modified":1660722801252},{"_id":"themes/next/languages/tr.yml","hash":"c5f0c20743b1dd52ccb256050b1397d023e6bcd9","modified":1660722801252},{"_id":"themes/next/languages/uk.yml","hash":"1eb59e581568da9a81d6e20541b4ada5fc1c55c0","modified":1660722801252},{"_id":"themes/next/languages/vi.yml","hash":"8da921dd8335dd676efce31bf75fdd4af7ce6448","modified":1660722801252},{"_id":"themes/next/languages/zh-CN.yml","hash":"fbbf3a0b664ae8e927c700b0a813692b94345156","modified":1660722801252},{"_id":"themes/next/languages/zh-HK.yml","hash":"7903b96912c605e630fb695534012501b2fad805","modified":1660722801252},{"_id":"themes/next/languages/zh-TW.yml","hash":"6e6d2cd8f4244cb1b349b94904cb4770935acefd","modified":1660722801252},{"_id":"themes/next/layout/_layout.swig","hash":"2c53b282edb0c7aa2a96cbd7e09ab66f05015394","modified":1660722801252},{"_id":"themes/next/layout/archive.swig","hash":"2b6450c6b6d2bcbcd123ad9f59922a5e323d77a5","modified":1660722801256},{"_id":"themes/next/layout/category.swig","hash":"5d955284a42f802a48560b4452c80906a5d1da02","modified":1660722801256},{"_id":"themes/next/layout/index.swig","hash":"c2a3896c64e96790edc10426ef586b6186a87f46","modified":1660722801256},{"_id":"themes/next/layout/page.swig","hash":"78874eee616c4c0dd4bf0d96e4f76224a0244ac2","modified":1660722801256},{"_id":"themes/next/layout/post.swig","hash":"318249db246a57e9422875a2457c6acfce974ba5","modified":1660722801256},{"_id":"themes/next/layout/schedule.swig","hash":"3268dd3d90d8b0e142cfa1a2ebb23355baeda148","modified":1660722801256},{"_id":"themes/next/layout/tag.swig","hash":"ba402ce8fd55e80b240e019e8d8c48949b194373","modified":1660722801256},{"_id":"themes/next/scripts/merge-configs.js","hash":"33afe97284d34542015d358a720823feeebef120","modified":1660722801256},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1660722801256},{"_id":"themes/next/source/manifest.json","hash":"fec1db3c1681dfb9965ff785e7c1ad6f5d5e1d9f","modified":1660722801264},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1660722801264},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1660722801264},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1660722801264},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1660722801256},{"_id":"source/images/tween-letter.gif","hash":"c3da13c4e0e8dc1690142ef61bdbecfea0db229c","modified":1660722801244},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1660722801252},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1660722801252},{"_id":"themes/next/docs/ru/README.md","hash":"953deb732e0b3b22c423122a189d6847d908c4b8","modified":1660722801252},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1660722801252},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"6855402e2ef59aae307e8bd2a990647d3a605eb8","modified":1660722801252},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"a45a791b49954331390d548ac34169d573ea5922","modified":1660722801252},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"bd2c955d9b7b1b45bd74a4536717d547e03fcde3","modified":1660722801252},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1660722801252},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1660722801252},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"24cf2618d164440b047bb9396263de83bee5b993","modified":1660722801252},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"8ac2f5d2a023211d8d8ea626cbf6b8dea67ac201","modified":1660722801252},{"_id":"themes/next/docs/zh-CN/README.md","hash":"15e55eb77616500fa4c64982d6bad9ac17a46e2a","modified":1660722801252},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"5da70d7fa0c988a66a469b9795d33d471a4a4433","modified":1660722801252},{"_id":"themes/next/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1660722801252},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1660722801252},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1660722801252},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"cbfb2167404258a0ad61e48d15347525ebc34e13","modified":1660722801252},{"_id":"themes/next/layout/_macro/post.swig","hash":"1b856766e8f1bf26f1146d0d910cac3dd34657b0","modified":1660722801252},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"4321a016939ba856a9ab7fac25b803acde55cddb","modified":1660722801252},{"_id":"themes/next/layout/_partials/comments.swig","hash":"dce2938bb54c3cef3319f09f2621b93bc41117a0","modified":1660722801252},{"_id":"themes/next/layout/_partials/footer.swig","hash":"07f88421bda86d9d5ff32d130b1cb1196b99a326","modified":1660722801252},{"_id":"themes/next/layout/_partials/github-banner.swig","hash":"c0f6f02d7d7eb20eb216003c6cfb4ea52060f791","modified":1660722801252},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1660722801252},{"_id":"themes/next/layout/_partials/post-edit.swig","hash":"06dac109504812b63766a80ede9ddacbd42d227d","modified":1660722801252},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"d01881f8056203c4b6920328db8c2ae8fa662a08","modified":1660722801252},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"d66bc7ec3cc03f60fcc7d555368a5b9b010f7f11","modified":1660722801252},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"97704b586310b74a88aa397ab9000fc58f13a3be","modified":1660722801252},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"0c3bb1526d71af862818e2e63ac5ba975c708ecb","modified":1660722801252},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"bd5acdd7e243730af72851092cf242e8fece25a2","modified":1660722801256},{"_id":"themes/next/layout/_third-party/copy-code.swig","hash":"a8ab2035654dd06d94faf11a35750529e922d719","modified":1660722801256},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"d359e638a86bd9664101c48e9344f21ec96e6a15","modified":1660722801256},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"927f19160ae14e7030df306fc7114ba777476282","modified":1660722801256},{"_id":"themes/next/layout/_third-party/pangu.swig","hash":"19f5cb569f046acf798c7640dab950fa76c46e17","modified":1660722801256},{"_id":"themes/next/layout/_third-party/pdf.swig","hash":"2a8503ef6fbc7257018121c04858b25074803013","modified":1660722801256},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"98f3f2cd6c6d8e4239cd13d8cf378c8e1e9290a9","modified":1660722801256},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1660722801256},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1b250c1b7945cb1029b9e855edb09854f7c8250a","modified":1660722801256},{"_id":"themes/next/scripts/helpers/engine.js","hash":"60eb1554456d9d0e5afc4a2d16f1580a0aa02da8","modified":1660722801256},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"15582e823d228c0b2288543c1eb460c40afad29b","modified":1660722801256},{"_id":"themes/next/scripts/tags/button.js","hash":"4b12c376bea894d23cca0f9fcb3d6518b6db279d","modified":1660722801256},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1660722801256},{"_id":"themes/next/scripts/tags/exturl.js","hash":"7ded3e7a78380b32de3e12f156e0978ef5c2890a","modified":1660722801256},{"_id":"themes/next/scripts/tags/full-image.js","hash":"e282bf5a7c70b3d354001e8f66d3bef1a4fbb79e","modified":1660722801256},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"981e01aaf45a1f0f23ce0796d03134f9e437aaca","modified":1660722801256},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"5db59d56f4f4082382bf1c16722e6c383892b0c5","modified":1660722801256},{"_id":"themes/next/scripts/tags/label.js","hash":"f0ecd3b5773b19a6bd93a819dfe0c49ee418e4de","modified":1660722801256},{"_id":"themes/next/scripts/tags/note.js","hash":"adb945ba93ac487d46b969ca4e59d3681b8f8d1c","modified":1660722801256},{"_id":"themes/next/scripts/tags/tabs.js","hash":"e37761253d68a29593fe9ed2fe403f49b6e971de","modified":1660722801256},{"_id":"themes/next/source/css/main.styl","hash":"c26ca6e7b5bd910b9046d6722c8e00be672890e0","modified":1660722801256},{"_id":"themes/next/source/images/VK-inverted.svg","hash":"b1c10ee375ba903c737e0cfa760b2d45feeb1d92","modified":1660722801256},{"_id":"themes/next/source/images/VK.svg","hash":"9192aed68c95d4a8a1cf8960b251b489f61449d2","modified":1660722801256},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1660722801256},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1660722801256},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1660722801256},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1660722801256},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1660722801260},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1660722801260},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1660722801260},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1660722801260},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1660722801260},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1660722801260},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1660722801260},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1660722801260},{"_id":"themes/next/source/images/favicon16.ico","hash":"5cb648cde151f0d8134095bfb906fb62abde0dbe","modified":1660722801260},{"_id":"themes/next/source/images/favicon32.ico","hash":"74aea0237f7f4a58a7b201de0d63e491afc4d0b6","modified":1660722801260},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1660722801260},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1660722801260},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1660722801260},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1660722801260},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1660722801260},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1660722801260},{"_id":"themes/next/source/images/vk.png","hash":"b4d73f412a345a50a8c3df66d519c163df549e7b","modified":1660722801260},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1660722801252},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1660722801252},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1660722801256},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1660722801256},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1660722801256},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1660722801256},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1660722801256},{"_id":"themes/next/layout/_macro/menu/menu-badge.swig","hash":"65c5e585982dae7ae1542cada71858b4ea1f73d6","modified":1660722801252},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"4049a29a6ea8498d6acd0060a26048b92480f3c3","modified":1660722801252},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"9683906502c10b3d3abeb733ebf3749b1d63a84f","modified":1660722801252},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1660722801252},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"fd780171713aada5eb4f4ffed8e714617c8ae6be","modified":1660722801252},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"2082f5077551123e695e8afec471c9c44b436acb","modified":1660722801252},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"3db735d0cd2d449edf2674310ac1e7c0043cb357","modified":1660722801252},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"69722be16ce5eae5c027168f9b2fded4776e1b53","modified":1660722801252},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"6e9b985455e1d66cddd87639e36fc8784669ecda","modified":1660722801252},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"5adc60100e129c1d0307bdcaa0c7b8e8375a6ea4","modified":1660722801252},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"2940df694fff28e8bf71b6546b4162f1e38227db","modified":1660722801252},{"_id":"themes/next/layout/_partials/post/reward.swig","hash":"64d65d9ad0cc94734ac6ded279e2b5dc870a1cab","modified":1660722801252},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"08fe30ce8909b920540231e36c97e28cfbce62b6","modified":1660722801252},{"_id":"themes/next/layout/_partials/post/wechat-subscriber.swig","hash":"a9e1346b83cf99e06bed59a53fc069279751e52a","modified":1660722801252},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a33b29ccbdc2248aedff23b04e0627f435824406","modified":1660722801252},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1660722801252},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"84538342373ab866309d3da15b71de2258c254b0","modified":1660722801252},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1660722801252},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1660722801252},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1660722801252},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1660722801252},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"2f73cc9ffb63534f0b6d8f0e9ee853c1af1b1244","modified":1660722801252},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"c7f2855f19dfdf18aba8c58d55b7489e631ed035","modified":1660722801252},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"94e106755c5fb6f40431b621beeba0bd33877e57","modified":1660722801252},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"94e106755c5fb6f40431b621beeba0bd33877e57","modified":1660722801252},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1660722801252},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"88995dd7406963fdd413a24a57447b2f60c2a70e","modified":1660722801252},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"591b2ccd9713ccb922b9fcf5e278b6de9c5ec30b","modified":1660722801252},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"07307f1f0e0e9858f2c7143cbdfcb2a9a92149ab","modified":1660722801252},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1660722801252},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1660722801252},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"beb53371c035b62e1a2c7bb76c63afbb595fe6e5","modified":1660722801252},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5dbeb640707a9c91357e373b9063a48c8e78f439","modified":1660722801252},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"438c6f5e6665d72f4ea7ee206011d669246f6102","modified":1660722801252},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"fae69a0e1a1d42f7bb44e594a29857d94594698b","modified":1660722801252},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"f240a50cd9b627620d9a374a29cf95f0c5e99d7c","modified":1660722801256},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1660722801256},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"cbb2c3ae3908b3c2025bcdab9e8336cca8611554","modified":1660722801256},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"c28f3f4aa31d7f996d26a97df6cd7ffa9bfd2cec","modified":1660722801256},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"aea70f5ec17917b75812020d8bf2aeabd434e8bc","modified":1660722801256},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c4c50a646254a186413bb5e4e320af4071a8b072","modified":1660722801256},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"c1b9f2d061baecafb60dae53f707595665176a93","modified":1660722801256},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"9809d63a4234c5f268ff0b489579149b849728fc","modified":1660722801256},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"f9c808bcbdfd17137a9fe6f16413770b7b9779d5","modified":1660722801256},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"607a60588ad3d226eb0fb50df601e2f2ff6d627c","modified":1660722801256},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"682202416764f9ea6c9eeea6a08c6213f263c9f7","modified":1660722801256},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"a6fc00ec7f5642aabd66aa1cf51c6acc5b10e012","modified":1660722801256},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"97dbc2035bcb5aa7eafb80a4202dc827cce34983","modified":1660722801256},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"07b310f6d24e1e64961f4bbbac7c67c42e40e14f","modified":1660722801256},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1660722801256},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1660722801256},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1660722801256},{"_id":"themes/next/scripts/filters/after_post_render/exturl.js","hash":"9c9f61b7bfb3349b03b1e61355f20232044b5fd8","modified":1660722801256},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"479ed81833156a2dfdcfba6ea2669e705c007560","modified":1660722801256},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1660722801256},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1660722801256},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"2640a54fa63bdd4c547eab7ce2fc1192cf0ccec8","modified":1660722801256},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"086f5979b3de091c3378512e6c5c2f8fcb4f6298","modified":1660722801256},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"e1f6f59ad6e562dfe640ee4ed5d1ac9b6aba4114","modified":1660722801256},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1660722801256},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c167eeb6b736f7b021fba98c38c2c21032ee1255","modified":1660722801256},{"_id":"themes/next/source/css/_variables/base.styl","hash":"f9b83d0385529e52ce7ba95ed5ed6b3d4e2419bb","modified":1660722801256},{"_id":"themes/next/source/images/icons/android-icon-144x144.png","hash":"21454388ef12ef1205064682c508351d40f7122e","modified":1660722801260},{"_id":"themes/next/source/images/icons/android-icon-192x192.png","hash":"8aa58488ae5b3a2b03a5b248263f1bfcfeb8cf8d","modified":1660722801260},{"_id":"themes/next/source/images/icons/android-icon-36x36.png","hash":"59684d421147f0a56e81b0fd976534e809556125","modified":1660722801260},{"_id":"themes/next/source/images/icons/android-icon-48x48.png","hash":"d401b08c1a39c7a3b6dd1cf015f500b44c3e23a7","modified":1660722801260},{"_id":"themes/next/source/images/icons/android-icon-72x72.png","hash":"73090feaf62471fe93abc08784139d5c5c9462d1","modified":1660722801260},{"_id":"themes/next/source/images/icons/android-icon-96x96.png","hash":"0b7f7f536874b905a80116fee7ff9a247affd8c0","modified":1660722801260},{"_id":"themes/next/source/images/icons/apple-icon-114x114.png","hash":"4d9ac951388c268e7fb5133376a2c0fdbf56024f","modified":1660722801260},{"_id":"themes/next/source/images/icons/apple-icon-120x120.png","hash":"42626bc7dd9cc9da7ba53727efa22a280da080f9","modified":1660722801260},{"_id":"themes/next/source/images/icons/apple-icon-144x144.png","hash":"21454388ef12ef1205064682c508351d40f7122e","modified":1660722801260},{"_id":"themes/next/source/images/icons/apple-icon-152x152.png","hash":"bec812ada745551f5b02c70236c5e52e3575c26a","modified":1660722801260},{"_id":"themes/next/source/images/icons/apple-icon-180x180.png","hash":"e8f69a207b8eda7b9ba26fcdc290f01e8cadd679","modified":1660722801260},{"_id":"themes/next/source/images/icons/apple-icon-57x57.png","hash":"d07d7bce93eebd7cd1e9e5068d7940076580de77","modified":1660722801260},{"_id":"themes/next/source/images/icons/apple-icon-60x60.png","hash":"1bd9dd4532b83f4ee9dadf73fcc5854d76fe891a","modified":1660722801260},{"_id":"themes/next/source/images/icons/apple-icon-72x72.png","hash":"73090feaf62471fe93abc08784139d5c5c9462d1","modified":1660722801260},{"_id":"themes/next/source/images/icons/apple-icon-76x76.png","hash":"07ddd586d788c498db6aad193d04cb50a6a297ae","modified":1660722801260},{"_id":"themes/next/source/images/icons/browserconfig.xml","hash":"853389b6c4273965899eb1302d665eb91395fd0c","modified":1660722801260},{"_id":"themes/next/source/images/icons/favicon-16x16.png","hash":"81b7b17bff44c5a31cf155678fa7b96e81d60eba","modified":1660722801260},{"_id":"themes/next/source/images/icons/apple-icon-precomposed.png","hash":"e9c02f8fbb43d779d9a4f56a9ce4081e46bf9a71","modified":1660722801260},{"_id":"themes/next/source/images/icons/apple-icon.png","hash":"e9c02f8fbb43d779d9a4f56a9ce4081e46bf9a71","modified":1660722801260},{"_id":"themes/next/source/images/icons/favicon-32x32.png","hash":"1b1e6d8ee9292bedaa2e371e44e09c75ed316ca7","modified":1660722801260},{"_id":"themes/next/source/images/icons/favicon-96x96.png","hash":"0b7f7f536874b905a80116fee7ff9a247affd8c0","modified":1660722801260},{"_id":"themes/next/source/images/icons/favicon.ico","hash":"201784c5a5f7d7514b90890e2a5e2cbb3337a2bc","modified":1660722801260},{"_id":"themes/next/source/images/icons/ms-icon-70x70.png","hash":"35a12ce3d4c32e1df4162bc6f41ae8940a9ee9aa","modified":1660722801260},{"_id":"themes/next/source/images/icons/ms-icon-144x144.png","hash":"21454388ef12ef1205064682c508351d40f7122e","modified":1660722801260},{"_id":"themes/next/source/images/icons/ms-icon-150x150.png","hash":"652b4f51303ba567d00ec8b6bfe33c00b378d4a6","modified":1660722801260},{"_id":"themes/next/source/images/icons/ms-icon-310x310.png","hash":"8ed6aa0b016b8960dc24ebebb3e99abff29e4570","modified":1660722801260},{"_id":"themes/next/source/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1660722801260},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1660722801260},{"_id":"themes/next/source/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1660722801260},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1660722801260},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1660722801260},{"_id":"themes/next/source/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1660722801260},{"_id":"themes/next/source/js/src/motion.js","hash":"b45d2c0d48f2c8e6a0621b8063845f76b89476cc","modified":1660722801260},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1660722801260},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1660722801260},{"_id":"themes/next/source/js/src/utils.js","hash":"28a79d317b7f4012917a54cac770551596bf6241","modified":1660722801260},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1660722801264},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1660722801264},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1660722801264},{"_id":"source/images/text-transition.gif","hash":"21bb1e8c9a14113c2b1c6a53d019ddfbefd23a47","modified":1660722801244},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1660722801260},{"_id":"source/images/letter-transition-no-down.gif","hash":"d5ea7fb5174ca14dfb3920eacb43495a4c3ee48e","modified":1660722801244},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"6958a97fde63e03983ec2394a4f8e408860fb42b","modified":1660722801256},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"b4a2f1d031fe44452cf55ded8211cf018235073a","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1660722801256},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"aebbd86500d819c4532ab290c62b6f432bc2f878","modified":1660722801256},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"ec2a62400642bb69edd9259e74e8f1c8ed53c42b","modified":1660722801256},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1660722801256},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"efc40a32487e0ac7b94b1ca81bdbdcc4ec8f2924","modified":1660722801256},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1660722801256},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1660722801256},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"02d138ed65060e98f20bc5b1dd59a791222b7156","modified":1660722801256},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"0b0064998a0f4690f1f85296008ac750c91c34c3","modified":1660722801256},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1660722801256},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1660722801256},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"fe2dc74726a515549956d233becda188da64f948","modified":1660722801256},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"2212511ae14258d93bec57993c0385e5ffbb382b","modified":1660722801256},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1660722801256},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"5e12572b18846250e016a872a738026478ceef37","modified":1660722801256},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1660722801256},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1660722801256},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"936132428a0d35b3947ccedd4c379940abcf223a","modified":1660722801256},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1660722801256},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1660722801256},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"d5e8ea6336bc2e237d501ed0d5bbcbbfe296c832","modified":1660722801256},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1660722801256},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"74c7dccf0a3ee9fc2ca25ad8e998243191813a0e","modified":1660722801256},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"215d8e943540d17bafabb14c2bf7707956b0ee92","modified":1660722801256},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1660722801256},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e7afdb343f9502f433f49044e42fe347719ce330","modified":1660722801256},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b5b936dddb7b4de4720cd1e8428b30a2f06d63fb","modified":1660722801256},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"5779cc8086b1cfde9bc4f1afdd85223bdc45f0a0","modified":1660722801256},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"958f3a70ea684264f23054d37d5e744a32c2e68a","modified":1660722801260},{"_id":"source/images/complete-transition.gif","hash":"73e7b751a9a40fa425bf0369c7b0410d2e0b74a9","modified":1660722801240},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1660722801264},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"39dee82d481dd9d44e33658960ec63e47cd0a715","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"ee37e6c465b9b2a7e39175fccfcbed14f2db039b","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"7cc3f36222494c9a1325c5347d7eb9ae53755a32","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"05e68adae13f4d99a6ac6493daab39c92e39a6bd","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"2dfa5fde3df69fba8282627e592fe637c2cbac6b","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"a1eeceea4b88fba184408cb2507bbef1f5e7b0e0","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"7dd9a0378ccff3e4a2003f486b1a34e74c20dac6","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"fb451dc4cc0355b57849c27d3eb110c73562f794","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"f2911a048e5c20ca2a059bd1087d98ac1c51681c","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"3b5a37ba5e70f92c1ee707c8053524e38adbb710","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"2356226157e8068b0e9bbe2f7d0f74e1ab49199b","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ca89b167d368eac50a4f808fa53ba67e69cbef94","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"417f05ff12a2aaca6ceeac8b7e7eb26e9440c4c3","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"1cf64afd4b49143972f7617869539be3adb91a5e","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"f4e9f870baa56eae423a123062f00e24cc780be1","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"549a8a0b5301d32acd86a97f17340cdfcd46fb63","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"8e058c99dd7d41f0bd34c7c28b6ac9fbb17dcb5e","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"578bb2d5f24cad39205bbafb4c39c7e9962b9fa9","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"3039df53b94b0847b0c451d2d227270b479cc184","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"35c0350096921dd8e2222ec41b6c17a4ea6b44f2","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"e18b90c97aaff027e795f5a0cb10476a71bf1c3a","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"b34bb2ea4d16e47e6fdc06cd4feb32d93ccbd779","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"4427ed3250483ed5b7baad74fa93474bd1eda729","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"43bc58daa8d35d5d515dc787ceb21dd77633fe49","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"10e9bb3392826a5a8f4cabfc14c6d81645f33fe6","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"ac7753d536341aa824d7bce0332735e838916995","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"6157665b8fc26ce4635c926128ffbd831a2fdd46","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"76937db9702053d772f6758d9cea4088c2a6e2a3","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"d4fefad868498adff03321b9dc38e75c61e08def","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"6ec8ea7b11a146777b6b8da0f71f0cc1dbd129df","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1660722801256},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"5e340ee2407a4e39cd708794cfcc718a5f398d7b","modified":1660722801256},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1660722801256},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1660722801256},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1660722801256},{"_id":"themes/next/source/images/taka.png","hash":"be15431a303f15c4854f329758ecbf498548ff00","modified":1660722801260},{"_id":"source/images/bar-transition.gif","hash":"bc928c994c383ec8832b3bc09cf075e2d782cbff","modified":1660722801240}],"Category":[],"Data":[],"Page":[{"_content":"{\n \"name\": \"VK-B\",\n \"theme_color\": \"#1e374b\",\n \"background_color\": \"#0d1216\",\n \"display\": \"fullscreen\",\n \"scope\": \"/\",\n \"start_url\": \"/\",\n \"icons\": [\n  {\n   \"src\": \"images/icons/android-icon-36x36.png\",\n   \"sizes\": \"36x36\",\n   \"type\": \"image/png\",\n   \"density\": \"0.75\"\n  },\n  {\n   \"src\": \"images/icons/android-icon-48x48.png\",\n   \"sizes\": \"48x48\",\n   \"type\": \"image/png\",\n   \"density\": \"1.0\"\n  },\n  {\n   \"src\": \"images/icons/android-icon-72x72.png\",\n   \"sizes\": \"72x72\",\n   \"type\": \"image/png\",\n   \"density\": \"1.5\"\n  },\n  {\n   \"src\": \"images/icons/android-icon-96x96.png\",\n   \"sizes\": \"96x96\",\n   \"type\": \"image/png\",\n   \"density\": \"2.0\"\n  },\n  {\n   \"src\": \"images/icons/android-icon-144x144.png\",\n   \"sizes\": \"144x144\",\n   \"type\": \"image/png\",\n   \"density\": \"3.0\"\n  },\n  {\n   \"src\": \"images/icons/android-icon-192x192.png\",\n   \"sizes\": \"192x192\",\n   \"type\": \"image/png\",\n   \"density\": \"4.0\"\n  }\n ]\n}","source":"manifest.json","raw":"{\n \"name\": \"VK-B\",\n \"theme_color\": \"#1e374b\",\n \"background_color\": \"#0d1216\",\n \"display\": \"fullscreen\",\n \"scope\": \"/\",\n \"start_url\": \"/\",\n \"icons\": [\n  {\n   \"src\": \"images/icons/android-icon-36x36.png\",\n   \"sizes\": \"36x36\",\n   \"type\": \"image/png\",\n   \"density\": \"0.75\"\n  },\n  {\n   \"src\": \"images/icons/android-icon-48x48.png\",\n   \"sizes\": \"48x48\",\n   \"type\": \"image/png\",\n   \"density\": \"1.0\"\n  },\n  {\n   \"src\": \"images/icons/android-icon-72x72.png\",\n   \"sizes\": \"72x72\",\n   \"type\": \"image/png\",\n   \"density\": \"1.5\"\n  },\n  {\n   \"src\": \"images/icons/android-icon-96x96.png\",\n   \"sizes\": \"96x96\",\n   \"type\": \"image/png\",\n   \"density\": \"2.0\"\n  },\n  {\n   \"src\": \"images/icons/android-icon-144x144.png\",\n   \"sizes\": \"144x144\",\n   \"type\": \"image/png\",\n   \"density\": \"3.0\"\n  },\n  {\n   \"src\": \"images/icons/android-icon-192x192.png\",\n   \"sizes\": \"192x192\",\n   \"type\": \"image/png\",\n   \"density\": \"4.0\"\n  }\n ]\n}","date":"2022-08-17T07:53:21.244Z","updated":"2022-08-17T07:53:21.244Z","path":"manifest.json","layout":"false","title":"","comments":1,"_id":"cl6xbhzhh0000zk080xv27b1e","content":"{\"name\":\"VK-B\",\"theme_color\":\"#1e374b\",\"background_color\":\"#0d1216\",\"display\":\"fullscreen\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"images/icons/android-icon-36x36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\",\"density\":\"0.75\"},{\"src\":\"images/icons/android-icon-48x48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\",\"density\":\"1.0\"},{\"src\":\"images/icons/android-icon-72x72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\",\"density\":\"1.5\"},{\"src\":\"images/icons/android-icon-96x96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\",\"density\":\"2.0\"},{\"src\":\"images/icons/android-icon-144x144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\",\"density\":\"3.0\"},{\"src\":\"images/icons/android-icon-192x192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\",\"density\":\"4.0\"}]}","site":{"data":{}},"excerpt":"","more":"{\"name\":\"VK-B\",\"theme_color\":\"#1e374b\",\"background_color\":\"#0d1216\",\"display\":\"fullscreen\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"images/icons/android-icon-36x36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\",\"density\":\"0.75\"},{\"src\":\"images/icons/android-icon-48x48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\",\"density\":\"1.0\"},{\"src\":\"images/icons/android-icon-72x72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\",\"density\":\"1.5\"},{\"src\":\"images/icons/android-icon-96x96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\",\"density\":\"2.0\"},{\"src\":\"images/icons/android-icon-144x144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\",\"density\":\"3.0\"},{\"src\":\"images/icons/android-icon-192x192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\",\"density\":\"4.0\"}]}"},{"title":"关于","date":"2018-12-17T09:10:06.000Z","comments":0,"_content":"\n曾经沧海难为水，除却巫山不是云\n\n我庆幸自己能度过曾经充实、圆满和浪漫的大学时光\n\n如今自己真正背起行囊，肩负责任\n\n纵没有当年洒脱，但求问心无愧\n\n我是Vincent Ko，一个有点小忧绪、文艺、爱音乐的小Coder\n\n> 对我来说，应该没有什么比认识你们，更幸运的了吧....\n>                                                ---V.K\n\n\nEmail: im.vincentko@gmail.com\n听说该野人还出没于： [掘金](https://juejin.im/user/5a66dff2f265da3e4f0a4f1b)、[github](forrany.github.com)、[微博](https://weibo.com/gaowencan/profile?rightmod=1&wvr=6&mod=personinfo) 等地，欢迎组队捕捉(￣▽￣)\"","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2018-12-17 17:10:06\ncomments: false\n---\n\n曾经沧海难为水，除却巫山不是云\n\n我庆幸自己能度过曾经充实、圆满和浪漫的大学时光\n\n如今自己真正背起行囊，肩负责任\n\n纵没有当年洒脱，但求问心无愧\n\n我是Vincent Ko，一个有点小忧绪、文艺、爱音乐的小Coder\n\n> 对我来说，应该没有什么比认识你们，更幸运的了吧....\n>                                                ---V.K\n\n\nEmail: im.vincentko@gmail.com\n听说该野人还出没于： [掘金](https://juejin.im/user/5a66dff2f265da3e4f0a4f1b)、[github](forrany.github.com)、[微博](https://weibo.com/gaowencan/profile?rightmod=1&wvr=6&mod=personinfo) 等地，欢迎组队捕捉(￣▽￣)\"","updated":"2022-08-17T07:53:21.232Z","path":"about/index.html","layout":"page","_id":"cl6xbhzjl0002zk08ofxusdxd","content":"<p>曾经沧海难为水，除却巫山不是云</p>\n<p>我庆幸自己能度过曾经充实、圆满和浪漫的大学时光</p>\n<p>如今自己真正背起行囊，肩负责任</p>\n<p>纵没有当年洒脱，但求问心无愧</p>\n<p>我是Vincent Ko，一个有点小忧绪、文艺、爱音乐的小Coder</p>\n<blockquote>\n<p>对我来说，应该没有什么比认识你们，更幸运的了吧….<br>                                               —V.K</p>\n</blockquote>\n<p>Email: <a href=\"mailto:im.vincentko@gmail.com\" target=\"_blank\" rel=\"noopener\">im.vincentko@gmail.com</a><br>听说该野人还出没于： <a href=\"https://juejin.im/user/5a66dff2f265da3e4f0a4f1b\" target=\"_blank\" rel=\"noopener\">掘金</a>、<a href=\"forrany.github.com\">github</a>、<a href=\"https://weibo.com/gaowencan/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo\" target=\"_blank\" rel=\"noopener\">微博</a> 等地，欢迎组队捕捉(￣▽￣)”</p>\n","site":{"data":{}},"excerpt":"","more":"<p>曾经沧海难为水，除却巫山不是云</p>\n<p>我庆幸自己能度过曾经充实、圆满和浪漫的大学时光</p>\n<p>如今自己真正背起行囊，肩负责任</p>\n<p>纵没有当年洒脱，但求问心无愧</p>\n<p>我是Vincent Ko，一个有点小忧绪、文艺、爱音乐的小Coder</p>\n<blockquote>\n<p>对我来说，应该没有什么比认识你们，更幸运的了吧….<br>                                               —V.K</p>\n</blockquote>\n<p>Email: <a href=\"mailto:im.vincentko@gmail.com\" target=\"_blank\" rel=\"noopener\">im.vincentko@gmail.com</a><br>听说该野人还出没于： <a href=\"https://juejin.im/user/5a66dff2f265da3e4f0a4f1b\" target=\"_blank\" rel=\"noopener\">掘金</a>、<a href=\"forrany.github.com\">github</a>、<a href=\"https://weibo.com/gaowencan/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo\" target=\"_blank\" rel=\"noopener\">微博</a> 等地，欢迎组队捕捉(￣▽￣)”</p>\n"},{"title":"gallery","date":"2018-12-17T09:33:02.000Z","_content":"","source":"gallery/index.md","raw":"---\ntitle: gallery\ndate: 2018-12-17 17:33:02\n---\n","updated":"2022-08-17T07:53:21.232Z","path":"gallery/index.html","comments":1,"layout":"page","_id":"cl6xbhzjn0004zk08q507lr15","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2022-08-17T07:53:21.244Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: \ntype: \"tags\"\ncomments: false\n---\n","updated":"2022-08-17T07:53:21.244Z","path":"tags/index.html","layout":"page","_id":"cl6xbhzjr0007zk08tekypu5q","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"layout":"post","title":"VK的秋招前端奇遇记(一)","subtitle":"","date":"2018-08-10T04:00:00.000Z","author":"Vinecnt Ko","header-img":"img/home-bg-o.jpg","header-mask":0.3,"catalog":true,"_content":"\n\n\n这个系列主要是对自己秋招以来，笔试、面试过程中的问题进行记录和解决，希望自己能够\"吃一堑长一智\"\n\n系列笔记：\n\n[1.VK的秋招前端奇遇记(一)](https://forrany.github.io/2018/08/10/2018-08-10-VK-mistake-1/)\n\n[2.VK的秋招前端奇遇记(二)](https://forrany.github.io/2018/08/11/2018-08-11-VK-mistake-2/)\n\n[3.VK的秋招前端奇遇记(三)](https://forrany.github.io/2018/08/12/2018-08-12-VK-mistake-3/)\n\n[4.VK的秋招前端奇遇记(四)](https://forrany.github.io/2018/09/04/2018-09-04-VK-mistake-4/)\n\n[5.番外篇：前端面试&笔试算法 Algorithm](https://forrany.github.io/2018/08/21/2018-08-21-front-end-interview-algorithm/)\n\n---\n\n参考资料：[37 Essential JavaScript Interview Questions](https://www.toptal.com/javascript/interview-questions)\n有很多内容来自以上参考，真的可以说是非常经典了！\n\n### Css相关\n#### 1. display:none与visibility:hidden的区别（2018拼多多前端笔试真题)\n答案：在视觉效果上，两者是相同的，但是对于操作dom上是不同的 。\ndispaly:none 会让dom的整个宽、高等相关位置元素失效，整个消失；\nvisibility:hidden 只是让该元素不可见，但是width以及原有位置是不会改变的\n\n### javascript\n#### 1. 基本问题\n##### 1) 是否可以使用 `typeof bar === 'object'`来检测bar是不是object类型，有和风险？\n\n答案： 有风险，js的基本数据类型有 `String` `Number` `Boolean` `undefined` `null`和一种复杂数据类型`object`(ES6新增了`symbol`)。\n\n对于复杂数据类型`object`，其实`typeof null`返回的也是`object`，因为本质上`null`就是一个占位用的对象。另一方面，数组`Array`也不能用`typeof`检测数据类型，因为同样会返回`object`。 \n\n因此，如果想要检测`bar`是不是`object`，可以这样子：\n```javascript   \n    console.log((bar !== null) && (tiopnuiop[yuiop[]\\\\]poi456/ypeof bar ==='object'))\n    //当然，如果认为function也是 object，可以用下面的语句\n    console.log((bar !== nul)&& (typeof bar ==='object')||(typeof bar ==='function'))\n```\n除此以外，还有比如Array的情况，因为Array也会返回`object`，如果我们不像让Array被认为是Object，就必须真正的认清Array，人情Array的方法有：\n```javascript\n console.log( bar instanceof Array)  // 如果数组，返回true\n console.log( Array.isArray(bar))  //ES5方法\n console.log( Ojbect.prototype.toString.call(arr) === '[object Array]') \n```\n\n##### 2) 以下两个函数是否等价\n```javascript\nfunction foo1()\n{\n  return {\n      bar: \"hello\"\n  };\n}\n\nfunction foo2()\n{\n  return\n  {\n      bar: \"hello\"\n  };\n}\n```\n答案： 不等价！！\n注意，第二个函数返回的是`undefined`\n```javascript\nconsole.log(foo1()); // {bar : \"hellp\"}\nconsole.log(foo2()); // undefined\n```\n这也是为什么函数返回对象时，或写大括号时，把`{`写在一边，因为第二个函数js会默认return后面返回的东西(是空),等价于\n```javascript\nreturn undefined\n{xxx}\n//后面当然，当然是写了也白写\n```\n\n##### 3) `NaN`是什么?它是什么类型？如何检测一个变量是不是`NaN`？\n答案： NaN即`Not A Number`，但实际上它是`Number`类型\n`typeof NaN` 将会返回`Number`。\n这个东西比较厉害，因为\n```javascript\nNaN === NaN  //false\n```\n你会发现，它自己都不等于它自己，因此判断变量是否是它，不能使用`===`。\n可以使用isNaN方法\n```javascript\n//检查变量是否是nan\nisNaN(bar);\nObject.is(bar,NaN); //ES6方法，这个方法会修正JS中的一些小bug\n```\nObject.is()方法，要求严格相等，且Object.is(NaN,NaN)会返回true\n\n#### 2.作用域相关问题\n以下程序的输出是什么:\n```javascript\n(function(){\n  var a = b = 3;\n})();\nconsole.log(\"a defined? \" + (typeof a !== 'undefined'));\nconsole.log(\"b defined? \" + (typeof b !== 'undefined'));\n```\n\n答案： \n a defined? false   \n b defined? true  \n 理解这道题的核心在于如何理解`var a = b = 3`这句话，实际上这句话等于\n``` javascript\nvar a; \nb = 3;\n```\n这样子，实际上，b是声明在了全局变量中(编译器在预编译帮你声明了，然而在严格模式下是不行的)\na是局部变量，所以在函数之外是没有定义的。\n\n#### 3.this&对象&数组\n##### 1)下面程序输出是什么\n```javascript\nvar myObject = {\n    foo: \"bar\",\n    func: function() {\n        var self = this;\n        console.log(\"outer func:  this.foo = \" + this.foo);\n        console.log(\"outer func:  self.foo = \" + self.foo);\n        (function() {\n            console.log(this);\n            console.log(\"inner func:  this.foo = \" + this.foo);\n            console.log(\"inner func:  self.foo = \" + self.foo);\n        }());\n    }\n};\nmyObject.func();\n\n\n//答案\nouter func: this.foo = bar\nouter func: serl.foo = bar\ninner func: this.foo = undefined\ninner func: self.foo = bar\n```\n分析： 搞清楚this的指向。记住以下几种规则\n\n* 谁调用，this指向谁 `xxx.fun()`\n* new一个对象，this指向实例本身`var c = new fun()`\n* 使用call/apply/bind修改this指向。\n\n看题目，`outer func`显然是第一种情况，谁调用，this指向谁，这个时候都是myOjbect。\n而在立即执行函数中，在这里this是没有进行绑定指向的，自然从属于window，所以这里this.foo是undefied\n\n补充关于箭头函数的this\n```javascript\nfunction a() {\n    return () => {\n        return () => {\n        \tconsole.log(this)\n        }\n    }\n}\nconsole.log(a()()())\n```\n注意：**箭头函数其实是没有 this 的，这个函数中的 this 只取决于他外面的第一个不是箭头函数的函数的 this。在这个例子中，因为调用 a 符合前面代码中的第一个情况，所以 this 是 window。并且 this 一旦绑定了上下文，就不会被任何代码改变。**\n\n##### 2)数组的filter，以下输出结果是什么(2018拼多多前端原题)\n```javascript\nvar arr = [1,2,3];\narr[10] = 9;\narr.filter((item)=> {\n    return item === undefined?\n})\n\n//答案\n[]\n```\n解析： 是的，答案的确是[]，不是`[undefined x 7]`。 \n首先，看下前两句执行后，arr是什么\n```javascript\nconsole.log(arr)\n//[1,2,3, emptyx7, 9]\nconsole.log(arr[5])\n//undefined\n```\n从上面结果可以看出，的确中间未定义的(显示为empty的是undefined)。那么，filter之后，不是应该返回为`undefined`的数据吗？\n\n是的，但是，当数组中都是undefined时，数组就是空，或者说`[empty x 7] === []`\n\n#### 4. JS小数计算不准确的bug\n以下代码返回值是什么\n```javascript\nconsole.log(0.1 + 0.2);\nconsole.log(0.1 + 0.2 == 0.3);\n\n//答案: 0.30000000000000004\n        false\n```\n解析： 详细的解析见连接,这里说一下解决办法 [0.1+0.2 != 0.3](https://segmentfault.com/a/1190000015051329?utm_source=index-hottest)\n```javascript\n//解决办法\nparseFloat((0.1+0.2).toFixed(10));\n```\n\n#### 5. 算法/思路相关\n##### 1) 讨论实现判断变量是否是整数的函数`isInter(x)`的实现\n\n答案： 在ES6中，是有现成的方法`Number.isInteger`可以使用的。如果自己实现，思路是什么呢\n```javascript\n//1 异或运算\nfunction isInter(x) {\n    return x ^ 0 === x\n}\n\n//2 取整\nreturn Math.round(x) === x  //同样可以用floor ceil\n\n//取余\nreturn (typeof x === 'number')&&(x % 1 === 0)\n```\n\n##### 2) 写一个sum方法，可以实现以下两种调用方式\n```javascript\nconsole.log(sum(2,3)) //5\nconsole.log(sum(2)(3)) //5\n```\n\n答案： \n```javascript\n//方法1\nvar sum = function(x,y) {\n    if(y === undefined) {\n        return function(y) {\n            return x + y;\n        }\n    }else {\n        return x + y;\n    }\n}\n\n//方法2\nvar sum = function(x){\n    if( arguments.length === 1) {\n        return function (y) {\n            return x + y;\n        }\n    } else {\n        console.log('here');\n        return arguments[0] + arguments[1];\n    }\n}\n```\n\n##### 3） 使用递归的方法，将obj变为obj2的格式(拼多多2018前端笔试真题)\n```javascript\nobj = [\n    {id:1,parent:null},\n    {id:2,parent:1},\n    {id:3,parent:2}\n]\n\nobj2 = {\n    obj:{\n        id: 1,\n        parent: null,\n        child: {\n            id: 2,\n            parent: 1,\n            child: {\n                id: ,3,\n                parent: 2\n            }\n        }\n    }\n}\n```","source":"_posts/2018-08-10-VK-mistake(1).md","raw":"---\nlayout:     post\ntitle:      \"VK的秋招前端奇遇记(一)\"\nsubtitle:   \"\"\ndate:       2018-08-10 12:00:00\nauthor:     \"Vinecnt Ko\"\nheader-img: \"img/home-bg-o.jpg\"\nheader-mask: 0.3\ncatalog:    true\ntags:\n    - 前端面试\n    - JavaScript\n    - 前端笔试\n---\n\n\n\n这个系列主要是对自己秋招以来，笔试、面试过程中的问题进行记录和解决，希望自己能够\"吃一堑长一智\"\n\n系列笔记：\n\n[1.VK的秋招前端奇遇记(一)](https://forrany.github.io/2018/08/10/2018-08-10-VK-mistake-1/)\n\n[2.VK的秋招前端奇遇记(二)](https://forrany.github.io/2018/08/11/2018-08-11-VK-mistake-2/)\n\n[3.VK的秋招前端奇遇记(三)](https://forrany.github.io/2018/08/12/2018-08-12-VK-mistake-3/)\n\n[4.VK的秋招前端奇遇记(四)](https://forrany.github.io/2018/09/04/2018-09-04-VK-mistake-4/)\n\n[5.番外篇：前端面试&笔试算法 Algorithm](https://forrany.github.io/2018/08/21/2018-08-21-front-end-interview-algorithm/)\n\n---\n\n参考资料：[37 Essential JavaScript Interview Questions](https://www.toptal.com/javascript/interview-questions)\n有很多内容来自以上参考，真的可以说是非常经典了！\n\n### Css相关\n#### 1. display:none与visibility:hidden的区别（2018拼多多前端笔试真题)\n答案：在视觉效果上，两者是相同的，但是对于操作dom上是不同的 。\ndispaly:none 会让dom的整个宽、高等相关位置元素失效，整个消失；\nvisibility:hidden 只是让该元素不可见，但是width以及原有位置是不会改变的\n\n### javascript\n#### 1. 基本问题\n##### 1) 是否可以使用 `typeof bar === 'object'`来检测bar是不是object类型，有和风险？\n\n答案： 有风险，js的基本数据类型有 `String` `Number` `Boolean` `undefined` `null`和一种复杂数据类型`object`(ES6新增了`symbol`)。\n\n对于复杂数据类型`object`，其实`typeof null`返回的也是`object`，因为本质上`null`就是一个占位用的对象。另一方面，数组`Array`也不能用`typeof`检测数据类型，因为同样会返回`object`。 \n\n因此，如果想要检测`bar`是不是`object`，可以这样子：\n```javascript   \n    console.log((bar !== null) && (tiopnuiop[yuiop[]\\\\]poi456/ypeof bar ==='object'))\n    //当然，如果认为function也是 object，可以用下面的语句\n    console.log((bar !== nul)&& (typeof bar ==='object')||(typeof bar ==='function'))\n```\n除此以外，还有比如Array的情况，因为Array也会返回`object`，如果我们不像让Array被认为是Object，就必须真正的认清Array，人情Array的方法有：\n```javascript\n console.log( bar instanceof Array)  // 如果数组，返回true\n console.log( Array.isArray(bar))  //ES5方法\n console.log( Ojbect.prototype.toString.call(arr) === '[object Array]') \n```\n\n##### 2) 以下两个函数是否等价\n```javascript\nfunction foo1()\n{\n  return {\n      bar: \"hello\"\n  };\n}\n\nfunction foo2()\n{\n  return\n  {\n      bar: \"hello\"\n  };\n}\n```\n答案： 不等价！！\n注意，第二个函数返回的是`undefined`\n```javascript\nconsole.log(foo1()); // {bar : \"hellp\"}\nconsole.log(foo2()); // undefined\n```\n这也是为什么函数返回对象时，或写大括号时，把`{`写在一边，因为第二个函数js会默认return后面返回的东西(是空),等价于\n```javascript\nreturn undefined\n{xxx}\n//后面当然，当然是写了也白写\n```\n\n##### 3) `NaN`是什么?它是什么类型？如何检测一个变量是不是`NaN`？\n答案： NaN即`Not A Number`，但实际上它是`Number`类型\n`typeof NaN` 将会返回`Number`。\n这个东西比较厉害，因为\n```javascript\nNaN === NaN  //false\n```\n你会发现，它自己都不等于它自己，因此判断变量是否是它，不能使用`===`。\n可以使用isNaN方法\n```javascript\n//检查变量是否是nan\nisNaN(bar);\nObject.is(bar,NaN); //ES6方法，这个方法会修正JS中的一些小bug\n```\nObject.is()方法，要求严格相等，且Object.is(NaN,NaN)会返回true\n\n#### 2.作用域相关问题\n以下程序的输出是什么:\n```javascript\n(function(){\n  var a = b = 3;\n})();\nconsole.log(\"a defined? \" + (typeof a !== 'undefined'));\nconsole.log(\"b defined? \" + (typeof b !== 'undefined'));\n```\n\n答案： \n a defined? false   \n b defined? true  \n 理解这道题的核心在于如何理解`var a = b = 3`这句话，实际上这句话等于\n``` javascript\nvar a; \nb = 3;\n```\n这样子，实际上，b是声明在了全局变量中(编译器在预编译帮你声明了，然而在严格模式下是不行的)\na是局部变量，所以在函数之外是没有定义的。\n\n#### 3.this&对象&数组\n##### 1)下面程序输出是什么\n```javascript\nvar myObject = {\n    foo: \"bar\",\n    func: function() {\n        var self = this;\n        console.log(\"outer func:  this.foo = \" + this.foo);\n        console.log(\"outer func:  self.foo = \" + self.foo);\n        (function() {\n            console.log(this);\n            console.log(\"inner func:  this.foo = \" + this.foo);\n            console.log(\"inner func:  self.foo = \" + self.foo);\n        }());\n    }\n};\nmyObject.func();\n\n\n//答案\nouter func: this.foo = bar\nouter func: serl.foo = bar\ninner func: this.foo = undefined\ninner func: self.foo = bar\n```\n分析： 搞清楚this的指向。记住以下几种规则\n\n* 谁调用，this指向谁 `xxx.fun()`\n* new一个对象，this指向实例本身`var c = new fun()`\n* 使用call/apply/bind修改this指向。\n\n看题目，`outer func`显然是第一种情况，谁调用，this指向谁，这个时候都是myOjbect。\n而在立即执行函数中，在这里this是没有进行绑定指向的，自然从属于window，所以这里this.foo是undefied\n\n补充关于箭头函数的this\n```javascript\nfunction a() {\n    return () => {\n        return () => {\n        \tconsole.log(this)\n        }\n    }\n}\nconsole.log(a()()())\n```\n注意：**箭头函数其实是没有 this 的，这个函数中的 this 只取决于他外面的第一个不是箭头函数的函数的 this。在这个例子中，因为调用 a 符合前面代码中的第一个情况，所以 this 是 window。并且 this 一旦绑定了上下文，就不会被任何代码改变。**\n\n##### 2)数组的filter，以下输出结果是什么(2018拼多多前端原题)\n```javascript\nvar arr = [1,2,3];\narr[10] = 9;\narr.filter((item)=> {\n    return item === undefined?\n})\n\n//答案\n[]\n```\n解析： 是的，答案的确是[]，不是`[undefined x 7]`。 \n首先，看下前两句执行后，arr是什么\n```javascript\nconsole.log(arr)\n//[1,2,3, emptyx7, 9]\nconsole.log(arr[5])\n//undefined\n```\n从上面结果可以看出，的确中间未定义的(显示为empty的是undefined)。那么，filter之后，不是应该返回为`undefined`的数据吗？\n\n是的，但是，当数组中都是undefined时，数组就是空，或者说`[empty x 7] === []`\n\n#### 4. JS小数计算不准确的bug\n以下代码返回值是什么\n```javascript\nconsole.log(0.1 + 0.2);\nconsole.log(0.1 + 0.2 == 0.3);\n\n//答案: 0.30000000000000004\n        false\n```\n解析： 详细的解析见连接,这里说一下解决办法 [0.1+0.2 != 0.3](https://segmentfault.com/a/1190000015051329?utm_source=index-hottest)\n```javascript\n//解决办法\nparseFloat((0.1+0.2).toFixed(10));\n```\n\n#### 5. 算法/思路相关\n##### 1) 讨论实现判断变量是否是整数的函数`isInter(x)`的实现\n\n答案： 在ES6中，是有现成的方法`Number.isInteger`可以使用的。如果自己实现，思路是什么呢\n```javascript\n//1 异或运算\nfunction isInter(x) {\n    return x ^ 0 === x\n}\n\n//2 取整\nreturn Math.round(x) === x  //同样可以用floor ceil\n\n//取余\nreturn (typeof x === 'number')&&(x % 1 === 0)\n```\n\n##### 2) 写一个sum方法，可以实现以下两种调用方式\n```javascript\nconsole.log(sum(2,3)) //5\nconsole.log(sum(2)(3)) //5\n```\n\n答案： \n```javascript\n//方法1\nvar sum = function(x,y) {\n    if(y === undefined) {\n        return function(y) {\n            return x + y;\n        }\n    }else {\n        return x + y;\n    }\n}\n\n//方法2\nvar sum = function(x){\n    if( arguments.length === 1) {\n        return function (y) {\n            return x + y;\n        }\n    } else {\n        console.log('here');\n        return arguments[0] + arguments[1];\n    }\n}\n```\n\n##### 3） 使用递归的方法，将obj变为obj2的格式(拼多多2018前端笔试真题)\n```javascript\nobj = [\n    {id:1,parent:null},\n    {id:2,parent:1},\n    {id:3,parent:2}\n]\n\nobj2 = {\n    obj:{\n        id: 1,\n        parent: null,\n        child: {\n            id: 2,\n            parent: 1,\n            child: {\n                id: ,3,\n                parent: 2\n            }\n        }\n    }\n}\n```","slug":"2018-08-10-VK-mistake-1","published":1,"updated":"2022-08-17T07:53:21.232Z","comments":1,"photos":[],"link":"","_id":"cl6xbhzjh0001zk08evpqbpx5","content":"<p>这个系列主要是对自己秋招以来，笔试、面试过程中的问题进行记录和解决，希望自己能够”吃一堑长一智”</p>\n<p>系列笔记：</p>\n<p><a href=\"https://forrany.github.io/2018/08/10/2018-08-10-VK-mistake-1/\" target=\"_blank\" rel=\"noopener\">1.VK的秋招前端奇遇记(一)</a></p>\n<p><a href=\"https://forrany.github.io/2018/08/11/2018-08-11-VK-mistake-2/\" target=\"_blank\" rel=\"noopener\">2.VK的秋招前端奇遇记(二)</a></p>\n<p><a href=\"https://forrany.github.io/2018/08/12/2018-08-12-VK-mistake-3/\" target=\"_blank\" rel=\"noopener\">3.VK的秋招前端奇遇记(三)</a></p>\n<p><a href=\"https://forrany.github.io/2018/09/04/2018-09-04-VK-mistake-4/\" target=\"_blank\" rel=\"noopener\">4.VK的秋招前端奇遇记(四)</a></p>\n<p><a href=\"https://forrany.github.io/2018/08/21/2018-08-21-front-end-interview-algorithm/\" target=\"_blank\" rel=\"noopener\">5.番外篇：前端面试&amp;笔试算法 Algorithm</a></p>\n<hr>\n<p>参考资料：<a href=\"https://www.toptal.com/javascript/interview-questions\" target=\"_blank\" rel=\"noopener\">37 Essential JavaScript Interview Questions</a><br>有很多内容来自以上参考，真的可以说是非常经典了！</p>\n<h3 id=\"Css相关\"><a href=\"#Css相关\" class=\"headerlink\" title=\"Css相关\"></a>Css相关</h3><h4 id=\"1-display-none与visibility-hidden的区别（2018拼多多前端笔试真题\"><a href=\"#1-display-none与visibility-hidden的区别（2018拼多多前端笔试真题\" class=\"headerlink\" title=\"1. display:none与visibility:hidden的区别（2018拼多多前端笔试真题)\"></a>1. display:none与visibility:hidden的区别（2018拼多多前端笔试真题)</h4><p>答案：在视觉效果上，两者是相同的，但是对于操作dom上是不同的 。<br>dispaly:none 会让dom的整个宽、高等相关位置元素失效，整个消失；<br>visibility:hidden 只是让该元素不可见，但是width以及原有位置是不会改变的</p>\n<h3 id=\"javascript\"><a href=\"#javascript\" class=\"headerlink\" title=\"javascript\"></a>javascript</h3><h4 id=\"1-基本问题\"><a href=\"#1-基本问题\" class=\"headerlink\" title=\"1. 基本问题\"></a>1. 基本问题</h4><h5 id=\"1-是否可以使用-typeof-bar-39-object-39-来检测bar是不是object类型，有和风险？\"><a href=\"#1-是否可以使用-typeof-bar-39-object-39-来检测bar是不是object类型，有和风险？\" class=\"headerlink\" title=\"1) 是否可以使用 typeof bar === &#39;object&#39;来检测bar是不是object类型，有和风险？\"></a>1) 是否可以使用 <code>typeof bar === &#39;object&#39;</code>来检测bar是不是object类型，有和风险？</h5><p>答案： 有风险，js的基本数据类型有 <code>String</code> <code>Number</code> <code>Boolean</code> <code>undefined</code> <code>null</code>和一种复杂数据类型<code>object</code>(ES6新增了<code>symbol</code>)。</p>\n<p>对于复杂数据类型<code>object</code>，其实<code>typeof null</code>返回的也是<code>object</code>，因为本质上<code>null</code>就是一个占位用的对象。另一方面，数组<code>Array</code>也不能用<code>typeof</code>检测数据类型，因为同样会返回<code>object</code>。 </p>\n<p>因此，如果想要检测<code>bar</code>是不是<code>object</code>，可以这样子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log((bar !== <span class=\"literal\">null</span>) &amp;&amp; (tiopnuiop[yuiop[]\\\\]poi456/ypeof bar ===<span class=\"string\">'object'</span>))</span><br><span class=\"line\"><span class=\"comment\">//当然，如果认为function也是 object，可以用下面的语句</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((bar !== nul)&amp;&amp; (<span class=\"keyword\">typeof</span> bar ===<span class=\"string\">'object'</span>)||(<span class=\"keyword\">typeof</span> bar ===<span class=\"string\">'function'</span>))</span><br></pre></td></tr></table></figure></p>\n<p>除此以外，还有比如Array的情况，因为Array也会返回<code>object</code>，如果我们不像让Array被认为是Object，就必须真正的认清Array，人情Array的方法有：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log( bar <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>)  <span class=\"comment\">// 如果数组，返回true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( <span class=\"built_in\">Array</span>.isArray(bar))  <span class=\"comment\">//ES5方法</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( Ojbect.prototype.toString.call(arr) === <span class=\"string\">'[object Array]'</span>)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"2-以下两个函数是否等价\"><a href=\"#2-以下两个函数是否等价\" class=\"headerlink\" title=\"2) 以下两个函数是否等价\"></a>2) 以下两个函数是否等价</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo1</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      bar: <span class=\"string\">\"hello\"</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo2</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      bar: <span class=\"string\">\"hello\"</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>答案： 不等价！！<br>注意，第二个函数返回的是<code>undefined</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(foo1()); <span class=\"comment\">// &#123;bar : \"hellp\"&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo2()); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure></p>\n<p>这也是为什么函数返回对象时，或写大括号时，把<code>{</code>写在一边，因为第二个函数js会默认return后面返回的东西(是空),等价于<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">undefined</span></span><br><span class=\"line\">&#123;xxx&#125;</span><br><span class=\"line\"><span class=\"comment\">//后面当然，当然是写了也白写</span></span><br></pre></td></tr></table></figure></p>\n<h5 id=\"3-NaN是什么-它是什么类型？如何检测一个变量是不是NaN？\"><a href=\"#3-NaN是什么-它是什么类型？如何检测一个变量是不是NaN？\" class=\"headerlink\" title=\"3) NaN是什么?它是什么类型？如何检测一个变量是不是NaN？\"></a>3) <code>NaN</code>是什么?它是什么类型？如何检测一个变量是不是<code>NaN</code>？</h5><p>答案： NaN即<code>Not A Number</code>，但实际上它是<code>Number</code>类型<br><code>typeof NaN</code> 将会返回<code>Number</code>。<br>这个东西比较厉害，因为<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">NaN</span> === <span class=\"literal\">NaN</span>  <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></p>\n<p>你会发现，它自己都不等于它自己，因此判断变量是否是它，不能使用<code>===</code>。<br>可以使用isNaN方法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//检查变量是否是nan</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(bar);</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.is(bar,<span class=\"literal\">NaN</span>); <span class=\"comment\">//ES6方法，这个方法会修正JS中的一些小bug</span></span><br></pre></td></tr></table></figure></p>\n<p>Object.is()方法，要求严格相等，且Object.is(NaN,NaN)会返回true</p>\n<h4 id=\"2-作用域相关问题\"><a href=\"#2-作用域相关问题\" class=\"headerlink\" title=\"2.作用域相关问题\"></a>2.作用域相关问题</h4><p>以下程序的输出是什么:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = b = <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"a defined? \"</span> + (<span class=\"keyword\">typeof</span> a !== <span class=\"string\">'undefined'</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"b defined? \"</span> + (<span class=\"keyword\">typeof</span> b !== <span class=\"string\">'undefined'</span>));</span><br></pre></td></tr></table></figure></p>\n<p>答案：<br> a defined? false<br> b defined? true<br> 理解这道题的核心在于如何理解<code>var a = b = 3</code>这句话，实际上这句话等于<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a; </span><br><span class=\"line\">b = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure></p>\n<p>这样子，实际上，b是声明在了全局变量中(编译器在预编译帮你声明了，然而在严格模式下是不行的)<br>a是局部变量，所以在函数之外是没有定义的。</p>\n<h4 id=\"3-this-amp-对象-amp-数组\"><a href=\"#3-this-amp-对象-amp-数组\" class=\"headerlink\" title=\"3.this&amp;对象&amp;数组\"></a>3.this&amp;对象&amp;数组</h4><h5 id=\"1-下面程序输出是什么\"><a href=\"#1-下面程序输出是什么\" class=\"headerlink\" title=\"1)下面程序输出是什么\"></a>1)下面程序输出是什么</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">    foo: <span class=\"string\">\"bar\"</span>,</span><br><span class=\"line\">    func: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"outer func:  this.foo = \"</span> + <span class=\"keyword\">this</span>.foo);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"outer func:  self.foo = \"</span> + self.foo);</span><br><span class=\"line\">        (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"inner func:  this.foo = \"</span> + <span class=\"keyword\">this</span>.foo);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"inner func:  self.foo = \"</span> + self.foo);</span><br><span class=\"line\">        &#125;());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myObject.func();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//答案</span></span><br><span class=\"line\">outer func: <span class=\"keyword\">this</span>.foo = bar</span><br><span class=\"line\">outer func: serl.foo = bar</span><br><span class=\"line\">inner func: <span class=\"keyword\">this</span>.foo = <span class=\"literal\">undefined</span></span><br><span class=\"line\">inner func: self.foo = bar</span><br></pre></td></tr></table></figure>\n<p>分析： 搞清楚this的指向。记住以下几种规则</p>\n<ul>\n<li>谁调用，this指向谁 <code>xxx.fun()</code></li>\n<li>new一个对象，this指向实例本身<code>var c = new fun()</code></li>\n<li>使用call/apply/bind修改this指向。</li>\n</ul>\n<p>看题目，<code>outer func</code>显然是第一种情况，谁调用，this指向谁，这个时候都是myOjbect。<br>而在立即执行函数中，在这里this是没有进行绑定指向的，自然从属于window，所以这里this.foo是undefied</p>\n<p>补充关于箭头函数的this<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        \t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a()()())</span><br></pre></td></tr></table></figure></p>\n<p>注意：<strong>箭头函数其实是没有 this 的，这个函数中的 this 只取决于他外面的第一个不是箭头函数的函数的 this。在这个例子中，因为调用 a 符合前面代码中的第一个情况，所以 this 是 window。并且 this 一旦绑定了上下文，就不会被任何代码改变。</strong></p>\n<h5 id=\"2-数组的filter，以下输出结果是什么-2018拼多多前端原题\"><a href=\"#2-数组的filter，以下输出结果是什么-2018拼多多前端原题\" class=\"headerlink\" title=\"2)数组的filter，以下输出结果是什么(2018拼多多前端原题)\"></a>2)数组的filter，以下输出结果是什么(2018拼多多前端原题)</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">arr[<span class=\"number\">10</span>] = <span class=\"number\">9</span>;</span><br><span class=\"line\">arr.filter(<span class=\"function\">(<span class=\"params\">item</span>)=&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> item === <span class=\"literal\">undefined</span>?</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//答案</span></span><br><span class=\"line\">[]</span><br></pre></td></tr></table></figure>\n<p>解析： 是的，答案的确是[]，不是<code>[undefined x 7]</code>。<br>首先，看下前两句执行后，arr是什么<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(arr)</span><br><span class=\"line\"><span class=\"comment\">//[1,2,3, emptyx7, 9]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr[<span class=\"number\">5</span>])</span><br><span class=\"line\"><span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure></p>\n<p>从上面结果可以看出，的确中间未定义的(显示为empty的是undefined)。那么，filter之后，不是应该返回为<code>undefined</code>的数据吗？</p>\n<p>是的，但是，当数组中都是undefined时，数组就是空，或者说<code>[empty x 7] === []</code></p>\n<h4 id=\"4-JS小数计算不准确的bug\"><a href=\"#4-JS小数计算不准确的bug\" class=\"headerlink\" title=\"4. JS小数计算不准确的bug\"></a>4. JS小数计算不准确的bug</h4><p>以下代码返回值是什么<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">0.1</span> + <span class=\"number\">0.2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">0.1</span> + <span class=\"number\">0.2</span> == <span class=\"number\">0.3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//答案: 0.30000000000000004</span></span><br><span class=\"line\">        <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure></p>\n<p>解析： 详细的解析见连接,这里说一下解决办法 <a href=\"https://segmentfault.com/a/1190000015051329?utm_source=index-hottest\" target=\"_blank\" rel=\"noopener\">0.1+0.2 != 0.3</a><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//解决办法</span></span><br><span class=\"line\"><span class=\"built_in\">parseFloat</span>((<span class=\"number\">0.1</span>+<span class=\"number\">0.2</span>).toFixed(<span class=\"number\">10</span>));</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-算法-思路相关\"><a href=\"#5-算法-思路相关\" class=\"headerlink\" title=\"5. 算法/思路相关\"></a>5. 算法/思路相关</h4><h5 id=\"1-讨论实现判断变量是否是整数的函数isInter-x-的实现\"><a href=\"#1-讨论实现判断变量是否是整数的函数isInter-x-的实现\" class=\"headerlink\" title=\"1) 讨论实现判断变量是否是整数的函数isInter(x)的实现\"></a>1) 讨论实现判断变量是否是整数的函数<code>isInter(x)</code>的实现</h5><p>答案： 在ES6中，是有现成的方法<code>Number.isInteger</code>可以使用的。如果自己实现，思路是什么呢<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1 异或运算</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isInter</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x ^ <span class=\"number\">0</span> === x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2 取整</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.round(x) === x  <span class=\"comment\">//同样可以用floor ceil</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//取余</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> (<span class=\"keyword\">typeof</span> x === <span class=\"string\">'number'</span>)&amp;&amp;(x % <span class=\"number\">1</span> === <span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"2-写一个sum方法，可以实现以下两种调用方式\"><a href=\"#2-写一个sum方法，可以实现以下两种调用方式\" class=\"headerlink\" title=\"2) 写一个sum方法，可以实现以下两种调用方式\"></a>2) 写一个sum方法，可以实现以下两种调用方式</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(<span class=\"number\">2</span>,<span class=\"number\">3</span>)) <span class=\"comment\">//5</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(<span class=\"number\">2</span>)(<span class=\"number\">3</span>)) <span class=\"comment\">//5</span></span><br></pre></td></tr></table></figure>\n<p>答案：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方法1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(y === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//方法2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( <span class=\"built_in\">arguments</span>.length === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'here'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>] + <span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"3）-使用递归的方法，将obj变为obj2的格式-拼多多2018前端笔试真题\"><a href=\"#3）-使用递归的方法，将obj变为obj2的格式-拼多多2018前端笔试真题\" class=\"headerlink\" title=\"3） 使用递归的方法，将obj变为obj2的格式(拼多多2018前端笔试真题)\"></a>3） 使用递归的方法，将obj变为obj2的格式(拼多多2018前端笔试真题)</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj = [</span><br><span class=\"line\">    &#123;<span class=\"attr\">id</span>:<span class=\"number\">1</span>,<span class=\"attr\">parent</span>:<span class=\"literal\">null</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">id</span>:<span class=\"number\">2</span>,<span class=\"attr\">parent</span>:<span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">id</span>:<span class=\"number\">3</span>,<span class=\"attr\">parent</span>:<span class=\"number\">2</span>&#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">obj2 = &#123;</span><br><span class=\"line\">    obj:&#123;</span><br><span class=\"line\">        id: <span class=\"number\">1</span>,</span><br><span class=\"line\">        parent: <span class=\"literal\">null</span>,</span><br><span class=\"line\">        child: &#123;</span><br><span class=\"line\">            id: <span class=\"number\">2</span>,</span><br><span class=\"line\">            parent: <span class=\"number\">1</span>,</span><br><span class=\"line\">            child: &#123;</span><br><span class=\"line\">                id: ,<span class=\"number\">3</span>,</span><br><span class=\"line\">                parent: <span class=\"number\">2</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>这个系列主要是对自己秋招以来，笔试、面试过程中的问题进行记录和解决，希望自己能够”吃一堑长一智”</p>\n<p>系列笔记：</p>\n<p><a href=\"https://forrany.github.io/2018/08/10/2018-08-10-VK-mistake-1/\" target=\"_blank\" rel=\"noopener\">1.VK的秋招前端奇遇记(一)</a></p>\n<p><a href=\"https://forrany.github.io/2018/08/11/2018-08-11-VK-mistake-2/\" target=\"_blank\" rel=\"noopener\">2.VK的秋招前端奇遇记(二)</a></p>\n<p><a href=\"https://forrany.github.io/2018/08/12/2018-08-12-VK-mistake-3/\" target=\"_blank\" rel=\"noopener\">3.VK的秋招前端奇遇记(三)</a></p>\n<p><a href=\"https://forrany.github.io/2018/09/04/2018-09-04-VK-mistake-4/\" target=\"_blank\" rel=\"noopener\">4.VK的秋招前端奇遇记(四)</a></p>\n<p><a href=\"https://forrany.github.io/2018/08/21/2018-08-21-front-end-interview-algorithm/\" target=\"_blank\" rel=\"noopener\">5.番外篇：前端面试&amp;笔试算法 Algorithm</a></p>\n<hr>\n<p>参考资料：<a href=\"https://www.toptal.com/javascript/interview-questions\" target=\"_blank\" rel=\"noopener\">37 Essential JavaScript Interview Questions</a><br>有很多内容来自以上参考，真的可以说是非常经典了！</p>\n<h3 id=\"Css相关\"><a href=\"#Css相关\" class=\"headerlink\" title=\"Css相关\"></a>Css相关</h3><h4 id=\"1-display-none与visibility-hidden的区别（2018拼多多前端笔试真题\"><a href=\"#1-display-none与visibility-hidden的区别（2018拼多多前端笔试真题\" class=\"headerlink\" title=\"1. display:none与visibility:hidden的区别（2018拼多多前端笔试真题)\"></a>1. display:none与visibility:hidden的区别（2018拼多多前端笔试真题)</h4><p>答案：在视觉效果上，两者是相同的，但是对于操作dom上是不同的 。<br>dispaly:none 会让dom的整个宽、高等相关位置元素失效，整个消失；<br>visibility:hidden 只是让该元素不可见，但是width以及原有位置是不会改变的</p>\n<h3 id=\"javascript\"><a href=\"#javascript\" class=\"headerlink\" title=\"javascript\"></a>javascript</h3><h4 id=\"1-基本问题\"><a href=\"#1-基本问题\" class=\"headerlink\" title=\"1. 基本问题\"></a>1. 基本问题</h4><h5 id=\"1-是否可以使用-typeof-bar-39-object-39-来检测bar是不是object类型，有和风险？\"><a href=\"#1-是否可以使用-typeof-bar-39-object-39-来检测bar是不是object类型，有和风险？\" class=\"headerlink\" title=\"1) 是否可以使用 typeof bar === &#39;object&#39;来检测bar是不是object类型，有和风险？\"></a>1) 是否可以使用 <code>typeof bar === &#39;object&#39;</code>来检测bar是不是object类型，有和风险？</h5><p>答案： 有风险，js的基本数据类型有 <code>String</code> <code>Number</code> <code>Boolean</code> <code>undefined</code> <code>null</code>和一种复杂数据类型<code>object</code>(ES6新增了<code>symbol</code>)。</p>\n<p>对于复杂数据类型<code>object</code>，其实<code>typeof null</code>返回的也是<code>object</code>，因为本质上<code>null</code>就是一个占位用的对象。另一方面，数组<code>Array</code>也不能用<code>typeof</code>检测数据类型，因为同样会返回<code>object</code>。 </p>\n<p>因此，如果想要检测<code>bar</code>是不是<code>object</code>，可以这样子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log((bar !== <span class=\"literal\">null</span>) &amp;&amp; (tiopnuiop[yuiop[]\\\\]poi456/ypeof bar ===<span class=\"string\">'object'</span>))</span><br><span class=\"line\"><span class=\"comment\">//当然，如果认为function也是 object，可以用下面的语句</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log((bar !== nul)&amp;&amp; (<span class=\"keyword\">typeof</span> bar ===<span class=\"string\">'object'</span>)||(<span class=\"keyword\">typeof</span> bar ===<span class=\"string\">'function'</span>))</span><br></pre></td></tr></table></figure></p>\n<p>除此以外，还有比如Array的情况，因为Array也会返回<code>object</code>，如果我们不像让Array被认为是Object，就必须真正的认清Array，人情Array的方法有：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log( bar <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>)  <span class=\"comment\">// 如果数组，返回true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( <span class=\"built_in\">Array</span>.isArray(bar))  <span class=\"comment\">//ES5方法</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( Ojbect.prototype.toString.call(arr) === <span class=\"string\">'[object Array]'</span>)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"2-以下两个函数是否等价\"><a href=\"#2-以下两个函数是否等价\" class=\"headerlink\" title=\"2) 以下两个函数是否等价\"></a>2) 以下两个函数是否等价</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo1</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      bar: <span class=\"string\">\"hello\"</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo2</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">      bar: <span class=\"string\">\"hello\"</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>答案： 不等价！！<br>注意，第二个函数返回的是<code>undefined</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(foo1()); <span class=\"comment\">// &#123;bar : \"hellp\"&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo2()); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure></p>\n<p>这也是为什么函数返回对象时，或写大括号时，把<code>{</code>写在一边，因为第二个函数js会默认return后面返回的东西(是空),等价于<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"literal\">undefined</span></span><br><span class=\"line\">&#123;xxx&#125;</span><br><span class=\"line\"><span class=\"comment\">//后面当然，当然是写了也白写</span></span><br></pre></td></tr></table></figure></p>\n<h5 id=\"3-NaN是什么-它是什么类型？如何检测一个变量是不是NaN？\"><a href=\"#3-NaN是什么-它是什么类型？如何检测一个变量是不是NaN？\" class=\"headerlink\" title=\"3) NaN是什么?它是什么类型？如何检测一个变量是不是NaN？\"></a>3) <code>NaN</code>是什么?它是什么类型？如何检测一个变量是不是<code>NaN</code>？</h5><p>答案： NaN即<code>Not A Number</code>，但实际上它是<code>Number</code>类型<br><code>typeof NaN</code> 将会返回<code>Number</code>。<br>这个东西比较厉害，因为<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">NaN</span> === <span class=\"literal\">NaN</span>  <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></p>\n<p>你会发现，它自己都不等于它自己，因此判断变量是否是它，不能使用<code>===</code>。<br>可以使用isNaN方法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//检查变量是否是nan</span></span><br><span class=\"line\"><span class=\"built_in\">isNaN</span>(bar);</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.is(bar,<span class=\"literal\">NaN</span>); <span class=\"comment\">//ES6方法，这个方法会修正JS中的一些小bug</span></span><br></pre></td></tr></table></figure></p>\n<p>Object.is()方法，要求严格相等，且Object.is(NaN,NaN)会返回true</p>\n<h4 id=\"2-作用域相关问题\"><a href=\"#2-作用域相关问题\" class=\"headerlink\" title=\"2.作用域相关问题\"></a>2.作用域相关问题</h4><p>以下程序的输出是什么:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = b = <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"a defined? \"</span> + (<span class=\"keyword\">typeof</span> a !== <span class=\"string\">'undefined'</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"b defined? \"</span> + (<span class=\"keyword\">typeof</span> b !== <span class=\"string\">'undefined'</span>));</span><br></pre></td></tr></table></figure></p>\n<p>答案：<br> a defined? false<br> b defined? true<br> 理解这道题的核心在于如何理解<code>var a = b = 3</code>这句话，实际上这句话等于<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a; </span><br><span class=\"line\">b = <span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure></p>\n<p>这样子，实际上，b是声明在了全局变量中(编译器在预编译帮你声明了，然而在严格模式下是不行的)<br>a是局部变量，所以在函数之外是没有定义的。</p>\n<h4 id=\"3-this-amp-对象-amp-数组\"><a href=\"#3-this-amp-对象-amp-数组\" class=\"headerlink\" title=\"3.this&amp;对象&amp;数组\"></a>3.this&amp;对象&amp;数组</h4><h5 id=\"1-下面程序输出是什么\"><a href=\"#1-下面程序输出是什么\" class=\"headerlink\" title=\"1)下面程序输出是什么\"></a>1)下面程序输出是什么</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">    foo: <span class=\"string\">\"bar\"</span>,</span><br><span class=\"line\">    func: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"outer func:  this.foo = \"</span> + <span class=\"keyword\">this</span>.foo);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"outer func:  self.foo = \"</span> + self.foo);</span><br><span class=\"line\">        (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"inner func:  this.foo = \"</span> + <span class=\"keyword\">this</span>.foo);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"inner func:  self.foo = \"</span> + self.foo);</span><br><span class=\"line\">        &#125;());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">myObject.func();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//答案</span></span><br><span class=\"line\">outer func: <span class=\"keyword\">this</span>.foo = bar</span><br><span class=\"line\">outer func: serl.foo = bar</span><br><span class=\"line\">inner func: <span class=\"keyword\">this</span>.foo = <span class=\"literal\">undefined</span></span><br><span class=\"line\">inner func: self.foo = bar</span><br></pre></td></tr></table></figure>\n<p>分析： 搞清楚this的指向。记住以下几种规则</p>\n<ul>\n<li>谁调用，this指向谁 <code>xxx.fun()</code></li>\n<li>new一个对象，this指向实例本身<code>var c = new fun()</code></li>\n<li>使用call/apply/bind修改this指向。</li>\n</ul>\n<p>看题目，<code>outer func</code>显然是第一种情况，谁调用，this指向谁，这个时候都是myOjbect。<br>而在立即执行函数中，在这里this是没有进行绑定指向的，自然从属于window，所以这里this.foo是undefied</p>\n<p>补充关于箭头函数的this<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        \t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a()()())</span><br></pre></td></tr></table></figure></p>\n<p>注意：<strong>箭头函数其实是没有 this 的，这个函数中的 this 只取决于他外面的第一个不是箭头函数的函数的 this。在这个例子中，因为调用 a 符合前面代码中的第一个情况，所以 this 是 window。并且 this 一旦绑定了上下文，就不会被任何代码改变。</strong></p>\n<h5 id=\"2-数组的filter，以下输出结果是什么-2018拼多多前端原题\"><a href=\"#2-数组的filter，以下输出结果是什么-2018拼多多前端原题\" class=\"headerlink\" title=\"2)数组的filter，以下输出结果是什么(2018拼多多前端原题)\"></a>2)数组的filter，以下输出结果是什么(2018拼多多前端原题)</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">arr[<span class=\"number\">10</span>] = <span class=\"number\">9</span>;</span><br><span class=\"line\">arr.filter(<span class=\"function\">(<span class=\"params\">item</span>)=&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> item === <span class=\"literal\">undefined</span>?</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//答案</span></span><br><span class=\"line\">[]</span><br></pre></td></tr></table></figure>\n<p>解析： 是的，答案的确是[]，不是<code>[undefined x 7]</code>。<br>首先，看下前两句执行后，arr是什么<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(arr)</span><br><span class=\"line\"><span class=\"comment\">//[1,2,3, emptyx7, 9]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr[<span class=\"number\">5</span>])</span><br><span class=\"line\"><span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure></p>\n<p>从上面结果可以看出，的确中间未定义的(显示为empty的是undefined)。那么，filter之后，不是应该返回为<code>undefined</code>的数据吗？</p>\n<p>是的，但是，当数组中都是undefined时，数组就是空，或者说<code>[empty x 7] === []</code></p>\n<h4 id=\"4-JS小数计算不准确的bug\"><a href=\"#4-JS小数计算不准确的bug\" class=\"headerlink\" title=\"4. JS小数计算不准确的bug\"></a>4. JS小数计算不准确的bug</h4><p>以下代码返回值是什么<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">0.1</span> + <span class=\"number\">0.2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">0.1</span> + <span class=\"number\">0.2</span> == <span class=\"number\">0.3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//答案: 0.30000000000000004</span></span><br><span class=\"line\">        <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure></p>\n<p>解析： 详细的解析见连接,这里说一下解决办法 <a href=\"https://segmentfault.com/a/1190000015051329?utm_source=index-hottest\" target=\"_blank\" rel=\"noopener\">0.1+0.2 != 0.3</a><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//解决办法</span></span><br><span class=\"line\"><span class=\"built_in\">parseFloat</span>((<span class=\"number\">0.1</span>+<span class=\"number\">0.2</span>).toFixed(<span class=\"number\">10</span>));</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"5-算法-思路相关\"><a href=\"#5-算法-思路相关\" class=\"headerlink\" title=\"5. 算法/思路相关\"></a>5. 算法/思路相关</h4><h5 id=\"1-讨论实现判断变量是否是整数的函数isInter-x-的实现\"><a href=\"#1-讨论实现判断变量是否是整数的函数isInter-x-的实现\" class=\"headerlink\" title=\"1) 讨论实现判断变量是否是整数的函数isInter(x)的实现\"></a>1) 讨论实现判断变量是否是整数的函数<code>isInter(x)</code>的实现</h5><p>答案： 在ES6中，是有现成的方法<code>Number.isInteger</code>可以使用的。如果自己实现，思路是什么呢<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1 异或运算</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isInter</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x ^ <span class=\"number\">0</span> === x</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//2 取整</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.round(x) === x  <span class=\"comment\">//同样可以用floor ceil</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//取余</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> (<span class=\"keyword\">typeof</span> x === <span class=\"string\">'number'</span>)&amp;&amp;(x % <span class=\"number\">1</span> === <span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"2-写一个sum方法，可以实现以下两种调用方式\"><a href=\"#2-写一个sum方法，可以实现以下两种调用方式\" class=\"headerlink\" title=\"2) 写一个sum方法，可以实现以下两种调用方式\"></a>2) 写一个sum方法，可以实现以下两种调用方式</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(<span class=\"number\">2</span>,<span class=\"number\">3</span>)) <span class=\"comment\">//5</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum(<span class=\"number\">2</span>)(<span class=\"number\">3</span>)) <span class=\"comment\">//5</span></span><br></pre></td></tr></table></figure>\n<p>答案：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方法1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(y === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//方法2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( <span class=\"built_in\">arguments</span>.length === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'here'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>] + <span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"3）-使用递归的方法，将obj变为obj2的格式-拼多多2018前端笔试真题\"><a href=\"#3）-使用递归的方法，将obj变为obj2的格式-拼多多2018前端笔试真题\" class=\"headerlink\" title=\"3） 使用递归的方法，将obj变为obj2的格式(拼多多2018前端笔试真题)\"></a>3） 使用递归的方法，将obj变为obj2的格式(拼多多2018前端笔试真题)</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj = [</span><br><span class=\"line\">    &#123;<span class=\"attr\">id</span>:<span class=\"number\">1</span>,<span class=\"attr\">parent</span>:<span class=\"literal\">null</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">id</span>:<span class=\"number\">2</span>,<span class=\"attr\">parent</span>:<span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">id</span>:<span class=\"number\">3</span>,<span class=\"attr\">parent</span>:<span class=\"number\">2</span>&#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">obj2 = &#123;</span><br><span class=\"line\">    obj:&#123;</span><br><span class=\"line\">        id: <span class=\"number\">1</span>,</span><br><span class=\"line\">        parent: <span class=\"literal\">null</span>,</span><br><span class=\"line\">        child: &#123;</span><br><span class=\"line\">            id: <span class=\"number\">2</span>,</span><br><span class=\"line\">            parent: <span class=\"number\">1</span>,</span><br><span class=\"line\">            child: &#123;</span><br><span class=\"line\">                id: ,<span class=\"number\">3</span>,</span><br><span class=\"line\">                parent: <span class=\"number\">2</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"VK的秋招前端奇遇记(二)","subtitle":"","date":"2018-08-11T04:00:00.000Z","author":"Vinecnt Ko","header-img":"img/home-bg-o.jpg","header-mask":0.3,"catalog":true,"_content":"\n系列笔记：\n\n[1.VK的秋招前端奇遇记(一)](https://forrany.github.io/2018/08/10/2018-08-10-VK-mistake-1/)\n\n[2.VK的秋招前端奇遇记(二)](https://forrany.github.io/2018/08/11/2018-08-11-VK-mistake-2/)\n\n[3.VK的秋招前端奇遇记(三)](https://forrany.github.io/2018/08/12/2018-08-12-VK-mistake-3/)\n\n[4.VK的秋招前端奇遇记(四)](https://forrany.github.io/2018/09/04/2018-09-04-VK-mistake-4/)\n\n[5.番外篇：前端面试&笔试算法 Algorithm](https://forrany.github.io/2018/08/21/2018-08-21-front-end-interview-algorithm/)\n\n---\n\n### JavaScript\n\n#### 1. 数组的神奇变化\n请问以下输出是什么\n```JavaScript\nvar arr1 = \"john\".split('');\nvar arr2 = arr1.reverse();\nvar arr3 = \"jones\".split('');\narr2.push(arr3);\nconsole.log(\"array 1: length=\" + arr1.length + \" last=\" + arr1.slice(-1));\nconsole.log(\"array 2: length=\" + arr2.length + \" last=\" + arr2.slice(-1));\n```\n答案：\n```JavaScript\n\"array 1: length=5 last=j,o,n,e,s\"\n\"array 2: length=5 last=j,o,n,e,s\"\n```\n是的，发现两个输出一样，先说这道题的核心，再好好想想吧\n* (1) 数组不是简单数据类型(值类型),会保存在堆中(heap)中，当使用`var arr1 = arr2`赋值时，只是浅拷贝，拿到了`arr2`的引用，这样带来的问题就是，修改`arr1`的时候`arr2`也会收到影响。\n* (2) `arr1.push(arr2)`，这就是为什么有一个函数叫`concat`，`push`会直接把整个数组push进去，而不会分开搞\n搞清楚以上两点，这个题基本上就解开了。\n\n#### 2.+ - 运算符之惑\n以下程序输出是什么？\n```JavaScript\nconsole.log(1 +  \"2\" + \"2\");\nconsole.log(1 +  +\"2\" + \"2\");\nconsole.log(1 +  -\"1\" + \"2\");\nconsole.log(+\"1\" +  \"1\" + \"2\");\nconsole.log( \"A\" - \"B\" + \"2\");\nconsole.log( \"A\" - \"B\" + 2);\n```\n\n答案：\n```JavaScript\n\"122\"\n\"32\"\n\"02\"\n\"112\"\n\"NaN2\"\nNaN\n```\n嗯，核心是以下几点，自己再细细思考\n* (1) `-` `+`会隐式转换为`Number`类型\n* (2) 当`+` 作为运算符出现在`String`类型前时，会认为需要字符串拼接，因此会隐式转换为`String`\n* (3) `Number`包含一个特殊的类型NaN,当对非数字进行Number转换时，会变为这个。\n\n**第一题**： 第二条，认为需要字符串拼接 1被转换为`1`，答案`122`\n**第二题**： 注意到第二个`2`前面的`+`号，是符合第一条的，因此第二个`2`被转换为Number类型，答案为`32`\n**第三题**： 同理，答案`02`\n**第五题**： 运用(1)(3)，显然是`NaN2`，第六题同理\n\n#### 3.堆栈溢出之谜\n下面的代码将会造成栈溢出，请问如何优化，不改变原有逻辑\n```JavaScript\nvar list = readHugeList();\n\nvar nextListItem = function() {\n    var item = list.pop();\n\n    if (item) {\n        // process the list item...\n        nextListItem();\n    }\n};\n```\n答案：\n```JavaScript\nvar nextListItem = function() {\n    var item = list.pop();\n\n    if (item) {\n        // process the list item...\n        setTimeout(nextListItem,0}\n};\n```\n首先必须搞清楚，堆栈溢出的原因。\n\n在JS中，不小心的操作或者编程习惯，很容易造成堆栈溢出，特别是进行回调或者循环的时候。 引用以下来说明溢出的原因：\n> 原因是每次执行代码时，都会分配一定尺寸的栈空间（Windows系统中为1M），每次方法调用时都会在栈里储存一定信息（如参数、局部变量、返回值等等），这些信息再少也会占用一定空间，成千上万个此类空间累积起来，自然就超过线程的栈空间了。那么如何解决此类问题？\n\n这里介绍两个思路解决此问题：\n1. 异步\n2. 闭包\n\n显然，这里就是使用的第一种方法，闭包。为什么使用setTimeout就可以解决问题？我们看下与没用之前的差别。如果没有使用setTimeout，那么函数将在大数据前不断的回调，直到最后走到重点，最初的函数才运行结束，释放内存。 但是如果使用了`setTimeout`，我们知道它是异步的，即使设置了时间为0，它也允许先执行下面的内容，可以释放堆栈，从而避免堆栈溢出的问题。\n换言之，加了`setTimeout`，nextListItem函数被压入**事件队列**，函数可以退出，因此每次会清空调用堆栈。\n\n**闭包** 也是一样的道理，因为这道题要求不修改原有逻辑，第一种是最合适的答案，当然用闭包避免的方法就是返回出来一个函数\n```JavaScript\nvar nextListItem = function() {\n    var item = list.pop();\n\n    if (item) {\n        // process the list item...\n        return nextListItem()\n    }\n};\n```\n当然，这样做会改变函数的调用方式，我们就需要不断的调用\n`nextListItem()()()`\n为了处理这个办法，可以对其进行进一步的封装\n```JavaScript\nvar nextListItem = function() {\n    var item = list.pop();\n\n    if (item) {\n        // process the list item...\n        return nextListItem()\n    }\n};\n\nfunction autoRun(fun) {\n    var value = nextListItem();\n    while(typeof value === 'function') {\n        value = nextListItem()\n    }\n    return\n}\n```\n这样，就解决堆栈溢出的问题。\n这里闭包的思路来源与[堆栈溢出解决方案](http://www.zuojj.com/archives/1115.html)\n\n#### 4.你真的懂对象(Object)的key吗？\n下面函数的输出是什么？\n```JavaScript\nvar a={},\n    b={key:'b'},\n    c={key:'c'};\n\na[b]=123;\na[c]=456;\n\nconsole.log(a[b]);\n```\n答案：\n输出是这样的`456`，不是`123`，至少我有有点以外...\n\n原因是什么呢？ 这里了解ES6新的数据类型map的应该就会意识到了，没错，对象的key值是只允许`String`类型的，这也是为什么引入了map数据类型了。 好了，那如果把一个对象作为key值，就会调用`toString`方法了。\n\n`Object.prototype.toString(obj)`会得到什么呢？没错`[object Object]。 那所以\n```\na[b] ==> a[\"[object Object\"] = 123;\na[b] ==> a[\"[object Object\"] = 456;\n```\n答案，显而易见\n\n#### 5.回文判断\n请做一个回文判断的函数，判断是否是回文\n\n答案： 这是一个很简单、很常规的方法。链表是最好的判断回文的方法，当然得益于JS数组的灵活方法，可以更容易实现。 \n\n这里主要考虑了一个健壮性的问题,多了一个正则来检测：\n```JavaScript\nfunction check(str) {\n    str = str.replace(/\\W/g,'').toLowerCase();\n    return str === str.split('').reverse().join()\n}\n```\n","source":"_posts/2018-08-11-VK-mistake(2).md","raw":"---\nlayout:     post\ntitle:      \"VK的秋招前端奇遇记(二)\"\nsubtitle:   \"\"\ndate:       2018-08-11 12:00:00\nauthor:     \"Vinecnt Ko\"\nheader-img: \"img/home-bg-o.jpg\"\nheader-mask: 0.3\ncatalog:    true\ntags:\n    - 前端面试\n    - JavaScript\n    - 前端笔试\n---\n\n系列笔记：\n\n[1.VK的秋招前端奇遇记(一)](https://forrany.github.io/2018/08/10/2018-08-10-VK-mistake-1/)\n\n[2.VK的秋招前端奇遇记(二)](https://forrany.github.io/2018/08/11/2018-08-11-VK-mistake-2/)\n\n[3.VK的秋招前端奇遇记(三)](https://forrany.github.io/2018/08/12/2018-08-12-VK-mistake-3/)\n\n[4.VK的秋招前端奇遇记(四)](https://forrany.github.io/2018/09/04/2018-09-04-VK-mistake-4/)\n\n[5.番外篇：前端面试&笔试算法 Algorithm](https://forrany.github.io/2018/08/21/2018-08-21-front-end-interview-algorithm/)\n\n---\n\n### JavaScript\n\n#### 1. 数组的神奇变化\n请问以下输出是什么\n```JavaScript\nvar arr1 = \"john\".split('');\nvar arr2 = arr1.reverse();\nvar arr3 = \"jones\".split('');\narr2.push(arr3);\nconsole.log(\"array 1: length=\" + arr1.length + \" last=\" + arr1.slice(-1));\nconsole.log(\"array 2: length=\" + arr2.length + \" last=\" + arr2.slice(-1));\n```\n答案：\n```JavaScript\n\"array 1: length=5 last=j,o,n,e,s\"\n\"array 2: length=5 last=j,o,n,e,s\"\n```\n是的，发现两个输出一样，先说这道题的核心，再好好想想吧\n* (1) 数组不是简单数据类型(值类型),会保存在堆中(heap)中，当使用`var arr1 = arr2`赋值时，只是浅拷贝，拿到了`arr2`的引用，这样带来的问题就是，修改`arr1`的时候`arr2`也会收到影响。\n* (2) `arr1.push(arr2)`，这就是为什么有一个函数叫`concat`，`push`会直接把整个数组push进去，而不会分开搞\n搞清楚以上两点，这个题基本上就解开了。\n\n#### 2.+ - 运算符之惑\n以下程序输出是什么？\n```JavaScript\nconsole.log(1 +  \"2\" + \"2\");\nconsole.log(1 +  +\"2\" + \"2\");\nconsole.log(1 +  -\"1\" + \"2\");\nconsole.log(+\"1\" +  \"1\" + \"2\");\nconsole.log( \"A\" - \"B\" + \"2\");\nconsole.log( \"A\" - \"B\" + 2);\n```\n\n答案：\n```JavaScript\n\"122\"\n\"32\"\n\"02\"\n\"112\"\n\"NaN2\"\nNaN\n```\n嗯，核心是以下几点，自己再细细思考\n* (1) `-` `+`会隐式转换为`Number`类型\n* (2) 当`+` 作为运算符出现在`String`类型前时，会认为需要字符串拼接，因此会隐式转换为`String`\n* (3) `Number`包含一个特殊的类型NaN,当对非数字进行Number转换时，会变为这个。\n\n**第一题**： 第二条，认为需要字符串拼接 1被转换为`1`，答案`122`\n**第二题**： 注意到第二个`2`前面的`+`号，是符合第一条的，因此第二个`2`被转换为Number类型，答案为`32`\n**第三题**： 同理，答案`02`\n**第五题**： 运用(1)(3)，显然是`NaN2`，第六题同理\n\n#### 3.堆栈溢出之谜\n下面的代码将会造成栈溢出，请问如何优化，不改变原有逻辑\n```JavaScript\nvar list = readHugeList();\n\nvar nextListItem = function() {\n    var item = list.pop();\n\n    if (item) {\n        // process the list item...\n        nextListItem();\n    }\n};\n```\n答案：\n```JavaScript\nvar nextListItem = function() {\n    var item = list.pop();\n\n    if (item) {\n        // process the list item...\n        setTimeout(nextListItem,0}\n};\n```\n首先必须搞清楚，堆栈溢出的原因。\n\n在JS中，不小心的操作或者编程习惯，很容易造成堆栈溢出，特别是进行回调或者循环的时候。 引用以下来说明溢出的原因：\n> 原因是每次执行代码时，都会分配一定尺寸的栈空间（Windows系统中为1M），每次方法调用时都会在栈里储存一定信息（如参数、局部变量、返回值等等），这些信息再少也会占用一定空间，成千上万个此类空间累积起来，自然就超过线程的栈空间了。那么如何解决此类问题？\n\n这里介绍两个思路解决此问题：\n1. 异步\n2. 闭包\n\n显然，这里就是使用的第一种方法，闭包。为什么使用setTimeout就可以解决问题？我们看下与没用之前的差别。如果没有使用setTimeout，那么函数将在大数据前不断的回调，直到最后走到重点，最初的函数才运行结束，释放内存。 但是如果使用了`setTimeout`，我们知道它是异步的，即使设置了时间为0，它也允许先执行下面的内容，可以释放堆栈，从而避免堆栈溢出的问题。\n换言之，加了`setTimeout`，nextListItem函数被压入**事件队列**，函数可以退出，因此每次会清空调用堆栈。\n\n**闭包** 也是一样的道理，因为这道题要求不修改原有逻辑，第一种是最合适的答案，当然用闭包避免的方法就是返回出来一个函数\n```JavaScript\nvar nextListItem = function() {\n    var item = list.pop();\n\n    if (item) {\n        // process the list item...\n        return nextListItem()\n    }\n};\n```\n当然，这样做会改变函数的调用方式，我们就需要不断的调用\n`nextListItem()()()`\n为了处理这个办法，可以对其进行进一步的封装\n```JavaScript\nvar nextListItem = function() {\n    var item = list.pop();\n\n    if (item) {\n        // process the list item...\n        return nextListItem()\n    }\n};\n\nfunction autoRun(fun) {\n    var value = nextListItem();\n    while(typeof value === 'function') {\n        value = nextListItem()\n    }\n    return\n}\n```\n这样，就解决堆栈溢出的问题。\n这里闭包的思路来源与[堆栈溢出解决方案](http://www.zuojj.com/archives/1115.html)\n\n#### 4.你真的懂对象(Object)的key吗？\n下面函数的输出是什么？\n```JavaScript\nvar a={},\n    b={key:'b'},\n    c={key:'c'};\n\na[b]=123;\na[c]=456;\n\nconsole.log(a[b]);\n```\n答案：\n输出是这样的`456`，不是`123`，至少我有有点以外...\n\n原因是什么呢？ 这里了解ES6新的数据类型map的应该就会意识到了，没错，对象的key值是只允许`String`类型的，这也是为什么引入了map数据类型了。 好了，那如果把一个对象作为key值，就会调用`toString`方法了。\n\n`Object.prototype.toString(obj)`会得到什么呢？没错`[object Object]。 那所以\n```\na[b] ==> a[\"[object Object\"] = 123;\na[b] ==> a[\"[object Object\"] = 456;\n```\n答案，显而易见\n\n#### 5.回文判断\n请做一个回文判断的函数，判断是否是回文\n\n答案： 这是一个很简单、很常规的方法。链表是最好的判断回文的方法，当然得益于JS数组的灵活方法，可以更容易实现。 \n\n这里主要考虑了一个健壮性的问题,多了一个正则来检测：\n```JavaScript\nfunction check(str) {\n    str = str.replace(/\\W/g,'').toLowerCase();\n    return str === str.split('').reverse().join()\n}\n```\n","slug":"2018-08-11-VK-mistake-2","published":1,"updated":"2022-08-17T07:53:21.232Z","comments":1,"photos":[],"link":"","_id":"cl6xbhzjm0003zk080e8tjluu","content":"<p>系列笔记：</p>\n<p><a href=\"https://forrany.github.io/2018/08/10/2018-08-10-VK-mistake-1/\" target=\"_blank\" rel=\"noopener\">1.VK的秋招前端奇遇记(一)</a></p>\n<p><a href=\"https://forrany.github.io/2018/08/11/2018-08-11-VK-mistake-2/\" target=\"_blank\" rel=\"noopener\">2.VK的秋招前端奇遇记(二)</a></p>\n<p><a href=\"https://forrany.github.io/2018/08/12/2018-08-12-VK-mistake-3/\" target=\"_blank\" rel=\"noopener\">3.VK的秋招前端奇遇记(三)</a></p>\n<p><a href=\"https://forrany.github.io/2018/09/04/2018-09-04-VK-mistake-4/\" target=\"_blank\" rel=\"noopener\">4.VK的秋招前端奇遇记(四)</a></p>\n<p><a href=\"https://forrany.github.io/2018/08/21/2018-08-21-front-end-interview-algorithm/\" target=\"_blank\" rel=\"noopener\">5.番外篇：前端面试&amp;笔试算法 Algorithm</a></p>\n<hr>\n<h3 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h3><h4 id=\"1-数组的神奇变化\"><a href=\"#1-数组的神奇变化\" class=\"headerlink\" title=\"1. 数组的神奇变化\"></a>1. 数组的神奇变化</h4><p>请问以下输出是什么<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = <span class=\"string\">\"john\"</span>.split(<span class=\"string\">''</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = arr1.reverse();</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr3 = <span class=\"string\">\"jones\"</span>.split(<span class=\"string\">''</span>);</span><br><span class=\"line\">arr2.push(arr3);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"array 1: length=\"</span> + arr1.length + <span class=\"string\">\" last=\"</span> + arr1.slice(<span class=\"number\">-1</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"array 2: length=\"</span> + arr2.length + <span class=\"string\">\" last=\"</span> + arr2.slice(<span class=\"number\">-1</span>));</span><br></pre></td></tr></table></figure></p>\n<p>答案：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"array 1: length=5 last=j,o,n,e,s\"</span></span><br><span class=\"line\"><span class=\"string\">\"array 2: length=5 last=j,o,n,e,s\"</span></span><br></pre></td></tr></table></figure></p>\n<p>是的，发现两个输出一样，先说这道题的核心，再好好想想吧</p>\n<ul>\n<li>(1) 数组不是简单数据类型(值类型),会保存在堆中(heap)中，当使用<code>var arr1 = arr2</code>赋值时，只是浅拷贝，拿到了<code>arr2</code>的引用，这样带来的问题就是，修改<code>arr1</code>的时候<code>arr2</code>也会收到影响。</li>\n<li>(2) <code>arr1.push(arr2)</code>，这就是为什么有一个函数叫<code>concat</code>，<code>push</code>会直接把整个数组push进去，而不会分开搞<br>搞清楚以上两点，这个题基本上就解开了。</li>\n</ul>\n<h4 id=\"2-运算符之惑\"><a href=\"#2-运算符之惑\" class=\"headerlink\" title=\"2.+ - 运算符之惑\"></a>2.+ - 运算符之惑</h4><p>以下程序输出是什么？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> +  <span class=\"string\">\"2\"</span> + <span class=\"string\">\"2\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> +  +<span class=\"string\">\"2\"</span> + <span class=\"string\">\"2\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> +  -<span class=\"string\">\"1\"</span> + <span class=\"string\">\"2\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(+<span class=\"string\">\"1\"</span> +  <span class=\"string\">\"1\"</span> + <span class=\"string\">\"2\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( <span class=\"string\">\"A\"</span> - <span class=\"string\">\"B\"</span> + <span class=\"string\">\"2\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( <span class=\"string\">\"A\"</span> - <span class=\"string\">\"B\"</span> + <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure></p>\n<p>答案：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"122\"</span></span><br><span class=\"line\"><span class=\"string\">\"32\"</span></span><br><span class=\"line\"><span class=\"string\">\"02\"</span></span><br><span class=\"line\"><span class=\"string\">\"112\"</span></span><br><span class=\"line\"><span class=\"string\">\"NaN2\"</span></span><br><span class=\"line\"><span class=\"literal\">NaN</span></span><br></pre></td></tr></table></figure></p>\n<p>嗯，核心是以下几点，自己再细细思考</p>\n<ul>\n<li>(1) <code>-</code> <code>+</code>会隐式转换为<code>Number</code>类型</li>\n<li>(2) 当<code>+</code> 作为运算符出现在<code>String</code>类型前时，会认为需要字符串拼接，因此会隐式转换为<code>String</code></li>\n<li>(3) <code>Number</code>包含一个特殊的类型NaN,当对非数字进行Number转换时，会变为这个。</li>\n</ul>\n<p><strong>第一题</strong>： 第二条，认为需要字符串拼接 1被转换为<code>1</code>，答案<code>122</code><br><strong>第二题</strong>： 注意到第二个<code>2</code>前面的<code>+</code>号，是符合第一条的，因此第二个<code>2</code>被转换为Number类型，答案为<code>32</code><br><strong>第三题</strong>： 同理，答案<code>02</code><br><strong>第五题</strong>： 运用(1)(3)，显然是<code>NaN2</code>，第六题同理</p>\n<h4 id=\"3-堆栈溢出之谜\"><a href=\"#3-堆栈溢出之谜\" class=\"headerlink\" title=\"3.堆栈溢出之谜\"></a>3.堆栈溢出之谜</h4><p>下面的代码将会造成栈溢出，请问如何优化，不改变原有逻辑<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = readHugeList();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> nextListItem = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> item = list.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// process the list item...</span></span><br><span class=\"line\">        nextListItem();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>答案：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nextListItem = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> item = list.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// process the list item...</span></span><br><span class=\"line\">        setTimeout(nextListItem,<span class=\"number\">0</span>&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>首先必须搞清楚，堆栈溢出的原因。</p>\n<p>在JS中，不小心的操作或者编程习惯，很容易造成堆栈溢出，特别是进行回调或者循环的时候。 引用以下来说明溢出的原因：</p>\n<blockquote>\n<p>原因是每次执行代码时，都会分配一定尺寸的栈空间（Windows系统中为1M），每次方法调用时都会在栈里储存一定信息（如参数、局部变量、返回值等等），这些信息再少也会占用一定空间，成千上万个此类空间累积起来，自然就超过线程的栈空间了。那么如何解决此类问题？</p>\n</blockquote>\n<p>这里介绍两个思路解决此问题：</p>\n<ol>\n<li>异步</li>\n<li>闭包</li>\n</ol>\n<p>显然，这里就是使用的第一种方法，闭包。为什么使用setTimeout就可以解决问题？我们看下与没用之前的差别。如果没有使用setTimeout，那么函数将在大数据前不断的回调，直到最后走到重点，最初的函数才运行结束，释放内存。 但是如果使用了<code>setTimeout</code>，我们知道它是异步的，即使设置了时间为0，它也允许先执行下面的内容，可以释放堆栈，从而避免堆栈溢出的问题。<br>换言之，加了<code>setTimeout</code>，nextListItem函数被压入<strong>事件队列</strong>，函数可以退出，因此每次会清空调用堆栈。</p>\n<p><strong>闭包</strong> 也是一样的道理，因为这道题要求不修改原有逻辑，第一种是最合适的答案，当然用闭包避免的方法就是返回出来一个函数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nextListItem = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> item = list.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// process the list item...</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> nextListItem()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>当然，这样做会改变函数的调用方式，我们就需要不断的调用<br><code>nextListItem()()()</code><br>为了处理这个办法，可以对其进行进一步的封装<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nextListItem = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> item = list.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// process the list item...</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> nextListItem()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">autoRun</span>(<span class=\"params\">fun</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value = nextListItem();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"keyword\">typeof</span> value === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        value = nextListItem()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样，就解决堆栈溢出的问题。<br>这里闭包的思路来源与<a href=\"http://www.zuojj.com/archives/1115.html\" target=\"_blank\" rel=\"noopener\">堆栈溢出解决方案</a></p>\n<h4 id=\"4-你真的懂对象-Object-的key吗？\"><a href=\"#4-你真的懂对象-Object-的key吗？\" class=\"headerlink\" title=\"4.你真的懂对象(Object)的key吗？\"></a>4.你真的懂对象(Object)的key吗？</h4><p>下面函数的输出是什么？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a=&#123;&#125;,</span><br><span class=\"line\">    b=&#123;<span class=\"attr\">key</span>:<span class=\"string\">'b'</span>&#125;,</span><br><span class=\"line\">    c=&#123;<span class=\"attr\">key</span>:<span class=\"string\">'c'</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">a[b]=<span class=\"number\">123</span>;</span><br><span class=\"line\">a[c]=<span class=\"number\">456</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a[b]);</span><br></pre></td></tr></table></figure></p>\n<p>答案：<br>输出是这样的<code>456</code>，不是<code>123</code>，至少我有有点以外…</p>\n<p>原因是什么呢？ 这里了解ES6新的数据类型map的应该就会意识到了，没错，对象的key值是只允许<code>String</code>类型的，这也是为什么引入了map数据类型了。 好了，那如果把一个对象作为key值，就会调用<code>toString</code>方法了。</p>\n<p><code>Object.prototype.toString(obj)</code>会得到什么呢？没错`[object Object]。 那所以<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a[b] ==&gt; a[&quot;[object Object&quot;] = 123;</span><br><span class=\"line\">a[b] ==&gt; a[&quot;[object Object&quot;] = 456;</span><br></pre></td></tr></table></figure></p>\n<p>答案，显而易见</p>\n<h4 id=\"5-回文判断\"><a href=\"#5-回文判断\" class=\"headerlink\" title=\"5.回文判断\"></a>5.回文判断</h4><p>请做一个回文判断的函数，判断是否是回文</p>\n<p>答案： 这是一个很简单、很常规的方法。链表是最好的判断回文的方法，当然得益于JS数组的灵活方法，可以更容易实现。 </p>\n<p>这里主要考虑了一个健壮性的问题,多了一个正则来检测：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">check</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">    str = str.replace(<span class=\"regexp\">/\\W/g</span>,<span class=\"string\">''</span>).toLowerCase();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> str === str.split(<span class=\"string\">''</span>).reverse().join()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>系列笔记：</p>\n<p><a href=\"https://forrany.github.io/2018/08/10/2018-08-10-VK-mistake-1/\" target=\"_blank\" rel=\"noopener\">1.VK的秋招前端奇遇记(一)</a></p>\n<p><a href=\"https://forrany.github.io/2018/08/11/2018-08-11-VK-mistake-2/\" target=\"_blank\" rel=\"noopener\">2.VK的秋招前端奇遇记(二)</a></p>\n<p><a href=\"https://forrany.github.io/2018/08/12/2018-08-12-VK-mistake-3/\" target=\"_blank\" rel=\"noopener\">3.VK的秋招前端奇遇记(三)</a></p>\n<p><a href=\"https://forrany.github.io/2018/09/04/2018-09-04-VK-mistake-4/\" target=\"_blank\" rel=\"noopener\">4.VK的秋招前端奇遇记(四)</a></p>\n<p><a href=\"https://forrany.github.io/2018/08/21/2018-08-21-front-end-interview-algorithm/\" target=\"_blank\" rel=\"noopener\">5.番外篇：前端面试&amp;笔试算法 Algorithm</a></p>\n<hr>\n<h3 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h3><h4 id=\"1-数组的神奇变化\"><a href=\"#1-数组的神奇变化\" class=\"headerlink\" title=\"1. 数组的神奇变化\"></a>1. 数组的神奇变化</h4><p>请问以下输出是什么<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = <span class=\"string\">\"john\"</span>.split(<span class=\"string\">''</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = arr1.reverse();</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr3 = <span class=\"string\">\"jones\"</span>.split(<span class=\"string\">''</span>);</span><br><span class=\"line\">arr2.push(arr3);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"array 1: length=\"</span> + arr1.length + <span class=\"string\">\" last=\"</span> + arr1.slice(<span class=\"number\">-1</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"array 2: length=\"</span> + arr2.length + <span class=\"string\">\" last=\"</span> + arr2.slice(<span class=\"number\">-1</span>));</span><br></pre></td></tr></table></figure></p>\n<p>答案：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"array 1: length=5 last=j,o,n,e,s\"</span></span><br><span class=\"line\"><span class=\"string\">\"array 2: length=5 last=j,o,n,e,s\"</span></span><br></pre></td></tr></table></figure></p>\n<p>是的，发现两个输出一样，先说这道题的核心，再好好想想吧</p>\n<ul>\n<li>(1) 数组不是简单数据类型(值类型),会保存在堆中(heap)中，当使用<code>var arr1 = arr2</code>赋值时，只是浅拷贝，拿到了<code>arr2</code>的引用，这样带来的问题就是，修改<code>arr1</code>的时候<code>arr2</code>也会收到影响。</li>\n<li>(2) <code>arr1.push(arr2)</code>，这就是为什么有一个函数叫<code>concat</code>，<code>push</code>会直接把整个数组push进去，而不会分开搞<br>搞清楚以上两点，这个题基本上就解开了。</li>\n</ul>\n<h4 id=\"2-运算符之惑\"><a href=\"#2-运算符之惑\" class=\"headerlink\" title=\"2.+ - 运算符之惑\"></a>2.+ - 运算符之惑</h4><p>以下程序输出是什么？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> +  <span class=\"string\">\"2\"</span> + <span class=\"string\">\"2\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> +  +<span class=\"string\">\"2\"</span> + <span class=\"string\">\"2\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> +  -<span class=\"string\">\"1\"</span> + <span class=\"string\">\"2\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(+<span class=\"string\">\"1\"</span> +  <span class=\"string\">\"1\"</span> + <span class=\"string\">\"2\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( <span class=\"string\">\"A\"</span> - <span class=\"string\">\"B\"</span> + <span class=\"string\">\"2\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( <span class=\"string\">\"A\"</span> - <span class=\"string\">\"B\"</span> + <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure></p>\n<p>答案：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"122\"</span></span><br><span class=\"line\"><span class=\"string\">\"32\"</span></span><br><span class=\"line\"><span class=\"string\">\"02\"</span></span><br><span class=\"line\"><span class=\"string\">\"112\"</span></span><br><span class=\"line\"><span class=\"string\">\"NaN2\"</span></span><br><span class=\"line\"><span class=\"literal\">NaN</span></span><br></pre></td></tr></table></figure></p>\n<p>嗯，核心是以下几点，自己再细细思考</p>\n<ul>\n<li>(1) <code>-</code> <code>+</code>会隐式转换为<code>Number</code>类型</li>\n<li>(2) 当<code>+</code> 作为运算符出现在<code>String</code>类型前时，会认为需要字符串拼接，因此会隐式转换为<code>String</code></li>\n<li>(3) <code>Number</code>包含一个特殊的类型NaN,当对非数字进行Number转换时，会变为这个。</li>\n</ul>\n<p><strong>第一题</strong>： 第二条，认为需要字符串拼接 1被转换为<code>1</code>，答案<code>122</code><br><strong>第二题</strong>： 注意到第二个<code>2</code>前面的<code>+</code>号，是符合第一条的，因此第二个<code>2</code>被转换为Number类型，答案为<code>32</code><br><strong>第三题</strong>： 同理，答案<code>02</code><br><strong>第五题</strong>： 运用(1)(3)，显然是<code>NaN2</code>，第六题同理</p>\n<h4 id=\"3-堆栈溢出之谜\"><a href=\"#3-堆栈溢出之谜\" class=\"headerlink\" title=\"3.堆栈溢出之谜\"></a>3.堆栈溢出之谜</h4><p>下面的代码将会造成栈溢出，请问如何优化，不改变原有逻辑<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = readHugeList();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> nextListItem = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> item = list.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// process the list item...</span></span><br><span class=\"line\">        nextListItem();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>答案：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nextListItem = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> item = list.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// process the list item...</span></span><br><span class=\"line\">        setTimeout(nextListItem,<span class=\"number\">0</span>&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>首先必须搞清楚，堆栈溢出的原因。</p>\n<p>在JS中，不小心的操作或者编程习惯，很容易造成堆栈溢出，特别是进行回调或者循环的时候。 引用以下来说明溢出的原因：</p>\n<blockquote>\n<p>原因是每次执行代码时，都会分配一定尺寸的栈空间（Windows系统中为1M），每次方法调用时都会在栈里储存一定信息（如参数、局部变量、返回值等等），这些信息再少也会占用一定空间，成千上万个此类空间累积起来，自然就超过线程的栈空间了。那么如何解决此类问题？</p>\n</blockquote>\n<p>这里介绍两个思路解决此问题：</p>\n<ol>\n<li>异步</li>\n<li>闭包</li>\n</ol>\n<p>显然，这里就是使用的第一种方法，闭包。为什么使用setTimeout就可以解决问题？我们看下与没用之前的差别。如果没有使用setTimeout，那么函数将在大数据前不断的回调，直到最后走到重点，最初的函数才运行结束，释放内存。 但是如果使用了<code>setTimeout</code>，我们知道它是异步的，即使设置了时间为0，它也允许先执行下面的内容，可以释放堆栈，从而避免堆栈溢出的问题。<br>换言之，加了<code>setTimeout</code>，nextListItem函数被压入<strong>事件队列</strong>，函数可以退出，因此每次会清空调用堆栈。</p>\n<p><strong>闭包</strong> 也是一样的道理，因为这道题要求不修改原有逻辑，第一种是最合适的答案，当然用闭包避免的方法就是返回出来一个函数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nextListItem = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> item = list.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// process the list item...</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> nextListItem()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>当然，这样做会改变函数的调用方式，我们就需要不断的调用<br><code>nextListItem()()()</code><br>为了处理这个办法，可以对其进行进一步的封装<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nextListItem = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> item = list.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (item) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// process the list item...</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> nextListItem()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">autoRun</span>(<span class=\"params\">fun</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> value = nextListItem();</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"keyword\">typeof</span> value === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">        value = nextListItem()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样，就解决堆栈溢出的问题。<br>这里闭包的思路来源与<a href=\"http://www.zuojj.com/archives/1115.html\" target=\"_blank\" rel=\"noopener\">堆栈溢出解决方案</a></p>\n<h4 id=\"4-你真的懂对象-Object-的key吗？\"><a href=\"#4-你真的懂对象-Object-的key吗？\" class=\"headerlink\" title=\"4.你真的懂对象(Object)的key吗？\"></a>4.你真的懂对象(Object)的key吗？</h4><p>下面函数的输出是什么？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a=&#123;&#125;,</span><br><span class=\"line\">    b=&#123;<span class=\"attr\">key</span>:<span class=\"string\">'b'</span>&#125;,</span><br><span class=\"line\">    c=&#123;<span class=\"attr\">key</span>:<span class=\"string\">'c'</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">a[b]=<span class=\"number\">123</span>;</span><br><span class=\"line\">a[c]=<span class=\"number\">456</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a[b]);</span><br></pre></td></tr></table></figure></p>\n<p>答案：<br>输出是这样的<code>456</code>，不是<code>123</code>，至少我有有点以外…</p>\n<p>原因是什么呢？ 这里了解ES6新的数据类型map的应该就会意识到了，没错，对象的key值是只允许<code>String</code>类型的，这也是为什么引入了map数据类型了。 好了，那如果把一个对象作为key值，就会调用<code>toString</code>方法了。</p>\n<p><code>Object.prototype.toString(obj)</code>会得到什么呢？没错`[object Object]。 那所以<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a[b] ==&gt; a[&quot;[object Object&quot;] = 123;</span><br><span class=\"line\">a[b] ==&gt; a[&quot;[object Object&quot;] = 456;</span><br></pre></td></tr></table></figure></p>\n<p>答案，显而易见</p>\n<h4 id=\"5-回文判断\"><a href=\"#5-回文判断\" class=\"headerlink\" title=\"5.回文判断\"></a>5.回文判断</h4><p>请做一个回文判断的函数，判断是否是回文</p>\n<p>答案： 这是一个很简单、很常规的方法。链表是最好的判断回文的方法，当然得益于JS数组的灵活方法，可以更容易实现。 </p>\n<p>这里主要考虑了一个健壮性的问题,多了一个正则来检测：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">check</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">    str = str.replace(<span class=\"regexp\">/\\W/g</span>,<span class=\"string\">''</span>).toLowerCase();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> str === str.split(<span class=\"string\">''</span>).reverse().join()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"layout":"post","title":"VK的秋招前端奇遇记(三)","subtitle":"","date":"2018-08-12T04:00:00.000Z","author":"Vinecnt Ko","header-img":"img/home-bg-o.jpg","header-mask":0.3,"catalog":true,"_content":"\nJavaScript总是给人以惊喜，学习不止，进步不断，今天继续补充JS容易搞错的几道笔试/面试题，为了秋招继续努力，欢迎一起为秋招努力的小伙伴共勉\n\n系列笔记：\n\n[1.VK的秋招前端奇遇记(一)](https://forrany.github.io/2018/08/10/2018-08-10-VK-mistake-1/)\n\n[2.VK的秋招前端奇遇记(二)](https://forrany.github.io/2018/08/11/2018-08-11-VK-mistake-2/)\n\n[3.VK的秋招前端奇遇记(三)](https://forrany.github.io/2018/08/12/2018-08-12-VK-mistake-3/)\n\n[4.VK的秋招前端奇遇记(四)](https://forrany.github.io/2018/09/04/2018-09-04-VK-mistake-4/)\n\n[5.番外篇：前端面试&笔试算法 Algorithm](https://forrany.github.io/2018/08/21/2018-08-21-front-end-interview-algorithm/)\n\n---\n\n##  ”老生常错“的this与作用域相关\n\n### Q1. 下面程序的输出结果是？\n\n```javascript\nvar length = 10;\nfunction fn() {\n\tconsole.log(this.length);\n}\n\nvar obj = {\n  length: 5,\n  method: function(fn) {\n    fn();\n    arguments[0]();\n  }\n};\n\nobj.method(fn, 1);\n```\n\n\n\noutput: \n\n```javascript\n10\n2\n```\n\n这个我做错在第二个输出上，其实对`this`了解后就知道，第一个输出`10`应该是很显然的：虽然在程序执行时，使用了`obj.method`方法，让this指向了`obj`，但是真正的函数执行在函数体内部，也即当`fn()`执行的时候，`this`是指向`window`的，所以第一次执行结果是10\n\n那么这里第二次执行`arguments[0]`为什么结果是`2`？\n\n分析下在`method(fn,1)`执行时，经历了什么： 首先两个参数`fn`和`1`会被放入`arguments`中，在`arguments`中第一个参数就是我们传入的函数；接下来`fn`执行，此时`this`没有绑定因此指向`window`，输出`10`。 然而到了`arguments[0]()`这一句，相当于把`arguments[0]`中的第一个参数拿来执行, 效果如下:\n\n```javascript\narguments[0]()  //执行,等同于下面的\narguments.0() //当然这句话是不合法的，但是这样我们可以更清楚知道，this是指向arguments实例本身\n```\n\n`arguments.length`就是它本身的长度(arguments是一个类数组，具有length属性)，因此输出`2`\n\n---\n\n### Q2. try..catch程序的输出结果\n\n```javascript\n(function () {\n    try {\n        throw new Error();\n    } catch (x) {\n        var x = 1, y = 2;\n        console.log(x);\n    }\n    console.log(x);\n    console.log(y);\n})();\n```\n\n输出结果:\n\n```javascript\n1\nundefined\n2\n```\n\n我们都知道`var`是在预编译阶段会有一个变量提升，这种类型很容易解决，但是当遇到在`catch(x)`中与已有变量重名的情况，一定要区分两者之间的关系。\n\n用变量提升的方法，把程序重写并分析如下：\n\n```javascript\n(function () {\n    var x,y;  // 外部变量提升\n    try {\n        throw new Error();\n    } catch (x/* 内部的x */) {\n\t\tx = 1; //内部的x，和上面声明的x不是一回事！！\n         y = 2; //内部没有声明，作用域链向上找，外面的y\n        console.log(x); //当然是1\n    }\n    console.log(x);  //只声明，未赋值，undefined\n    console.log(y);  //就是2了\n})();\n```\n\n这样子就很清晰，之后注意预编译的过程，把变量和函数定义进行提升后，进行分析，会清楚很多\n\n---\n\n### Q3. 下面程序的输出\n\n```javascript\nvar x = 21;\nvar girl = function () {\n    console.log(x);\n    var x = 20;\n};\ngirl ();\n```\n\n输出：\n\n```javascript\nundefined\n```\n\n说实话，这个题目我没做错，我没做错，我没做错！\n\n因为和Q2一样，而且还没有Q2难，一句话解释就是： 函数内部变量提升。 相当于\n\n```javascript\nvar x = 21;\nvar girl = function() {\n    var x;\n    console.log(x); // undefined\n    x = 20;\n}\n}\n```\n\n\n\n## 那些诡异的边角知识\n\n### Q1.  运算符考点： 下面程序输出是什么?\n\n```javascript\nconsole.log(1 < 2 < 3);\nconsole.log(3 > 2 > 1);\n```\n\n输出:\n\n```javascript\ntrue\nflase\n```\n\n第一个输出结果是好理解的，主要看下第二个为什么是`false`\n\n核心在于js怎么去解析`<`和`>`运算符。 在JS中，这种运算符是从左向右运算的，所以`3>2>1`就被转换成了`true>1`,而`true`的值是`1`，接着比较`1>1`就返回false了。\n\n---\n\n### Q2. typeof，下面输出结果是什么\n\n```javascript\nconsole.log(typeof typeof 1);\n```\n\n答案是`string`\n\n会输出`string`，这个题目不仅仅是typeof的考察，也是对js运算的一个考察。 在js中一般有两种操作\n\n* 赋值操作，例如`a = b` `2>3`之类的，上面的题目提到过，是从左向右的顺序\n* 取值操作， js问内存：`有没有见过这个家伙？`，比如`console.log(a)` `typeof a` 都属于这个类型，是从右向左的\n\n因此，这个题就被分解为`typeof 1`返回`\"number\"`，注意是一个字符串。 接下来`typeof \"number\"`，返回`string`\n\n---\n\n### Q3. `typeof undefined == typeof NULL `输出结果是什么\n\n首先搞清楚两点：\n\n* `typeof undefined` 输出是`undefined`\n* `typeof null`输出是`object`\n\n但是，另一方面，因为js对大小写敏感，`null ` ≠ `NULL`，所以``typeof NULL` 返回`undefined`\n\n结果是： `true`\n\n### Q4. 递归设计。 实现一个函数，给该函数一个DOM节点，函数访问其所有子元素(所有子元素，不仅仅是直接子元素)，每次访问子元素的时候，并为其传一个callback。\n\n访问一个DOM tree，是一个经典的深度优先搜索的算法\n\n```javascript\nfunction Traverse(DOM,callback) {\n    callback(DOM);\n    var list = DOM.children;\n    Array.prototype.forEach.apply(list,(item)=>{\n        Traverse(item,callback); //递归\n    })\n}\n```\n\n","source":"_posts/2018-08-12-VK-mistake(3).md","raw":"---\nlayout:     post\ntitle:      \"VK的秋招前端奇遇记(三)\"\nsubtitle:   \"\"\ndate:       2018-08-12 12:00:00\nauthor:     \"Vinecnt Ko\"\nheader-img: \"img/home-bg-o.jpg\"\nheader-mask: 0.3\ncatalog:    true\ntags:\n    - 前端面试\n    - JavaScript\n    - 前端笔试\n---\n\nJavaScript总是给人以惊喜，学习不止，进步不断，今天继续补充JS容易搞错的几道笔试/面试题，为了秋招继续努力，欢迎一起为秋招努力的小伙伴共勉\n\n系列笔记：\n\n[1.VK的秋招前端奇遇记(一)](https://forrany.github.io/2018/08/10/2018-08-10-VK-mistake-1/)\n\n[2.VK的秋招前端奇遇记(二)](https://forrany.github.io/2018/08/11/2018-08-11-VK-mistake-2/)\n\n[3.VK的秋招前端奇遇记(三)](https://forrany.github.io/2018/08/12/2018-08-12-VK-mistake-3/)\n\n[4.VK的秋招前端奇遇记(四)](https://forrany.github.io/2018/09/04/2018-09-04-VK-mistake-4/)\n\n[5.番外篇：前端面试&笔试算法 Algorithm](https://forrany.github.io/2018/08/21/2018-08-21-front-end-interview-algorithm/)\n\n---\n\n##  ”老生常错“的this与作用域相关\n\n### Q1. 下面程序的输出结果是？\n\n```javascript\nvar length = 10;\nfunction fn() {\n\tconsole.log(this.length);\n}\n\nvar obj = {\n  length: 5,\n  method: function(fn) {\n    fn();\n    arguments[0]();\n  }\n};\n\nobj.method(fn, 1);\n```\n\n\n\noutput: \n\n```javascript\n10\n2\n```\n\n这个我做错在第二个输出上，其实对`this`了解后就知道，第一个输出`10`应该是很显然的：虽然在程序执行时，使用了`obj.method`方法，让this指向了`obj`，但是真正的函数执行在函数体内部，也即当`fn()`执行的时候，`this`是指向`window`的，所以第一次执行结果是10\n\n那么这里第二次执行`arguments[0]`为什么结果是`2`？\n\n分析下在`method(fn,1)`执行时，经历了什么： 首先两个参数`fn`和`1`会被放入`arguments`中，在`arguments`中第一个参数就是我们传入的函数；接下来`fn`执行，此时`this`没有绑定因此指向`window`，输出`10`。 然而到了`arguments[0]()`这一句，相当于把`arguments[0]`中的第一个参数拿来执行, 效果如下:\n\n```javascript\narguments[0]()  //执行,等同于下面的\narguments.0() //当然这句话是不合法的，但是这样我们可以更清楚知道，this是指向arguments实例本身\n```\n\n`arguments.length`就是它本身的长度(arguments是一个类数组，具有length属性)，因此输出`2`\n\n---\n\n### Q2. try..catch程序的输出结果\n\n```javascript\n(function () {\n    try {\n        throw new Error();\n    } catch (x) {\n        var x = 1, y = 2;\n        console.log(x);\n    }\n    console.log(x);\n    console.log(y);\n})();\n```\n\n输出结果:\n\n```javascript\n1\nundefined\n2\n```\n\n我们都知道`var`是在预编译阶段会有一个变量提升，这种类型很容易解决，但是当遇到在`catch(x)`中与已有变量重名的情况，一定要区分两者之间的关系。\n\n用变量提升的方法，把程序重写并分析如下：\n\n```javascript\n(function () {\n    var x,y;  // 外部变量提升\n    try {\n        throw new Error();\n    } catch (x/* 内部的x */) {\n\t\tx = 1; //内部的x，和上面声明的x不是一回事！！\n         y = 2; //内部没有声明，作用域链向上找，外面的y\n        console.log(x); //当然是1\n    }\n    console.log(x);  //只声明，未赋值，undefined\n    console.log(y);  //就是2了\n})();\n```\n\n这样子就很清晰，之后注意预编译的过程，把变量和函数定义进行提升后，进行分析，会清楚很多\n\n---\n\n### Q3. 下面程序的输出\n\n```javascript\nvar x = 21;\nvar girl = function () {\n    console.log(x);\n    var x = 20;\n};\ngirl ();\n```\n\n输出：\n\n```javascript\nundefined\n```\n\n说实话，这个题目我没做错，我没做错，我没做错！\n\n因为和Q2一样，而且还没有Q2难，一句话解释就是： 函数内部变量提升。 相当于\n\n```javascript\nvar x = 21;\nvar girl = function() {\n    var x;\n    console.log(x); // undefined\n    x = 20;\n}\n}\n```\n\n\n\n## 那些诡异的边角知识\n\n### Q1.  运算符考点： 下面程序输出是什么?\n\n```javascript\nconsole.log(1 < 2 < 3);\nconsole.log(3 > 2 > 1);\n```\n\n输出:\n\n```javascript\ntrue\nflase\n```\n\n第一个输出结果是好理解的，主要看下第二个为什么是`false`\n\n核心在于js怎么去解析`<`和`>`运算符。 在JS中，这种运算符是从左向右运算的，所以`3>2>1`就被转换成了`true>1`,而`true`的值是`1`，接着比较`1>1`就返回false了。\n\n---\n\n### Q2. typeof，下面输出结果是什么\n\n```javascript\nconsole.log(typeof typeof 1);\n```\n\n答案是`string`\n\n会输出`string`，这个题目不仅仅是typeof的考察，也是对js运算的一个考察。 在js中一般有两种操作\n\n* 赋值操作，例如`a = b` `2>3`之类的，上面的题目提到过，是从左向右的顺序\n* 取值操作， js问内存：`有没有见过这个家伙？`，比如`console.log(a)` `typeof a` 都属于这个类型，是从右向左的\n\n因此，这个题就被分解为`typeof 1`返回`\"number\"`，注意是一个字符串。 接下来`typeof \"number\"`，返回`string`\n\n---\n\n### Q3. `typeof undefined == typeof NULL `输出结果是什么\n\n首先搞清楚两点：\n\n* `typeof undefined` 输出是`undefined`\n* `typeof null`输出是`object`\n\n但是，另一方面，因为js对大小写敏感，`null ` ≠ `NULL`，所以``typeof NULL` 返回`undefined`\n\n结果是： `true`\n\n### Q4. 递归设计。 实现一个函数，给该函数一个DOM节点，函数访问其所有子元素(所有子元素，不仅仅是直接子元素)，每次访问子元素的时候，并为其传一个callback。\n\n访问一个DOM tree，是一个经典的深度优先搜索的算法\n\n```javascript\nfunction Traverse(DOM,callback) {\n    callback(DOM);\n    var list = DOM.children;\n    Array.prototype.forEach.apply(list,(item)=>{\n        Traverse(item,callback); //递归\n    })\n}\n```\n\n","slug":"2018-08-12-VK-mistake-3","published":1,"updated":"2022-08-17T07:53:21.232Z","comments":1,"photos":[],"link":"","_id":"cl6xbhzjq0006zk081dc5wsaw","content":"<p>JavaScript总是给人以惊喜，学习不止，进步不断，今天继续补充JS容易搞错的几道笔试/面试题，为了秋招继续努力，欢迎一起为秋招努力的小伙伴共勉</p>\n<p>系列笔记：</p>\n<p><a href=\"https://forrany.github.io/2018/08/10/2018-08-10-VK-mistake-1/\" target=\"_blank\" rel=\"noopener\">1.VK的秋招前端奇遇记(一)</a></p>\n<p><a href=\"https://forrany.github.io/2018/08/11/2018-08-11-VK-mistake-2/\" target=\"_blank\" rel=\"noopener\">2.VK的秋招前端奇遇记(二)</a></p>\n<p><a href=\"https://forrany.github.io/2018/08/12/2018-08-12-VK-mistake-3/\" target=\"_blank\" rel=\"noopener\">3.VK的秋招前端奇遇记(三)</a></p>\n<p><a href=\"https://forrany.github.io/2018/09/04/2018-09-04-VK-mistake-4/\" target=\"_blank\" rel=\"noopener\">4.VK的秋招前端奇遇记(四)</a></p>\n<p><a href=\"https://forrany.github.io/2018/08/21/2018-08-21-front-end-interview-algorithm/\" target=\"_blank\" rel=\"noopener\">5.番外篇：前端面试&amp;笔试算法 Algorithm</a></p>\n<hr>\n<h2 id=\"”老生常错“的this与作用域相关\"><a href=\"#”老生常错“的this与作用域相关\" class=\"headerlink\" title=\"”老生常错“的this与作用域相关\"></a>”老生常错“的this与作用域相关</h2><h3 id=\"Q1-下面程序的输出结果是？\"><a href=\"#Q1-下面程序的输出结果是？\" class=\"headerlink\" title=\"Q1. 下面程序的输出结果是？\"></a>Q1. 下面程序的输出结果是？</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> length = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.length);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  length: <span class=\"number\">5</span>,</span><br><span class=\"line\">  method: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">    fn();</span><br><span class=\"line\">    <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>]();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.method(fn, <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>output: </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>这个我做错在第二个输出上，其实对<code>this</code>了解后就知道，第一个输出<code>10</code>应该是很显然的：虽然在程序执行时，使用了<code>obj.method</code>方法，让this指向了<code>obj</code>，但是真正的函数执行在函数体内部，也即当<code>fn()</code>执行的时候，<code>this</code>是指向<code>window</code>的，所以第一次执行结果是10</p>\n<p>那么这里第二次执行<code>arguments[0]</code>为什么结果是<code>2</code>？</p>\n<p>分析下在<code>method(fn,1)</code>执行时，经历了什么： 首先两个参数<code>fn</code>和<code>1</code>会被放入<code>arguments</code>中，在<code>arguments</code>中第一个参数就是我们传入的函数；接下来<code>fn</code>执行，此时<code>this</code>没有绑定因此指向<code>window</code>，输出<code>10</code>。 然而到了<code>arguments[0]()</code>这一句，相当于把<code>arguments[0]</code>中的第一个参数拿来执行, 效果如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>]()  <span class=\"comment\">//执行,等同于下面的</span></span><br><span class=\"line\"><span class=\"built_in\">arguments</span><span class=\"number\">.0</span>() <span class=\"comment\">//当然这句话是不合法的，但是这样我们可以更清楚知道，this是指向arguments实例本身</span></span><br></pre></td></tr></table></figure>\n<p><code>arguments.length</code>就是它本身的长度(arguments是一个类数组，具有length属性)，因此输出<code>2</code></p>\n<hr>\n<h3 id=\"Q2-try-catch程序的输出结果\"><a href=\"#Q2-try-catch程序的输出结果\" class=\"headerlink\" title=\"Q2. try..catch程序的输出结果\"></a>Q2. try..catch程序的输出结果</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (x) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> x = <span class=\"number\">1</span>, y = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(y);</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>我们都知道<code>var</code>是在预编译阶段会有一个变量提升，这种类型很容易解决，但是当遇到在<code>catch(x)</code>中与已有变量重名的情况，一定要区分两者之间的关系。</p>\n<p>用变量提升的方法，把程序重写并分析如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x,y;  <span class=\"comment\">// 外部变量提升</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (x<span class=\"comment\">/* 内部的x */</span>) &#123;</span><br><span class=\"line\">\t\tx = <span class=\"number\">1</span>; <span class=\"comment\">//内部的x，和上面声明的x不是一回事！！</span></span><br><span class=\"line\">         y = <span class=\"number\">2</span>; <span class=\"comment\">//内部没有声明，作用域链向上找，外面的y</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(x); <span class=\"comment\">//当然是1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);  <span class=\"comment\">//只声明，未赋值，undefined</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(y);  <span class=\"comment\">//就是2了</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>这样子就很清晰，之后注意预编译的过程，把变量和函数定义进行提升后，进行分析，会清楚很多</p>\n<hr>\n<h3 id=\"Q3-下面程序的输出\"><a href=\"#Q3-下面程序的输出\" class=\"headerlink\" title=\"Q3. 下面程序的输出\"></a>Q3. 下面程序的输出</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">21</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> girl = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">20</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">girl ();</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">undefined</span></span><br></pre></td></tr></table></figure>\n<p>说实话，这个题目我没做错，我没做错，我没做错！</p>\n<p>因为和Q2一样，而且还没有Q2难，一句话解释就是： 函数内部变量提升。 相当于</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">21</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> girl = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    x = <span class=\"number\">20</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"那些诡异的边角知识\"><a href=\"#那些诡异的边角知识\" class=\"headerlink\" title=\"那些诡异的边角知识\"></a>那些诡异的边角知识</h2><h3 id=\"Q1-运算符考点：-下面程序输出是什么\"><a href=\"#Q1-运算符考点：-下面程序输出是什么\" class=\"headerlink\" title=\"Q1.  运算符考点： 下面程序输出是什么?\"></a>Q1.  运算符考点： 下面程序输出是什么?</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> &lt; <span class=\"number\">2</span> &lt; <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">3</span> &gt; <span class=\"number\">2</span> &gt; <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>输出:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">true</span></span><br><span class=\"line\">flase</span><br></pre></td></tr></table></figure>\n<p>第一个输出结果是好理解的，主要看下第二个为什么是<code>false</code></p>\n<p>核心在于js怎么去解析<code>&lt;</code>和<code>&gt;</code>运算符。 在JS中，这种运算符是从左向右运算的，所以<code>3&gt;2&gt;1</code>就被转换成了<code>true&gt;1</code>,而<code>true</code>的值是<code>1</code>，接着比较<code>1&gt;1</code>就返回false了。</p>\n<hr>\n<h3 id=\"Q2-typeof，下面输出结果是什么\"><a href=\"#Q2-typeof，下面输出结果是什么\" class=\"headerlink\" title=\"Q2. typeof，下面输出结果是什么\"></a>Q2. typeof，下面输出结果是什么</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"keyword\">typeof</span> <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>答案是<code>string</code></p>\n<p>会输出<code>string</code>，这个题目不仅仅是typeof的考察，也是对js运算的一个考察。 在js中一般有两种操作</p>\n<ul>\n<li>赋值操作，例如<code>a = b</code> <code>2&gt;3</code>之类的，上面的题目提到过，是从左向右的顺序</li>\n<li>取值操作， js问内存：<code>有没有见过这个家伙？</code>，比如<code>console.log(a)</code> <code>typeof a</code> 都属于这个类型，是从右向左的</li>\n</ul>\n<p>因此，这个题就被分解为<code>typeof 1</code>返回<code>&quot;number&quot;</code>，注意是一个字符串。 接下来<code>typeof &quot;number&quot;</code>，返回<code>string</code></p>\n<hr>\n<h3 id=\"Q3-typeof-undefined-typeof-NULL输出结果是什么\"><a href=\"#Q3-typeof-undefined-typeof-NULL输出结果是什么\" class=\"headerlink\" title=\"Q3. typeof undefined == typeof NULL输出结果是什么\"></a>Q3. <code>typeof undefined == typeof NULL</code>输出结果是什么</h3><p>首先搞清楚两点：</p>\n<ul>\n<li><code>typeof undefined</code> 输出是<code>undefined</code></li>\n<li><code>typeof null</code>输出是<code>object</code></li>\n</ul>\n<p>但是，另一方面，因为js对大小写敏感，<code>null</code> ≠ <code>NULL</code>，所以<code></code>typeof NULL<code>返回</code>undefined`</p>\n<p>结果是： <code>true</code></p>\n<h3 id=\"Q4-递归设计。-实现一个函数，给该函数一个DOM节点，函数访问其所有子元素-所有子元素，不仅仅是直接子元素-，每次访问子元素的时候，并为其传一个callback。\"><a href=\"#Q4-递归设计。-实现一个函数，给该函数一个DOM节点，函数访问其所有子元素-所有子元素，不仅仅是直接子元素-，每次访问子元素的时候，并为其传一个callback。\" class=\"headerlink\" title=\"Q4. 递归设计。 实现一个函数，给该函数一个DOM节点，函数访问其所有子元素(所有子元素，不仅仅是直接子元素)，每次访问子元素的时候，并为其传一个callback。\"></a>Q4. 递归设计。 实现一个函数，给该函数一个DOM节点，函数访问其所有子元素(所有子元素，不仅仅是直接子元素)，每次访问子元素的时候，并为其传一个callback。</h3><p>访问一个DOM tree，是一个经典的深度优先搜索的算法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Traverse</span>(<span class=\"params\">DOM,callback</span>) </span>&#123;</span><br><span class=\"line\">    callback(DOM);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> list = DOM.children;</span><br><span class=\"line\">    <span class=\"built_in\">Array</span>.prototype.forEach.apply(list,(item)=&gt;&#123;</span><br><span class=\"line\">        Traverse(item,callback); <span class=\"comment\">//递归</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>JavaScript总是给人以惊喜，学习不止，进步不断，今天继续补充JS容易搞错的几道笔试/面试题，为了秋招继续努力，欢迎一起为秋招努力的小伙伴共勉</p>\n<p>系列笔记：</p>\n<p><a href=\"https://forrany.github.io/2018/08/10/2018-08-10-VK-mistake-1/\" target=\"_blank\" rel=\"noopener\">1.VK的秋招前端奇遇记(一)</a></p>\n<p><a href=\"https://forrany.github.io/2018/08/11/2018-08-11-VK-mistake-2/\" target=\"_blank\" rel=\"noopener\">2.VK的秋招前端奇遇记(二)</a></p>\n<p><a href=\"https://forrany.github.io/2018/08/12/2018-08-12-VK-mistake-3/\" target=\"_blank\" rel=\"noopener\">3.VK的秋招前端奇遇记(三)</a></p>\n<p><a href=\"https://forrany.github.io/2018/09/04/2018-09-04-VK-mistake-4/\" target=\"_blank\" rel=\"noopener\">4.VK的秋招前端奇遇记(四)</a></p>\n<p><a href=\"https://forrany.github.io/2018/08/21/2018-08-21-front-end-interview-algorithm/\" target=\"_blank\" rel=\"noopener\">5.番外篇：前端面试&amp;笔试算法 Algorithm</a></p>\n<hr>\n<h2 id=\"”老生常错“的this与作用域相关\"><a href=\"#”老生常错“的this与作用域相关\" class=\"headerlink\" title=\"”老生常错“的this与作用域相关\"></a>”老生常错“的this与作用域相关</h2><h3 id=\"Q1-下面程序的输出结果是？\"><a href=\"#Q1-下面程序的输出结果是？\" class=\"headerlink\" title=\"Q1. 下面程序的输出结果是？\"></a>Q1. 下面程序的输出结果是？</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> length = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.length);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  length: <span class=\"number\">5</span>,</span><br><span class=\"line\">  method: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">    fn();</span><br><span class=\"line\">    <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>]();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.method(fn, <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>output: </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>这个我做错在第二个输出上，其实对<code>this</code>了解后就知道，第一个输出<code>10</code>应该是很显然的：虽然在程序执行时，使用了<code>obj.method</code>方法，让this指向了<code>obj</code>，但是真正的函数执行在函数体内部，也即当<code>fn()</code>执行的时候，<code>this</code>是指向<code>window</code>的，所以第一次执行结果是10</p>\n<p>那么这里第二次执行<code>arguments[0]</code>为什么结果是<code>2</code>？</p>\n<p>分析下在<code>method(fn,1)</code>执行时，经历了什么： 首先两个参数<code>fn</code>和<code>1</code>会被放入<code>arguments</code>中，在<code>arguments</code>中第一个参数就是我们传入的函数；接下来<code>fn</code>执行，此时<code>this</code>没有绑定因此指向<code>window</code>，输出<code>10</code>。 然而到了<code>arguments[0]()</code>这一句，相当于把<code>arguments[0]</code>中的第一个参数拿来执行, 效果如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>]()  <span class=\"comment\">//执行,等同于下面的</span></span><br><span class=\"line\"><span class=\"built_in\">arguments</span><span class=\"number\">.0</span>() <span class=\"comment\">//当然这句话是不合法的，但是这样我们可以更清楚知道，this是指向arguments实例本身</span></span><br></pre></td></tr></table></figure>\n<p><code>arguments.length</code>就是它本身的长度(arguments是一个类数组，具有length属性)，因此输出<code>2</code></p>\n<hr>\n<h3 id=\"Q2-try-catch程序的输出结果\"><a href=\"#Q2-try-catch程序的输出结果\" class=\"headerlink\" title=\"Q2. try..catch程序的输出结果\"></a>Q2. try..catch程序的输出结果</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (x) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> x = <span class=\"number\">1</span>, y = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(y);</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>输出结果:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>我们都知道<code>var</code>是在预编译阶段会有一个变量提升，这种类型很容易解决，但是当遇到在<code>catch(x)</code>中与已有变量重名的情况，一定要区分两者之间的关系。</p>\n<p>用变量提升的方法，把程序重写并分析如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x,y;  <span class=\"comment\">// 外部变量提升</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (x<span class=\"comment\">/* 内部的x */</span>) &#123;</span><br><span class=\"line\">\t\tx = <span class=\"number\">1</span>; <span class=\"comment\">//内部的x，和上面声明的x不是一回事！！</span></span><br><span class=\"line\">         y = <span class=\"number\">2</span>; <span class=\"comment\">//内部没有声明，作用域链向上找，外面的y</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(x); <span class=\"comment\">//当然是1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);  <span class=\"comment\">//只声明，未赋值，undefined</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(y);  <span class=\"comment\">//就是2了</span></span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>这样子就很清晰，之后注意预编译的过程，把变量和函数定义进行提升后，进行分析，会清楚很多</p>\n<hr>\n<h3 id=\"Q3-下面程序的输出\"><a href=\"#Q3-下面程序的输出\" class=\"headerlink\" title=\"Q3. 下面程序的输出\"></a>Q3. 下面程序的输出</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">21</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> girl = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">20</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">girl ();</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">undefined</span></span><br></pre></td></tr></table></figure>\n<p>说实话，这个题目我没做错，我没做错，我没做错！</p>\n<p>因为和Q2一样，而且还没有Q2难，一句话解释就是： 函数内部变量提升。 相当于</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">21</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> girl = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    x = <span class=\"number\">20</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"那些诡异的边角知识\"><a href=\"#那些诡异的边角知识\" class=\"headerlink\" title=\"那些诡异的边角知识\"></a>那些诡异的边角知识</h2><h3 id=\"Q1-运算符考点：-下面程序输出是什么\"><a href=\"#Q1-运算符考点：-下面程序输出是什么\" class=\"headerlink\" title=\"Q1.  运算符考点： 下面程序输出是什么?\"></a>Q1.  运算符考点： 下面程序输出是什么?</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span> &lt; <span class=\"number\">2</span> &lt; <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">3</span> &gt; <span class=\"number\">2</span> &gt; <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>输出:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">true</span></span><br><span class=\"line\">flase</span><br></pre></td></tr></table></figure>\n<p>第一个输出结果是好理解的，主要看下第二个为什么是<code>false</code></p>\n<p>核心在于js怎么去解析<code>&lt;</code>和<code>&gt;</code>运算符。 在JS中，这种运算符是从左向右运算的，所以<code>3&gt;2&gt;1</code>就被转换成了<code>true&gt;1</code>,而<code>true</code>的值是<code>1</code>，接着比较<code>1&gt;1</code>就返回false了。</p>\n<hr>\n<h3 id=\"Q2-typeof，下面输出结果是什么\"><a href=\"#Q2-typeof，下面输出结果是什么\" class=\"headerlink\" title=\"Q2. typeof，下面输出结果是什么\"></a>Q2. typeof，下面输出结果是什么</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"keyword\">typeof</span> <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>答案是<code>string</code></p>\n<p>会输出<code>string</code>，这个题目不仅仅是typeof的考察，也是对js运算的一个考察。 在js中一般有两种操作</p>\n<ul>\n<li>赋值操作，例如<code>a = b</code> <code>2&gt;3</code>之类的，上面的题目提到过，是从左向右的顺序</li>\n<li>取值操作， js问内存：<code>有没有见过这个家伙？</code>，比如<code>console.log(a)</code> <code>typeof a</code> 都属于这个类型，是从右向左的</li>\n</ul>\n<p>因此，这个题就被分解为<code>typeof 1</code>返回<code>&quot;number&quot;</code>，注意是一个字符串。 接下来<code>typeof &quot;number&quot;</code>，返回<code>string</code></p>\n<hr>\n<h3 id=\"Q3-typeof-undefined-typeof-NULL输出结果是什么\"><a href=\"#Q3-typeof-undefined-typeof-NULL输出结果是什么\" class=\"headerlink\" title=\"Q3. typeof undefined == typeof NULL输出结果是什么\"></a>Q3. <code>typeof undefined == typeof NULL</code>输出结果是什么</h3><p>首先搞清楚两点：</p>\n<ul>\n<li><code>typeof undefined</code> 输出是<code>undefined</code></li>\n<li><code>typeof null</code>输出是<code>object</code></li>\n</ul>\n<p>但是，另一方面，因为js对大小写敏感，<code>null</code> ≠ <code>NULL</code>，所以<code></code>typeof NULL<code>返回</code>undefined`</p>\n<p>结果是： <code>true</code></p>\n<h3 id=\"Q4-递归设计。-实现一个函数，给该函数一个DOM节点，函数访问其所有子元素-所有子元素，不仅仅是直接子元素-，每次访问子元素的时候，并为其传一个callback。\"><a href=\"#Q4-递归设计。-实现一个函数，给该函数一个DOM节点，函数访问其所有子元素-所有子元素，不仅仅是直接子元素-，每次访问子元素的时候，并为其传一个callback。\" class=\"headerlink\" title=\"Q4. 递归设计。 实现一个函数，给该函数一个DOM节点，函数访问其所有子元素(所有子元素，不仅仅是直接子元素)，每次访问子元素的时候，并为其传一个callback。\"></a>Q4. 递归设计。 实现一个函数，给该函数一个DOM节点，函数访问其所有子元素(所有子元素，不仅仅是直接子元素)，每次访问子元素的时候，并为其传一个callback。</h3><p>访问一个DOM tree，是一个经典的深度优先搜索的算法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Traverse</span>(<span class=\"params\">DOM,callback</span>) </span>&#123;</span><br><span class=\"line\">    callback(DOM);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> list = DOM.children;</span><br><span class=\"line\">    <span class=\"built_in\">Array</span>.prototype.forEach.apply(list,(item)=&gt;&#123;</span><br><span class=\"line\">        Traverse(item,callback); <span class=\"comment\">//递归</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"可能是最好的正则表达式教程的笔记","subtitle":"Note of the best RG coures","date":"2018-08-15T04:00:00.000Z","author":"Vinecnt Ko","header-img":"img/home-bg-o.jpg","header-mask":0.3,"catalog":true,"_content":"## 1.1. 基本语法\n通过一张图表来对正则表达式的基本进行一个回顾\n\nsingle char | quantifiers(位置) | Column C\n---------|----------|---------\n \\d 匹配数字 | * 0个或者更多 | ^一行的开头\n \\w  匹配word(数字、字母)| + 1个或更多，至少1个 | $一行的结尾\n \\W 匹配**非**word(数字、字母) | ? 0个或1个,一个Optional | \\b 单词\"结界\"(word bounds)\n \\s 匹配white space(包括空格、tab等) | {min,max}出现次数在一个范围内 | C3\n \\S 匹配**非**white space(包括空格、tab等) | {n}匹配出现n次的 | C3\n . 匹配任何，任何的字符 | B3 | C3\n\n### 1.1.1. single char\n假设你有一段字符如下：\n![字符](https://github.com/forrany/Web-Project/blob/master/blog_image/%E5%AD%97%E7%AC%A61.png?raw=true)\n\n * `\\w`\n\n 将匹配所有word，当然，() - 等字符除外\n\n * `\\w\\w\\w`\n\n发现匹配的有'`The`se `are` `som`e `pho`ne `number`s ...' \n 注意正则表达式是匹配一个连续串的规则，所以可以看到三个字母的单词可以匹配到，6个单词的也可以匹配到。\n\n * `\\s\\s`\n\n 匹配到一行中连续两个空格\n\n ## quantifiers\n假设我们有这一段话：\n```\nThe colors of the rainbow have many colours \nand the rainbow does not  have a single colour.\n```\n我们想把所有的颜色找出来`colors` `colours` `colour`\n\n**答案** `colou?rs?`  嗯，看起来很简单，很方便。\n\n---\n 好了，现在想要匹配一行中的4个数字，或者一行中的5个字母等，这时候用quantifiers就非常方便了。\n\n> 我现在想找5个字母组成的单词\n\n* `\\w{5}`\n这样可以吗？嗯..不行的，看下它匹配的内容,如下:\n'`These` are some `phone` `numbe`rs 915-555-1234...'\n的确，我们模板给的很简单，它只找一行中，连续出现5个字母的序列。所以现在改进一下好了\n\n* `\\w{5}\\s`\n为了能找到单词，所以我希望5个字母后，跟一个空格的序列，这样应该可以了吧，看下匹配情况：\n'`These `are some `phone `nu`mbers `915-555-1234...'\n嗯，是的，只有目前这些方法，是做不到的。 所以，我们需要第三个工具  \"position\"\n\n### 1.1.2. position\n\n回到刚才的问题之前，先熟悉下`^` `$` 和 `\\b`\n```\nThis is somthing\nis about\na blah\nwords\nsequence of words\nHello and\nGoodBye and \nGo gogo!\n```\n来看下各种正则所匹配的内容\n\n* `\\w+`\n这个应该毫无疑问，匹配所有的words\n\n* `^\\w+`\n多了一个`^`，这样子，就只能匹配到每一行开头的单词了`This` `is` `a` `words` `sequence` `Hello` `GoodBye` `Go`\n\n* `\\w+$`\n这样就能匹配到每行的最后一个字母\n\n回到刚才的问题\n>现在想找5个字母组成的单词\n\n就变得很简单了，使用单词结界符`\\b`\n\n答案就是`\\b\\w{5}\\b`\n\n### 1.1.3. 找个电话号码吧\n\n最后，找一个刚才出现的电话号`123-456-1231`\n\n用以上最基本的正则方法就是 `\\d{3}-\\d{3}-\\d{4}`，这样就找到了。 但是有的时候，电话号码是`123.456.1234` 或者 `(212)867-4233`的结构怎么办呢？\n\n正则表达式中的`或`或者其他表达方式，下面一一来介绍。\n\n## 1.2. 字符分类(char class) \n前面记录了最基本的方法，接下来说一下分类符`[]`\n\n这个符号用来表示逻辑关系`或`，比如`[abc]`表示a或者b或c.`[-.]`表示符号`-`或者`.`号(**注意这里，在`[]`中的`.`号代表的就是这个符号，但是如果在其外面，表示个匹配所有。 所以如果不在`[]`之中，想要匹配'.'，就要通过转意符号`\\.`**)\n\n### 1.2.1. 分类的简单应用\n字符序列：\n```\nThe lynk is quite a link don't you think? l nk l(nk\n```\n正则表达式：\n`l[yi (]k`\n\n结果:\n```\nlynk  link  l nk   l(nk\n```\n很容易理解的，就是表达`或`逻辑。 \n\n### 1.2.2. 匹配所有可能的电话号码\n好了，现在回到之前遗留的问题，有以下字段，请匹配所有可能的电话号码：\n```\nThese are some phone numbers 915-134-3122. Also,\nyou can call me at 643.123.1333 and of course,\nI'm always reachable at (212)867-5509\n```\n好的，一步一步来，刚才我们使用`\\d{3}-\\d{3}-\\d{4}`匹配了连字符的情况。现在我们可以很轻松的把`.`这种情况加进去了\n\n第一步： `\\d{3}[-.]\\d{3}[-.]\\d{4}`\n\n第二步: 为了能够匹配括号，可以使用?来，因为这是一个option选择。所以最后就成了\n\n`\\(?\\d{3}[-.)]\\d{3}[-.]\\d{4}`\n\n**这里还是要说明，在[]中，特殊字符不需要转义，可以直接使用，比如`[.()]`,但是在外面，是需要转义的`\\(` `\\.`等**\n\n### 1.2.3. []的特殊语法\n\n刚才介绍了最简单和基本的功能，但是有些特殊的地方需要注意\n\n1. -连接符不是第一个字符时\n`[-.]`的含义是连字符`-`或者点符`.`。 但是，如果当连字符不是第一个字符时，比如`[a-z]`，这就表示是从字母a到字符z。\n\n2. []中的^\n`^`在之前介绍中，是表示一行开头，但是在`[]`中，有着不同的含义。 \n`[ab]` 表示a或者b\n`[^ab]` 啥都行，只要不是a或b(anythings except a and b)，相当于取反\n\n### 1.2.4. []和()\n除了使用`[]`表示或逻辑,`()`也是可以的。用法是`(a|b)`表示a或者b\n\n比如下面的例子，匹配所有email\n```\ngaoyaqi411@126.com  \ndyumc@google.net \nsam@sjtu.edu\n```\n思路：\n\n首先要想我到底相匹配什么，这里我想匹配的是\n1. 任何一个以words开头的，一个或更多  `\\w+`\n2. 紧接着是一个`@`符号  `\\w+@`\n3. 接着有一个或者更多的words `\\w+@\\w+`\n4. 接着一个`.`标点 `\\w+@\\w+\\.`\n5. 接着一个`com` `net` 或 `edu` `\\w+@\\w+\\.(com|net|edu)`\n\n**还是提醒注意第四步的`\\.`转义符号**\n\n好了，这样几可以匹配以上的所有邮箱了。但是还有一个问题，因为邮箱用户名是可以有`.`的，比如`vincent.ko@126.com`\n\n其实仍然很简单，修复如下：\n`[\\w.]+@\\w+\\.(com|net|edu)`\n\n### 1.2.5. 总结\n1. `[]`的作用，用英文表达就是\"alternation\",表达一个或的逻辑；\n2. `/[-.(]/` 在符号中的连字符`-`放在第一位表示连字符本身，如果放在中间，表示\"从..到..\"，比如`[a-z]`表示a-z\n3. `[.)]` 括号中的特殊符号不需要转义，就表示其本身\n4. `[^ab]` 括号中的`^`表示非，anythings except `a` and `b`\n5. `(a|b)`也可表示选择，但是它有更强大的功能....\n\n所以，`()`的强大功能是什么呢？ 分组捕获，这对序列的替换、交换是很有帮助的。 后面一节进行学习记录\n\n## 1.3. 分组捕获(capturing groups)\n\n什么是分组捕获，现在回到之前电话号码的例子\n```\n212-555-1234\n915-412-1333\n\n//我想要保留区号，把后面的电话号码变为通用性的\n👇👇👇👇👇👇👇👇👇👇👇👇\n\n212-xxx-xxxx\n915-xxx-xxxx\n```\n按照之前的做法`\\d{3}-\\d{3}-\\d{4}`,这种匹配的方式，是将整个电话号码作为一个组(group)匹配起来。 我们把`212-555-1234`这样的叫`Group0`。\n\n这个时候，如果我们加了一个括号`\\d{3}-(\\d{3})-\\d{4}`，那么匹配到的`555`就叫`Group1`。 \n以此类推，如果有两个小括号`\\d{3}-(\\d{3})-(\\d{4})`那么分组就是下面的情况：\n```\n212-555-1234   Group0\n555            Group1\n1234           Group2\n```\n\n### 1.3.1. 选择分组\n现在组已经分好，那么如何选择已经匹配的分组？\n\n这里有两种方法，第一种使用`$`符号，比如`$1` 代表`555`,`$2`代表`1234`；第二种，使用`\\`,比如`\\1`代表`555`。两种的使用场景不一样，先讲`$`\n\n现在为了满足最开始的要求，我们可以这么做\n```\nreg: \\(?(\\d{3})[-.)]\\d{3}[-.]\\d{4}\n\nreplace: $1-xxx-xxxx\n```\n**ps: 这里可以直接用JS的replace函数进行操作，但是正则不是JS专属的，所以这里先介绍通用方法，之后对JS部分进行总结**\n\n### 1.3.2. 实景训练\n\n1. 现在有一个名单列表，但是姓和名称是反的，我需要把他交换过来\n```\nshiffina, Daniel\nshifafl, Daniell\nshquer, Danny\n...\n```\n\n实现方法:\n```\nreg: (\\w+),\\s(\\w+)\n\nreplace: $2 $1\n```\n注意：`$0` 是所有匹配到的，所以第一个加括号的是`$1`\n\n2. 匹配markdown中的link标签，并替换为html标签\n```\n[google](http://google.com)\n[itp](http://itp.nyu.edu)\n[Coding Rainbow](http://codingrainbow.com)\n```\n\n解析： 这道题有些坑，需要慢慢来。\n\n看到这个，第一个想考虑匹配`[google]`这个东西，立马想到正则表达式`\\[.*\\]`。 这个是巨大的坑，在当前来看，它的确能正确匹配到上面的三条。 但是如果文本是这样的：\n![字符匹配](https://github.com/forrany/Web-Project/blob/master/blog_image/zifupipei.png?raw=true)\n\n看到了，第一行的内容会全部匹配下来，而不能区分`[google]`和`[test]`。 之所以这样，**是因为`.`是贪婪的，他表示所有，所有能匹配到的，所以当然也包括了`]`，一直到这一行的最后一个`]`，它才停止。**\n\n所以为了让它能正确匹配，需要去掉这种贪婪的属性。这里用到`？` 。 当`?`放在了`quantifiers`符号后，表示去掉贪婪属性，匹配到终止条件，即可停下。\n\n`\\[.*?\\]`这样子，就可以将`[google]`和`[test]`分开,效果如下：\n![分割](https://github.com/forrany/Web-Project/blob/master/blog_image/split.png?raw=true)\n\n接下来完成所有内容：\n```\nreg: \\[(.*?)\\]\\((http.*?)\\)\n\nreplace: <a href=\"$2\">$1</a>\n```\n\n### 1.3.3. 使用`\\`选择器\n\n`$`选择符是在替换的时候进行的标志或选择，但是如果在正则表达式本身，就要使用`\\`选择了。比如以下的场景\n\n```\nThis is is a a dog , I think think this is is really\na a good good dog. Don't you you thinks so so ?\n```\n\n我们想要匹配比如`is is` `so so `这样连续的序列，就用到了下面的表达方式: `(\\w+)\\s\\1`\n\n效果:\n![效果图](https://github.com/forrany/Web-Project/blob/master/blog_image/xiaoguo.png?raw=true)\n\n嗯，差不多达到效果，但是有一些小的bug。比如第一句话`This is is a` 这个就匹配不准确，会把第一个This的后面字母匹配进去。\n**这就用到第一节说的字符结界 `\\b`了**，就变成了`\\b(\\w+)\\s\\1\\b`\n\n好了，大功告成，就不贴效果图了，自行脑补就好了。\n\n### 1.3.4. 总结\n1. 分组捕获，使用()进行数据分组，编号0代表整个匹配项，选择的分组从1号开始\n2. 选择器可以使用`$1`和`\\1`，但是使用场景不同，`\\`用在正则表达式自己身上\n3. `?`符号可以禁止贪婪属性，放在`.*`之后，表示一次匹配遇到重点就可以停止。否则将会一直向后匹配。\n\n## 1.4. 在JavaScript中的应用\n\n在js中，主要的正则表达式都是涉及到string的应用。\n```\nvar str = \"hello\"\nvar r = /w+/\n```\n这两个分别是string和reg的字面量创建方法。当要使用正则来进行操作的时候，使用了`r.test()`和`str.match()` 以及`str.replace`等方法。\n\n### 1.4.1. reg.test()\n\n正则表达式本身有一个test的方法，这个方法只能测试是否包含，返回一个bool变量。\n```\nvar r = /\\d{3}/;\nvar a = '123';\nvar b = '123ABC';\nvar c = 'abc';\n\nr.test(a)  //true\nr.test(b) //true\nr.test(c) //false\n```\n\n嗯，这个很简单，而且用的实际不多，下面着重讲str上的一些方法。\n\n### 1.4.2. str.match()\n\n与test()不同，不只是返回bool变量，它会返回你所匹配到的内容。\n```javascript\nvar r = /compus/\nvar reg = /w+/\nvar s = \"compus, I know something about you\"\nr.test(s)  //true\ns.match(r)  //[\"compus\"]\ns.match(reg) //[\"compus\"]\n\n```\n等等，好像有点问题，为什么最后一个返回的也是\"compus\"？这不科学。\n\n好吧，实际上，match()返回了第一个可以匹配的序列。想要实现之前的效果，就要用到JS里关于正则的几个flag\n#### 1.4.2.1. flag\n这个标志就在建立正则的时候就要有的，主要有三个\n\nflag | 含义\n---------|----------\n g | 全部的，给我匹配全部的 \n i | 忽略大小写\n m | 多行匹配\n\n 所以为了解决刚才的问题，只要这样子设置reg就可以了\n ```javascript\nvar reg = /w+/g\n ```\n\n看下面一个练习\n```javascript\nvar str = \"Here is a Phone Number 111-2313 and 133-2311\"\n\nvar r = /\\d{3}[-.]\\d{4}/\nvar rg = /\\d{3}[-.]d{4}/g\n\nconsole.log(str.match(r)); //[\"111-2313\"]\nconsole.log(str.match(rg));//[\"111-2313\",\"133-2311\"]\n```\n嗯，找电话号码，是的，很方便。但是还有一个问题，刚才说的分组，那么match会返回分组吗？\n\n```javascript\nvar sr = /(\\d{3})[-.]\\d{4}/\nvar srg = /(\\d{3})[-.]\\d{4}/g\n\nconsole.log(str.match(sr)); //[\"111-2313\",\"111\"]\nconsole.log(str.match(srg)); //[\"111-2313\",\"133-2311\"]\n```\n\n所以结论是： 当使用了全局flag`g`的时候，不会返回分组，而是全部的匹配结果；如果没有使用`g`，会将匹配到的结果和分组以数组的形式返回。\n\n那么如何实现全局的分组？ \n\n### 1.4.3. reg.exec()\n从字面意思来看，正则表达式的执行方法。 这个方法可以实现匹配全局，并返回分组的结果。\n> reg.exec()每次调用，返回一个匹配的结果，匹配结果和分组以数组的形式返回，不断的调用即可返回下一个结果，直到返回`null`\n\n```javascript\nvar str = \"Here is a Phone Number 111-2313 and 133-2311\" ;\nvar srg = /(\\d{3})[-.]\\d{4}/g;\nvar result = srg.exec(str);\nwhile(result !== null) {\n    console.log(result);\n    result = srg.exec(str);\n}\n\n```\nresult包含的内容可能比想象中的多，它是一个数组，比如第一次执行，他的结果为：\n```javascript\n[\"133-2311\", \"133\", index: 36, \ninput: \"Here is a Phone Number 111-2313 and 133-2311\" groups: undefined]\n```\n\n### 1.4.4. str.split\n现在来到了更强的功能上，先说下split，我们知道split是将字符串按照某个字符分隔开，比如有以下一段话，需要将其分割成单词。\n```\nvar s = \"unicorns and rainbows And, Cupcakes\"\n```\n\n分割成单词，首先想到的是空格隔开，于是可以用下面方式实现\n```javascript\nvar result = s.split(' ');\nvar result1 = s.split(/\\s/);\n//完全一样的效果\n//[\"unicorns\", \"and\", \"rainbows\", \"And,\", \"Cupcakes\"]\n```\n嗯，这样体现不出来正则的强大，而且最主要的是没有实现要求。因为还有一个\"And,\"。所以要用正则了，匹配条件是`逗号或者空格`\n\n```javascript\nresult = s.split(/[,\\s]/);\n\n//[\"unicorns\", \"and\", \"rainbows\", \"And\", \"\", \"Cupcakes\"]\n```\n结果仍然和需要的有出入，因为多了一个\"\"。 我们并不是想让它分割的依据是`逗号或者空格`,依据应该是`逗号或空格所在的连续序列`。 在原来的基础上加一个`+`，改成`/[,\\s]+/`，这个含义就是`一个单独的逗号，或者一个单独的空格`\n```javascript\nresult = s.split(/[,\\s]+/);\n// [\"unicorns\", \"and\", \"rainbows\", \"And\", \"Cupcakes\"]\n```\n\n#### 1.4.4.1. 单词分割\n好了，拓展一下，实现一个段落的单词分割，一个正则表达式就是\n```javascript\nresult = s.split(/[,.!?\\s]+/)\n```\n当然，有个最简单的方法，我们可以这样去做\n```javascript\nresult = s.split(/\\W+/);\n```\n\n接着，如果我们想将一个段落的句子都分隔开，一个可以实现的表达式就是\n```javascript\nresult = s.split(/[.,!?]+/)\n```\n\n最后，有一个小需求，就是在分割句子的同时，还想把相应的分隔符保留下来。\n```javascript\nvar s = \n\"Hello,My name is Vincent. Nice to Meet you!What's your name? Haha.\"\n```\n这是一个小小的ponit，记住**如果想要保留分隔符，只要给匹配的内容分组即可**\n```javascript\nvar result = s.split(/([.,!?]+)/)\n//[\"Hello\", \",\", \"My name is Vincent\", \".\", \" Nice to Meet you\", \"!\", \"What's your name\", \"?\", \" Haha\", \".\", \"\"]\n```\n可以看到，这样就会把分隔符也存储起来。\n\n### 1.4.5. str.replace()\nreplace也是字符串的方法，它的基本用法是`str.replace(reg,replace|function)`，第一个参数是正则表达式，代表匹配的内容，第二个参数是替换的字符串或者一个回掉函数。\n\n**注意，replace不会修改原字符串，只是返回一个修改后的字符串;除此外，正则表达式如果没有使用`g`标志，也和`match`一样，只匹配/替换第一个**\n\n#### 1.4.5.1. 最简单的替换\n> 替换一个序列中的元音字母(aeiou)，将其替换成一个double。 比如x->xx\n\n```javascript\nvar s = \"Hello,My name is Vincent.\"\nvar result = s.replace(/([aeiou])/g,\"$1$1\")\n//\"Heelloo,My naamee iis Viinceent.\"\n```\n**注意，第二个参数必须是字符串; 注意不要忘记加`g`**\n\n#### 1.4.5.2. 牛x哄哄的function参数来了\n嗯，这才是最强大的地方，第二参数传入function，先看一个最简单的示例\n```javascript\nvar s = \"Hello,My name is Vincent. What is your name?\"\nvar newStr = s.replace(/\\b\\w{4}\\b/g,replacer)\nconsole.log(newStr)\nfunction replacer(match) {\n    console.log(match);\n    return match.toUpperCase();\n}\n/*\nname\nWhat\nyour\nname\nHello,My NAME is Vincent. WHAT is YOUR NAME?\n*/\n```\n\n所以，函数的参数是匹配到的内容，返回的是需要替换的内容。好了，基本示例解释了基本用法，那么之前讨论的分组怎么办？如何实现分组呢？\n```javascript\n//分组\n\nfunction replacer(match,group1,group2) {\n    console.log(group1);\n    console.log(group2);\n}\n\n```\n如果正则表达式分组处理，那么在回调函数中，函数的第二个、第三参数就是group1,group2。这样子，就可以做很多神奇的事情\n\n#### 1.4.5.3. 综合练习题\n1. 判断一个字符串中出现次数最多的字符，并统计次数\n\n```javascript\nvar s = 'aaabbbcccaaabbbaaa';\nvar a = s.split('').sort().join(\"\");  //\"aaaaaaaaabbbbbbccc\"\nvar ans = a.match(/(\\w)\\1+/g);\nans.sort(function(a,b) {\n    return a.length - b.length;\n})\nconsole.log('ans is : ' + ans[ans.length])\n\n```\n\n### 1.4.6. 总结\n1. 在js中，正则表达式字面量`/reg/`和字符串字面量`\"str\"`用于创建正则和字符串。其中正则上有两个方法`reg.test()`和`reg.exec()`\n2. `reg.test(str)`方法，返回布尔变量，用于指示是否有所匹配； `reg.exec(str)`有点类似与迭代器，每次执行，返回匹配结果和分组，直到返回为`null`结束。\n3. 字符串方法主要有`str.match(reg)`,`str.split(reg)`和`str.replace(reg,str|function)` 三种方法。\n4. `match`比较特殊，如果正则包含了分组，且没有`g`标志，则返回匹配内容和分组; 如果没有分组，且有`g`标志，返回所有匹配内容\n5. `split`方法主要用于字符串分割，如果想要保存分隔符，记得将匹配内容分组(用小括号包起来)\n6. `replace`是最强大的方法，当使用回掉函数时，返回值就是替换值; 参数分别为`匹配值` `group1` `group2`...","source":"_posts/2018-08-15-regular-expression.md","raw":"---\nlayout:     post\ntitle:      \"可能是最好的正则表达式教程的笔记\"\nsubtitle:   \"Note of the best RG coures\"\ndate:       2018-08-15 12:00:00\nauthor:     \"Vinecnt Ko\"\nheader-img: \"img/home-bg-o.jpg\"\nheader-mask: 0.3\ncatalog:    true\ntags:\n    - 正则表达式\n    - JavaScript\n---\n## 1.1. 基本语法\n通过一张图表来对正则表达式的基本进行一个回顾\n\nsingle char | quantifiers(位置) | Column C\n---------|----------|---------\n \\d 匹配数字 | * 0个或者更多 | ^一行的开头\n \\w  匹配word(数字、字母)| + 1个或更多，至少1个 | $一行的结尾\n \\W 匹配**非**word(数字、字母) | ? 0个或1个,一个Optional | \\b 单词\"结界\"(word bounds)\n \\s 匹配white space(包括空格、tab等) | {min,max}出现次数在一个范围内 | C3\n \\S 匹配**非**white space(包括空格、tab等) | {n}匹配出现n次的 | C3\n . 匹配任何，任何的字符 | B3 | C3\n\n### 1.1.1. single char\n假设你有一段字符如下：\n![字符](https://github.com/forrany/Web-Project/blob/master/blog_image/%E5%AD%97%E7%AC%A61.png?raw=true)\n\n * `\\w`\n\n 将匹配所有word，当然，() - 等字符除外\n\n * `\\w\\w\\w`\n\n发现匹配的有'`The`se `are` `som`e `pho`ne `number`s ...' \n 注意正则表达式是匹配一个连续串的规则，所以可以看到三个字母的单词可以匹配到，6个单词的也可以匹配到。\n\n * `\\s\\s`\n\n 匹配到一行中连续两个空格\n\n ## quantifiers\n假设我们有这一段话：\n```\nThe colors of the rainbow have many colours \nand the rainbow does not  have a single colour.\n```\n我们想把所有的颜色找出来`colors` `colours` `colour`\n\n**答案** `colou?rs?`  嗯，看起来很简单，很方便。\n\n---\n 好了，现在想要匹配一行中的4个数字，或者一行中的5个字母等，这时候用quantifiers就非常方便了。\n\n> 我现在想找5个字母组成的单词\n\n* `\\w{5}`\n这样可以吗？嗯..不行的，看下它匹配的内容,如下:\n'`These` are some `phone` `numbe`rs 915-555-1234...'\n的确，我们模板给的很简单，它只找一行中，连续出现5个字母的序列。所以现在改进一下好了\n\n* `\\w{5}\\s`\n为了能找到单词，所以我希望5个字母后，跟一个空格的序列，这样应该可以了吧，看下匹配情况：\n'`These `are some `phone `nu`mbers `915-555-1234...'\n嗯，是的，只有目前这些方法，是做不到的。 所以，我们需要第三个工具  \"position\"\n\n### 1.1.2. position\n\n回到刚才的问题之前，先熟悉下`^` `$` 和 `\\b`\n```\nThis is somthing\nis about\na blah\nwords\nsequence of words\nHello and\nGoodBye and \nGo gogo!\n```\n来看下各种正则所匹配的内容\n\n* `\\w+`\n这个应该毫无疑问，匹配所有的words\n\n* `^\\w+`\n多了一个`^`，这样子，就只能匹配到每一行开头的单词了`This` `is` `a` `words` `sequence` `Hello` `GoodBye` `Go`\n\n* `\\w+$`\n这样就能匹配到每行的最后一个字母\n\n回到刚才的问题\n>现在想找5个字母组成的单词\n\n就变得很简单了，使用单词结界符`\\b`\n\n答案就是`\\b\\w{5}\\b`\n\n### 1.1.3. 找个电话号码吧\n\n最后，找一个刚才出现的电话号`123-456-1231`\n\n用以上最基本的正则方法就是 `\\d{3}-\\d{3}-\\d{4}`，这样就找到了。 但是有的时候，电话号码是`123.456.1234` 或者 `(212)867-4233`的结构怎么办呢？\n\n正则表达式中的`或`或者其他表达方式，下面一一来介绍。\n\n## 1.2. 字符分类(char class) \n前面记录了最基本的方法，接下来说一下分类符`[]`\n\n这个符号用来表示逻辑关系`或`，比如`[abc]`表示a或者b或c.`[-.]`表示符号`-`或者`.`号(**注意这里，在`[]`中的`.`号代表的就是这个符号，但是如果在其外面，表示个匹配所有。 所以如果不在`[]`之中，想要匹配'.'，就要通过转意符号`\\.`**)\n\n### 1.2.1. 分类的简单应用\n字符序列：\n```\nThe lynk is quite a link don't you think? l nk l(nk\n```\n正则表达式：\n`l[yi (]k`\n\n结果:\n```\nlynk  link  l nk   l(nk\n```\n很容易理解的，就是表达`或`逻辑。 \n\n### 1.2.2. 匹配所有可能的电话号码\n好了，现在回到之前遗留的问题，有以下字段，请匹配所有可能的电话号码：\n```\nThese are some phone numbers 915-134-3122. Also,\nyou can call me at 643.123.1333 and of course,\nI'm always reachable at (212)867-5509\n```\n好的，一步一步来，刚才我们使用`\\d{3}-\\d{3}-\\d{4}`匹配了连字符的情况。现在我们可以很轻松的把`.`这种情况加进去了\n\n第一步： `\\d{3}[-.]\\d{3}[-.]\\d{4}`\n\n第二步: 为了能够匹配括号，可以使用?来，因为这是一个option选择。所以最后就成了\n\n`\\(?\\d{3}[-.)]\\d{3}[-.]\\d{4}`\n\n**这里还是要说明，在[]中，特殊字符不需要转义，可以直接使用，比如`[.()]`,但是在外面，是需要转义的`\\(` `\\.`等**\n\n### 1.2.3. []的特殊语法\n\n刚才介绍了最简单和基本的功能，但是有些特殊的地方需要注意\n\n1. -连接符不是第一个字符时\n`[-.]`的含义是连字符`-`或者点符`.`。 但是，如果当连字符不是第一个字符时，比如`[a-z]`，这就表示是从字母a到字符z。\n\n2. []中的^\n`^`在之前介绍中，是表示一行开头，但是在`[]`中，有着不同的含义。 \n`[ab]` 表示a或者b\n`[^ab]` 啥都行，只要不是a或b(anythings except a and b)，相当于取反\n\n### 1.2.4. []和()\n除了使用`[]`表示或逻辑,`()`也是可以的。用法是`(a|b)`表示a或者b\n\n比如下面的例子，匹配所有email\n```\ngaoyaqi411@126.com  \ndyumc@google.net \nsam@sjtu.edu\n```\n思路：\n\n首先要想我到底相匹配什么，这里我想匹配的是\n1. 任何一个以words开头的，一个或更多  `\\w+`\n2. 紧接着是一个`@`符号  `\\w+@`\n3. 接着有一个或者更多的words `\\w+@\\w+`\n4. 接着一个`.`标点 `\\w+@\\w+\\.`\n5. 接着一个`com` `net` 或 `edu` `\\w+@\\w+\\.(com|net|edu)`\n\n**还是提醒注意第四步的`\\.`转义符号**\n\n好了，这样几可以匹配以上的所有邮箱了。但是还有一个问题，因为邮箱用户名是可以有`.`的，比如`vincent.ko@126.com`\n\n其实仍然很简单，修复如下：\n`[\\w.]+@\\w+\\.(com|net|edu)`\n\n### 1.2.5. 总结\n1. `[]`的作用，用英文表达就是\"alternation\",表达一个或的逻辑；\n2. `/[-.(]/` 在符号中的连字符`-`放在第一位表示连字符本身，如果放在中间，表示\"从..到..\"，比如`[a-z]`表示a-z\n3. `[.)]` 括号中的特殊符号不需要转义，就表示其本身\n4. `[^ab]` 括号中的`^`表示非，anythings except `a` and `b`\n5. `(a|b)`也可表示选择，但是它有更强大的功能....\n\n所以，`()`的强大功能是什么呢？ 分组捕获，这对序列的替换、交换是很有帮助的。 后面一节进行学习记录\n\n## 1.3. 分组捕获(capturing groups)\n\n什么是分组捕获，现在回到之前电话号码的例子\n```\n212-555-1234\n915-412-1333\n\n//我想要保留区号，把后面的电话号码变为通用性的\n👇👇👇👇👇👇👇👇👇👇👇👇\n\n212-xxx-xxxx\n915-xxx-xxxx\n```\n按照之前的做法`\\d{3}-\\d{3}-\\d{4}`,这种匹配的方式，是将整个电话号码作为一个组(group)匹配起来。 我们把`212-555-1234`这样的叫`Group0`。\n\n这个时候，如果我们加了一个括号`\\d{3}-(\\d{3})-\\d{4}`，那么匹配到的`555`就叫`Group1`。 \n以此类推，如果有两个小括号`\\d{3}-(\\d{3})-(\\d{4})`那么分组就是下面的情况：\n```\n212-555-1234   Group0\n555            Group1\n1234           Group2\n```\n\n### 1.3.1. 选择分组\n现在组已经分好，那么如何选择已经匹配的分组？\n\n这里有两种方法，第一种使用`$`符号，比如`$1` 代表`555`,`$2`代表`1234`；第二种，使用`\\`,比如`\\1`代表`555`。两种的使用场景不一样，先讲`$`\n\n现在为了满足最开始的要求，我们可以这么做\n```\nreg: \\(?(\\d{3})[-.)]\\d{3}[-.]\\d{4}\n\nreplace: $1-xxx-xxxx\n```\n**ps: 这里可以直接用JS的replace函数进行操作，但是正则不是JS专属的，所以这里先介绍通用方法，之后对JS部分进行总结**\n\n### 1.3.2. 实景训练\n\n1. 现在有一个名单列表，但是姓和名称是反的，我需要把他交换过来\n```\nshiffina, Daniel\nshifafl, Daniell\nshquer, Danny\n...\n```\n\n实现方法:\n```\nreg: (\\w+),\\s(\\w+)\n\nreplace: $2 $1\n```\n注意：`$0` 是所有匹配到的，所以第一个加括号的是`$1`\n\n2. 匹配markdown中的link标签，并替换为html标签\n```\n[google](http://google.com)\n[itp](http://itp.nyu.edu)\n[Coding Rainbow](http://codingrainbow.com)\n```\n\n解析： 这道题有些坑，需要慢慢来。\n\n看到这个，第一个想考虑匹配`[google]`这个东西，立马想到正则表达式`\\[.*\\]`。 这个是巨大的坑，在当前来看，它的确能正确匹配到上面的三条。 但是如果文本是这样的：\n![字符匹配](https://github.com/forrany/Web-Project/blob/master/blog_image/zifupipei.png?raw=true)\n\n看到了，第一行的内容会全部匹配下来，而不能区分`[google]`和`[test]`。 之所以这样，**是因为`.`是贪婪的，他表示所有，所有能匹配到的，所以当然也包括了`]`，一直到这一行的最后一个`]`，它才停止。**\n\n所以为了让它能正确匹配，需要去掉这种贪婪的属性。这里用到`？` 。 当`?`放在了`quantifiers`符号后，表示去掉贪婪属性，匹配到终止条件，即可停下。\n\n`\\[.*?\\]`这样子，就可以将`[google]`和`[test]`分开,效果如下：\n![分割](https://github.com/forrany/Web-Project/blob/master/blog_image/split.png?raw=true)\n\n接下来完成所有内容：\n```\nreg: \\[(.*?)\\]\\((http.*?)\\)\n\nreplace: <a href=\"$2\">$1</a>\n```\n\n### 1.3.3. 使用`\\`选择器\n\n`$`选择符是在替换的时候进行的标志或选择，但是如果在正则表达式本身，就要使用`\\`选择了。比如以下的场景\n\n```\nThis is is a a dog , I think think this is is really\na a good good dog. Don't you you thinks so so ?\n```\n\n我们想要匹配比如`is is` `so so `这样连续的序列，就用到了下面的表达方式: `(\\w+)\\s\\1`\n\n效果:\n![效果图](https://github.com/forrany/Web-Project/blob/master/blog_image/xiaoguo.png?raw=true)\n\n嗯，差不多达到效果，但是有一些小的bug。比如第一句话`This is is a` 这个就匹配不准确，会把第一个This的后面字母匹配进去。\n**这就用到第一节说的字符结界 `\\b`了**，就变成了`\\b(\\w+)\\s\\1\\b`\n\n好了，大功告成，就不贴效果图了，自行脑补就好了。\n\n### 1.3.4. 总结\n1. 分组捕获，使用()进行数据分组，编号0代表整个匹配项，选择的分组从1号开始\n2. 选择器可以使用`$1`和`\\1`，但是使用场景不同，`\\`用在正则表达式自己身上\n3. `?`符号可以禁止贪婪属性，放在`.*`之后，表示一次匹配遇到重点就可以停止。否则将会一直向后匹配。\n\n## 1.4. 在JavaScript中的应用\n\n在js中，主要的正则表达式都是涉及到string的应用。\n```\nvar str = \"hello\"\nvar r = /w+/\n```\n这两个分别是string和reg的字面量创建方法。当要使用正则来进行操作的时候，使用了`r.test()`和`str.match()` 以及`str.replace`等方法。\n\n### 1.4.1. reg.test()\n\n正则表达式本身有一个test的方法，这个方法只能测试是否包含，返回一个bool变量。\n```\nvar r = /\\d{3}/;\nvar a = '123';\nvar b = '123ABC';\nvar c = 'abc';\n\nr.test(a)  //true\nr.test(b) //true\nr.test(c) //false\n```\n\n嗯，这个很简单，而且用的实际不多，下面着重讲str上的一些方法。\n\n### 1.4.2. str.match()\n\n与test()不同，不只是返回bool变量，它会返回你所匹配到的内容。\n```javascript\nvar r = /compus/\nvar reg = /w+/\nvar s = \"compus, I know something about you\"\nr.test(s)  //true\ns.match(r)  //[\"compus\"]\ns.match(reg) //[\"compus\"]\n\n```\n等等，好像有点问题，为什么最后一个返回的也是\"compus\"？这不科学。\n\n好吧，实际上，match()返回了第一个可以匹配的序列。想要实现之前的效果，就要用到JS里关于正则的几个flag\n#### 1.4.2.1. flag\n这个标志就在建立正则的时候就要有的，主要有三个\n\nflag | 含义\n---------|----------\n g | 全部的，给我匹配全部的 \n i | 忽略大小写\n m | 多行匹配\n\n 所以为了解决刚才的问题，只要这样子设置reg就可以了\n ```javascript\nvar reg = /w+/g\n ```\n\n看下面一个练习\n```javascript\nvar str = \"Here is a Phone Number 111-2313 and 133-2311\"\n\nvar r = /\\d{3}[-.]\\d{4}/\nvar rg = /\\d{3}[-.]d{4}/g\n\nconsole.log(str.match(r)); //[\"111-2313\"]\nconsole.log(str.match(rg));//[\"111-2313\",\"133-2311\"]\n```\n嗯，找电话号码，是的，很方便。但是还有一个问题，刚才说的分组，那么match会返回分组吗？\n\n```javascript\nvar sr = /(\\d{3})[-.]\\d{4}/\nvar srg = /(\\d{3})[-.]\\d{4}/g\n\nconsole.log(str.match(sr)); //[\"111-2313\",\"111\"]\nconsole.log(str.match(srg)); //[\"111-2313\",\"133-2311\"]\n```\n\n所以结论是： 当使用了全局flag`g`的时候，不会返回分组，而是全部的匹配结果；如果没有使用`g`，会将匹配到的结果和分组以数组的形式返回。\n\n那么如何实现全局的分组？ \n\n### 1.4.3. reg.exec()\n从字面意思来看，正则表达式的执行方法。 这个方法可以实现匹配全局，并返回分组的结果。\n> reg.exec()每次调用，返回一个匹配的结果，匹配结果和分组以数组的形式返回，不断的调用即可返回下一个结果，直到返回`null`\n\n```javascript\nvar str = \"Here is a Phone Number 111-2313 and 133-2311\" ;\nvar srg = /(\\d{3})[-.]\\d{4}/g;\nvar result = srg.exec(str);\nwhile(result !== null) {\n    console.log(result);\n    result = srg.exec(str);\n}\n\n```\nresult包含的内容可能比想象中的多，它是一个数组，比如第一次执行，他的结果为：\n```javascript\n[\"133-2311\", \"133\", index: 36, \ninput: \"Here is a Phone Number 111-2313 and 133-2311\" groups: undefined]\n```\n\n### 1.4.4. str.split\n现在来到了更强的功能上，先说下split，我们知道split是将字符串按照某个字符分隔开，比如有以下一段话，需要将其分割成单词。\n```\nvar s = \"unicorns and rainbows And, Cupcakes\"\n```\n\n分割成单词，首先想到的是空格隔开，于是可以用下面方式实现\n```javascript\nvar result = s.split(' ');\nvar result1 = s.split(/\\s/);\n//完全一样的效果\n//[\"unicorns\", \"and\", \"rainbows\", \"And,\", \"Cupcakes\"]\n```\n嗯，这样体现不出来正则的强大，而且最主要的是没有实现要求。因为还有一个\"And,\"。所以要用正则了，匹配条件是`逗号或者空格`\n\n```javascript\nresult = s.split(/[,\\s]/);\n\n//[\"unicorns\", \"and\", \"rainbows\", \"And\", \"\", \"Cupcakes\"]\n```\n结果仍然和需要的有出入，因为多了一个\"\"。 我们并不是想让它分割的依据是`逗号或者空格`,依据应该是`逗号或空格所在的连续序列`。 在原来的基础上加一个`+`，改成`/[,\\s]+/`，这个含义就是`一个单独的逗号，或者一个单独的空格`\n```javascript\nresult = s.split(/[,\\s]+/);\n// [\"unicorns\", \"and\", \"rainbows\", \"And\", \"Cupcakes\"]\n```\n\n#### 1.4.4.1. 单词分割\n好了，拓展一下，实现一个段落的单词分割，一个正则表达式就是\n```javascript\nresult = s.split(/[,.!?\\s]+/)\n```\n当然，有个最简单的方法，我们可以这样去做\n```javascript\nresult = s.split(/\\W+/);\n```\n\n接着，如果我们想将一个段落的句子都分隔开，一个可以实现的表达式就是\n```javascript\nresult = s.split(/[.,!?]+/)\n```\n\n最后，有一个小需求，就是在分割句子的同时，还想把相应的分隔符保留下来。\n```javascript\nvar s = \n\"Hello,My name is Vincent. Nice to Meet you!What's your name? Haha.\"\n```\n这是一个小小的ponit，记住**如果想要保留分隔符，只要给匹配的内容分组即可**\n```javascript\nvar result = s.split(/([.,!?]+)/)\n//[\"Hello\", \",\", \"My name is Vincent\", \".\", \" Nice to Meet you\", \"!\", \"What's your name\", \"?\", \" Haha\", \".\", \"\"]\n```\n可以看到，这样就会把分隔符也存储起来。\n\n### 1.4.5. str.replace()\nreplace也是字符串的方法，它的基本用法是`str.replace(reg,replace|function)`，第一个参数是正则表达式，代表匹配的内容，第二个参数是替换的字符串或者一个回掉函数。\n\n**注意，replace不会修改原字符串，只是返回一个修改后的字符串;除此外，正则表达式如果没有使用`g`标志，也和`match`一样，只匹配/替换第一个**\n\n#### 1.4.5.1. 最简单的替换\n> 替换一个序列中的元音字母(aeiou)，将其替换成一个double。 比如x->xx\n\n```javascript\nvar s = \"Hello,My name is Vincent.\"\nvar result = s.replace(/([aeiou])/g,\"$1$1\")\n//\"Heelloo,My naamee iis Viinceent.\"\n```\n**注意，第二个参数必须是字符串; 注意不要忘记加`g`**\n\n#### 1.4.5.2. 牛x哄哄的function参数来了\n嗯，这才是最强大的地方，第二参数传入function，先看一个最简单的示例\n```javascript\nvar s = \"Hello,My name is Vincent. What is your name?\"\nvar newStr = s.replace(/\\b\\w{4}\\b/g,replacer)\nconsole.log(newStr)\nfunction replacer(match) {\n    console.log(match);\n    return match.toUpperCase();\n}\n/*\nname\nWhat\nyour\nname\nHello,My NAME is Vincent. WHAT is YOUR NAME?\n*/\n```\n\n所以，函数的参数是匹配到的内容，返回的是需要替换的内容。好了，基本示例解释了基本用法，那么之前讨论的分组怎么办？如何实现分组呢？\n```javascript\n//分组\n\nfunction replacer(match,group1,group2) {\n    console.log(group1);\n    console.log(group2);\n}\n\n```\n如果正则表达式分组处理，那么在回调函数中，函数的第二个、第三参数就是group1,group2。这样子，就可以做很多神奇的事情\n\n#### 1.4.5.3. 综合练习题\n1. 判断一个字符串中出现次数最多的字符，并统计次数\n\n```javascript\nvar s = 'aaabbbcccaaabbbaaa';\nvar a = s.split('').sort().join(\"\");  //\"aaaaaaaaabbbbbbccc\"\nvar ans = a.match(/(\\w)\\1+/g);\nans.sort(function(a,b) {\n    return a.length - b.length;\n})\nconsole.log('ans is : ' + ans[ans.length])\n\n```\n\n### 1.4.6. 总结\n1. 在js中，正则表达式字面量`/reg/`和字符串字面量`\"str\"`用于创建正则和字符串。其中正则上有两个方法`reg.test()`和`reg.exec()`\n2. `reg.test(str)`方法，返回布尔变量，用于指示是否有所匹配； `reg.exec(str)`有点类似与迭代器，每次执行，返回匹配结果和分组，直到返回为`null`结束。\n3. 字符串方法主要有`str.match(reg)`,`str.split(reg)`和`str.replace(reg,str|function)` 三种方法。\n4. `match`比较特殊，如果正则包含了分组，且没有`g`标志，则返回匹配内容和分组; 如果没有分组，且有`g`标志，返回所有匹配内容\n5. `split`方法主要用于字符串分割，如果想要保存分隔符，记得将匹配内容分组(用小括号包起来)\n6. `replace`是最强大的方法，当使用回掉函数时，返回值就是替换值; 参数分别为`匹配值` `group1` `group2`...","slug":"2018-08-15-regular-expression","published":1,"updated":"2022-08-17T07:53:21.232Z","comments":1,"photos":[],"link":"","_id":"cl6xbhzjs0008zk08558nvijl","content":"<h2 id=\"1-1-基本语法\"><a href=\"#1-1-基本语法\" class=\"headerlink\" title=\"1.1. 基本语法\"></a>1.1. 基本语法</h2><p>通过一张图表来对正则表达式的基本进行一个回顾</p>\n<table>\n<thead>\n<tr>\n<th>single char</th>\n<th>quantifiers(位置)</th>\n<th>Column C</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td> \\d 匹配数字</td>\n<td>* 0个或者更多</td>\n<td>^一行的开头</td>\n</tr>\n<tr>\n<td> \\w  匹配word(数字、字母)</td>\n<td>+ 1个或更多，至少1个</td>\n<td>$一行的结尾</td>\n</tr>\n<tr>\n<td> \\W 匹配<strong>非</strong>word(数字、字母)</td>\n<td>? 0个或1个,一个Optional</td>\n<td>\\b 单词”结界”(word bounds)</td>\n</tr>\n<tr>\n<td> \\s 匹配white space(包括空格、tab等)</td>\n<td>{min,max}出现次数在一个范围内</td>\n<td>C3</td>\n</tr>\n<tr>\n<td> \\S 匹配<strong>非</strong>white space(包括空格、tab等)</td>\n<td>{n}匹配出现n次的</td>\n<td>C3</td>\n</tr>\n<tr>\n<td> . 匹配任何，任何的字符</td>\n<td>B3</td>\n<td>C3</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"1-1-1-single-char\"><a href=\"#1-1-1-single-char\" class=\"headerlink\" title=\"1.1.1. single char\"></a>1.1.1. single char</h3><p>假设你有一段字符如下：<br><img src=\"https://github.com/forrany/Web-Project/blob/master/blog_image/%E5%AD%97%E7%AC%A61.png?raw=true\" alt=\"字符\"></p>\n<ul>\n<li><p><code>\\w</code></p>\n<p>将匹配所有word，当然，() - 等字符除外</p>\n</li>\n<li><p><code>\\w\\w\\w</code></p>\n</li>\n</ul>\n<p>发现匹配的有’<code>The</code>se <code>are</code> <code>som</code>e <code>pho</code>ne <code>number</code>s …’<br> 注意正则表达式是匹配一个连续串的规则，所以可以看到三个字母的单词可以匹配到，6个单词的也可以匹配到。</p>\n<ul>\n<li><p><code>\\s\\s</code></p>\n<p>匹配到一行中连续两个空格</p>\n<h2 id=\"quantifiers\"><a href=\"#quantifiers\" class=\"headerlink\" title=\"quantifiers\"></a>quantifiers</h2><p>假设我们有这一段话：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The colors of the rainbow have many colours </span><br><span class=\"line\">and the rainbow does not  have a single colour.</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>我们想把所有的颜色找出来<code>colors</code> <code>colours</code> <code>colour</code></p>\n<p><strong>答案</strong> <code>colou?rs?</code>  嗯，看起来很简单，很方便。</p>\n<hr>\n<p> 好了，现在想要匹配一行中的4个数字，或者一行中的5个字母等，这时候用quantifiers就非常方便了。</p>\n<blockquote>\n<p>我现在想找5个字母组成的单词</p>\n</blockquote>\n<ul>\n<li><p><code>\\w{5}</code><br>这样可以吗？嗯..不行的，看下它匹配的内容,如下:<br>‘<code>These</code> are some <code>phone</code> <code>numbe</code>rs 915-555-1234…’<br>的确，我们模板给的很简单，它只找一行中，连续出现5个字母的序列。所以现在改进一下好了</p>\n</li>\n<li><p><code>\\w{5}\\s</code><br>为了能找到单词，所以我希望5个字母后，跟一个空格的序列，这样应该可以了吧，看下匹配情况：<br>‘<code>These</code>are some <code>phone</code>nu<code>mbers</code>915-555-1234…’<br>嗯，是的，只有目前这些方法，是做不到的。 所以，我们需要第三个工具  “position”</p>\n</li>\n</ul>\n<h3 id=\"1-1-2-position\"><a href=\"#1-1-2-position\" class=\"headerlink\" title=\"1.1.2. position\"></a>1.1.2. position</h3><p>回到刚才的问题之前，先熟悉下<code>^</code> <code>$</code> 和 <code>\\b</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This is somthing</span><br><span class=\"line\">is about</span><br><span class=\"line\">a blah</span><br><span class=\"line\">words</span><br><span class=\"line\">sequence of words</span><br><span class=\"line\">Hello and</span><br><span class=\"line\">GoodBye and </span><br><span class=\"line\">Go gogo!</span><br></pre></td></tr></table></figure></p>\n<p>来看下各种正则所匹配的内容</p>\n<ul>\n<li><p><code>\\w+</code><br>这个应该毫无疑问，匹配所有的words</p>\n</li>\n<li><p><code>^\\w+</code><br>多了一个<code>^</code>，这样子，就只能匹配到每一行开头的单词了<code>This</code> <code>is</code> <code>a</code> <code>words</code> <code>sequence</code> <code>Hello</code> <code>GoodBye</code> <code>Go</code></p>\n</li>\n<li><p><code>\\w+$</code><br>这样就能匹配到每行的最后一个字母</p>\n</li>\n</ul>\n<p>回到刚才的问题</p>\n<blockquote>\n<p>现在想找5个字母组成的单词</p>\n</blockquote>\n<p>就变得很简单了，使用单词结界符<code>\\b</code></p>\n<p>答案就是<code>\\b\\w{5}\\b</code></p>\n<h3 id=\"1-1-3-找个电话号码吧\"><a href=\"#1-1-3-找个电话号码吧\" class=\"headerlink\" title=\"1.1.3. 找个电话号码吧\"></a>1.1.3. 找个电话号码吧</h3><p>最后，找一个刚才出现的电话号<code>123-456-1231</code></p>\n<p>用以上最基本的正则方法就是 <code>\\d{3}-\\d{3}-\\d{4}</code>，这样就找到了。 但是有的时候，电话号码是<code>123.456.1234</code> 或者 <code>(212)867-4233</code>的结构怎么办呢？</p>\n<p>正则表达式中的<code>或</code>或者其他表达方式，下面一一来介绍。</p>\n<h2 id=\"1-2-字符分类-char-class\"><a href=\"#1-2-字符分类-char-class\" class=\"headerlink\" title=\"1.2. 字符分类(char class)\"></a>1.2. 字符分类(char class)</h2><p>前面记录了最基本的方法，接下来说一下分类符<code>[]</code></p>\n<p>这个符号用来表示逻辑关系<code>或</code>，比如<code>[abc]</code>表示a或者b或c.<code>[-.]</code>表示符号<code>-</code>或者<code>.</code>号(<strong>注意这里，在<code>[]</code>中的<code>.</code>号代表的就是这个符号，但是如果在其外面，表示个匹配所有。 所以如果不在<code>[]</code>之中，想要匹配’.’，就要通过转意符号<code>\\.</code></strong>)</p>\n<h3 id=\"1-2-1-分类的简单应用\"><a href=\"#1-2-1-分类的简单应用\" class=\"headerlink\" title=\"1.2.1. 分类的简单应用\"></a>1.2.1. 分类的简单应用</h3><p>字符序列：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The lynk is quite a link don&apos;t you think? l nk l(nk</span><br></pre></td></tr></table></figure></p>\n<p>正则表达式：<br><code>l[yi (]k</code></p>\n<p>结果:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lynk  link  l nk   l(nk</span><br></pre></td></tr></table></figure></p>\n<p>很容易理解的，就是表达<code>或</code>逻辑。 </p>\n<h3 id=\"1-2-2-匹配所有可能的电话号码\"><a href=\"#1-2-2-匹配所有可能的电话号码\" class=\"headerlink\" title=\"1.2.2. 匹配所有可能的电话号码\"></a>1.2.2. 匹配所有可能的电话号码</h3><p>好了，现在回到之前遗留的问题，有以下字段，请匹配所有可能的电话号码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">These are some phone numbers 915-134-3122. Also,</span><br><span class=\"line\">you can call me at 643.123.1333 and of course,</span><br><span class=\"line\">I&apos;m always reachable at (212)867-5509</span><br></pre></td></tr></table></figure></p>\n<p>好的，一步一步来，刚才我们使用<code>\\d{3}-\\d{3}-\\d{4}</code>匹配了连字符的情况。现在我们可以很轻松的把<code>.</code>这种情况加进去了</p>\n<p>第一步： <code>\\d{3}[-.]\\d{3}[-.]\\d{4}</code></p>\n<p>第二步: 为了能够匹配括号，可以使用?来，因为这是一个option选择。所以最后就成了</p>\n<p><code>\\(?\\d{3}[-.)]\\d{3}[-.]\\d{4}</code></p>\n<p><strong>这里还是要说明，在[]中，特殊字符不需要转义，可以直接使用，比如<code>[.()]</code>,但是在外面，是需要转义的<code>\\(</code> <code>\\.</code>等</strong></p>\n<h3 id=\"1-2-3-的特殊语法\"><a href=\"#1-2-3-的特殊语法\" class=\"headerlink\" title=\"1.2.3. []的特殊语法\"></a>1.2.3. []的特殊语法</h3><p>刚才介绍了最简单和基本的功能，但是有些特殊的地方需要注意</p>\n<ol>\n<li><p>-连接符不是第一个字符时<br><code>[-.]</code>的含义是连字符<code>-</code>或者点符<code>.</code>。 但是，如果当连字符不是第一个字符时，比如<code>[a-z]</code>，这就表示是从字母a到字符z。</p>\n</li>\n<li><p>[]中的^<br><code>^</code>在之前介绍中，是表示一行开头，但是在<code>[]</code>中，有着不同的含义。<br><code>[ab]</code> 表示a或者b<br><code>[^ab]</code> 啥都行，只要不是a或b(anythings except a and b)，相当于取反</p>\n</li>\n</ol>\n<h3 id=\"1-2-4-和\"><a href=\"#1-2-4-和\" class=\"headerlink\" title=\"1.2.4. []和()\"></a>1.2.4. []和()</h3><p>除了使用<code>[]</code>表示或逻辑,<code>()</code>也是可以的。用法是<code>(a|b)</code>表示a或者b</p>\n<p>比如下面的例子，匹配所有email<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gaoyaqi411@126.com  </span><br><span class=\"line\">dyumc@google.net </span><br><span class=\"line\">sam@sjtu.edu</span><br></pre></td></tr></table></figure></p>\n<p>思路：</p>\n<p>首先要想我到底相匹配什么，这里我想匹配的是</p>\n<ol>\n<li>任何一个以words开头的，一个或更多  <code>\\w+</code></li>\n<li>紧接着是一个<code>@</code>符号  <code>\\w+@</code></li>\n<li>接着有一个或者更多的words <code>\\w+@\\w+</code></li>\n<li>接着一个<code>.</code>标点 <code>\\w+@\\w+\\.</code></li>\n<li>接着一个<code>com</code> <code>net</code> 或 <code>edu</code> <code>\\w+@\\w+\\.(com|net|edu)</code></li>\n</ol>\n<p><strong>还是提醒注意第四步的<code>\\.</code>转义符号</strong></p>\n<p>好了，这样几可以匹配以上的所有邮箱了。但是还有一个问题，因为邮箱用户名是可以有<code>.</code>的，比如<a href=\"mailto:`vincent.ko@126.com\" target=\"_blank\" rel=\"noopener\">`vincent.ko@126.com</a>`</p>\n<p>其实仍然很简单，修复如下：<br><code>[\\w.]+@\\w+\\.(com|net|edu)</code></p>\n<h3 id=\"1-2-5-总结\"><a href=\"#1-2-5-总结\" class=\"headerlink\" title=\"1.2.5. 总结\"></a>1.2.5. 总结</h3><ol>\n<li><code>[]</code>的作用，用英文表达就是”alternation”,表达一个或的逻辑；</li>\n<li><code>/[-.(]/</code> 在符号中的连字符<code>-</code>放在第一位表示连字符本身，如果放在中间，表示”从..到..”，比如<code>[a-z]</code>表示a-z</li>\n<li><code>[.)]</code> 括号中的特殊符号不需要转义，就表示其本身</li>\n<li><code>[^ab]</code> 括号中的<code>^</code>表示非，anythings except <code>a</code> and <code>b</code></li>\n<li><code>(a|b)</code>也可表示选择，但是它有更强大的功能….</li>\n</ol>\n<p>所以，<code>()</code>的强大功能是什么呢？ 分组捕获，这对序列的替换、交换是很有帮助的。 后面一节进行学习记录</p>\n<h2 id=\"1-3-分组捕获-capturing-groups\"><a href=\"#1-3-分组捕获-capturing-groups\" class=\"headerlink\" title=\"1.3. 分组捕获(capturing groups)\"></a>1.3. 分组捕获(capturing groups)</h2><p>什么是分组捕获，现在回到之前电话号码的例子<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">212-555-1234</span><br><span class=\"line\">915-412-1333</span><br><span class=\"line\"></span><br><span class=\"line\">//我想要保留区号，把后面的电话号码变为通用性的</span><br><span class=\"line\">👇👇👇👇👇👇👇👇👇👇👇👇</span><br><span class=\"line\"></span><br><span class=\"line\">212-xxx-xxxx</span><br><span class=\"line\">915-xxx-xxxx</span><br></pre></td></tr></table></figure></p>\n<p>按照之前的做法<code>\\d{3}-\\d{3}-\\d{4}</code>,这种匹配的方式，是将整个电话号码作为一个组(group)匹配起来。 我们把<code>212-555-1234</code>这样的叫<code>Group0</code>。</p>\n<p>这个时候，如果我们加了一个括号<code>\\d{3}-(\\d{3})-\\d{4}</code>，那么匹配到的<code>555</code>就叫<code>Group1</code>。<br>以此类推，如果有两个小括号<code>\\d{3}-(\\d{3})-(\\d{4})</code>那么分组就是下面的情况：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">212-555-1234   Group0</span><br><span class=\"line\">555            Group1</span><br><span class=\"line\">1234           Group2</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"1-3-1-选择分组\"><a href=\"#1-3-1-选择分组\" class=\"headerlink\" title=\"1.3.1. 选择分组\"></a>1.3.1. 选择分组</h3><p>现在组已经分好，那么如何选择已经匹配的分组？</p>\n<p>这里有两种方法，第一种使用<code>$</code>符号，比如<code>$1</code> 代表<code>555</code>,<code>$2</code>代表<code>1234</code>；第二种，使用<code>\\</code>,比如<code>\\1</code>代表<code>555</code>。两种的使用场景不一样，先讲<code>$</code></p>\n<p>现在为了满足最开始的要求，我们可以这么做<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reg: \\(?(\\d&#123;3&#125;)[-.)]\\d&#123;3&#125;[-.]\\d&#123;4&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">replace: $1-xxx-xxxx</span><br></pre></td></tr></table></figure></p>\n<p><strong>ps: 这里可以直接用JS的replace函数进行操作，但是正则不是JS专属的，所以这里先介绍通用方法，之后对JS部分进行总结</strong></p>\n<h3 id=\"1-3-2-实景训练\"><a href=\"#1-3-2-实景训练\" class=\"headerlink\" title=\"1.3.2. 实景训练\"></a>1.3.2. 实景训练</h3><ol>\n<li>现在有一个名单列表，但是姓和名称是反的，我需要把他交换过来<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shiffina, Daniel</span><br><span class=\"line\">shifafl, Daniell</span><br><span class=\"line\">shquer, Danny</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>实现方法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reg: (\\w+),\\s(\\w+)</span><br><span class=\"line\"></span><br><span class=\"line\">replace: $2 $1</span><br></pre></td></tr></table></figure></p>\n<p>注意：<code>$0</code> 是所有匹配到的，所以第一个加括号的是<code>$1</code></p>\n<ol start=\"2\">\n<li>匹配markdown中的link标签，并替换为html标签<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[google](http://google.com)</span><br><span class=\"line\">[itp](http://itp.nyu.edu)</span><br><span class=\"line\">[Coding Rainbow](http://codingrainbow.com)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>解析： 这道题有些坑，需要慢慢来。</p>\n<p>看到这个，第一个想考虑匹配<code>[google]</code>这个东西，立马想到正则表达式<code>\\[.*\\]</code>。 这个是巨大的坑，在当前来看，它的确能正确匹配到上面的三条。 但是如果文本是这样的：<br><img src=\"https://github.com/forrany/Web-Project/blob/master/blog_image/zifupipei.png?raw=true\" alt=\"字符匹配\"></p>\n<p>看到了，第一行的内容会全部匹配下来，而不能区分<code>[google]</code>和<code>[test]</code>。 之所以这样，<strong>是因为<code>.</code>是贪婪的，他表示所有，所有能匹配到的，所以当然也包括了<code>]</code>，一直到这一行的最后一个<code>]</code>，它才停止。</strong></p>\n<p>所以为了让它能正确匹配，需要去掉这种贪婪的属性。这里用到<code>？</code> 。 当<code>?</code>放在了<code>quantifiers</code>符号后，表示去掉贪婪属性，匹配到终止条件，即可停下。</p>\n<p><code>\\[.*?\\]</code>这样子，就可以将<code>[google]</code>和<code>[test]</code>分开,效果如下：<br><img src=\"https://github.com/forrany/Web-Project/blob/master/blog_image/split.png?raw=true\" alt=\"分割\"></p>\n<p>接下来完成所有内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reg: \\[(.*?)\\]\\((http.*?)\\)</span><br><span class=\"line\"></span><br><span class=\"line\">replace: &lt;a href=&quot;$2&quot;&gt;$1&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"1-3-3-使用-选择器\"><a href=\"#1-3-3-使用-选择器\" class=\"headerlink\" title=\"1.3.3. 使用\\选择器\"></a>1.3.3. 使用<code>\\</code>选择器</h3><p><code>$</code>选择符是在替换的时候进行的标志或选择，但是如果在正则表达式本身，就要使用<code>\\</code>选择了。比如以下的场景</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This is is a a dog , I think think this is is really</span><br><span class=\"line\">a a good good dog. Don&apos;t you you thinks so so ?</span><br></pre></td></tr></table></figure>\n<p>我们想要匹配比如<code>is is</code> <code>so so</code>这样连续的序列，就用到了下面的表达方式: <code>(\\w+)\\s\\1</code></p>\n<p>效果:<br><img src=\"https://github.com/forrany/Web-Project/blob/master/blog_image/xiaoguo.png?raw=true\" alt=\"效果图\"></p>\n<p>嗯，差不多达到效果，但是有一些小的bug。比如第一句话<code>This is is a</code> 这个就匹配不准确，会把第一个This的后面字母匹配进去。<br><strong>这就用到第一节说的字符结界 <code>\\b</code>了</strong>，就变成了<code>\\b(\\w+)\\s\\1\\b</code></p>\n<p>好了，大功告成，就不贴效果图了，自行脑补就好了。</p>\n<h3 id=\"1-3-4-总结\"><a href=\"#1-3-4-总结\" class=\"headerlink\" title=\"1.3.4. 总结\"></a>1.3.4. 总结</h3><ol>\n<li>分组捕获，使用()进行数据分组，编号0代表整个匹配项，选择的分组从1号开始</li>\n<li>选择器可以使用<code>$1</code>和<code>\\1</code>，但是使用场景不同，<code>\\</code>用在正则表达式自己身上</li>\n<li><code>?</code>符号可以禁止贪婪属性，放在<code>.*</code>之后，表示一次匹配遇到重点就可以停止。否则将会一直向后匹配。</li>\n</ol>\n<h2 id=\"1-4-在JavaScript中的应用\"><a href=\"#1-4-在JavaScript中的应用\" class=\"headerlink\" title=\"1.4. 在JavaScript中的应用\"></a>1.4. 在JavaScript中的应用</h2><p>在js中，主要的正则表达式都是涉及到string的应用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;hello&quot;</span><br><span class=\"line\">var r = /w+/</span><br></pre></td></tr></table></figure></p>\n<p>这两个分别是string和reg的字面量创建方法。当要使用正则来进行操作的时候，使用了<code>r.test()</code>和<code>str.match()</code> 以及<code>str.replace</code>等方法。</p>\n<h3 id=\"1-4-1-reg-test\"><a href=\"#1-4-1-reg-test\" class=\"headerlink\" title=\"1.4.1. reg.test()\"></a>1.4.1. reg.test()</h3><p>正则表达式本身有一个test的方法，这个方法只能测试是否包含，返回一个bool变量。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var r = /\\d&#123;3&#125;/;</span><br><span class=\"line\">var a = &apos;123&apos;;</span><br><span class=\"line\">var b = &apos;123ABC&apos;;</span><br><span class=\"line\">var c = &apos;abc&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">r.test(a)  //true</span><br><span class=\"line\">r.test(b) //true</span><br><span class=\"line\">r.test(c) //false</span><br></pre></td></tr></table></figure></p>\n<p>嗯，这个很简单，而且用的实际不多，下面着重讲str上的一些方法。</p>\n<h3 id=\"1-4-2-str-match\"><a href=\"#1-4-2-str-match\" class=\"headerlink\" title=\"1.4.2. str.match()\"></a>1.4.2. str.match()</h3><p>与test()不同，不只是返回bool变量，它会返回你所匹配到的内容。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> r = <span class=\"regexp\">/compus/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/w+/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">\"compus, I know something about you\"</span></span><br><span class=\"line\">r.test(s)  <span class=\"comment\">//true</span></span><br><span class=\"line\">s.match(r)  <span class=\"comment\">//[\"compus\"]</span></span><br><span class=\"line\">s.match(reg) <span class=\"comment\">//[\"compus\"]</span></span><br></pre></td></tr></table></figure></p>\n<p>等等，好像有点问题，为什么最后一个返回的也是”compus”？这不科学。</p>\n<p>好吧，实际上，match()返回了第一个可以匹配的序列。想要实现之前的效果，就要用到JS里关于正则的几个flag</p>\n<h4 id=\"1-4-2-1-flag\"><a href=\"#1-4-2-1-flag\" class=\"headerlink\" title=\"1.4.2.1. flag\"></a>1.4.2.1. flag</h4><p>这个标志就在建立正则的时候就要有的，主要有三个</p>\n<table>\n<thead>\n<tr>\n<th>flag</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td> g</td>\n<td>全部的，给我匹配全部的 </td>\n</tr>\n<tr>\n<td> i</td>\n<td>忽略大小写</td>\n</tr>\n<tr>\n<td> m</td>\n<td>多行匹配</td>\n</tr>\n</tbody>\n</table>\n<p> 所以为了解决刚才的问题，只要这样子设置reg就可以了<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/w+/g</span></span><br></pre></td></tr></table></figure></p>\n<p>看下面一个练习<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"Here is a Phone Number 111-2313 and 133-2311\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> r = <span class=\"regexp\">/\\d&#123;3&#125;[-.]\\d&#123;4&#125;/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> rg = <span class=\"regexp\">/\\d&#123;3&#125;[-.]d&#123;4&#125;/g</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str.match(r)); <span class=\"comment\">//[\"111-2313\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str.match(rg));<span class=\"comment\">//[\"111-2313\",\"133-2311\"]</span></span><br></pre></td></tr></table></figure></p>\n<p>嗯，找电话号码，是的，很方便。但是还有一个问题，刚才说的分组，那么match会返回分组吗？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sr = <span class=\"regexp\">/(\\d&#123;3&#125;)[-.]\\d&#123;4&#125;/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> srg = <span class=\"regexp\">/(\\d&#123;3&#125;)[-.]\\d&#123;4&#125;/g</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str.match(sr)); <span class=\"comment\">//[\"111-2313\",\"111\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str.match(srg)); <span class=\"comment\">//[\"111-2313\",\"133-2311\"]</span></span><br></pre></td></tr></table></figure>\n<p>所以结论是： 当使用了全局flag<code>g</code>的时候，不会返回分组，而是全部的匹配结果；如果没有使用<code>g</code>，会将匹配到的结果和分组以数组的形式返回。</p>\n<p>那么如何实现全局的分组？ </p>\n<h3 id=\"1-4-3-reg-exec\"><a href=\"#1-4-3-reg-exec\" class=\"headerlink\" title=\"1.4.3. reg.exec()\"></a>1.4.3. reg.exec()</h3><p>从字面意思来看，正则表达式的执行方法。 这个方法可以实现匹配全局，并返回分组的结果。</p>\n<blockquote>\n<p>reg.exec()每次调用，返回一个匹配的结果，匹配结果和分组以数组的形式返回，不断的调用即可返回下一个结果，直到返回<code>null</code></p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"Here is a Phone Number 111-2313 and 133-2311\"</span> ;</span><br><span class=\"line\"><span class=\"keyword\">var</span> srg = <span class=\"regexp\">/(\\d&#123;3&#125;)[-.]\\d&#123;4&#125;/g</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = srg.exec(str);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(result !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">    result = srg.exec(str);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>result包含的内容可能比想象中的多，它是一个数组，比如第一次执行，他的结果为：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">\"133-2311\"</span>, <span class=\"string\">\"133\"</span>, <span class=\"attr\">index</span>: <span class=\"number\">36</span>, </span><br><span class=\"line\">input: <span class=\"string\">\"Here is a Phone Number 111-2313 and 133-2311\"</span> groups: <span class=\"literal\">undefined</span>]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"1-4-4-str-split\"><a href=\"#1-4-4-str-split\" class=\"headerlink\" title=\"1.4.4. str.split\"></a>1.4.4. str.split</h3><p>现在来到了更强的功能上，先说下split，我们知道split是将字符串按照某个字符分隔开，比如有以下一段话，需要将其分割成单词。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s = &quot;unicorns and rainbows And, Cupcakes&quot;</span><br></pre></td></tr></table></figure></p>\n<p>分割成单词，首先想到的是空格隔开，于是可以用下面方式实现<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> result = s.split(<span class=\"string\">' '</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> result1 = s.split(<span class=\"regexp\">/\\s/</span>);</span><br><span class=\"line\"><span class=\"comment\">//完全一样的效果</span></span><br><span class=\"line\"><span class=\"comment\">//[\"unicorns\", \"and\", \"rainbows\", \"And,\", \"Cupcakes\"]</span></span><br></pre></td></tr></table></figure></p>\n<p>嗯，这样体现不出来正则的强大，而且最主要的是没有实现要求。因为还有一个”And,”。所以要用正则了，匹配条件是<code>逗号或者空格</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = s.split(<span class=\"regexp\">/[,\\s]/</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//[\"unicorns\", \"and\", \"rainbows\", \"And\", \"\", \"Cupcakes\"]</span></span><br></pre></td></tr></table></figure>\n<p>结果仍然和需要的有出入，因为多了一个””。 我们并不是想让它分割的依据是<code>逗号或者空格</code>,依据应该是<code>逗号或空格所在的连续序列</code>。 在原来的基础上加一个<code>+</code>，改成<code>/[,\\s]+/</code>，这个含义就是<code>一个单独的逗号，或者一个单独的空格</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = s.split(<span class=\"regexp\">/[,\\s]+/</span>);</span><br><span class=\"line\"><span class=\"comment\">// [\"unicorns\", \"and\", \"rainbows\", \"And\", \"Cupcakes\"]</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"1-4-4-1-单词分割\"><a href=\"#1-4-4-1-单词分割\" class=\"headerlink\" title=\"1.4.4.1. 单词分割\"></a>1.4.4.1. 单词分割</h4><p>好了，拓展一下，实现一个段落的单词分割，一个正则表达式就是<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = s.split(<span class=\"regexp\">/[,.!?\\s]+/</span>)</span><br></pre></td></tr></table></figure></p>\n<p>当然，有个最简单的方法，我们可以这样去做<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = s.split(<span class=\"regexp\">/\\W+/</span>);</span><br></pre></td></tr></table></figure></p>\n<p>接着，如果我们想将一个段落的句子都分隔开，一个可以实现的表达式就是<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = s.split(<span class=\"regexp\">/[.,!?]+/</span>)</span><br></pre></td></tr></table></figure></p>\n<p>最后，有一个小需求，就是在分割句子的同时，还想把相应的分隔符保留下来。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = </span><br><span class=\"line\"><span class=\"string\">\"Hello,My name is Vincent. Nice to Meet you!What's your name? Haha.\"</span></span><br></pre></td></tr></table></figure></p>\n<p>这是一个小小的ponit，记住<strong>如果想要保留分隔符，只要给匹配的内容分组即可</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> result = s.split(<span class=\"regexp\">/([.,!?]+)/</span>)</span><br><span class=\"line\"><span class=\"comment\">//[\"Hello\", \",\", \"My name is Vincent\", \".\", \" Nice to Meet you\", \"!\", \"What's your name\", \"?\", \" Haha\", \".\", \"\"]</span></span><br></pre></td></tr></table></figure></p>\n<p>可以看到，这样就会把分隔符也存储起来。</p>\n<h3 id=\"1-4-5-str-replace\"><a href=\"#1-4-5-str-replace\" class=\"headerlink\" title=\"1.4.5. str.replace()\"></a>1.4.5. str.replace()</h3><p>replace也是字符串的方法，它的基本用法是<code>str.replace(reg,replace|function)</code>，第一个参数是正则表达式，代表匹配的内容，第二个参数是替换的字符串或者一个回掉函数。</p>\n<p><strong>注意，replace不会修改原字符串，只是返回一个修改后的字符串;除此外，正则表达式如果没有使用<code>g</code>标志，也和<code>match</code>一样，只匹配/替换第一个</strong></p>\n<h4 id=\"1-4-5-1-最简单的替换\"><a href=\"#1-4-5-1-最简单的替换\" class=\"headerlink\" title=\"1.4.5.1. 最简单的替换\"></a>1.4.5.1. 最简单的替换</h4><blockquote>\n<p>替换一个序列中的元音字母(aeiou)，将其替换成一个double。 比如x-&gt;xx</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">\"Hello,My name is Vincent.\"</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = s.replace(<span class=\"regexp\">/([aeiou])/g</span>,<span class=\"string\">\"$1$1\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//\"Heelloo,My naamee iis Viinceent.\"</span></span><br></pre></td></tr></table></figure>\n<p><strong>注意，第二个参数必须是字符串; 注意不要忘记加<code>g</code></strong></p>\n<h4 id=\"1-4-5-2-牛x哄哄的function参数来了\"><a href=\"#1-4-5-2-牛x哄哄的function参数来了\" class=\"headerlink\" title=\"1.4.5.2. 牛x哄哄的function参数来了\"></a>1.4.5.2. 牛x哄哄的function参数来了</h4><p>嗯，这才是最强大的地方，第二参数传入function，先看一个最简单的示例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">\"Hello,My name is Vincent. What is your name?\"</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> newStr = s.replace(<span class=\"regexp\">/\\b\\w&#123;4&#125;\\b/g</span>,replacer)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newStr)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">replacer</span>(<span class=\"params\">match</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(match);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> match.toUpperCase();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">name</span></span><br><span class=\"line\"><span class=\"comment\">What</span></span><br><span class=\"line\"><span class=\"comment\">your</span></span><br><span class=\"line\"><span class=\"comment\">name</span></span><br><span class=\"line\"><span class=\"comment\">Hello,My NAME is Vincent. WHAT is YOUR NAME?</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></p>\n<p>所以，函数的参数是匹配到的内容，返回的是需要替换的内容。好了，基本示例解释了基本用法，那么之前讨论的分组怎么办？如何实现分组呢？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//分组</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">replacer</span>(<span class=\"params\">match,group1,group2</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(group1);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(group2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果正则表达式分组处理，那么在回调函数中，函数的第二个、第三参数就是group1,group2。这样子，就可以做很多神奇的事情</p>\n<h4 id=\"1-4-5-3-综合练习题\"><a href=\"#1-4-5-3-综合练习题\" class=\"headerlink\" title=\"1.4.5.3. 综合练习题\"></a>1.4.5.3. 综合练习题</h4><ol>\n<li>判断一个字符串中出现次数最多的字符，并统计次数</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'aaabbbcccaaabbbaaa'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = s.split(<span class=\"string\">''</span>).sort().join(<span class=\"string\">\"\"</span>);  <span class=\"comment\">//\"aaaaaaaaabbbbbbccc\"</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ans = a.match(<span class=\"regexp\">/(\\w)\\1+/g</span>);</span><br><span class=\"line\">ans.sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.length - b.length;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'ans is : '</span> + ans[ans.length])</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-4-6-总结\"><a href=\"#1-4-6-总结\" class=\"headerlink\" title=\"1.4.6. 总结\"></a>1.4.6. 总结</h3><ol>\n<li>在js中，正则表达式字面量<code>/reg/</code>和字符串字面量<code>&quot;str&quot;</code>用于创建正则和字符串。其中正则上有两个方法<code>reg.test()</code>和<code>reg.exec()</code></li>\n<li><code>reg.test(str)</code>方法，返回布尔变量，用于指示是否有所匹配； <code>reg.exec(str)</code>有点类似与迭代器，每次执行，返回匹配结果和分组，直到返回为<code>null</code>结束。</li>\n<li>字符串方法主要有<code>str.match(reg)</code>,<code>str.split(reg)</code>和<code>str.replace(reg,str|function)</code> 三种方法。</li>\n<li><code>match</code>比较特殊，如果正则包含了分组，且没有<code>g</code>标志，则返回匹配内容和分组; 如果没有分组，且有<code>g</code>标志，返回所有匹配内容</li>\n<li><code>split</code>方法主要用于字符串分割，如果想要保存分隔符，记得将匹配内容分组(用小括号包起来)</li>\n<li><code>replace</code>是最强大的方法，当使用回掉函数时，返回值就是替换值; 参数分别为<code>匹配值</code> <code>group1</code> <code>group2</code>…</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-1-基本语法\"><a href=\"#1-1-基本语法\" class=\"headerlink\" title=\"1.1. 基本语法\"></a>1.1. 基本语法</h2><p>通过一张图表来对正则表达式的基本进行一个回顾</p>\n<table>\n<thead>\n<tr>\n<th>single char</th>\n<th>quantifiers(位置)</th>\n<th>Column C</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td> \\d 匹配数字</td>\n<td>* 0个或者更多</td>\n<td>^一行的开头</td>\n</tr>\n<tr>\n<td> \\w  匹配word(数字、字母)</td>\n<td>+ 1个或更多，至少1个</td>\n<td>$一行的结尾</td>\n</tr>\n<tr>\n<td> \\W 匹配<strong>非</strong>word(数字、字母)</td>\n<td>? 0个或1个,一个Optional</td>\n<td>\\b 单词”结界”(word bounds)</td>\n</tr>\n<tr>\n<td> \\s 匹配white space(包括空格、tab等)</td>\n<td>{min,max}出现次数在一个范围内</td>\n<td>C3</td>\n</tr>\n<tr>\n<td> \\S 匹配<strong>非</strong>white space(包括空格、tab等)</td>\n<td>{n}匹配出现n次的</td>\n<td>C3</td>\n</tr>\n<tr>\n<td> . 匹配任何，任何的字符</td>\n<td>B3</td>\n<td>C3</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"1-1-1-single-char\"><a href=\"#1-1-1-single-char\" class=\"headerlink\" title=\"1.1.1. single char\"></a>1.1.1. single char</h3><p>假设你有一段字符如下：<br><img src=\"https://github.com/forrany/Web-Project/blob/master/blog_image/%E5%AD%97%E7%AC%A61.png?raw=true\" alt=\"字符\"></p>\n<ul>\n<li><p><code>\\w</code></p>\n<p>将匹配所有word，当然，() - 等字符除外</p>\n</li>\n<li><p><code>\\w\\w\\w</code></p>\n</li>\n</ul>\n<p>发现匹配的有’<code>The</code>se <code>are</code> <code>som</code>e <code>pho</code>ne <code>number</code>s …’<br> 注意正则表达式是匹配一个连续串的规则，所以可以看到三个字母的单词可以匹配到，6个单词的也可以匹配到。</p>\n<ul>\n<li><p><code>\\s\\s</code></p>\n<p>匹配到一行中连续两个空格</p>\n<h2 id=\"quantifiers\"><a href=\"#quantifiers\" class=\"headerlink\" title=\"quantifiers\"></a>quantifiers</h2><p>假设我们有这一段话：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The colors of the rainbow have many colours </span><br><span class=\"line\">and the rainbow does not  have a single colour.</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>我们想把所有的颜色找出来<code>colors</code> <code>colours</code> <code>colour</code></p>\n<p><strong>答案</strong> <code>colou?rs?</code>  嗯，看起来很简单，很方便。</p>\n<hr>\n<p> 好了，现在想要匹配一行中的4个数字，或者一行中的5个字母等，这时候用quantifiers就非常方便了。</p>\n<blockquote>\n<p>我现在想找5个字母组成的单词</p>\n</blockquote>\n<ul>\n<li><p><code>\\w{5}</code><br>这样可以吗？嗯..不行的，看下它匹配的内容,如下:<br>‘<code>These</code> are some <code>phone</code> <code>numbe</code>rs 915-555-1234…’<br>的确，我们模板给的很简单，它只找一行中，连续出现5个字母的序列。所以现在改进一下好了</p>\n</li>\n<li><p><code>\\w{5}\\s</code><br>为了能找到单词，所以我希望5个字母后，跟一个空格的序列，这样应该可以了吧，看下匹配情况：<br>‘<code>These</code>are some <code>phone</code>nu<code>mbers</code>915-555-1234…’<br>嗯，是的，只有目前这些方法，是做不到的。 所以，我们需要第三个工具  “position”</p>\n</li>\n</ul>\n<h3 id=\"1-1-2-position\"><a href=\"#1-1-2-position\" class=\"headerlink\" title=\"1.1.2. position\"></a>1.1.2. position</h3><p>回到刚才的问题之前，先熟悉下<code>^</code> <code>$</code> 和 <code>\\b</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This is somthing</span><br><span class=\"line\">is about</span><br><span class=\"line\">a blah</span><br><span class=\"line\">words</span><br><span class=\"line\">sequence of words</span><br><span class=\"line\">Hello and</span><br><span class=\"line\">GoodBye and </span><br><span class=\"line\">Go gogo!</span><br></pre></td></tr></table></figure></p>\n<p>来看下各种正则所匹配的内容</p>\n<ul>\n<li><p><code>\\w+</code><br>这个应该毫无疑问，匹配所有的words</p>\n</li>\n<li><p><code>^\\w+</code><br>多了一个<code>^</code>，这样子，就只能匹配到每一行开头的单词了<code>This</code> <code>is</code> <code>a</code> <code>words</code> <code>sequence</code> <code>Hello</code> <code>GoodBye</code> <code>Go</code></p>\n</li>\n<li><p><code>\\w+$</code><br>这样就能匹配到每行的最后一个字母</p>\n</li>\n</ul>\n<p>回到刚才的问题</p>\n<blockquote>\n<p>现在想找5个字母组成的单词</p>\n</blockquote>\n<p>就变得很简单了，使用单词结界符<code>\\b</code></p>\n<p>答案就是<code>\\b\\w{5}\\b</code></p>\n<h3 id=\"1-1-3-找个电话号码吧\"><a href=\"#1-1-3-找个电话号码吧\" class=\"headerlink\" title=\"1.1.3. 找个电话号码吧\"></a>1.1.3. 找个电话号码吧</h3><p>最后，找一个刚才出现的电话号<code>123-456-1231</code></p>\n<p>用以上最基本的正则方法就是 <code>\\d{3}-\\d{3}-\\d{4}</code>，这样就找到了。 但是有的时候，电话号码是<code>123.456.1234</code> 或者 <code>(212)867-4233</code>的结构怎么办呢？</p>\n<p>正则表达式中的<code>或</code>或者其他表达方式，下面一一来介绍。</p>\n<h2 id=\"1-2-字符分类-char-class\"><a href=\"#1-2-字符分类-char-class\" class=\"headerlink\" title=\"1.2. 字符分类(char class)\"></a>1.2. 字符分类(char class)</h2><p>前面记录了最基本的方法，接下来说一下分类符<code>[]</code></p>\n<p>这个符号用来表示逻辑关系<code>或</code>，比如<code>[abc]</code>表示a或者b或c.<code>[-.]</code>表示符号<code>-</code>或者<code>.</code>号(<strong>注意这里，在<code>[]</code>中的<code>.</code>号代表的就是这个符号，但是如果在其外面，表示个匹配所有。 所以如果不在<code>[]</code>之中，想要匹配’.’，就要通过转意符号<code>\\.</code></strong>)</p>\n<h3 id=\"1-2-1-分类的简单应用\"><a href=\"#1-2-1-分类的简单应用\" class=\"headerlink\" title=\"1.2.1. 分类的简单应用\"></a>1.2.1. 分类的简单应用</h3><p>字符序列：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The lynk is quite a link don&apos;t you think? l nk l(nk</span><br></pre></td></tr></table></figure></p>\n<p>正则表达式：<br><code>l[yi (]k</code></p>\n<p>结果:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lynk  link  l nk   l(nk</span><br></pre></td></tr></table></figure></p>\n<p>很容易理解的，就是表达<code>或</code>逻辑。 </p>\n<h3 id=\"1-2-2-匹配所有可能的电话号码\"><a href=\"#1-2-2-匹配所有可能的电话号码\" class=\"headerlink\" title=\"1.2.2. 匹配所有可能的电话号码\"></a>1.2.2. 匹配所有可能的电话号码</h3><p>好了，现在回到之前遗留的问题，有以下字段，请匹配所有可能的电话号码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">These are some phone numbers 915-134-3122. Also,</span><br><span class=\"line\">you can call me at 643.123.1333 and of course,</span><br><span class=\"line\">I&apos;m always reachable at (212)867-5509</span><br></pre></td></tr></table></figure></p>\n<p>好的，一步一步来，刚才我们使用<code>\\d{3}-\\d{3}-\\d{4}</code>匹配了连字符的情况。现在我们可以很轻松的把<code>.</code>这种情况加进去了</p>\n<p>第一步： <code>\\d{3}[-.]\\d{3}[-.]\\d{4}</code></p>\n<p>第二步: 为了能够匹配括号，可以使用?来，因为这是一个option选择。所以最后就成了</p>\n<p><code>\\(?\\d{3}[-.)]\\d{3}[-.]\\d{4}</code></p>\n<p><strong>这里还是要说明，在[]中，特殊字符不需要转义，可以直接使用，比如<code>[.()]</code>,但是在外面，是需要转义的<code>\\(</code> <code>\\.</code>等</strong></p>\n<h3 id=\"1-2-3-的特殊语法\"><a href=\"#1-2-3-的特殊语法\" class=\"headerlink\" title=\"1.2.3. []的特殊语法\"></a>1.2.3. []的特殊语法</h3><p>刚才介绍了最简单和基本的功能，但是有些特殊的地方需要注意</p>\n<ol>\n<li><p>-连接符不是第一个字符时<br><code>[-.]</code>的含义是连字符<code>-</code>或者点符<code>.</code>。 但是，如果当连字符不是第一个字符时，比如<code>[a-z]</code>，这就表示是从字母a到字符z。</p>\n</li>\n<li><p>[]中的^<br><code>^</code>在之前介绍中，是表示一行开头，但是在<code>[]</code>中，有着不同的含义。<br><code>[ab]</code> 表示a或者b<br><code>[^ab]</code> 啥都行，只要不是a或b(anythings except a and b)，相当于取反</p>\n</li>\n</ol>\n<h3 id=\"1-2-4-和\"><a href=\"#1-2-4-和\" class=\"headerlink\" title=\"1.2.4. []和()\"></a>1.2.4. []和()</h3><p>除了使用<code>[]</code>表示或逻辑,<code>()</code>也是可以的。用法是<code>(a|b)</code>表示a或者b</p>\n<p>比如下面的例子，匹配所有email<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gaoyaqi411@126.com  </span><br><span class=\"line\">dyumc@google.net </span><br><span class=\"line\">sam@sjtu.edu</span><br></pre></td></tr></table></figure></p>\n<p>思路：</p>\n<p>首先要想我到底相匹配什么，这里我想匹配的是</p>\n<ol>\n<li>任何一个以words开头的，一个或更多  <code>\\w+</code></li>\n<li>紧接着是一个<code>@</code>符号  <code>\\w+@</code></li>\n<li>接着有一个或者更多的words <code>\\w+@\\w+</code></li>\n<li>接着一个<code>.</code>标点 <code>\\w+@\\w+\\.</code></li>\n<li>接着一个<code>com</code> <code>net</code> 或 <code>edu</code> <code>\\w+@\\w+\\.(com|net|edu)</code></li>\n</ol>\n<p><strong>还是提醒注意第四步的<code>\\.</code>转义符号</strong></p>\n<p>好了，这样几可以匹配以上的所有邮箱了。但是还有一个问题，因为邮箱用户名是可以有<code>.</code>的，比如<a href=\"mailto:`vincent.ko@126.com\" target=\"_blank\" rel=\"noopener\">`vincent.ko@126.com</a>`</p>\n<p>其实仍然很简单，修复如下：<br><code>[\\w.]+@\\w+\\.(com|net|edu)</code></p>\n<h3 id=\"1-2-5-总结\"><a href=\"#1-2-5-总结\" class=\"headerlink\" title=\"1.2.5. 总结\"></a>1.2.5. 总结</h3><ol>\n<li><code>[]</code>的作用，用英文表达就是”alternation”,表达一个或的逻辑；</li>\n<li><code>/[-.(]/</code> 在符号中的连字符<code>-</code>放在第一位表示连字符本身，如果放在中间，表示”从..到..”，比如<code>[a-z]</code>表示a-z</li>\n<li><code>[.)]</code> 括号中的特殊符号不需要转义，就表示其本身</li>\n<li><code>[^ab]</code> 括号中的<code>^</code>表示非，anythings except <code>a</code> and <code>b</code></li>\n<li><code>(a|b)</code>也可表示选择，但是它有更强大的功能….</li>\n</ol>\n<p>所以，<code>()</code>的强大功能是什么呢？ 分组捕获，这对序列的替换、交换是很有帮助的。 后面一节进行学习记录</p>\n<h2 id=\"1-3-分组捕获-capturing-groups\"><a href=\"#1-3-分组捕获-capturing-groups\" class=\"headerlink\" title=\"1.3. 分组捕获(capturing groups)\"></a>1.3. 分组捕获(capturing groups)</h2><p>什么是分组捕获，现在回到之前电话号码的例子<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">212-555-1234</span><br><span class=\"line\">915-412-1333</span><br><span class=\"line\"></span><br><span class=\"line\">//我想要保留区号，把后面的电话号码变为通用性的</span><br><span class=\"line\">👇👇👇👇👇👇👇👇👇👇👇👇</span><br><span class=\"line\"></span><br><span class=\"line\">212-xxx-xxxx</span><br><span class=\"line\">915-xxx-xxxx</span><br></pre></td></tr></table></figure></p>\n<p>按照之前的做法<code>\\d{3}-\\d{3}-\\d{4}</code>,这种匹配的方式，是将整个电话号码作为一个组(group)匹配起来。 我们把<code>212-555-1234</code>这样的叫<code>Group0</code>。</p>\n<p>这个时候，如果我们加了一个括号<code>\\d{3}-(\\d{3})-\\d{4}</code>，那么匹配到的<code>555</code>就叫<code>Group1</code>。<br>以此类推，如果有两个小括号<code>\\d{3}-(\\d{3})-(\\d{4})</code>那么分组就是下面的情况：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">212-555-1234   Group0</span><br><span class=\"line\">555            Group1</span><br><span class=\"line\">1234           Group2</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"1-3-1-选择分组\"><a href=\"#1-3-1-选择分组\" class=\"headerlink\" title=\"1.3.1. 选择分组\"></a>1.3.1. 选择分组</h3><p>现在组已经分好，那么如何选择已经匹配的分组？</p>\n<p>这里有两种方法，第一种使用<code>$</code>符号，比如<code>$1</code> 代表<code>555</code>,<code>$2</code>代表<code>1234</code>；第二种，使用<code>\\</code>,比如<code>\\1</code>代表<code>555</code>。两种的使用场景不一样，先讲<code>$</code></p>\n<p>现在为了满足最开始的要求，我们可以这么做<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reg: \\(?(\\d&#123;3&#125;)[-.)]\\d&#123;3&#125;[-.]\\d&#123;4&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">replace: $1-xxx-xxxx</span><br></pre></td></tr></table></figure></p>\n<p><strong>ps: 这里可以直接用JS的replace函数进行操作，但是正则不是JS专属的，所以这里先介绍通用方法，之后对JS部分进行总结</strong></p>\n<h3 id=\"1-3-2-实景训练\"><a href=\"#1-3-2-实景训练\" class=\"headerlink\" title=\"1.3.2. 实景训练\"></a>1.3.2. 实景训练</h3><ol>\n<li>现在有一个名单列表，但是姓和名称是反的，我需要把他交换过来<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shiffina, Daniel</span><br><span class=\"line\">shifafl, Daniell</span><br><span class=\"line\">shquer, Danny</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>实现方法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reg: (\\w+),\\s(\\w+)</span><br><span class=\"line\"></span><br><span class=\"line\">replace: $2 $1</span><br></pre></td></tr></table></figure></p>\n<p>注意：<code>$0</code> 是所有匹配到的，所以第一个加括号的是<code>$1</code></p>\n<ol start=\"2\">\n<li>匹配markdown中的link标签，并替换为html标签<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[google](http://google.com)</span><br><span class=\"line\">[itp](http://itp.nyu.edu)</span><br><span class=\"line\">[Coding Rainbow](http://codingrainbow.com)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>解析： 这道题有些坑，需要慢慢来。</p>\n<p>看到这个，第一个想考虑匹配<code>[google]</code>这个东西，立马想到正则表达式<code>\\[.*\\]</code>。 这个是巨大的坑，在当前来看，它的确能正确匹配到上面的三条。 但是如果文本是这样的：<br><img src=\"https://github.com/forrany/Web-Project/blob/master/blog_image/zifupipei.png?raw=true\" alt=\"字符匹配\"></p>\n<p>看到了，第一行的内容会全部匹配下来，而不能区分<code>[google]</code>和<code>[test]</code>。 之所以这样，<strong>是因为<code>.</code>是贪婪的，他表示所有，所有能匹配到的，所以当然也包括了<code>]</code>，一直到这一行的最后一个<code>]</code>，它才停止。</strong></p>\n<p>所以为了让它能正确匹配，需要去掉这种贪婪的属性。这里用到<code>？</code> 。 当<code>?</code>放在了<code>quantifiers</code>符号后，表示去掉贪婪属性，匹配到终止条件，即可停下。</p>\n<p><code>\\[.*?\\]</code>这样子，就可以将<code>[google]</code>和<code>[test]</code>分开,效果如下：<br><img src=\"https://github.com/forrany/Web-Project/blob/master/blog_image/split.png?raw=true\" alt=\"分割\"></p>\n<p>接下来完成所有内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reg: \\[(.*?)\\]\\((http.*?)\\)</span><br><span class=\"line\"></span><br><span class=\"line\">replace: &lt;a href=&quot;$2&quot;&gt;$1&lt;/a&gt;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"1-3-3-使用-选择器\"><a href=\"#1-3-3-使用-选择器\" class=\"headerlink\" title=\"1.3.3. 使用\\选择器\"></a>1.3.3. 使用<code>\\</code>选择器</h3><p><code>$</code>选择符是在替换的时候进行的标志或选择，但是如果在正则表达式本身，就要使用<code>\\</code>选择了。比如以下的场景</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This is is a a dog , I think think this is is really</span><br><span class=\"line\">a a good good dog. Don&apos;t you you thinks so so ?</span><br></pre></td></tr></table></figure>\n<p>我们想要匹配比如<code>is is</code> <code>so so</code>这样连续的序列，就用到了下面的表达方式: <code>(\\w+)\\s\\1</code></p>\n<p>效果:<br><img src=\"https://github.com/forrany/Web-Project/blob/master/blog_image/xiaoguo.png?raw=true\" alt=\"效果图\"></p>\n<p>嗯，差不多达到效果，但是有一些小的bug。比如第一句话<code>This is is a</code> 这个就匹配不准确，会把第一个This的后面字母匹配进去。<br><strong>这就用到第一节说的字符结界 <code>\\b</code>了</strong>，就变成了<code>\\b(\\w+)\\s\\1\\b</code></p>\n<p>好了，大功告成，就不贴效果图了，自行脑补就好了。</p>\n<h3 id=\"1-3-4-总结\"><a href=\"#1-3-4-总结\" class=\"headerlink\" title=\"1.3.4. 总结\"></a>1.3.4. 总结</h3><ol>\n<li>分组捕获，使用()进行数据分组，编号0代表整个匹配项，选择的分组从1号开始</li>\n<li>选择器可以使用<code>$1</code>和<code>\\1</code>，但是使用场景不同，<code>\\</code>用在正则表达式自己身上</li>\n<li><code>?</code>符号可以禁止贪婪属性，放在<code>.*</code>之后，表示一次匹配遇到重点就可以停止。否则将会一直向后匹配。</li>\n</ol>\n<h2 id=\"1-4-在JavaScript中的应用\"><a href=\"#1-4-在JavaScript中的应用\" class=\"headerlink\" title=\"1.4. 在JavaScript中的应用\"></a>1.4. 在JavaScript中的应用</h2><p>在js中，主要的正则表达式都是涉及到string的应用。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;hello&quot;</span><br><span class=\"line\">var r = /w+/</span><br></pre></td></tr></table></figure></p>\n<p>这两个分别是string和reg的字面量创建方法。当要使用正则来进行操作的时候，使用了<code>r.test()</code>和<code>str.match()</code> 以及<code>str.replace</code>等方法。</p>\n<h3 id=\"1-4-1-reg-test\"><a href=\"#1-4-1-reg-test\" class=\"headerlink\" title=\"1.4.1. reg.test()\"></a>1.4.1. reg.test()</h3><p>正则表达式本身有一个test的方法，这个方法只能测试是否包含，返回一个bool变量。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var r = /\\d&#123;3&#125;/;</span><br><span class=\"line\">var a = &apos;123&apos;;</span><br><span class=\"line\">var b = &apos;123ABC&apos;;</span><br><span class=\"line\">var c = &apos;abc&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">r.test(a)  //true</span><br><span class=\"line\">r.test(b) //true</span><br><span class=\"line\">r.test(c) //false</span><br></pre></td></tr></table></figure></p>\n<p>嗯，这个很简单，而且用的实际不多，下面着重讲str上的一些方法。</p>\n<h3 id=\"1-4-2-str-match\"><a href=\"#1-4-2-str-match\" class=\"headerlink\" title=\"1.4.2. str.match()\"></a>1.4.2. str.match()</h3><p>与test()不同，不只是返回bool变量，它会返回你所匹配到的内容。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> r = <span class=\"regexp\">/compus/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/w+/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">\"compus, I know something about you\"</span></span><br><span class=\"line\">r.test(s)  <span class=\"comment\">//true</span></span><br><span class=\"line\">s.match(r)  <span class=\"comment\">//[\"compus\"]</span></span><br><span class=\"line\">s.match(reg) <span class=\"comment\">//[\"compus\"]</span></span><br></pre></td></tr></table></figure></p>\n<p>等等，好像有点问题，为什么最后一个返回的也是”compus”？这不科学。</p>\n<p>好吧，实际上，match()返回了第一个可以匹配的序列。想要实现之前的效果，就要用到JS里关于正则的几个flag</p>\n<h4 id=\"1-4-2-1-flag\"><a href=\"#1-4-2-1-flag\" class=\"headerlink\" title=\"1.4.2.1. flag\"></a>1.4.2.1. flag</h4><p>这个标志就在建立正则的时候就要有的，主要有三个</p>\n<table>\n<thead>\n<tr>\n<th>flag</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td> g</td>\n<td>全部的，给我匹配全部的 </td>\n</tr>\n<tr>\n<td> i</td>\n<td>忽略大小写</td>\n</tr>\n<tr>\n<td> m</td>\n<td>多行匹配</td>\n</tr>\n</tbody>\n</table>\n<p> 所以为了解决刚才的问题，只要这样子设置reg就可以了<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reg = <span class=\"regexp\">/w+/g</span></span><br></pre></td></tr></table></figure></p>\n<p>看下面一个练习<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"Here is a Phone Number 111-2313 and 133-2311\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> r = <span class=\"regexp\">/\\d&#123;3&#125;[-.]\\d&#123;4&#125;/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> rg = <span class=\"regexp\">/\\d&#123;3&#125;[-.]d&#123;4&#125;/g</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str.match(r)); <span class=\"comment\">//[\"111-2313\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str.match(rg));<span class=\"comment\">//[\"111-2313\",\"133-2311\"]</span></span><br></pre></td></tr></table></figure></p>\n<p>嗯，找电话号码，是的，很方便。但是还有一个问题，刚才说的分组，那么match会返回分组吗？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sr = <span class=\"regexp\">/(\\d&#123;3&#125;)[-.]\\d&#123;4&#125;/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> srg = <span class=\"regexp\">/(\\d&#123;3&#125;)[-.]\\d&#123;4&#125;/g</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str.match(sr)); <span class=\"comment\">//[\"111-2313\",\"111\"]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str.match(srg)); <span class=\"comment\">//[\"111-2313\",\"133-2311\"]</span></span><br></pre></td></tr></table></figure>\n<p>所以结论是： 当使用了全局flag<code>g</code>的时候，不会返回分组，而是全部的匹配结果；如果没有使用<code>g</code>，会将匹配到的结果和分组以数组的形式返回。</p>\n<p>那么如何实现全局的分组？ </p>\n<h3 id=\"1-4-3-reg-exec\"><a href=\"#1-4-3-reg-exec\" class=\"headerlink\" title=\"1.4.3. reg.exec()\"></a>1.4.3. reg.exec()</h3><p>从字面意思来看，正则表达式的执行方法。 这个方法可以实现匹配全局，并返回分组的结果。</p>\n<blockquote>\n<p>reg.exec()每次调用，返回一个匹配的结果，匹配结果和分组以数组的形式返回，不断的调用即可返回下一个结果，直到返回<code>null</code></p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"Here is a Phone Number 111-2313 and 133-2311\"</span> ;</span><br><span class=\"line\"><span class=\"keyword\">var</span> srg = <span class=\"regexp\">/(\\d&#123;3&#125;)[-.]\\d&#123;4&#125;/g</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = srg.exec(str);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(result !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(result);</span><br><span class=\"line\">    result = srg.exec(str);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>result包含的内容可能比想象中的多，它是一个数组，比如第一次执行，他的结果为：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">\"133-2311\"</span>, <span class=\"string\">\"133\"</span>, <span class=\"attr\">index</span>: <span class=\"number\">36</span>, </span><br><span class=\"line\">input: <span class=\"string\">\"Here is a Phone Number 111-2313 and 133-2311\"</span> groups: <span class=\"literal\">undefined</span>]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"1-4-4-str-split\"><a href=\"#1-4-4-str-split\" class=\"headerlink\" title=\"1.4.4. str.split\"></a>1.4.4. str.split</h3><p>现在来到了更强的功能上，先说下split，我们知道split是将字符串按照某个字符分隔开，比如有以下一段话，需要将其分割成单词。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s = &quot;unicorns and rainbows And, Cupcakes&quot;</span><br></pre></td></tr></table></figure></p>\n<p>分割成单词，首先想到的是空格隔开，于是可以用下面方式实现<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> result = s.split(<span class=\"string\">' '</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> result1 = s.split(<span class=\"regexp\">/\\s/</span>);</span><br><span class=\"line\"><span class=\"comment\">//完全一样的效果</span></span><br><span class=\"line\"><span class=\"comment\">//[\"unicorns\", \"and\", \"rainbows\", \"And,\", \"Cupcakes\"]</span></span><br></pre></td></tr></table></figure></p>\n<p>嗯，这样体现不出来正则的强大，而且最主要的是没有实现要求。因为还有一个”And,”。所以要用正则了，匹配条件是<code>逗号或者空格</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = s.split(<span class=\"regexp\">/[,\\s]/</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//[\"unicorns\", \"and\", \"rainbows\", \"And\", \"\", \"Cupcakes\"]</span></span><br></pre></td></tr></table></figure>\n<p>结果仍然和需要的有出入，因为多了一个””。 我们并不是想让它分割的依据是<code>逗号或者空格</code>,依据应该是<code>逗号或空格所在的连续序列</code>。 在原来的基础上加一个<code>+</code>，改成<code>/[,\\s]+/</code>，这个含义就是<code>一个单独的逗号，或者一个单独的空格</code><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = s.split(<span class=\"regexp\">/[,\\s]+/</span>);</span><br><span class=\"line\"><span class=\"comment\">// [\"unicorns\", \"and\", \"rainbows\", \"And\", \"Cupcakes\"]</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"1-4-4-1-单词分割\"><a href=\"#1-4-4-1-单词分割\" class=\"headerlink\" title=\"1.4.4.1. 单词分割\"></a>1.4.4.1. 单词分割</h4><p>好了，拓展一下，实现一个段落的单词分割，一个正则表达式就是<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = s.split(<span class=\"regexp\">/[,.!?\\s]+/</span>)</span><br></pre></td></tr></table></figure></p>\n<p>当然，有个最简单的方法，我们可以这样去做<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = s.split(<span class=\"regexp\">/\\W+/</span>);</span><br></pre></td></tr></table></figure></p>\n<p>接着，如果我们想将一个段落的句子都分隔开，一个可以实现的表达式就是<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = s.split(<span class=\"regexp\">/[.,!?]+/</span>)</span><br></pre></td></tr></table></figure></p>\n<p>最后，有一个小需求，就是在分割句子的同时，还想把相应的分隔符保留下来。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = </span><br><span class=\"line\"><span class=\"string\">\"Hello,My name is Vincent. Nice to Meet you!What's your name? Haha.\"</span></span><br></pre></td></tr></table></figure></p>\n<p>这是一个小小的ponit，记住<strong>如果想要保留分隔符，只要给匹配的内容分组即可</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> result = s.split(<span class=\"regexp\">/([.,!?]+)/</span>)</span><br><span class=\"line\"><span class=\"comment\">//[\"Hello\", \",\", \"My name is Vincent\", \".\", \" Nice to Meet you\", \"!\", \"What's your name\", \"?\", \" Haha\", \".\", \"\"]</span></span><br></pre></td></tr></table></figure></p>\n<p>可以看到，这样就会把分隔符也存储起来。</p>\n<h3 id=\"1-4-5-str-replace\"><a href=\"#1-4-5-str-replace\" class=\"headerlink\" title=\"1.4.5. str.replace()\"></a>1.4.5. str.replace()</h3><p>replace也是字符串的方法，它的基本用法是<code>str.replace(reg,replace|function)</code>，第一个参数是正则表达式，代表匹配的内容，第二个参数是替换的字符串或者一个回掉函数。</p>\n<p><strong>注意，replace不会修改原字符串，只是返回一个修改后的字符串;除此外，正则表达式如果没有使用<code>g</code>标志，也和<code>match</code>一样，只匹配/替换第一个</strong></p>\n<h4 id=\"1-4-5-1-最简单的替换\"><a href=\"#1-4-5-1-最简单的替换\" class=\"headerlink\" title=\"1.4.5.1. 最简单的替换\"></a>1.4.5.1. 最简单的替换</h4><blockquote>\n<p>替换一个序列中的元音字母(aeiou)，将其替换成一个double。 比如x-&gt;xx</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">\"Hello,My name is Vincent.\"</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = s.replace(<span class=\"regexp\">/([aeiou])/g</span>,<span class=\"string\">\"$1$1\"</span>)</span><br><span class=\"line\"><span class=\"comment\">//\"Heelloo,My naamee iis Viinceent.\"</span></span><br></pre></td></tr></table></figure>\n<p><strong>注意，第二个参数必须是字符串; 注意不要忘记加<code>g</code></strong></p>\n<h4 id=\"1-4-5-2-牛x哄哄的function参数来了\"><a href=\"#1-4-5-2-牛x哄哄的function参数来了\" class=\"headerlink\" title=\"1.4.5.2. 牛x哄哄的function参数来了\"></a>1.4.5.2. 牛x哄哄的function参数来了</h4><p>嗯，这才是最强大的地方，第二参数传入function，先看一个最简单的示例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">\"Hello,My name is Vincent. What is your name?\"</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> newStr = s.replace(<span class=\"regexp\">/\\b\\w&#123;4&#125;\\b/g</span>,replacer)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newStr)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">replacer</span>(<span class=\"params\">match</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(match);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> match.toUpperCase();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">name</span></span><br><span class=\"line\"><span class=\"comment\">What</span></span><br><span class=\"line\"><span class=\"comment\">your</span></span><br><span class=\"line\"><span class=\"comment\">name</span></span><br><span class=\"line\"><span class=\"comment\">Hello,My NAME is Vincent. WHAT is YOUR NAME?</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></p>\n<p>所以，函数的参数是匹配到的内容，返回的是需要替换的内容。好了，基本示例解释了基本用法，那么之前讨论的分组怎么办？如何实现分组呢？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//分组</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">replacer</span>(<span class=\"params\">match,group1,group2</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(group1);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(group2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果正则表达式分组处理，那么在回调函数中，函数的第二个、第三参数就是group1,group2。这样子，就可以做很多神奇的事情</p>\n<h4 id=\"1-4-5-3-综合练习题\"><a href=\"#1-4-5-3-综合练习题\" class=\"headerlink\" title=\"1.4.5.3. 综合练习题\"></a>1.4.5.3. 综合练习题</h4><ol>\n<li>判断一个字符串中出现次数最多的字符，并统计次数</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">'aaabbbcccaaabbbaaa'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = s.split(<span class=\"string\">''</span>).sort().join(<span class=\"string\">\"\"</span>);  <span class=\"comment\">//\"aaaaaaaaabbbbbbccc\"</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ans = a.match(<span class=\"regexp\">/(\\w)\\1+/g</span>);</span><br><span class=\"line\">ans.sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.length - b.length;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'ans is : '</span> + ans[ans.length])</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-4-6-总结\"><a href=\"#1-4-6-总结\" class=\"headerlink\" title=\"1.4.6. 总结\"></a>1.4.6. 总结</h3><ol>\n<li>在js中，正则表达式字面量<code>/reg/</code>和字符串字面量<code>&quot;str&quot;</code>用于创建正则和字符串。其中正则上有两个方法<code>reg.test()</code>和<code>reg.exec()</code></li>\n<li><code>reg.test(str)</code>方法，返回布尔变量，用于指示是否有所匹配； <code>reg.exec(str)</code>有点类似与迭代器，每次执行，返回匹配结果和分组，直到返回为<code>null</code>结束。</li>\n<li>字符串方法主要有<code>str.match(reg)</code>,<code>str.split(reg)</code>和<code>str.replace(reg,str|function)</code> 三种方法。</li>\n<li><code>match</code>比较特殊，如果正则包含了分组，且没有<code>g</code>标志，则返回匹配内容和分组; 如果没有分组，且有<code>g</code>标志，返回所有匹配内容</li>\n<li><code>split</code>方法主要用于字符串分割，如果想要保存分隔符，记得将匹配内容分组(用小括号包起来)</li>\n<li><code>replace</code>是最强大的方法，当使用回掉函数时，返回值就是替换值; 参数分别为<code>匹配值</code> <code>group1</code> <code>group2</code>…</li>\n</ol>\n"},{"layout":"post","title":"浅尝辄止,React是如何工作的","subtitle":"How React Works","date":"2018-08-22T04:00:00.000Z","author":"Vinecnt Ko","header-img":"img/How-react-works.jpg","header-mask":0.3,"catalog":true,"_content":"\n大神们可以写出“深入浅出”系列，小白就写点\"真·浅尝辄止\"系列的吧，主要便于自己理解和巩固，毕竟一开始就上源码还是会头大滴，于是就准备浅尝辄止的了解下\"React是如何工作的？\"\n\n> React是怎么工作的？ 你知道Diff算法吗     ---xx面试官\n\n## How React.js works\n\n### Virtual Dom VS Browser Dom\n\nReact除了是MVC框架，数据驱动页面的特点之外，核心的就是他很\"快\"。 按照普遍的说法：\"因为直接操作DOM会带来重绘、回流等，带来巨大的性能损耗而导致渲染慢等问题。React使用了虚拟DOM，每次状态更新，React比较虚拟DOM的差异之后，再更改变化的内容，最后统一由React去修改真实DOM、完成页面的更新、渲染。\"\n\n上面这段话，是我们都会说的，那么一般到这里，面试官就问了：\"什么是虚拟DOM，React是怎么进行比较的？Diff算法了解吗？\"。之前是有点崩溃的，于是决定浅尝一下：\n\n* 虚拟DOM是React的核心，它的本质是JavaScript对象；\n\n* BrowserDOM(也就是页面真实DOM)就是Browser对象了。\n\nDOM没什么好说的，主要说下虚拟DOM的一些特点：\n\n1. 本质是JS对象，代表着真实的DOM\n2. 比真实DOM的比较和操作快的多\n3. 每秒可创建200,000个虚拟DOM节点\n4. 每次setState或despatch一个action，都会创建一次全新的虚拟dom\n\n前几点没什么好说的，注意第四点，也就是你每一个改动，每一个动作都会让React去根据当前的状态创建一个全新的Virtual DOM。 \n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fuh58blllij20tc0hhdon.jpg)\n\n这里每当Virtual DOM生成，都打印了出来，可以看到，它代表着真实DOM，而每次生成全新的，也是为了能够比较old dom和new dom之前的差别。\n\n### Diff算法\n\n刚才提到了，React会抓取每个状态下的内容，生成一个全新的Virtual DOM，然后通过和前一个的比较，找出不同和差异。React的Diff算法有两个约定：\n\n1. 两个不同类型的元素，会产生两个不同的树\n2. 开发者，可以使用key关键字，告诉React哪些子元素在DOM下是稳定存在的、不变的。\n\n第二点着重说一下，举个例子：比如真实DOM的ul标签下，有一系列的`<li>`标签，然而当你想要重新排列这个标签时，如果你给了每个标签一个`key`值，React在比较差异的时候，就能够知道\"你还是你，只不过位置变化了\"。 React除了要最快的找到差异外，还希望变化是最小的。如果加了`key`，react就会保留实例，而不像之前一样，完全创造一个全新的DOM。\n\n来个更具体的：\n\n`1234`\n\n下一个状态后，序列变为\n\n`1243`\n\n对于我们来讲，其实就是调换了4和3的顺序。可是怎么让React知道，原来的那个`3`跑到了原来的`4`后面了呢？ 就是这个唯一的`key`起了作用。\n\n> 相关面试题：为什么React中列表模板中要加入key\n\n#### Diff运算实例\n\nDiff在进行比较的时候，首先会比较两个根元素，当差异是类型的改变的时候，可能就要花更多的“功夫”了\n\n##### 不同类型的dom元素\n\n比如现在状态有这样的一个改变:\n\n```html\n<div>\n    <Counter />\n</div>\n\n-----------\n<span>\n\t<Counter />\n</span>\n```\n\n可以看到，从`<div>`变成了`<span>`，这种类型的改变，带来的是直接对old tree的整体摧毁，包括子元素`Counter`。 所以旧的实例`Counter`会被完全摧毁后，创建一个新的实例来，显然这种效率是低下的\n\n##### 同类型dom元素\n\n当比较后发现两个是同类型的，那好办了，React会查看其属性的变化，然后直接修改属性，原来的实例都得意保留，从而使得渲染高效，比如：\n\n```html\n<div className=\"before\" title=\"stuff\" />\n\n<div className=\"after\" title=\"stuff\" />\n```\n\n除了`className`，包括`style`也是一样，增加、删除、修改都不会对整个 dom tree进行摧毁，而是属性的修改，保留其下面元素和节点\n\n#### 相同类型的组件元素\n\n与上面类似，相同类型的组件元素，子元素的实力会保持，不会摧毁。 当组件更新时，实例保持不变，以便在渲染之间保持状态。React更新底层组件实例的props以匹配新元素，并在底层实例上调用`componentWillReceiveProps（）`和`componentWillUpdate（）`。\n\n接下来，调用`render()`方法，diff算法对前一个结果和新结果进行递归\n\n##### key props\n\n如果前面对`key`的解释，还不够清除，这里用一个真正的实例来说明`key`的重要性吧。\n\n* 场景一：在一个列表最后增加一个元素\n\n```html\n<ul>\n  <li>first</li>\n  <li>second</li>\n</ul>\n------\n<ul>\n  <li>first</li>\n  <li>second</li>\n  <li>third</li>\n</ul>\n```\n\n可以看到，在这种情况下，React只需要在最后`insert`一个新元素即可，其他的都不需要变化，这个时候React是高效的,但是如果在场景二下:\n\n* 场景二：在列表最前面插入一个元素\n\n```html\n<ul>\n  <li>Duke</li>\n  <li>Villanova</li>\n</ul>\n---\n<ul>\n  <li>Connecticut</li>\n  <li>Duke</li>\n  <li>Villanova</li>\n</ul>\n```\n\n这对React可能就是灾难性的，因为React只知道前两个元素不同，因此会完全创新一个新的元素，最后导致三个元素都是重新创建的，这大大降低了效率。这个时候，`key`就排上用场了。当子元素有`key`时，React使用`key`将原始树中的子元素与后续树中的子元素相匹配。例如，在上面的低效示例中添加一个`key`可以使树转换更高效：\n\n```html\n<ul>\n  <li key=\"2015\">Duke</li>\n  <li key=\"2016\">Villanova</li>\n</ul>\n------\n<ul>\n  <li key=\"2014\">Connecticut</li>\n  <li key=\"2015\">Duke</li>\n  <li key=\"2016\">Villanova</li>\n</ul>\n```\n\n这样，只有`key`值为2014的是新创建的，而`2015`和`2016`仅仅是移动了位置而已。\n\n### 策略\n\nReact是用什么策略来比较两颗tree之间的差异呢？这个策略是最核心的部分：\n\n两个树的完全的 diff 算法是一个时间复杂度为 O(n^3) 的问题。但是在前端当中，你很少会跨越层级地移动DOM元素。所以 Virtual DOM 只会对同一个层级的元素进行对比：\n\n![](https://camo.githubusercontent.com/a32766a14f6b7fbe631475ed1a186fbd9de7f2c3/687474703a2f2f6c69766f7261732e6769746875622e696f2f626c6f672f7669727475616c2d646f6d2f636f6d706172652d696e2d6c6576656c2e706e67)\n\n上面的`div`只会和同一层级的`div`对比，第二层级的只会跟第二层级对比。这样算法复杂度就可以达到 O(n)。\n\n##### 深度优先遍历\n\n在实际代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记，然后记录差异\n\n![](https://camo.githubusercontent.com/6cdc35026bcbb6aa0f8fb4aaca3596963192a7f3/687474703a2f2f6c69766f7261732e6769746875622e696f2f626c6f672f7669727475616c2d646f6d2f6466732d77616c6b2e706e67)\n\n在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。\n\n比如第上图中的1号节点p，有了变化，这样子就记录如下：\n\n```javascript\npatches[1] = [{difference}, {difference}...]//用数组存储新旧节点的差异\n```\n\nok，那么差异类型呢，在上一节中已经说了，包括根元素的类型的不同分为两大类，然后根据不同的情况采取不同的更换策略。\n\n最后，就是在真实DOM进行操作，apply这些差异，更新和渲染了。\n\n---\n\n## 为什么Redux 需要 reducers是纯函数？\n\n这又是一个很厉害的问题了，使用Redux的都知道，reducers会接收上一个`state`和`action`作为参数，然后返回一个新的`state`，这个新的`state`不能是在原来`state`基础上的修改。所以经常可以看到以下的写法：\n\n```javascript\nreturn Object.assign(...)\n//或者----------\nreturn {...state,xx:xxx}\n```\n\n其作用，都是为了返回一个全新的对象。\n\n> 为什么reducers要求是纯函数(返回全新的对象，不影响原对象)?  --某面试官\n\n#### 纯函数\n\n从本质上讲，纯函数的定义如下：不修改函数的输入值，依赖于外部状态（比如数据库，DOM和全局变量），同时对于任何相同的输入有着相同的输出结果。\n\n举个例子，下面的**add**函数不修改变量a或b，同时不依赖外部状态，对于相同的输入始终返回相同的结果。\n\n```javascript\nconst add = (a,b) => {a + b};\n```\n\n这就是一个纯函数，结果对a、b没有任何影响，回头去看reducer，它符合纯函数的所有特征，所以就是一个纯函数\n\n#### 为什么必须是纯函数?\n\n先告诉你结果吧，如果在reducer中，在原来的`state`上进行操作，并返回的话，并不会让React重新渲染。 完全不会有任何变化！\n\n接下来看下Redux的源码：\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fuibmho0afj20rs0ardlt.jpg)\n\nRedux接收一个给定的state（对象），然后通过循环将state的每一部分传递给每个对应的reducer。如果有发生任何改变，reducer将返回一个新的对象。如果不发生任何变化，reducer将返回旧的state。\n\nRedux只通过比较新旧两个对象的存储位置来比较新旧两个对象是否相同。如果你在reducer内部直接修改旧的state对象的属性值，那么新的state和旧的state将都指向同一个对象。因此Redux认为没有任何改变，返回的state将为旧的state。\n\n好了，也就是说，从源码的角度来讲，redux要求开发者必须让新的`state`是全新的对象。那么为什么非要这么麻烦开发者呢？\n\n请看下面的例子：尝试比较a和b是否相同\n\n```javascript\nvar a = {\n    name: 'jack',\n    friend: ['sam','xiaoming','cunsi'],\n    years: 12,\n    ...//省略n项目\n}\n \nvar b = {\n    name: 'jack',\n    friend: ['sam','xiaoming','cunsi'],\n    years: 13,\n    ...//省略n项目\n}\n```\n\n思路是怎样的？我们需要遍历对象，如果对象的属性是数组，还需要进行递归遍历，去看内容是否一致、是否发生了变化。 这带来的性能损耗是非常巨大的。 有没有更好的办法？\n\n有！\n\n```javascript\n//接上面的例子\na === b  //false\n```\n\n我不要进行深度比较，只是浅比较，引用值不一样(不是同一个对象),那就是不一样的。 这就是`redux`的`reducer`如此设计的原因了\n\n## 参考资料\n\n[1.为什么Redux需要reducers是纯函数](https://www.zcfy.cc/article/why-redux-need-reducers-to-be-pure-functions-freecodecamp-2515.html)\n\n[2.深度剖析：如何实现一个 Virtual DOM 算法](https://github.com/livoras/blog/issues/13)\n\n[3.Learn how to code: how react.js works](https://www.youtube.com/watch?v=mLMfx8BEt8g)\n\n","source":"_posts/2018-08-22-how react works.md","raw":"---\nlayout:     post\ntitle:      \"浅尝辄止,React是如何工作的\"\nsubtitle:   \"How React Works\"\ndate:       2018-08-22 12:00:00\nauthor:     \"Vinecnt Ko\"\nheader-img: \"img/How-react-works.jpg\"\nheader-mask: 0.3\ncatalog:    true\ntags:\n    - 前端开发\n    - JavaScript\n    - React\n---\n\n大神们可以写出“深入浅出”系列，小白就写点\"真·浅尝辄止\"系列的吧，主要便于自己理解和巩固，毕竟一开始就上源码还是会头大滴，于是就准备浅尝辄止的了解下\"React是如何工作的？\"\n\n> React是怎么工作的？ 你知道Diff算法吗     ---xx面试官\n\n## How React.js works\n\n### Virtual Dom VS Browser Dom\n\nReact除了是MVC框架，数据驱动页面的特点之外，核心的就是他很\"快\"。 按照普遍的说法：\"因为直接操作DOM会带来重绘、回流等，带来巨大的性能损耗而导致渲染慢等问题。React使用了虚拟DOM，每次状态更新，React比较虚拟DOM的差异之后，再更改变化的内容，最后统一由React去修改真实DOM、完成页面的更新、渲染。\"\n\n上面这段话，是我们都会说的，那么一般到这里，面试官就问了：\"什么是虚拟DOM，React是怎么进行比较的？Diff算法了解吗？\"。之前是有点崩溃的，于是决定浅尝一下：\n\n* 虚拟DOM是React的核心，它的本质是JavaScript对象；\n\n* BrowserDOM(也就是页面真实DOM)就是Browser对象了。\n\nDOM没什么好说的，主要说下虚拟DOM的一些特点：\n\n1. 本质是JS对象，代表着真实的DOM\n2. 比真实DOM的比较和操作快的多\n3. 每秒可创建200,000个虚拟DOM节点\n4. 每次setState或despatch一个action，都会创建一次全新的虚拟dom\n\n前几点没什么好说的，注意第四点，也就是你每一个改动，每一个动作都会让React去根据当前的状态创建一个全新的Virtual DOM。 \n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fuh58blllij20tc0hhdon.jpg)\n\n这里每当Virtual DOM生成，都打印了出来，可以看到，它代表着真实DOM，而每次生成全新的，也是为了能够比较old dom和new dom之前的差别。\n\n### Diff算法\n\n刚才提到了，React会抓取每个状态下的内容，生成一个全新的Virtual DOM，然后通过和前一个的比较，找出不同和差异。React的Diff算法有两个约定：\n\n1. 两个不同类型的元素，会产生两个不同的树\n2. 开发者，可以使用key关键字，告诉React哪些子元素在DOM下是稳定存在的、不变的。\n\n第二点着重说一下，举个例子：比如真实DOM的ul标签下，有一系列的`<li>`标签，然而当你想要重新排列这个标签时，如果你给了每个标签一个`key`值，React在比较差异的时候，就能够知道\"你还是你，只不过位置变化了\"。 React除了要最快的找到差异外，还希望变化是最小的。如果加了`key`，react就会保留实例，而不像之前一样，完全创造一个全新的DOM。\n\n来个更具体的：\n\n`1234`\n\n下一个状态后，序列变为\n\n`1243`\n\n对于我们来讲，其实就是调换了4和3的顺序。可是怎么让React知道，原来的那个`3`跑到了原来的`4`后面了呢？ 就是这个唯一的`key`起了作用。\n\n> 相关面试题：为什么React中列表模板中要加入key\n\n#### Diff运算实例\n\nDiff在进行比较的时候，首先会比较两个根元素，当差异是类型的改变的时候，可能就要花更多的“功夫”了\n\n##### 不同类型的dom元素\n\n比如现在状态有这样的一个改变:\n\n```html\n<div>\n    <Counter />\n</div>\n\n-----------\n<span>\n\t<Counter />\n</span>\n```\n\n可以看到，从`<div>`变成了`<span>`，这种类型的改变，带来的是直接对old tree的整体摧毁，包括子元素`Counter`。 所以旧的实例`Counter`会被完全摧毁后，创建一个新的实例来，显然这种效率是低下的\n\n##### 同类型dom元素\n\n当比较后发现两个是同类型的，那好办了，React会查看其属性的变化，然后直接修改属性，原来的实例都得意保留，从而使得渲染高效，比如：\n\n```html\n<div className=\"before\" title=\"stuff\" />\n\n<div className=\"after\" title=\"stuff\" />\n```\n\n除了`className`，包括`style`也是一样，增加、删除、修改都不会对整个 dom tree进行摧毁，而是属性的修改，保留其下面元素和节点\n\n#### 相同类型的组件元素\n\n与上面类似，相同类型的组件元素，子元素的实力会保持，不会摧毁。 当组件更新时，实例保持不变，以便在渲染之间保持状态。React更新底层组件实例的props以匹配新元素，并在底层实例上调用`componentWillReceiveProps（）`和`componentWillUpdate（）`。\n\n接下来，调用`render()`方法，diff算法对前一个结果和新结果进行递归\n\n##### key props\n\n如果前面对`key`的解释，还不够清除，这里用一个真正的实例来说明`key`的重要性吧。\n\n* 场景一：在一个列表最后增加一个元素\n\n```html\n<ul>\n  <li>first</li>\n  <li>second</li>\n</ul>\n------\n<ul>\n  <li>first</li>\n  <li>second</li>\n  <li>third</li>\n</ul>\n```\n\n可以看到，在这种情况下，React只需要在最后`insert`一个新元素即可，其他的都不需要变化，这个时候React是高效的,但是如果在场景二下:\n\n* 场景二：在列表最前面插入一个元素\n\n```html\n<ul>\n  <li>Duke</li>\n  <li>Villanova</li>\n</ul>\n---\n<ul>\n  <li>Connecticut</li>\n  <li>Duke</li>\n  <li>Villanova</li>\n</ul>\n```\n\n这对React可能就是灾难性的，因为React只知道前两个元素不同，因此会完全创新一个新的元素，最后导致三个元素都是重新创建的，这大大降低了效率。这个时候，`key`就排上用场了。当子元素有`key`时，React使用`key`将原始树中的子元素与后续树中的子元素相匹配。例如，在上面的低效示例中添加一个`key`可以使树转换更高效：\n\n```html\n<ul>\n  <li key=\"2015\">Duke</li>\n  <li key=\"2016\">Villanova</li>\n</ul>\n------\n<ul>\n  <li key=\"2014\">Connecticut</li>\n  <li key=\"2015\">Duke</li>\n  <li key=\"2016\">Villanova</li>\n</ul>\n```\n\n这样，只有`key`值为2014的是新创建的，而`2015`和`2016`仅仅是移动了位置而已。\n\n### 策略\n\nReact是用什么策略来比较两颗tree之间的差异呢？这个策略是最核心的部分：\n\n两个树的完全的 diff 算法是一个时间复杂度为 O(n^3) 的问题。但是在前端当中，你很少会跨越层级地移动DOM元素。所以 Virtual DOM 只会对同一个层级的元素进行对比：\n\n![](https://camo.githubusercontent.com/a32766a14f6b7fbe631475ed1a186fbd9de7f2c3/687474703a2f2f6c69766f7261732e6769746875622e696f2f626c6f672f7669727475616c2d646f6d2f636f6d706172652d696e2d6c6576656c2e706e67)\n\n上面的`div`只会和同一层级的`div`对比，第二层级的只会跟第二层级对比。这样算法复杂度就可以达到 O(n)。\n\n##### 深度优先遍历\n\n在实际代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记，然后记录差异\n\n![](https://camo.githubusercontent.com/6cdc35026bcbb6aa0f8fb4aaca3596963192a7f3/687474703a2f2f6c69766f7261732e6769746875622e696f2f626c6f672f7669727475616c2d646f6d2f6466732d77616c6b2e706e67)\n\n在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。\n\n比如第上图中的1号节点p，有了变化，这样子就记录如下：\n\n```javascript\npatches[1] = [{difference}, {difference}...]//用数组存储新旧节点的差异\n```\n\nok，那么差异类型呢，在上一节中已经说了，包括根元素的类型的不同分为两大类，然后根据不同的情况采取不同的更换策略。\n\n最后，就是在真实DOM进行操作，apply这些差异，更新和渲染了。\n\n---\n\n## 为什么Redux 需要 reducers是纯函数？\n\n这又是一个很厉害的问题了，使用Redux的都知道，reducers会接收上一个`state`和`action`作为参数，然后返回一个新的`state`，这个新的`state`不能是在原来`state`基础上的修改。所以经常可以看到以下的写法：\n\n```javascript\nreturn Object.assign(...)\n//或者----------\nreturn {...state,xx:xxx}\n```\n\n其作用，都是为了返回一个全新的对象。\n\n> 为什么reducers要求是纯函数(返回全新的对象，不影响原对象)?  --某面试官\n\n#### 纯函数\n\n从本质上讲，纯函数的定义如下：不修改函数的输入值，依赖于外部状态（比如数据库，DOM和全局变量），同时对于任何相同的输入有着相同的输出结果。\n\n举个例子，下面的**add**函数不修改变量a或b，同时不依赖外部状态，对于相同的输入始终返回相同的结果。\n\n```javascript\nconst add = (a,b) => {a + b};\n```\n\n这就是一个纯函数，结果对a、b没有任何影响，回头去看reducer，它符合纯函数的所有特征，所以就是一个纯函数\n\n#### 为什么必须是纯函数?\n\n先告诉你结果吧，如果在reducer中，在原来的`state`上进行操作，并返回的话，并不会让React重新渲染。 完全不会有任何变化！\n\n接下来看下Redux的源码：\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fuibmho0afj20rs0ardlt.jpg)\n\nRedux接收一个给定的state（对象），然后通过循环将state的每一部分传递给每个对应的reducer。如果有发生任何改变，reducer将返回一个新的对象。如果不发生任何变化，reducer将返回旧的state。\n\nRedux只通过比较新旧两个对象的存储位置来比较新旧两个对象是否相同。如果你在reducer内部直接修改旧的state对象的属性值，那么新的state和旧的state将都指向同一个对象。因此Redux认为没有任何改变，返回的state将为旧的state。\n\n好了，也就是说，从源码的角度来讲，redux要求开发者必须让新的`state`是全新的对象。那么为什么非要这么麻烦开发者呢？\n\n请看下面的例子：尝试比较a和b是否相同\n\n```javascript\nvar a = {\n    name: 'jack',\n    friend: ['sam','xiaoming','cunsi'],\n    years: 12,\n    ...//省略n项目\n}\n \nvar b = {\n    name: 'jack',\n    friend: ['sam','xiaoming','cunsi'],\n    years: 13,\n    ...//省略n项目\n}\n```\n\n思路是怎样的？我们需要遍历对象，如果对象的属性是数组，还需要进行递归遍历，去看内容是否一致、是否发生了变化。 这带来的性能损耗是非常巨大的。 有没有更好的办法？\n\n有！\n\n```javascript\n//接上面的例子\na === b  //false\n```\n\n我不要进行深度比较，只是浅比较，引用值不一样(不是同一个对象),那就是不一样的。 这就是`redux`的`reducer`如此设计的原因了\n\n## 参考资料\n\n[1.为什么Redux需要reducers是纯函数](https://www.zcfy.cc/article/why-redux-need-reducers-to-be-pure-functions-freecodecamp-2515.html)\n\n[2.深度剖析：如何实现一个 Virtual DOM 算法](https://github.com/livoras/blog/issues/13)\n\n[3.Learn how to code: how react.js works](https://www.youtube.com/watch?v=mLMfx8BEt8g)\n\n","slug":"2018-08-22-how-react-works","published":1,"updated":"2022-08-17T07:53:21.232Z","comments":1,"photos":[],"link":"","_id":"cl6xbhzjt0009zk08uor5zze0","content":"<p>大神们可以写出“深入浅出”系列，小白就写点”真·浅尝辄止”系列的吧，主要便于自己理解和巩固，毕竟一开始就上源码还是会头大滴，于是就准备浅尝辄止的了解下”React是如何工作的？”</p>\n<blockquote>\n<p>React是怎么工作的？ 你知道Diff算法吗     —xx面试官</p>\n</blockquote>\n<h2 id=\"How-React-js-works\"><a href=\"#How-React-js-works\" class=\"headerlink\" title=\"How React.js works\"></a>How React.js works</h2><h3 id=\"Virtual-Dom-VS-Browser-Dom\"><a href=\"#Virtual-Dom-VS-Browser-Dom\" class=\"headerlink\" title=\"Virtual Dom VS Browser Dom\"></a>Virtual Dom VS Browser Dom</h3><p>React除了是MVC框架，数据驱动页面的特点之外，核心的就是他很”快”。 按照普遍的说法：”因为直接操作DOM会带来重绘、回流等，带来巨大的性能损耗而导致渲染慢等问题。React使用了虚拟DOM，每次状态更新，React比较虚拟DOM的差异之后，再更改变化的内容，最后统一由React去修改真实DOM、完成页面的更新、渲染。”</p>\n<p>上面这段话，是我们都会说的，那么一般到这里，面试官就问了：”什么是虚拟DOM，React是怎么进行比较的？Diff算法了解吗？”。之前是有点崩溃的，于是决定浅尝一下：</p>\n<ul>\n<li><p>虚拟DOM是React的核心，它的本质是JavaScript对象；</p>\n</li>\n<li><p>BrowserDOM(也就是页面真实DOM)就是Browser对象了。</p>\n</li>\n</ul>\n<p>DOM没什么好说的，主要说下虚拟DOM的一些特点：</p>\n<ol>\n<li>本质是JS对象，代表着真实的DOM</li>\n<li>比真实DOM的比较和操作快的多</li>\n<li>每秒可创建200,000个虚拟DOM节点</li>\n<li>每次setState或despatch一个action，都会创建一次全新的虚拟dom</li>\n</ol>\n<p>前几点没什么好说的，注意第四点，也就是你每一个改动，每一个动作都会让React去根据当前的状态创建一个全新的Virtual DOM。 </p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fuh58blllij20tc0hhdon.jpg\" alt=\"\"></p>\n<p>这里每当Virtual DOM生成，都打印了出来，可以看到，它代表着真实DOM，而每次生成全新的，也是为了能够比较old dom和new dom之前的差别。</p>\n<h3 id=\"Diff算法\"><a href=\"#Diff算法\" class=\"headerlink\" title=\"Diff算法\"></a>Diff算法</h3><p>刚才提到了，React会抓取每个状态下的内容，生成一个全新的Virtual DOM，然后通过和前一个的比较，找出不同和差异。React的Diff算法有两个约定：</p>\n<ol>\n<li>两个不同类型的元素，会产生两个不同的树</li>\n<li>开发者，可以使用key关键字，告诉React哪些子元素在DOM下是稳定存在的、不变的。</li>\n</ol>\n<p>第二点着重说一下，举个例子：比如真实DOM的ul标签下，有一系列的<code>&lt;li&gt;</code>标签，然而当你想要重新排列这个标签时，如果你给了每个标签一个<code>key</code>值，React在比较差异的时候，就能够知道”你还是你，只不过位置变化了”。 React除了要最快的找到差异外，还希望变化是最小的。如果加了<code>key</code>，react就会保留实例，而不像之前一样，完全创造一个全新的DOM。</p>\n<p>来个更具体的：</p>\n<p><code>1234</code></p>\n<p>下一个状态后，序列变为</p>\n<p><code>1243</code></p>\n<p>对于我们来讲，其实就是调换了4和3的顺序。可是怎么让React知道，原来的那个<code>3</code>跑到了原来的<code>4</code>后面了呢？ 就是这个唯一的<code>key</code>起了作用。</p>\n<blockquote>\n<p>相关面试题：为什么React中列表模板中要加入key</p>\n</blockquote>\n<h4 id=\"Diff运算实例\"><a href=\"#Diff运算实例\" class=\"headerlink\" title=\"Diff运算实例\"></a>Diff运算实例</h4><p>Diff在进行比较的时候，首先会比较两个根元素，当差异是类型的改变的时候，可能就要花更多的“功夫”了</p>\n<h5 id=\"不同类型的dom元素\"><a href=\"#不同类型的dom元素\" class=\"headerlink\" title=\"不同类型的dom元素\"></a>不同类型的dom元素</h5><p>比如现在状态有这样的一个改变:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Counter</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">-----------</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">Counter</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，从<code>&lt;div&gt;</code>变成了<code>&lt;span&gt;</code>，这种类型的改变，带来的是直接对old tree的整体摧毁，包括子元素<code>Counter</code>。 所以旧的实例<code>Counter</code>会被完全摧毁后，创建一个新的实例来，显然这种效率是低下的</p>\n<h5 id=\"同类型dom元素\"><a href=\"#同类型dom元素\" class=\"headerlink\" title=\"同类型dom元素\"></a>同类型dom元素</h5><p>当比较后发现两个是同类型的，那好办了，React会查看其属性的变化，然后直接修改属性，原来的实例都得意保留，从而使得渲染高效，比如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"before\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"stuff\"</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"after\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"stuff\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>除了<code>className</code>，包括<code>style</code>也是一样，增加、删除、修改都不会对整个 dom tree进行摧毁，而是属性的修改，保留其下面元素和节点</p>\n<h4 id=\"相同类型的组件元素\"><a href=\"#相同类型的组件元素\" class=\"headerlink\" title=\"相同类型的组件元素\"></a>相同类型的组件元素</h4><p>与上面类似，相同类型的组件元素，子元素的实力会保持，不会摧毁。 当组件更新时，实例保持不变，以便在渲染之间保持状态。React更新底层组件实例的props以匹配新元素，并在底层实例上调用<code>componentWillReceiveProps（）</code>和<code>componentWillUpdate（）</code>。</p>\n<p>接下来，调用<code>render()</code>方法，diff算法对前一个结果和新结果进行递归</p>\n<h5 id=\"key-props\"><a href=\"#key-props\" class=\"headerlink\" title=\"key props\"></a>key props</h5><p>如果前面对<code>key</code>的解释，还不够清除，这里用一个真正的实例来说明<code>key</code>的重要性吧。</p>\n<ul>\n<li>场景一：在一个列表最后增加一个元素</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>first<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>second<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">------</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>first<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>second<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>third<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，在这种情况下，React只需要在最后<code>insert</code>一个新元素即可，其他的都不需要变化，这个时候React是高效的,但是如果在场景二下:</p>\n<ul>\n<li>场景二：在列表最前面插入一个元素</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>Duke<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>Villanova<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">---</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>Connecticut<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>Duke<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>Villanova<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这对React可能就是灾难性的，因为React只知道前两个元素不同，因此会完全创新一个新的元素，最后导致三个元素都是重新创建的，这大大降低了效率。这个时候，<code>key</code>就排上用场了。当子元素有<code>key</code>时，React使用<code>key</code>将原始树中的子元素与后续树中的子元素相匹配。例如，在上面的低效示例中添加一个<code>key</code>可以使树转换更高效：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">\"2015\"</span>&gt;</span>Duke<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">\"2016\"</span>&gt;</span>Villanova<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">------</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">\"2014\"</span>&gt;</span>Connecticut<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">\"2015\"</span>&gt;</span>Duke<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">\"2016\"</span>&gt;</span>Villanova<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这样，只有<code>key</code>值为2014的是新创建的，而<code>2015</code>和<code>2016</code>仅仅是移动了位置而已。</p>\n<h3 id=\"策略\"><a href=\"#策略\" class=\"headerlink\" title=\"策略\"></a>策略</h3><p>React是用什么策略来比较两颗tree之间的差异呢？这个策略是最核心的部分：</p>\n<p>两个树的完全的 diff 算法是一个时间复杂度为 O(n^3) 的问题。但是在前端当中，你很少会跨越层级地移动DOM元素。所以 Virtual DOM 只会对同一个层级的元素进行对比：</p>\n<p><img src=\"https://camo.githubusercontent.com/a32766a14f6b7fbe631475ed1a186fbd9de7f2c3/687474703a2f2f6c69766f7261732e6769746875622e696f2f626c6f672f7669727475616c2d646f6d2f636f6d706172652d696e2d6c6576656c2e706e67\" alt=\"\"></p>\n<p>上面的<code>div</code>只会和同一层级的<code>div</code>对比，第二层级的只会跟第二层级对比。这样算法复杂度就可以达到 O(n)。</p>\n<h5 id=\"深度优先遍历\"><a href=\"#深度优先遍历\" class=\"headerlink\" title=\"深度优先遍历\"></a>深度优先遍历</h5><p>在实际代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记，然后记录差异</p>\n<p><img src=\"https://camo.githubusercontent.com/6cdc35026bcbb6aa0f8fb4aaca3596963192a7f3/687474703a2f2f6c69766f7261732e6769746875622e696f2f626c6f672f7669727475616c2d646f6d2f6466732d77616c6b2e706e67\" alt=\"\"></p>\n<p>在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。</p>\n<p>比如第上图中的1号节点p，有了变化，这样子就记录如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">patches[<span class=\"number\">1</span>] = [&#123;difference&#125;, &#123;difference&#125;...]<span class=\"comment\">//用数组存储新旧节点的差异</span></span><br></pre></td></tr></table></figure>\n<p>ok，那么差异类型呢，在上一节中已经说了，包括根元素的类型的不同分为两大类，然后根据不同的情况采取不同的更换策略。</p>\n<p>最后，就是在真实DOM进行操作，apply这些差异，更新和渲染了。</p>\n<hr>\n<h2 id=\"为什么Redux-需要-reducers是纯函数？\"><a href=\"#为什么Redux-需要-reducers是纯函数？\" class=\"headerlink\" title=\"为什么Redux 需要 reducers是纯函数？\"></a>为什么Redux 需要 reducers是纯函数？</h2><p>这又是一个很厉害的问题了，使用Redux的都知道，reducers会接收上一个<code>state</code>和<code>action</code>作为参数，然后返回一个新的<code>state</code>，这个新的<code>state</code>不能是在原来<code>state</code>基础上的修改。所以经常可以看到以下的写法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(...)</span><br><span class=\"line\"><span class=\"comment\">//或者----------</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> &#123;...state,<span class=\"attr\">xx</span>:xxx&#125;</span><br></pre></td></tr></table></figure>\n<p>其作用，都是为了返回一个全新的对象。</p>\n<blockquote>\n<p>为什么reducers要求是纯函数(返回全新的对象，不影响原对象)?  –某面试官</p>\n</blockquote>\n<h4 id=\"纯函数\"><a href=\"#纯函数\" class=\"headerlink\" title=\"纯函数\"></a>纯函数</h4><p>从本质上讲，纯函数的定义如下：不修改函数的输入值，依赖于外部状态（比如数据库，DOM和全局变量），同时对于任何相同的输入有着相同的输出结果。</p>\n<p>举个例子，下面的<strong>add</strong>函数不修改变量a或b，同时不依赖外部状态，对于相同的输入始终返回相同的结果。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> add = <span class=\"function\">(<span class=\"params\">a,b</span>) =&gt;</span> &#123;a + b&#125;;</span><br></pre></td></tr></table></figure>\n<p>这就是一个纯函数，结果对a、b没有任何影响，回头去看reducer，它符合纯函数的所有特征，所以就是一个纯函数</p>\n<h4 id=\"为什么必须是纯函数\"><a href=\"#为什么必须是纯函数\" class=\"headerlink\" title=\"为什么必须是纯函数?\"></a>为什么必须是纯函数?</h4><p>先告诉你结果吧，如果在reducer中，在原来的<code>state</code>上进行操作，并返回的话，并不会让React重新渲染。 完全不会有任何变化！</p>\n<p>接下来看下Redux的源码：<br><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fuibmho0afj20rs0ardlt.jpg\" alt=\"\"></p>\n<p>Redux接收一个给定的state（对象），然后通过循环将state的每一部分传递给每个对应的reducer。如果有发生任何改变，reducer将返回一个新的对象。如果不发生任何变化，reducer将返回旧的state。</p>\n<p>Redux只通过比较新旧两个对象的存储位置来比较新旧两个对象是否相同。如果你在reducer内部直接修改旧的state对象的属性值，那么新的state和旧的state将都指向同一个对象。因此Redux认为没有任何改变，返回的state将为旧的state。</p>\n<p>好了，也就是说，从源码的角度来讲，redux要求开发者必须让新的<code>state</code>是全新的对象。那么为什么非要这么麻烦开发者呢？</p>\n<p>请看下面的例子：尝试比较a和b是否相同</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'jack'</span>,</span><br><span class=\"line\">    friend: [<span class=\"string\">'sam'</span>,<span class=\"string\">'xiaoming'</span>,<span class=\"string\">'cunsi'</span>],</span><br><span class=\"line\">    years: <span class=\"number\">12</span>,</span><br><span class=\"line\">    ...<span class=\"comment\">//省略n项目</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">var</span> b = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'jack'</span>,</span><br><span class=\"line\">    friend: [<span class=\"string\">'sam'</span>,<span class=\"string\">'xiaoming'</span>,<span class=\"string\">'cunsi'</span>],</span><br><span class=\"line\">    years: <span class=\"number\">13</span>,</span><br><span class=\"line\">    ...<span class=\"comment\">//省略n项目</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>思路是怎样的？我们需要遍历对象，如果对象的属性是数组，还需要进行递归遍历，去看内容是否一致、是否发生了变化。 这带来的性能损耗是非常巨大的。 有没有更好的办法？</p>\n<p>有！</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//接上面的例子</span></span><br><span class=\"line\">a === b  <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p>我不要进行深度比较，只是浅比较，引用值不一样(不是同一个对象),那就是不一样的。 这就是<code>redux</code>的<code>reducer</code>如此设计的原因了</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://www.zcfy.cc/article/why-redux-need-reducers-to-be-pure-functions-freecodecamp-2515.html\" target=\"_blank\" rel=\"noopener\">1.为什么Redux需要reducers是纯函数</a></p>\n<p><a href=\"https://github.com/livoras/blog/issues/13\" target=\"_blank\" rel=\"noopener\">2.深度剖析：如何实现一个 Virtual DOM 算法</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=mLMfx8BEt8g\" target=\"_blank\" rel=\"noopener\">3.Learn how to code: how react.js works</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>大神们可以写出“深入浅出”系列，小白就写点”真·浅尝辄止”系列的吧，主要便于自己理解和巩固，毕竟一开始就上源码还是会头大滴，于是就准备浅尝辄止的了解下”React是如何工作的？”</p>\n<blockquote>\n<p>React是怎么工作的？ 你知道Diff算法吗     —xx面试官</p>\n</blockquote>\n<h2 id=\"How-React-js-works\"><a href=\"#How-React-js-works\" class=\"headerlink\" title=\"How React.js works\"></a>How React.js works</h2><h3 id=\"Virtual-Dom-VS-Browser-Dom\"><a href=\"#Virtual-Dom-VS-Browser-Dom\" class=\"headerlink\" title=\"Virtual Dom VS Browser Dom\"></a>Virtual Dom VS Browser Dom</h3><p>React除了是MVC框架，数据驱动页面的特点之外，核心的就是他很”快”。 按照普遍的说法：”因为直接操作DOM会带来重绘、回流等，带来巨大的性能损耗而导致渲染慢等问题。React使用了虚拟DOM，每次状态更新，React比较虚拟DOM的差异之后，再更改变化的内容，最后统一由React去修改真实DOM、完成页面的更新、渲染。”</p>\n<p>上面这段话，是我们都会说的，那么一般到这里，面试官就问了：”什么是虚拟DOM，React是怎么进行比较的？Diff算法了解吗？”。之前是有点崩溃的，于是决定浅尝一下：</p>\n<ul>\n<li><p>虚拟DOM是React的核心，它的本质是JavaScript对象；</p>\n</li>\n<li><p>BrowserDOM(也就是页面真实DOM)就是Browser对象了。</p>\n</li>\n</ul>\n<p>DOM没什么好说的，主要说下虚拟DOM的一些特点：</p>\n<ol>\n<li>本质是JS对象，代表着真实的DOM</li>\n<li>比真实DOM的比较和操作快的多</li>\n<li>每秒可创建200,000个虚拟DOM节点</li>\n<li>每次setState或despatch一个action，都会创建一次全新的虚拟dom</li>\n</ol>\n<p>前几点没什么好说的，注意第四点，也就是你每一个改动，每一个动作都会让React去根据当前的状态创建一个全新的Virtual DOM。 </p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fuh58blllij20tc0hhdon.jpg\" alt=\"\"></p>\n<p>这里每当Virtual DOM生成，都打印了出来，可以看到，它代表着真实DOM，而每次生成全新的，也是为了能够比较old dom和new dom之前的差别。</p>\n<h3 id=\"Diff算法\"><a href=\"#Diff算法\" class=\"headerlink\" title=\"Diff算法\"></a>Diff算法</h3><p>刚才提到了，React会抓取每个状态下的内容，生成一个全新的Virtual DOM，然后通过和前一个的比较，找出不同和差异。React的Diff算法有两个约定：</p>\n<ol>\n<li>两个不同类型的元素，会产生两个不同的树</li>\n<li>开发者，可以使用key关键字，告诉React哪些子元素在DOM下是稳定存在的、不变的。</li>\n</ol>\n<p>第二点着重说一下，举个例子：比如真实DOM的ul标签下，有一系列的<code>&lt;li&gt;</code>标签，然而当你想要重新排列这个标签时，如果你给了每个标签一个<code>key</code>值，React在比较差异的时候，就能够知道”你还是你，只不过位置变化了”。 React除了要最快的找到差异外，还希望变化是最小的。如果加了<code>key</code>，react就会保留实例，而不像之前一样，完全创造一个全新的DOM。</p>\n<p>来个更具体的：</p>\n<p><code>1234</code></p>\n<p>下一个状态后，序列变为</p>\n<p><code>1243</code></p>\n<p>对于我们来讲，其实就是调换了4和3的顺序。可是怎么让React知道，原来的那个<code>3</code>跑到了原来的<code>4</code>后面了呢？ 就是这个唯一的<code>key</code>起了作用。</p>\n<blockquote>\n<p>相关面试题：为什么React中列表模板中要加入key</p>\n</blockquote>\n<h4 id=\"Diff运算实例\"><a href=\"#Diff运算实例\" class=\"headerlink\" title=\"Diff运算实例\"></a>Diff运算实例</h4><p>Diff在进行比较的时候，首先会比较两个根元素，当差异是类型的改变的时候，可能就要花更多的“功夫”了</p>\n<h5 id=\"不同类型的dom元素\"><a href=\"#不同类型的dom元素\" class=\"headerlink\" title=\"不同类型的dom元素\"></a>不同类型的dom元素</h5><p>比如现在状态有这样的一个改变:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">Counter</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">-----------</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">Counter</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，从<code>&lt;div&gt;</code>变成了<code>&lt;span&gt;</code>，这种类型的改变，带来的是直接对old tree的整体摧毁，包括子元素<code>Counter</code>。 所以旧的实例<code>Counter</code>会被完全摧毁后，创建一个新的实例来，显然这种效率是低下的</p>\n<h5 id=\"同类型dom元素\"><a href=\"#同类型dom元素\" class=\"headerlink\" title=\"同类型dom元素\"></a>同类型dom元素</h5><p>当比较后发现两个是同类型的，那好办了，React会查看其属性的变化，然后直接修改属性，原来的实例都得意保留，从而使得渲染高效，比如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"before\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"stuff\"</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">className</span>=<span class=\"string\">\"after\"</span> <span class=\"attr\">title</span>=<span class=\"string\">\"stuff\"</span> /&gt;</span></span><br></pre></td></tr></table></figure>\n<p>除了<code>className</code>，包括<code>style</code>也是一样，增加、删除、修改都不会对整个 dom tree进行摧毁，而是属性的修改，保留其下面元素和节点</p>\n<h4 id=\"相同类型的组件元素\"><a href=\"#相同类型的组件元素\" class=\"headerlink\" title=\"相同类型的组件元素\"></a>相同类型的组件元素</h4><p>与上面类似，相同类型的组件元素，子元素的实力会保持，不会摧毁。 当组件更新时，实例保持不变，以便在渲染之间保持状态。React更新底层组件实例的props以匹配新元素，并在底层实例上调用<code>componentWillReceiveProps（）</code>和<code>componentWillUpdate（）</code>。</p>\n<p>接下来，调用<code>render()</code>方法，diff算法对前一个结果和新结果进行递归</p>\n<h5 id=\"key-props\"><a href=\"#key-props\" class=\"headerlink\" title=\"key props\"></a>key props</h5><p>如果前面对<code>key</code>的解释，还不够清除，这里用一个真正的实例来说明<code>key</code>的重要性吧。</p>\n<ul>\n<li>场景一：在一个列表最后增加一个元素</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>first<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>second<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">------</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>first<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>second<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>third<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，在这种情况下，React只需要在最后<code>insert</code>一个新元素即可，其他的都不需要变化，这个时候React是高效的,但是如果在场景二下:</p>\n<ul>\n<li>场景二：在列表最前面插入一个元素</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>Duke<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>Villanova<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">---</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>Connecticut<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>Duke<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>Villanova<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这对React可能就是灾难性的，因为React只知道前两个元素不同，因此会完全创新一个新的元素，最后导致三个元素都是重新创建的，这大大降低了效率。这个时候，<code>key</code>就排上用场了。当子元素有<code>key</code>时，React使用<code>key</code>将原始树中的子元素与后续树中的子元素相匹配。例如，在上面的低效示例中添加一个<code>key</code>可以使树转换更高效：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">\"2015\"</span>&gt;</span>Duke<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">\"2016\"</span>&gt;</span>Villanova<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">------</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">\"2014\"</span>&gt;</span>Connecticut<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">\"2015\"</span>&gt;</span>Duke<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">key</span>=<span class=\"string\">\"2016\"</span>&gt;</span>Villanova<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这样，只有<code>key</code>值为2014的是新创建的，而<code>2015</code>和<code>2016</code>仅仅是移动了位置而已。</p>\n<h3 id=\"策略\"><a href=\"#策略\" class=\"headerlink\" title=\"策略\"></a>策略</h3><p>React是用什么策略来比较两颗tree之间的差异呢？这个策略是最核心的部分：</p>\n<p>两个树的完全的 diff 算法是一个时间复杂度为 O(n^3) 的问题。但是在前端当中，你很少会跨越层级地移动DOM元素。所以 Virtual DOM 只会对同一个层级的元素进行对比：</p>\n<p><img src=\"https://camo.githubusercontent.com/a32766a14f6b7fbe631475ed1a186fbd9de7f2c3/687474703a2f2f6c69766f7261732e6769746875622e696f2f626c6f672f7669727475616c2d646f6d2f636f6d706172652d696e2d6c6576656c2e706e67\" alt=\"\"></p>\n<p>上面的<code>div</code>只会和同一层级的<code>div</code>对比，第二层级的只会跟第二层级对比。这样算法复杂度就可以达到 O(n)。</p>\n<h5 id=\"深度优先遍历\"><a href=\"#深度优先遍历\" class=\"headerlink\" title=\"深度优先遍历\"></a>深度优先遍历</h5><p>在实际代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记，然后记录差异</p>\n<p><img src=\"https://camo.githubusercontent.com/6cdc35026bcbb6aa0f8fb4aaca3596963192a7f3/687474703a2f2f6c69766f7261732e6769746875622e696f2f626c6f672f7669727475616c2d646f6d2f6466732d77616c6b2e706e67\" alt=\"\"></p>\n<p>在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。</p>\n<p>比如第上图中的1号节点p，有了变化，这样子就记录如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">patches[<span class=\"number\">1</span>] = [&#123;difference&#125;, &#123;difference&#125;...]<span class=\"comment\">//用数组存储新旧节点的差异</span></span><br></pre></td></tr></table></figure>\n<p>ok，那么差异类型呢，在上一节中已经说了，包括根元素的类型的不同分为两大类，然后根据不同的情况采取不同的更换策略。</p>\n<p>最后，就是在真实DOM进行操作，apply这些差异，更新和渲染了。</p>\n<hr>\n<h2 id=\"为什么Redux-需要-reducers是纯函数？\"><a href=\"#为什么Redux-需要-reducers是纯函数？\" class=\"headerlink\" title=\"为什么Redux 需要 reducers是纯函数？\"></a>为什么Redux 需要 reducers是纯函数？</h2><p>这又是一个很厉害的问题了，使用Redux的都知道，reducers会接收上一个<code>state</code>和<code>action</code>作为参数，然后返回一个新的<code>state</code>，这个新的<code>state</code>不能是在原来<code>state</code>基础上的修改。所以经常可以看到以下的写法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(...)</span><br><span class=\"line\"><span class=\"comment\">//或者----------</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> &#123;...state,<span class=\"attr\">xx</span>:xxx&#125;</span><br></pre></td></tr></table></figure>\n<p>其作用，都是为了返回一个全新的对象。</p>\n<blockquote>\n<p>为什么reducers要求是纯函数(返回全新的对象，不影响原对象)?  –某面试官</p>\n</blockquote>\n<h4 id=\"纯函数\"><a href=\"#纯函数\" class=\"headerlink\" title=\"纯函数\"></a>纯函数</h4><p>从本质上讲，纯函数的定义如下：不修改函数的输入值，依赖于外部状态（比如数据库，DOM和全局变量），同时对于任何相同的输入有着相同的输出结果。</p>\n<p>举个例子，下面的<strong>add</strong>函数不修改变量a或b，同时不依赖外部状态，对于相同的输入始终返回相同的结果。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> add = <span class=\"function\">(<span class=\"params\">a,b</span>) =&gt;</span> &#123;a + b&#125;;</span><br></pre></td></tr></table></figure>\n<p>这就是一个纯函数，结果对a、b没有任何影响，回头去看reducer，它符合纯函数的所有特征，所以就是一个纯函数</p>\n<h4 id=\"为什么必须是纯函数\"><a href=\"#为什么必须是纯函数\" class=\"headerlink\" title=\"为什么必须是纯函数?\"></a>为什么必须是纯函数?</h4><p>先告诉你结果吧，如果在reducer中，在原来的<code>state</code>上进行操作，并返回的话，并不会让React重新渲染。 完全不会有任何变化！</p>\n<p>接下来看下Redux的源码：<br><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fuibmho0afj20rs0ardlt.jpg\" alt=\"\"></p>\n<p>Redux接收一个给定的state（对象），然后通过循环将state的每一部分传递给每个对应的reducer。如果有发生任何改变，reducer将返回一个新的对象。如果不发生任何变化，reducer将返回旧的state。</p>\n<p>Redux只通过比较新旧两个对象的存储位置来比较新旧两个对象是否相同。如果你在reducer内部直接修改旧的state对象的属性值，那么新的state和旧的state将都指向同一个对象。因此Redux认为没有任何改变，返回的state将为旧的state。</p>\n<p>好了，也就是说，从源码的角度来讲，redux要求开发者必须让新的<code>state</code>是全新的对象。那么为什么非要这么麻烦开发者呢？</p>\n<p>请看下面的例子：尝试比较a和b是否相同</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'jack'</span>,</span><br><span class=\"line\">    friend: [<span class=\"string\">'sam'</span>,<span class=\"string\">'xiaoming'</span>,<span class=\"string\">'cunsi'</span>],</span><br><span class=\"line\">    years: <span class=\"number\">12</span>,</span><br><span class=\"line\">    ...<span class=\"comment\">//省略n项目</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">var</span> b = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'jack'</span>,</span><br><span class=\"line\">    friend: [<span class=\"string\">'sam'</span>,<span class=\"string\">'xiaoming'</span>,<span class=\"string\">'cunsi'</span>],</span><br><span class=\"line\">    years: <span class=\"number\">13</span>,</span><br><span class=\"line\">    ...<span class=\"comment\">//省略n项目</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>思路是怎样的？我们需要遍历对象，如果对象的属性是数组，还需要进行递归遍历，去看内容是否一致、是否发生了变化。 这带来的性能损耗是非常巨大的。 有没有更好的办法？</p>\n<p>有！</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//接上面的例子</span></span><br><span class=\"line\">a === b  <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p>我不要进行深度比较，只是浅比较，引用值不一样(不是同一个对象),那就是不一样的。 这就是<code>redux</code>的<code>reducer</code>如此设计的原因了</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://www.zcfy.cc/article/why-redux-need-reducers-to-be-pure-functions-freecodecamp-2515.html\" target=\"_blank\" rel=\"noopener\">1.为什么Redux需要reducers是纯函数</a></p>\n<p><a href=\"https://github.com/livoras/blog/issues/13\" target=\"_blank\" rel=\"noopener\">2.深度剖析：如何实现一个 Virtual DOM 算法</a></p>\n<p><a href=\"https://www.youtube.com/watch?v=mLMfx8BEt8g\" target=\"_blank\" rel=\"noopener\">3.Learn how to code: how react.js works</a></p>\n"},{"layout":"post","title":"Generator 异步原理","subtitle":"The principle of generator","date":"2018-08-28T05:00:00.000Z","author":"Vinecnt Ko","header-img":"img/post-bg-js-version.jpg","header-mask":0.3,"catalog":true,"_content":"\n## 从实际应用场景开始\n假设我们有一个异步的请求，想要去通过api获取一些数据。这里借助`node-fetch`库来获取数据。\n`fetch`可以异步的获取数据，并返回一个promise，所以常规的异步操作和写法，大致如下\n```javascript\nvar fetch = require('node-fetch');\nfetch('http://jasonplacerholder.typecoder.com/posts/1')\n    .then( res => res.json() )\n    .then( post => post.title )\n    .then( x => console.log('Title: ',x))\n```\n\n好了，以上的代码就是一个获取api，并拿到api中的`title`内容。 关于promise这里不多说，fetch返回的就是一个promise。\n\n## genetor实现\n那么如果使用generator会如何实现实现同样的一个异步操作呢？ 这里先给结果，再来分析实现原理。这里记住`co`，这个co是干嘛的，一会分析并实现一个我们自己的co函数。\n\nco接收一个genetor，所以我们可以认为co就是一个generator的发动机，或者自动执行器。\n```javascript\nconst co = require('co');\nco(function *() {\n    const url = 'http://jasonplacerholder.typecoder.com/posts/1';\n    const response = yield fetch(url);\n    const post = yield response.json();\n    const title = post.title;\n    console.log('Title: ',title);\n})\n\n```\n好了，结束，执行后，会输出同样的结果，似乎和promise没有两样。下面先简单的逐行分析，来看看在genetor中，做了什么。\n```\n//从genetor的第一行开始\n第一行： 定义了url\n第二行： 声明response，并将fetch(url)的结果.....yield\nstop...\nWhat is yield???\n```\n嗯，所以，这个genetor的yield是干什么的？这是`genetor`和普通函数的不同之处，也是它可以做异步的基础。不同与普通函数，genetor遇到了`yield`之后，会将yield后面的处理内容抛出。\n\ngenetor: 运行呀---运行呀---运行呀--yield？ What？这是什么鬼，我搞不定，老大你帮我搞定后再加我---out..\n\nouter(执行器co）: 收到yield返回的结果，处理----返回给genetor\n\ngenetor: 收到处理结果---运行---yeild？这又是什么？你帮我搞定，out...\n\nouter(执行器co)： 收到yield返回的promise，处理---返回给genetor\n\n这就是异步的原理了，genetor遇到yield会把任务丢出去，它就暂时不运行了。 我们知道，yield丢出去的是一个iterator，当调用next()的时候，会返回genetor中。 所以其实`co`就是一个自动触发和调度`next()`的函数。\n\n## 实现co\n知道了原理，我们自己来实现这个过程。然后就会比较清除整个过程了。\n\n我们把函数改一下\n```javascript\nrun(function *() {\n    const url = 'http://jasonplacerholder.typecoder.com/posts/1';\n    const response = yield fetch(url);\n    const post = yield response.json();\n    const title = post.title;\n    console.log('Title: ',title);\n})\n\nfunction run(generator) {\n    const iterator = generator(); //genetor执行会返回一个iterator，然后调用next()才会执行到下一个yield\n    iterator.next(); //这里打印出来的结果看一下是{value: Promise {<pending>},done:false}\n\n}\n```\n解释： 就如上面genetor和outer的对话，遇到yield，genetor会说:\"我不知道怎么搞这个promise,你来搞吧，给你..“ 于是，外面的就会接住这个promise\n\n我们继续写\n```javascript\nfunction run(generator) {\n    const iterator = generator(); //genetor执行会返回一个iterator，然后调用next()才会执行到下一个yield\n    const iteration = iterator.next(); //这里打印出来的结果看一下是{value: Promise {<pending>},done:false}\n    const promise = iteration.value;\n    promise.then(x => iterator.next(x)) //ok，外部帮忙处理了promise，然后处理的结果，我们需要返回genetor，使其继续运行\n    //这个时候，genetor中的response拿到了值，就等于这里的x\n}\n```\n分析到这里，程序已经得到了response。 但是，下一句，立马又遇到了response.json()，同样又会丢出去一个内容，因此，我们这里再处理一下，如下：\n```javascript\nfunction run(generator) {\n    const iterator = generator(); //genetor执行会返回一个iterator，然后调用next()才会执行到下一个yield\n    const iteration = iterator.next(); //这里打印出来的结果看一下是{value: Promise {<pending>},done:false}\n    const promise = iteration.value;\n    promise.then(x => {\n        const anotherIterator = iterator.next(x);//注意,iterator.next()的含义，一方面会将运算结果返回，另一方面，genetor会继续将下一个yield的任务抛出，仍然是一个iterator\n        const anotherPromise = anotherIterator.value;\n        anotherPromise.then(post => iterator.next(post))\n        //到此，因为iterator再也没有yield，所以不会再次返回iterator了，也不用调用next()\n    }) \n}\n```\n至此，模拟的`co`方法已经实现了。\n\n流程如下:\n1. run传入一个genetor并运行，获得一个iterator(generator())\n2. 调用next()方法，获取到iteration,iteration的value是`yield fetch(url)`的结果，也即一个Promise。\n3. yield返回出的任务，由外部执行和处理，结束后在返回,于是使用then方法。\n4. 处理后的结果为`x`，调用`iterator.next(x)`把x返回的同时，拿到了下一个`yield`的抛出的任务。\n5. 处理任务，得到`post`，并通过`next(post)`返回给genetor。\n6. 嗯，我拿到你们处理的结果了，下一次我遇到`yield`还给你们，反正我不会，我也不会学，这任务都是你们的。\n\n也就是说，genetor的异步，就在于能将线程弹出，遇到`yield`后，交出线程。所以，我们做一个能够自动执行和触发`genetor`的执行器，就可以实现异步编程，而且看起来和同步的写法很相似。 这就是库`co`做的事情。\n\n### 完善我们自己的`co`\n刚才只有两个`yield`，我们希望方法有通用性，我们写个递归，让它能不断的触发\n```javascript\nfunction run(genetor) {\n    const iterator = genetor();\n    function autoRun(iteration) {\n        if(iteration.done) {return iteration.value;}\n        const anotherPromise = iteration.value;\n        anotherPromise.then(x => {\n            return autoRun(iterator.next(x));\n        })\n    }\n    return autoRun(iterator.next());\n}\n\n```\n\n好了，这样就完成了我们自己的简易版co函数。","source":"_posts/2018-08-28-How generator works.md","raw":"---\nlayout:     post\ntitle:      \"Generator 异步原理\"\nsubtitle:   \"The principle of generator\"\ndate:       2018-08-28 13:00:00\nauthor:     \"Vinecnt Ko\"\nheader-img: \"img/post-bg-js-version.jpg\"\nheader-mask: 0.3\ncatalog:    true\ntags:\n    - 前端面试\n    - JavaScript\n    - 异步原理\n    - Generator\n---\n\n## 从实际应用场景开始\n假设我们有一个异步的请求，想要去通过api获取一些数据。这里借助`node-fetch`库来获取数据。\n`fetch`可以异步的获取数据，并返回一个promise，所以常规的异步操作和写法，大致如下\n```javascript\nvar fetch = require('node-fetch');\nfetch('http://jasonplacerholder.typecoder.com/posts/1')\n    .then( res => res.json() )\n    .then( post => post.title )\n    .then( x => console.log('Title: ',x))\n```\n\n好了，以上的代码就是一个获取api，并拿到api中的`title`内容。 关于promise这里不多说，fetch返回的就是一个promise。\n\n## genetor实现\n那么如果使用generator会如何实现实现同样的一个异步操作呢？ 这里先给结果，再来分析实现原理。这里记住`co`，这个co是干嘛的，一会分析并实现一个我们自己的co函数。\n\nco接收一个genetor，所以我们可以认为co就是一个generator的发动机，或者自动执行器。\n```javascript\nconst co = require('co');\nco(function *() {\n    const url = 'http://jasonplacerholder.typecoder.com/posts/1';\n    const response = yield fetch(url);\n    const post = yield response.json();\n    const title = post.title;\n    console.log('Title: ',title);\n})\n\n```\n好了，结束，执行后，会输出同样的结果，似乎和promise没有两样。下面先简单的逐行分析，来看看在genetor中，做了什么。\n```\n//从genetor的第一行开始\n第一行： 定义了url\n第二行： 声明response，并将fetch(url)的结果.....yield\nstop...\nWhat is yield???\n```\n嗯，所以，这个genetor的yield是干什么的？这是`genetor`和普通函数的不同之处，也是它可以做异步的基础。不同与普通函数，genetor遇到了`yield`之后，会将yield后面的处理内容抛出。\n\ngenetor: 运行呀---运行呀---运行呀--yield？ What？这是什么鬼，我搞不定，老大你帮我搞定后再加我---out..\n\nouter(执行器co）: 收到yield返回的结果，处理----返回给genetor\n\ngenetor: 收到处理结果---运行---yeild？这又是什么？你帮我搞定，out...\n\nouter(执行器co)： 收到yield返回的promise，处理---返回给genetor\n\n这就是异步的原理了，genetor遇到yield会把任务丢出去，它就暂时不运行了。 我们知道，yield丢出去的是一个iterator，当调用next()的时候，会返回genetor中。 所以其实`co`就是一个自动触发和调度`next()`的函数。\n\n## 实现co\n知道了原理，我们自己来实现这个过程。然后就会比较清除整个过程了。\n\n我们把函数改一下\n```javascript\nrun(function *() {\n    const url = 'http://jasonplacerholder.typecoder.com/posts/1';\n    const response = yield fetch(url);\n    const post = yield response.json();\n    const title = post.title;\n    console.log('Title: ',title);\n})\n\nfunction run(generator) {\n    const iterator = generator(); //genetor执行会返回一个iterator，然后调用next()才会执行到下一个yield\n    iterator.next(); //这里打印出来的结果看一下是{value: Promise {<pending>},done:false}\n\n}\n```\n解释： 就如上面genetor和outer的对话，遇到yield，genetor会说:\"我不知道怎么搞这个promise,你来搞吧，给你..“ 于是，外面的就会接住这个promise\n\n我们继续写\n```javascript\nfunction run(generator) {\n    const iterator = generator(); //genetor执行会返回一个iterator，然后调用next()才会执行到下一个yield\n    const iteration = iterator.next(); //这里打印出来的结果看一下是{value: Promise {<pending>},done:false}\n    const promise = iteration.value;\n    promise.then(x => iterator.next(x)) //ok，外部帮忙处理了promise，然后处理的结果，我们需要返回genetor，使其继续运行\n    //这个时候，genetor中的response拿到了值，就等于这里的x\n}\n```\n分析到这里，程序已经得到了response。 但是，下一句，立马又遇到了response.json()，同样又会丢出去一个内容，因此，我们这里再处理一下，如下：\n```javascript\nfunction run(generator) {\n    const iterator = generator(); //genetor执行会返回一个iterator，然后调用next()才会执行到下一个yield\n    const iteration = iterator.next(); //这里打印出来的结果看一下是{value: Promise {<pending>},done:false}\n    const promise = iteration.value;\n    promise.then(x => {\n        const anotherIterator = iterator.next(x);//注意,iterator.next()的含义，一方面会将运算结果返回，另一方面，genetor会继续将下一个yield的任务抛出，仍然是一个iterator\n        const anotherPromise = anotherIterator.value;\n        anotherPromise.then(post => iterator.next(post))\n        //到此，因为iterator再也没有yield，所以不会再次返回iterator了，也不用调用next()\n    }) \n}\n```\n至此，模拟的`co`方法已经实现了。\n\n流程如下:\n1. run传入一个genetor并运行，获得一个iterator(generator())\n2. 调用next()方法，获取到iteration,iteration的value是`yield fetch(url)`的结果，也即一个Promise。\n3. yield返回出的任务，由外部执行和处理，结束后在返回,于是使用then方法。\n4. 处理后的结果为`x`，调用`iterator.next(x)`把x返回的同时，拿到了下一个`yield`的抛出的任务。\n5. 处理任务，得到`post`，并通过`next(post)`返回给genetor。\n6. 嗯，我拿到你们处理的结果了，下一次我遇到`yield`还给你们，反正我不会，我也不会学，这任务都是你们的。\n\n也就是说，genetor的异步，就在于能将线程弹出，遇到`yield`后，交出线程。所以，我们做一个能够自动执行和触发`genetor`的执行器，就可以实现异步编程，而且看起来和同步的写法很相似。 这就是库`co`做的事情。\n\n### 完善我们自己的`co`\n刚才只有两个`yield`，我们希望方法有通用性，我们写个递归，让它能不断的触发\n```javascript\nfunction run(genetor) {\n    const iterator = genetor();\n    function autoRun(iteration) {\n        if(iteration.done) {return iteration.value;}\n        const anotherPromise = iteration.value;\n        anotherPromise.then(x => {\n            return autoRun(iterator.next(x));\n        })\n    }\n    return autoRun(iterator.next());\n}\n\n```\n\n好了，这样就完成了我们自己的简易版co函数。","slug":"2018-08-28-How-generator-works","published":1,"updated":"2022-08-17T07:53:21.232Z","comments":1,"photos":[],"link":"","_id":"cl6xbhzjv000bzk08dnm1w7mh","content":"<h2 id=\"从实际应用场景开始\"><a href=\"#从实际应用场景开始\" class=\"headerlink\" title=\"从实际应用场景开始\"></a>从实际应用场景开始</h2><p>假设我们有一个异步的请求，想要去通过api获取一些数据。这里借助<code>node-fetch</code>库来获取数据。<br><code>fetch</code>可以异步的获取数据，并返回一个promise，所以常规的异步操作和写法，大致如下<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fetch = <span class=\"built_in\">require</span>(<span class=\"string\">'node-fetch'</span>);</span><br><span class=\"line\">fetch(<span class=\"string\">'http://jasonplacerholder.typecoder.com/posts/1'</span>)</span><br><span class=\"line\">    .then( <span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.json() )</span><br><span class=\"line\">    .then( <span class=\"function\"><span class=\"params\">post</span> =&gt;</span> post.title )</span><br><span class=\"line\">    .then( <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'Title: '</span>,x))</span><br></pre></td></tr></table></figure></p>\n<p>好了，以上的代码就是一个获取api，并拿到api中的<code>title</code>内容。 关于promise这里不多说，fetch返回的就是一个promise。</p>\n<h2 id=\"genetor实现\"><a href=\"#genetor实现\" class=\"headerlink\" title=\"genetor实现\"></a>genetor实现</h2><p>那么如果使用generator会如何实现实现同样的一个异步操作呢？ 这里先给结果，再来分析实现原理。这里记住<code>co</code>，这个co是干嘛的，一会分析并实现一个我们自己的co函数。</p>\n<p>co接收一个genetor，所以我们可以认为co就是一个generator的发动机，或者自动执行器。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> co = <span class=\"built_in\">require</span>(<span class=\"string\">'co'</span>);</span><br><span class=\"line\">co(<span class=\"function\"><span class=\"keyword\">function</span> *(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> url = <span class=\"string\">'http://jasonplacerholder.typecoder.com/posts/1'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">yield</span> fetch(url);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> post = <span class=\"keyword\">yield</span> response.json();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> title = post.title;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Title: '</span>,title);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>好了，结束，执行后，会输出同样的结果，似乎和promise没有两样。下面先简单的逐行分析，来看看在genetor中，做了什么。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//从genetor的第一行开始</span><br><span class=\"line\">第一行： 定义了url</span><br><span class=\"line\">第二行： 声明response，并将fetch(url)的结果.....yield</span><br><span class=\"line\">stop...</span><br><span class=\"line\">What is yield???</span><br></pre></td></tr></table></figure></p>\n<p>嗯，所以，这个genetor的yield是干什么的？这是<code>genetor</code>和普通函数的不同之处，也是它可以做异步的基础。不同与普通函数，genetor遇到了<code>yield</code>之后，会将yield后面的处理内容抛出。</p>\n<p>genetor: 运行呀—运行呀—运行呀–yield？ What？这是什么鬼，我搞不定，老大你帮我搞定后再加我—out..</p>\n<p>outer(执行器co）: 收到yield返回的结果，处理—-返回给genetor</p>\n<p>genetor: 收到处理结果—运行—yeild？这又是什么？你帮我搞定，out…</p>\n<p>outer(执行器co)： 收到yield返回的promise，处理—返回给genetor</p>\n<p>这就是异步的原理了，genetor遇到yield会把任务丢出去，它就暂时不运行了。 我们知道，yield丢出去的是一个iterator，当调用next()的时候，会返回genetor中。 所以其实<code>co</code>就是一个自动触发和调度<code>next()</code>的函数。</p>\n<h2 id=\"实现co\"><a href=\"#实现co\" class=\"headerlink\" title=\"实现co\"></a>实现co</h2><p>知道了原理，我们自己来实现这个过程。然后就会比较清除整个过程了。</p>\n<p>我们把函数改一下<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">run(<span class=\"function\"><span class=\"keyword\">function</span> *(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> url = <span class=\"string\">'http://jasonplacerholder.typecoder.com/posts/1'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">yield</span> fetch(url);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> post = <span class=\"keyword\">yield</span> response.json();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> title = post.title;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Title: '</span>,title);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\">generator</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> iterator = generator(); <span class=\"comment\">//genetor执行会返回一个iterator，然后调用next()才会执行到下一个yield</span></span><br><span class=\"line\">    iterator.next(); <span class=\"comment\">//这里打印出来的结果看一下是&#123;value: Promise &#123;&lt;pending&gt;&#125;,done:false&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>解释： 就如上面genetor和outer的对话，遇到yield，genetor会说:”我不知道怎么搞这个promise,你来搞吧，给你..“ 于是，外面的就会接住这个promise</p>\n<p>我们继续写<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\">generator</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> iterator = generator(); <span class=\"comment\">//genetor执行会返回一个iterator，然后调用next()才会执行到下一个yield</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> iteration = iterator.next(); <span class=\"comment\">//这里打印出来的结果看一下是&#123;value: Promise &#123;&lt;pending&gt;&#125;,done:false&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> promise = iteration.value;</span><br><span class=\"line\">    promise.then(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> iterator.next(x)) <span class=\"comment\">//ok，外部帮忙处理了promise，然后处理的结果，我们需要返回genetor，使其继续运行</span></span><br><span class=\"line\">    <span class=\"comment\">//这个时候，genetor中的response拿到了值，就等于这里的x</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>分析到这里，程序已经得到了response。 但是，下一句，立马又遇到了response.json()，同样又会丢出去一个内容，因此，我们这里再处理一下，如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\">generator</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> iterator = generator(); <span class=\"comment\">//genetor执行会返回一个iterator，然后调用next()才会执行到下一个yield</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> iteration = iterator.next(); <span class=\"comment\">//这里打印出来的结果看一下是&#123;value: Promise &#123;&lt;pending&gt;&#125;,done:false&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> promise = iteration.value;</span><br><span class=\"line\">    promise.then(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> anotherIterator = iterator.next(x);<span class=\"comment\">//注意,iterator.next()的含义，一方面会将运算结果返回，另一方面，genetor会继续将下一个yield的任务抛出，仍然是一个iterator</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> anotherPromise = anotherIterator.value;</span><br><span class=\"line\">        anotherPromise.then(<span class=\"function\"><span class=\"params\">post</span> =&gt;</span> iterator.next(post))</span><br><span class=\"line\">        <span class=\"comment\">//到此，因为iterator再也没有yield，所以不会再次返回iterator了，也不用调用next()</span></span><br><span class=\"line\">    &#125;) </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>至此，模拟的<code>co</code>方法已经实现了。</p>\n<p>流程如下:</p>\n<ol>\n<li>run传入一个genetor并运行，获得一个iterator(generator())</li>\n<li>调用next()方法，获取到iteration,iteration的value是<code>yield fetch(url)</code>的结果，也即一个Promise。</li>\n<li>yield返回出的任务，由外部执行和处理，结束后在返回,于是使用then方法。</li>\n<li>处理后的结果为<code>x</code>，调用<code>iterator.next(x)</code>把x返回的同时，拿到了下一个<code>yield</code>的抛出的任务。</li>\n<li>处理任务，得到<code>post</code>，并通过<code>next(post)</code>返回给genetor。</li>\n<li>嗯，我拿到你们处理的结果了，下一次我遇到<code>yield</code>还给你们，反正我不会，我也不会学，这任务都是你们的。</li>\n</ol>\n<p>也就是说，genetor的异步，就在于能将线程弹出，遇到<code>yield</code>后，交出线程。所以，我们做一个能够自动执行和触发<code>genetor</code>的执行器，就可以实现异步编程，而且看起来和同步的写法很相似。 这就是库<code>co</code>做的事情。</p>\n<h3 id=\"完善我们自己的co\"><a href=\"#完善我们自己的co\" class=\"headerlink\" title=\"完善我们自己的co\"></a>完善我们自己的<code>co</code></h3><p>刚才只有两个<code>yield</code>，我们希望方法有通用性，我们写个递归，让它能不断的触发<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\">genetor</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> iterator = genetor();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">autoRun</span>(<span class=\"params\">iteration</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(iteration.done) &#123;<span class=\"keyword\">return</span> iteration.value;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> anotherPromise = iteration.value;</span><br><span class=\"line\">        anotherPromise.then(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> autoRun(iterator.next(x));</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> autoRun(iterator.next());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>好了，这样就完成了我们自己的简易版co函数。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"从实际应用场景开始\"><a href=\"#从实际应用场景开始\" class=\"headerlink\" title=\"从实际应用场景开始\"></a>从实际应用场景开始</h2><p>假设我们有一个异步的请求，想要去通过api获取一些数据。这里借助<code>node-fetch</code>库来获取数据。<br><code>fetch</code>可以异步的获取数据，并返回一个promise，所以常规的异步操作和写法，大致如下<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fetch = <span class=\"built_in\">require</span>(<span class=\"string\">'node-fetch'</span>);</span><br><span class=\"line\">fetch(<span class=\"string\">'http://jasonplacerholder.typecoder.com/posts/1'</span>)</span><br><span class=\"line\">    .then( <span class=\"function\"><span class=\"params\">res</span> =&gt;</span> res.json() )</span><br><span class=\"line\">    .then( <span class=\"function\"><span class=\"params\">post</span> =&gt;</span> post.title )</span><br><span class=\"line\">    .then( <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'Title: '</span>,x))</span><br></pre></td></tr></table></figure></p>\n<p>好了，以上的代码就是一个获取api，并拿到api中的<code>title</code>内容。 关于promise这里不多说，fetch返回的就是一个promise。</p>\n<h2 id=\"genetor实现\"><a href=\"#genetor实现\" class=\"headerlink\" title=\"genetor实现\"></a>genetor实现</h2><p>那么如果使用generator会如何实现实现同样的一个异步操作呢？ 这里先给结果，再来分析实现原理。这里记住<code>co</code>，这个co是干嘛的，一会分析并实现一个我们自己的co函数。</p>\n<p>co接收一个genetor，所以我们可以认为co就是一个generator的发动机，或者自动执行器。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> co = <span class=\"built_in\">require</span>(<span class=\"string\">'co'</span>);</span><br><span class=\"line\">co(<span class=\"function\"><span class=\"keyword\">function</span> *(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> url = <span class=\"string\">'http://jasonplacerholder.typecoder.com/posts/1'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">yield</span> fetch(url);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> post = <span class=\"keyword\">yield</span> response.json();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> title = post.title;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Title: '</span>,title);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>好了，结束，执行后，会输出同样的结果，似乎和promise没有两样。下面先简单的逐行分析，来看看在genetor中，做了什么。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//从genetor的第一行开始</span><br><span class=\"line\">第一行： 定义了url</span><br><span class=\"line\">第二行： 声明response，并将fetch(url)的结果.....yield</span><br><span class=\"line\">stop...</span><br><span class=\"line\">What is yield???</span><br></pre></td></tr></table></figure></p>\n<p>嗯，所以，这个genetor的yield是干什么的？这是<code>genetor</code>和普通函数的不同之处，也是它可以做异步的基础。不同与普通函数，genetor遇到了<code>yield</code>之后，会将yield后面的处理内容抛出。</p>\n<p>genetor: 运行呀—运行呀—运行呀–yield？ What？这是什么鬼，我搞不定，老大你帮我搞定后再加我—out..</p>\n<p>outer(执行器co）: 收到yield返回的结果，处理—-返回给genetor</p>\n<p>genetor: 收到处理结果—运行—yeild？这又是什么？你帮我搞定，out…</p>\n<p>outer(执行器co)： 收到yield返回的promise，处理—返回给genetor</p>\n<p>这就是异步的原理了，genetor遇到yield会把任务丢出去，它就暂时不运行了。 我们知道，yield丢出去的是一个iterator，当调用next()的时候，会返回genetor中。 所以其实<code>co</code>就是一个自动触发和调度<code>next()</code>的函数。</p>\n<h2 id=\"实现co\"><a href=\"#实现co\" class=\"headerlink\" title=\"实现co\"></a>实现co</h2><p>知道了原理，我们自己来实现这个过程。然后就会比较清除整个过程了。</p>\n<p>我们把函数改一下<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">run(<span class=\"function\"><span class=\"keyword\">function</span> *(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> url = <span class=\"string\">'http://jasonplacerholder.typecoder.com/posts/1'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">yield</span> fetch(url);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> post = <span class=\"keyword\">yield</span> response.json();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> title = post.title;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Title: '</span>,title);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\">generator</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> iterator = generator(); <span class=\"comment\">//genetor执行会返回一个iterator，然后调用next()才会执行到下一个yield</span></span><br><span class=\"line\">    iterator.next(); <span class=\"comment\">//这里打印出来的结果看一下是&#123;value: Promise &#123;&lt;pending&gt;&#125;,done:false&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>解释： 就如上面genetor和outer的对话，遇到yield，genetor会说:”我不知道怎么搞这个promise,你来搞吧，给你..“ 于是，外面的就会接住这个promise</p>\n<p>我们继续写<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\">generator</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> iterator = generator(); <span class=\"comment\">//genetor执行会返回一个iterator，然后调用next()才会执行到下一个yield</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> iteration = iterator.next(); <span class=\"comment\">//这里打印出来的结果看一下是&#123;value: Promise &#123;&lt;pending&gt;&#125;,done:false&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> promise = iteration.value;</span><br><span class=\"line\">    promise.then(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> iterator.next(x)) <span class=\"comment\">//ok，外部帮忙处理了promise，然后处理的结果，我们需要返回genetor，使其继续运行</span></span><br><span class=\"line\">    <span class=\"comment\">//这个时候，genetor中的response拿到了值，就等于这里的x</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>分析到这里，程序已经得到了response。 但是，下一句，立马又遇到了response.json()，同样又会丢出去一个内容，因此，我们这里再处理一下，如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\">generator</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> iterator = generator(); <span class=\"comment\">//genetor执行会返回一个iterator，然后调用next()才会执行到下一个yield</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> iteration = iterator.next(); <span class=\"comment\">//这里打印出来的结果看一下是&#123;value: Promise &#123;&lt;pending&gt;&#125;,done:false&#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> promise = iteration.value;</span><br><span class=\"line\">    promise.then(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> anotherIterator = iterator.next(x);<span class=\"comment\">//注意,iterator.next()的含义，一方面会将运算结果返回，另一方面，genetor会继续将下一个yield的任务抛出，仍然是一个iterator</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> anotherPromise = anotherIterator.value;</span><br><span class=\"line\">        anotherPromise.then(<span class=\"function\"><span class=\"params\">post</span> =&gt;</span> iterator.next(post))</span><br><span class=\"line\">        <span class=\"comment\">//到此，因为iterator再也没有yield，所以不会再次返回iterator了，也不用调用next()</span></span><br><span class=\"line\">    &#125;) </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>至此，模拟的<code>co</code>方法已经实现了。</p>\n<p>流程如下:</p>\n<ol>\n<li>run传入一个genetor并运行，获得一个iterator(generator())</li>\n<li>调用next()方法，获取到iteration,iteration的value是<code>yield fetch(url)</code>的结果，也即一个Promise。</li>\n<li>yield返回出的任务，由外部执行和处理，结束后在返回,于是使用then方法。</li>\n<li>处理后的结果为<code>x</code>，调用<code>iterator.next(x)</code>把x返回的同时，拿到了下一个<code>yield</code>的抛出的任务。</li>\n<li>处理任务，得到<code>post</code>，并通过<code>next(post)</code>返回给genetor。</li>\n<li>嗯，我拿到你们处理的结果了，下一次我遇到<code>yield</code>还给你们，反正我不会，我也不会学，这任务都是你们的。</li>\n</ol>\n<p>也就是说，genetor的异步，就在于能将线程弹出，遇到<code>yield</code>后，交出线程。所以，我们做一个能够自动执行和触发<code>genetor</code>的执行器，就可以实现异步编程，而且看起来和同步的写法很相似。 这就是库<code>co</code>做的事情。</p>\n<h3 id=\"完善我们自己的co\"><a href=\"#完善我们自己的co\" class=\"headerlink\" title=\"完善我们自己的co\"></a>完善我们自己的<code>co</code></h3><p>刚才只有两个<code>yield</code>，我们希望方法有通用性，我们写个递归，让它能不断的触发<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\">genetor</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> iterator = genetor();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">autoRun</span>(<span class=\"params\">iteration</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(iteration.done) &#123;<span class=\"keyword\">return</span> iteration.value;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> anotherPromise = iteration.value;</span><br><span class=\"line\">        anotherPromise.then(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> autoRun(iterator.next(x));</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> autoRun(iterator.next());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>好了，这样就完成了我们自己的简易版co函数。</p>\n"},{"layout":"post","title":"JS事件机制之Microtasks & Tasks & Queues","subtitle":"Tasks, microtasks, queues and schedules","date":"2018-09-04T05:00:00.000Z","author":"Vinecnt Ko","header-img":"img/post-bg-js-version.jpg","header-mask":0.3,"catalog":true,"_content":"\n> 面试和笔试题目中，经常会出现'promise','setTimeout'等函数混合出现时候的运行顺序问题。 我们都知道这些异步的方法会在当前任务执行结束之后调用，但为什么'promise'会在'setTimeout'之前执行？ 具体的实现原理是什么？\n\n## 问题的提出\n上面问题的答案，都在文章[《Tasks, microtasks, queues and schedules》](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly)讲的非常透彻。 建议英文可以的同学直接看这篇文章，就不要看我这个“笔记”了。( *之所以叫笔记，因为大部分内容出自文章，但是又不是按字翻译* )\n\n以下的题目是我们刷题可以经常看到的一个常规题目：\n```javascript\nconsole.log('script start');\n\nsetTimeout(function() {\n  console.log('setTimeout');\n}, 0);\n\nPromise.resolve().then(function() {\n  console.log('promise1');\n}).then(function() {\n  console.log('promise2');\n});\n\nconsole.log('script end');\n```\n\n几乎每个前端er都可以毫不犹豫的给出答案:\n```javascript\nscript start\nscript end\npromise1\npromise2\nsetTimeout\n```\n问题来了，为什么`promise`的异步执行会在`setTimeout`之前，甚至`setTimeout`设置的延时是0都不行。 还有在Vue中，我们常用的nextTick()函数原理中，说的microtasks是什么东西？ 一切的解释都在开头给的文章中。 \n\nps： 再次再次声明，这篇文章仍然是我记得笔记，原文比我写的好得多，英文可以的小伙伴强烈推荐看原文。\n\n## js异步实现原理\n我们多多少少都应该听说过event loop，js是单线程的，通过异步它变得非常强大，而实现异步主要就是通过将异步的内容压入tasks，当前任务执行结束之后，再执行tasks中的callback。\n\n**Tasks**，是一个任务队列，Js在执行同步任务的时候，只要遇到了异步执行和函数，都会把这个内容压入Tasks中，然后在当前同步任务完成后，再去Tasks中执行相应的回调。 举个例子，比如刚才代码中的`setTimeout`，当遇到这个函数，总会跟一个异步执行的任务(callback)，那么这个时候，Tasks队列里，除了当前正在执行的script之外，会在后面压入一个`setTimeout callback`， 而这个callback的调用时机，就是在当前同步任务完成之后，才会调用。这就是为什么,'setTimeout' 会出现在'script end'之后了。\n\n**MicroTasks**，说一些这个，这个和`setTimeout`不同，因为它是在当前Task完成后，就立即执行的，或者可以理解成，'microTasks总是在当前任务的最后执行'。  另外，还有一个非常重要的特性是： **如果当前JS stack如果为空的时候(比如我们绑定了click事件后，等待和监听click时间的时候，JS stack就是空的),一会立即执行。** 关于这一点，之后有个例子会具体说明，先往下看。\n\n那么MicroTasks队列主要是promise和mutation observer 的回掉函数生成\n\n### 用新的理论来解释下\n好了，刚才大概说了几个概念，那么一开始的例子，到底发生了什么？\n\n`talk is cheap, show me a animation!!`---我自己说的\n\n下面的[动画](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly)说明对整个过程进行了说明:\n\n![原文中的动态演示](https://user-gold-cdn.xitu.io/2018/8/5/1650827c4eb4d2a5?w=420&h=306&f=gif&s=441671)\n\n1、 程序执行  `log: script start`\n* Tasks: Run script\n* JS stack: script\n\n2、 遇到setTimeout  `log: script start `\n* Tasks： Run script | setTimeout callback\n* JS stack: script\n\n3、 遇到Promise\n* Tasks: Run script | setTimeout callback\n* Microtasks: promise then\n* JS stack: script\n\n4、 执行最后一行 `log: script start | script end `\n* Tasks: Run script | setTimeout callback\n* Microtasks: promise then\n* JS stack: script\n\n4、 同步任务执行完毕，弹出相应的stack `log: script start | script end `\n* Tasks: Run script | setTimeout callback\n* Microtasks: promise then\n* JS stack:\n\n5、 同步任务最后是microTasks，JS stack压入callback `log: script start | script end | promise1`\n* Tasks: Run script | setTimeout callback\n* Microtasks: promise then | promise then\n* JS stack: promise1 calback\n6、 promise返回新的promise，压入microTasks，继续执行 `log: script start | script end | promise1 | promise2`\n* Tasks: Run script | setTimeout callback\n* Microtasks:  promise then\n* JS stack: promise2 calback\n\n8、 第一个Tasks结束,弹出 `log: script start | script end | promise1 | promise2`\n* Tasks: setTimeout callback\n* Microtasks:\n* JS stack:\n\n9、 下一个Tasks `log: script start | script end | promise1 | promise2 | setTimeout`\n* Tasks: setTimeout callback\n* Microtasks:\n* JS stack: setTimeout callback\n\n\n好了，结束了，这就比之前的理解\"promise比setTimeout快，异步先执行promise，再执行setTimeout\"就深刻的多。 因为promise所建立的回掉函数是压入了`mircroTasks`队列中，它仍然属于当前的Task，而`setTimeout`则是相当于在Task序列中添加了新的任务\n\n## 一个更复杂的例子\n好了，有了刚才的认识和铺垫，接下来通过一个更加复杂的例子来熟悉JS事件处理的一个过程。\n\n现在有这样一个页面结构：\n```html\n<div class=\"outer\">\n  <div class=\"inner\"></div>\n</div>\n\n```\n\n![](https://user-gold-cdn.xitu.io/2018/8/5/1650914100613dfd?w=225&h=194&f=png&s=1245)\njs代码如下,现在如果点击里面的方块，控制台会输出什么呢？[在线实例](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly)\n```javascript\n// Let's get hold of those elements\nvar outer = document.querySelector('.outer');\nvar inner = document.querySelector('.inner');\n\n// Let's listen for attribute changes on the\n// outer element\nnew MutationObserver(function() {\n  console.log('mutate');\n}).observe(outer, {\n  attributes: true\n});\n\n// Here's a click listener…\nfunction onClick() {\n  console.log('click');\n\n  setTimeout(function() {\n    console.log('timeout');\n  }, 0);\n\n  Promise.resolve().then(function() {\n    console.log('promise');\n  });\n\n  outer.setAttribute('data-random', Math.random());\n}\n\n// …which we'll attach to both elements\ninner.addEventListener('click', onClick);\nouter.addEventListener('click', onClick);\n```\n\n这里先把正确答案公布，按照之前的理论，正确答案应该是：\n```javascript\nclick\npromise\nmutate\nclick\npromise\nmutate\ntimeout\ntimeout\n```\n当然，不同浏览器，对于event loop的实现会稍有不同，这个是chrome下打印出来的结果，具体的其他形式还是推荐大家看原文了。\n\n下面分析下，为什么是上面的顺序呢？\n\n### 代码分析\n按照刚才的结论：\n\nclick事件显然是一个Task，Mutation observer和Promise是在microTasks队列中的，而setTimeout会被安排在Tasks之中。 因此\n\n1、点击事件触发\n* Tasks: Dispatch click\n* Microtasks: \n* JS stack:\n\n2、触发点击事件的函数，函数执行，压入JS stack\n* Tasks: Dispatch click\n* Microtasks: \n* JS stack: onClick\n* Log: 'click'\n\n3、遇到setTimeout，压入Tasks队列\n* Tasks: Dispatch click | setTimeout callBack\n* Microtasks: \n* JS stack: onClick\n* Log: 'click'\n\n4、遇到promise，压入Microtasks\n* Tasks: Dispatch click | setTimeout callBack\n* Microtasks: Promise.then\n* JS stack: onClick\n* Log: 'click'\n\n5、遇到 outer.setAttribute，触发mutation\n* Tasks: Dispatch click | setTimeout callBack\n* Microtasks: Promise.then | Mutation observers\n* JS stack: onClick\n* Log: 'click'\n\n6、onclick函数执行完毕，出JS stack\n* Tasks: Dispatch click | setTimeout callBack\n* Microtasks: Promise.then | Mutation observers\n* JS stack:\n* Log: 'click'\n\n7、这个时候，JS stack为空，执行Microtasks\n* Tasks: Dispatch click | setTimeout callBack\n* Microtasks: Promise.then | Mutation observers\n* JS stack: PromiseCallback\n* Log: 'click' 'promise'\n\n8、microtasks顺序执行\n* Tasks: Dispatch click | setTimeout callBack\n* Microtasks:  Mutation observers\n* JS stack: Mutation callback\n* Log: 'click' 'promise' 'mutate'\n\n接下来是重点，当microtasks为空，该执行下一个Tasks(setTimeout)了吗？并没有，因为js事件流中的冒泡被触发，也就是在外面的一层Div也会触发click函数，因此我们把刚才的步骤再走一遍。\n\n过程省略，结果为\n9、冒泡走一遍的结果为\n* Tasks: Dispatch click | setTimeout callBack | setTmeout callback(outer)\n* Microtasks:  Mutation observers\n* JS stack: Mutation callback\n* Log: `click` `promise` `mutate` `click`  `promise` `mutate` \n\n10、 第一个Tasks完成，出栈\n* Tasks: setTimeout callBack | setTmeout callback(outer)\n* Microtasks: \n* JS stack: setTimeout callback\n* Log: `click` `promise` `mutate` `click`  `promise` `mutate` `timeout`\n\n11、 第二个Tasks完成，出栈\n* Tasks: setTmeout callback(outer)\n* Microtasks: \n* JS stack: setTimeout(outer) callback\n* Log: `click` `promise` `mutate` `click`  `promise` `mutate` `timeout` `timeout`\n\n\n结束了\n\n所以这里的重点是什么？ 是**MicroTasks的执行时机： 见缝插针，它不一定就必须在Tasks的最后，只要JS stack为空，就可以执行**  这条规则出处在\n\n>If the stack of script settings objects is now empty, perform a microtask checkpoint                \n— HTML: Cleaning up after a callback step 3\n\n另一方面，ECMA也对此有过说明\n>Execution of a Job can be initiated only when there is no running execution context and the execution context stack is empty…                                     \n   — ECMAScript: Jobs and Job Queues\n\n**但是对于其他浏览器(firefox  safari ie)同样的代码，得出的结果是不同的哦。关键在于，对与 `job`和`microTasks`之间的一个联系是很模糊的。  但是我们就按照Chrome的实现来理解吧。**\n ### 最后一关\n\n 还是刚才那道题，只不过，我不用鼠标点击了，而是直接执行函数\n\n ```javascirpt\n inner.click()\n ```\n 如果这样，结果会一样吗？\n\n 答案是:\n ```javascript\n click\n click\n promise\n mutate\n promise\n timeout \n timeout\n ```\n\n What！！？？我怎么感觉我白学了？ 不着急，看下这次的过程是这样的，首先最大的不同在于，我们在函数最底部加了一个执行`inner.click()`，这样子，这个函数执行的过程，都是同步序列里的，所以这次的task的起点就在Run scripts:\n\n1、不同与鼠标点击，我们执行函数后，进入函数内部执行\n* Tasks: Run scripts\n* Microtasks: \n* JS stack: script | onClick\n* Log: `click`\n\n2、遇到setTimeout和promise&mutation\n* Tasks: Run scripts | setTimeout callback\n* Microtasks: Promise.then | Mutation Observers\n* JS stack: script | onClick\n* Log: `click`\n\n3、接下来关键，冒泡的时候，因为我们并没有执行完当前的script,还在`inner.click()`这个函数执行之中，因此当`onclick`结束，开始冒泡时，script并没有结束\n* Tasks: Run scripts | setTimeout callback\n* Microtasks: Promise.then | Mutation Observers\n* JS stack: script | onClick(这是冒泡的click，第一次click已经结束)\n* Log: `click` `click` \n\n4、冒泡阶段重复之前内容\n* Tasks: Run scripts | setTimeout callback |setTimeout callback(outer)\n* Microtasks: Promise.then | Mutation Observers |promise.then\n* JS stack: script | onClick(这是冒泡的click，第一次click已经结束)\n* Log: `click` `click`\n\n注意第二次没有增加mutation，因为已经有一个在渲染的了\n\n5、inner.click()执行完毕,执行Microtasks\n* Tasks: Run scripts | setTimeout callback |setTimeout callback(outer)\n* Microtasks: Promise.then | Mutation Observers |promise.then\n* JS stack: \n* Log: `click` `click` `promise`\n\n6、按理论执行\n* Tasks: Run scripts | setTimeout callback |setTimeout callback(outer)\n* Microtasks: Mutation Observers |promise.then\n* JS stack: \n* Log: `click` `click` `promise` `mutate`....\n\n后面的就不解释了，Microtasks依次出栈，接着Tasks顺序执行。\n\n## 总结\n\nJake老师的文章，对这个的解析和深入实在令人佩服，我也在面试中因把event loop解释的较为详尽而被面试官肯定，所以如果对异步以及event loop有疑惑的，可以好好的消化下这个内容，一起进步!\n","source":"_posts/2018-09-04-Tasks, microtasks, queues and schedules.md","raw":"---\nlayout:     post\ntitle:      \"JS事件机制之Microtasks & Tasks & Queues\"\nsubtitle:   \"Tasks, microtasks, queues and schedules\"\ndate:       2018-09-04 13:00:00\nauthor:     \"Vinecnt Ko\"\nheader-img: \"img/post-bg-js-version.jpg\"\nheader-mask: 0.3\ncatalog:    true\ntags:\n    - 前端面试\n    - JavaScript\n    - JS Event\n---\n\n> 面试和笔试题目中，经常会出现'promise','setTimeout'等函数混合出现时候的运行顺序问题。 我们都知道这些异步的方法会在当前任务执行结束之后调用，但为什么'promise'会在'setTimeout'之前执行？ 具体的实现原理是什么？\n\n## 问题的提出\n上面问题的答案，都在文章[《Tasks, microtasks, queues and schedules》](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly)讲的非常透彻。 建议英文可以的同学直接看这篇文章，就不要看我这个“笔记”了。( *之所以叫笔记，因为大部分内容出自文章，但是又不是按字翻译* )\n\n以下的题目是我们刷题可以经常看到的一个常规题目：\n```javascript\nconsole.log('script start');\n\nsetTimeout(function() {\n  console.log('setTimeout');\n}, 0);\n\nPromise.resolve().then(function() {\n  console.log('promise1');\n}).then(function() {\n  console.log('promise2');\n});\n\nconsole.log('script end');\n```\n\n几乎每个前端er都可以毫不犹豫的给出答案:\n```javascript\nscript start\nscript end\npromise1\npromise2\nsetTimeout\n```\n问题来了，为什么`promise`的异步执行会在`setTimeout`之前，甚至`setTimeout`设置的延时是0都不行。 还有在Vue中，我们常用的nextTick()函数原理中，说的microtasks是什么东西？ 一切的解释都在开头给的文章中。 \n\nps： 再次再次声明，这篇文章仍然是我记得笔记，原文比我写的好得多，英文可以的小伙伴强烈推荐看原文。\n\n## js异步实现原理\n我们多多少少都应该听说过event loop，js是单线程的，通过异步它变得非常强大，而实现异步主要就是通过将异步的内容压入tasks，当前任务执行结束之后，再执行tasks中的callback。\n\n**Tasks**，是一个任务队列，Js在执行同步任务的时候，只要遇到了异步执行和函数，都会把这个内容压入Tasks中，然后在当前同步任务完成后，再去Tasks中执行相应的回调。 举个例子，比如刚才代码中的`setTimeout`，当遇到这个函数，总会跟一个异步执行的任务(callback)，那么这个时候，Tasks队列里，除了当前正在执行的script之外，会在后面压入一个`setTimeout callback`， 而这个callback的调用时机，就是在当前同步任务完成之后，才会调用。这就是为什么,'setTimeout' 会出现在'script end'之后了。\n\n**MicroTasks**，说一些这个，这个和`setTimeout`不同，因为它是在当前Task完成后，就立即执行的，或者可以理解成，'microTasks总是在当前任务的最后执行'。  另外，还有一个非常重要的特性是： **如果当前JS stack如果为空的时候(比如我们绑定了click事件后，等待和监听click时间的时候，JS stack就是空的),一会立即执行。** 关于这一点，之后有个例子会具体说明，先往下看。\n\n那么MicroTasks队列主要是promise和mutation observer 的回掉函数生成\n\n### 用新的理论来解释下\n好了，刚才大概说了几个概念，那么一开始的例子，到底发生了什么？\n\n`talk is cheap, show me a animation!!`---我自己说的\n\n下面的[动画](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly)说明对整个过程进行了说明:\n\n![原文中的动态演示](https://user-gold-cdn.xitu.io/2018/8/5/1650827c4eb4d2a5?w=420&h=306&f=gif&s=441671)\n\n1、 程序执行  `log: script start`\n* Tasks: Run script\n* JS stack: script\n\n2、 遇到setTimeout  `log: script start `\n* Tasks： Run script | setTimeout callback\n* JS stack: script\n\n3、 遇到Promise\n* Tasks: Run script | setTimeout callback\n* Microtasks: promise then\n* JS stack: script\n\n4、 执行最后一行 `log: script start | script end `\n* Tasks: Run script | setTimeout callback\n* Microtasks: promise then\n* JS stack: script\n\n4、 同步任务执行完毕，弹出相应的stack `log: script start | script end `\n* Tasks: Run script | setTimeout callback\n* Microtasks: promise then\n* JS stack:\n\n5、 同步任务最后是microTasks，JS stack压入callback `log: script start | script end | promise1`\n* Tasks: Run script | setTimeout callback\n* Microtasks: promise then | promise then\n* JS stack: promise1 calback\n6、 promise返回新的promise，压入microTasks，继续执行 `log: script start | script end | promise1 | promise2`\n* Tasks: Run script | setTimeout callback\n* Microtasks:  promise then\n* JS stack: promise2 calback\n\n8、 第一个Tasks结束,弹出 `log: script start | script end | promise1 | promise2`\n* Tasks: setTimeout callback\n* Microtasks:\n* JS stack:\n\n9、 下一个Tasks `log: script start | script end | promise1 | promise2 | setTimeout`\n* Tasks: setTimeout callback\n* Microtasks:\n* JS stack: setTimeout callback\n\n\n好了，结束了，这就比之前的理解\"promise比setTimeout快，异步先执行promise，再执行setTimeout\"就深刻的多。 因为promise所建立的回掉函数是压入了`mircroTasks`队列中，它仍然属于当前的Task，而`setTimeout`则是相当于在Task序列中添加了新的任务\n\n## 一个更复杂的例子\n好了，有了刚才的认识和铺垫，接下来通过一个更加复杂的例子来熟悉JS事件处理的一个过程。\n\n现在有这样一个页面结构：\n```html\n<div class=\"outer\">\n  <div class=\"inner\"></div>\n</div>\n\n```\n\n![](https://user-gold-cdn.xitu.io/2018/8/5/1650914100613dfd?w=225&h=194&f=png&s=1245)\njs代码如下,现在如果点击里面的方块，控制台会输出什么呢？[在线实例](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly)\n```javascript\n// Let's get hold of those elements\nvar outer = document.querySelector('.outer');\nvar inner = document.querySelector('.inner');\n\n// Let's listen for attribute changes on the\n// outer element\nnew MutationObserver(function() {\n  console.log('mutate');\n}).observe(outer, {\n  attributes: true\n});\n\n// Here's a click listener…\nfunction onClick() {\n  console.log('click');\n\n  setTimeout(function() {\n    console.log('timeout');\n  }, 0);\n\n  Promise.resolve().then(function() {\n    console.log('promise');\n  });\n\n  outer.setAttribute('data-random', Math.random());\n}\n\n// …which we'll attach to both elements\ninner.addEventListener('click', onClick);\nouter.addEventListener('click', onClick);\n```\n\n这里先把正确答案公布，按照之前的理论，正确答案应该是：\n```javascript\nclick\npromise\nmutate\nclick\npromise\nmutate\ntimeout\ntimeout\n```\n当然，不同浏览器，对于event loop的实现会稍有不同，这个是chrome下打印出来的结果，具体的其他形式还是推荐大家看原文了。\n\n下面分析下，为什么是上面的顺序呢？\n\n### 代码分析\n按照刚才的结论：\n\nclick事件显然是一个Task，Mutation observer和Promise是在microTasks队列中的，而setTimeout会被安排在Tasks之中。 因此\n\n1、点击事件触发\n* Tasks: Dispatch click\n* Microtasks: \n* JS stack:\n\n2、触发点击事件的函数，函数执行，压入JS stack\n* Tasks: Dispatch click\n* Microtasks: \n* JS stack: onClick\n* Log: 'click'\n\n3、遇到setTimeout，压入Tasks队列\n* Tasks: Dispatch click | setTimeout callBack\n* Microtasks: \n* JS stack: onClick\n* Log: 'click'\n\n4、遇到promise，压入Microtasks\n* Tasks: Dispatch click | setTimeout callBack\n* Microtasks: Promise.then\n* JS stack: onClick\n* Log: 'click'\n\n5、遇到 outer.setAttribute，触发mutation\n* Tasks: Dispatch click | setTimeout callBack\n* Microtasks: Promise.then | Mutation observers\n* JS stack: onClick\n* Log: 'click'\n\n6、onclick函数执行完毕，出JS stack\n* Tasks: Dispatch click | setTimeout callBack\n* Microtasks: Promise.then | Mutation observers\n* JS stack:\n* Log: 'click'\n\n7、这个时候，JS stack为空，执行Microtasks\n* Tasks: Dispatch click | setTimeout callBack\n* Microtasks: Promise.then | Mutation observers\n* JS stack: PromiseCallback\n* Log: 'click' 'promise'\n\n8、microtasks顺序执行\n* Tasks: Dispatch click | setTimeout callBack\n* Microtasks:  Mutation observers\n* JS stack: Mutation callback\n* Log: 'click' 'promise' 'mutate'\n\n接下来是重点，当microtasks为空，该执行下一个Tasks(setTimeout)了吗？并没有，因为js事件流中的冒泡被触发，也就是在外面的一层Div也会触发click函数，因此我们把刚才的步骤再走一遍。\n\n过程省略，结果为\n9、冒泡走一遍的结果为\n* Tasks: Dispatch click | setTimeout callBack | setTmeout callback(outer)\n* Microtasks:  Mutation observers\n* JS stack: Mutation callback\n* Log: `click` `promise` `mutate` `click`  `promise` `mutate` \n\n10、 第一个Tasks完成，出栈\n* Tasks: setTimeout callBack | setTmeout callback(outer)\n* Microtasks: \n* JS stack: setTimeout callback\n* Log: `click` `promise` `mutate` `click`  `promise` `mutate` `timeout`\n\n11、 第二个Tasks完成，出栈\n* Tasks: setTmeout callback(outer)\n* Microtasks: \n* JS stack: setTimeout(outer) callback\n* Log: `click` `promise` `mutate` `click`  `promise` `mutate` `timeout` `timeout`\n\n\n结束了\n\n所以这里的重点是什么？ 是**MicroTasks的执行时机： 见缝插针，它不一定就必须在Tasks的最后，只要JS stack为空，就可以执行**  这条规则出处在\n\n>If the stack of script settings objects is now empty, perform a microtask checkpoint                \n— HTML: Cleaning up after a callback step 3\n\n另一方面，ECMA也对此有过说明\n>Execution of a Job can be initiated only when there is no running execution context and the execution context stack is empty…                                     \n   — ECMAScript: Jobs and Job Queues\n\n**但是对于其他浏览器(firefox  safari ie)同样的代码，得出的结果是不同的哦。关键在于，对与 `job`和`microTasks`之间的一个联系是很模糊的。  但是我们就按照Chrome的实现来理解吧。**\n ### 最后一关\n\n 还是刚才那道题，只不过，我不用鼠标点击了，而是直接执行函数\n\n ```javascirpt\n inner.click()\n ```\n 如果这样，结果会一样吗？\n\n 答案是:\n ```javascript\n click\n click\n promise\n mutate\n promise\n timeout \n timeout\n ```\n\n What！！？？我怎么感觉我白学了？ 不着急，看下这次的过程是这样的，首先最大的不同在于，我们在函数最底部加了一个执行`inner.click()`，这样子，这个函数执行的过程，都是同步序列里的，所以这次的task的起点就在Run scripts:\n\n1、不同与鼠标点击，我们执行函数后，进入函数内部执行\n* Tasks: Run scripts\n* Microtasks: \n* JS stack: script | onClick\n* Log: `click`\n\n2、遇到setTimeout和promise&mutation\n* Tasks: Run scripts | setTimeout callback\n* Microtasks: Promise.then | Mutation Observers\n* JS stack: script | onClick\n* Log: `click`\n\n3、接下来关键，冒泡的时候，因为我们并没有执行完当前的script,还在`inner.click()`这个函数执行之中，因此当`onclick`结束，开始冒泡时，script并没有结束\n* Tasks: Run scripts | setTimeout callback\n* Microtasks: Promise.then | Mutation Observers\n* JS stack: script | onClick(这是冒泡的click，第一次click已经结束)\n* Log: `click` `click` \n\n4、冒泡阶段重复之前内容\n* Tasks: Run scripts | setTimeout callback |setTimeout callback(outer)\n* Microtasks: Promise.then | Mutation Observers |promise.then\n* JS stack: script | onClick(这是冒泡的click，第一次click已经结束)\n* Log: `click` `click`\n\n注意第二次没有增加mutation，因为已经有一个在渲染的了\n\n5、inner.click()执行完毕,执行Microtasks\n* Tasks: Run scripts | setTimeout callback |setTimeout callback(outer)\n* Microtasks: Promise.then | Mutation Observers |promise.then\n* JS stack: \n* Log: `click` `click` `promise`\n\n6、按理论执行\n* Tasks: Run scripts | setTimeout callback |setTimeout callback(outer)\n* Microtasks: Mutation Observers |promise.then\n* JS stack: \n* Log: `click` `click` `promise` `mutate`....\n\n后面的就不解释了，Microtasks依次出栈，接着Tasks顺序执行。\n\n## 总结\n\nJake老师的文章，对这个的解析和深入实在令人佩服，我也在面试中因把event loop解释的较为详尽而被面试官肯定，所以如果对异步以及event loop有疑惑的，可以好好的消化下这个内容，一起进步!\n","slug":"2018-09-04-Tasks-microtasks-queues-and-schedules","published":1,"updated":"2022-08-17T07:53:21.232Z","comments":1,"photos":[],"link":"","_id":"cl6xbhzjw000czk08iczk8ka6","content":"<blockquote>\n<p>面试和笔试题目中，经常会出现’promise’,’setTimeout’等函数混合出现时候的运行顺序问题。 我们都知道这些异步的方法会在当前任务执行结束之后调用，但为什么’promise’会在’setTimeout’之前执行？ 具体的实现原理是什么？</p>\n</blockquote>\n<h2 id=\"问题的提出\"><a href=\"#问题的提出\" class=\"headerlink\" title=\"问题的提出\"></a>问题的提出</h2><p>上面问题的答案，都在文章<a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly\" target=\"_blank\" rel=\"noopener\">《Tasks, microtasks, queues and schedules》</a>讲的非常透彻。 建议英文可以的同学直接看这篇文章，就不要看我这个“笔记”了。( <em>之所以叫笔记，因为大部分内容出自文章，但是又不是按字翻译</em> )</p>\n<p>以下的题目是我们刷题可以经常看到的一个常规题目：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script start'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'setTimeout'</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise1'</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise2'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script end'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>几乎每个前端er都可以毫不犹豫的给出答案:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">script start</span><br><span class=\"line\">script end</span><br><span class=\"line\">promise1</span><br><span class=\"line\">promise2</span><br><span class=\"line\">setTimeout</span><br></pre></td></tr></table></figure></p>\n<p>问题来了，为什么<code>promise</code>的异步执行会在<code>setTimeout</code>之前，甚至<code>setTimeout</code>设置的延时是0都不行。 还有在Vue中，我们常用的nextTick()函数原理中，说的microtasks是什么东西？ 一切的解释都在开头给的文章中。 </p>\n<p>ps： 再次再次声明，这篇文章仍然是我记得笔记，原文比我写的好得多，英文可以的小伙伴强烈推荐看原文。</p>\n<h2 id=\"js异步实现原理\"><a href=\"#js异步实现原理\" class=\"headerlink\" title=\"js异步实现原理\"></a>js异步实现原理</h2><p>我们多多少少都应该听说过event loop，js是单线程的，通过异步它变得非常强大，而实现异步主要就是通过将异步的内容压入tasks，当前任务执行结束之后，再执行tasks中的callback。</p>\n<p><strong>Tasks</strong>，是一个任务队列，Js在执行同步任务的时候，只要遇到了异步执行和函数，都会把这个内容压入Tasks中，然后在当前同步任务完成后，再去Tasks中执行相应的回调。 举个例子，比如刚才代码中的<code>setTimeout</code>，当遇到这个函数，总会跟一个异步执行的任务(callback)，那么这个时候，Tasks队列里，除了当前正在执行的script之外，会在后面压入一个<code>setTimeout callback</code>， 而这个callback的调用时机，就是在当前同步任务完成之后，才会调用。这就是为什么,’setTimeout’ 会出现在’script end’之后了。</p>\n<p><strong>MicroTasks</strong>，说一些这个，这个和<code>setTimeout</code>不同，因为它是在当前Task完成后，就立即执行的，或者可以理解成，’microTasks总是在当前任务的最后执行’。  另外，还有一个非常重要的特性是： <strong>如果当前JS stack如果为空的时候(比如我们绑定了click事件后，等待和监听click时间的时候，JS stack就是空的),一会立即执行。</strong> 关于这一点，之后有个例子会具体说明，先往下看。</p>\n<p>那么MicroTasks队列主要是promise和mutation observer 的回掉函数生成</p>\n<h3 id=\"用新的理论来解释下\"><a href=\"#用新的理论来解释下\" class=\"headerlink\" title=\"用新的理论来解释下\"></a>用新的理论来解释下</h3><p>好了，刚才大概说了几个概念，那么一开始的例子，到底发生了什么？</p>\n<p><code>talk is cheap, show me a animation!!</code>—我自己说的</p>\n<p>下面的<a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly\" target=\"_blank\" rel=\"noopener\">动画</a>说明对整个过程进行了说明:</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/8/5/1650827c4eb4d2a5?w=420&amp;h=306&amp;f=gif&amp;s=441671\" alt=\"原文中的动态演示\"></p>\n<p>1、 程序执行  <code>log: script start</code></p>\n<ul>\n<li>Tasks: Run script</li>\n<li>JS stack: script</li>\n</ul>\n<p>2、 遇到setTimeout  <code>log: script start</code></p>\n<ul>\n<li>Tasks： Run script | setTimeout callback</li>\n<li>JS stack: script</li>\n</ul>\n<p>3、 遇到Promise</p>\n<ul>\n<li>Tasks: Run script | setTimeout callback</li>\n<li>Microtasks: promise then</li>\n<li>JS stack: script</li>\n</ul>\n<p>4、 执行最后一行 <code>log: script start | script end</code></p>\n<ul>\n<li>Tasks: Run script | setTimeout callback</li>\n<li>Microtasks: promise then</li>\n<li>JS stack: script</li>\n</ul>\n<p>4、 同步任务执行完毕，弹出相应的stack <code>log: script start | script end</code></p>\n<ul>\n<li>Tasks: Run script | setTimeout callback</li>\n<li>Microtasks: promise then</li>\n<li>JS stack:</li>\n</ul>\n<p>5、 同步任务最后是microTasks，JS stack压入callback <code>log: script start | script end | promise1</code></p>\n<ul>\n<li>Tasks: Run script | setTimeout callback</li>\n<li>Microtasks: promise then | promise then</li>\n<li>JS stack: promise1 calback<br>6、 promise返回新的promise，压入microTasks，继续执行 <code>log: script start | script end | promise1 | promise2</code></li>\n<li>Tasks: Run script | setTimeout callback</li>\n<li>Microtasks:  promise then</li>\n<li>JS stack: promise2 calback</li>\n</ul>\n<p>8、 第一个Tasks结束,弹出 <code>log: script start | script end | promise1 | promise2</code></p>\n<ul>\n<li>Tasks: setTimeout callback</li>\n<li>Microtasks:</li>\n<li>JS stack:</li>\n</ul>\n<p>9、 下一个Tasks <code>log: script start | script end | promise1 | promise2 | setTimeout</code></p>\n<ul>\n<li>Tasks: setTimeout callback</li>\n<li>Microtasks:</li>\n<li>JS stack: setTimeout callback</li>\n</ul>\n<p>好了，结束了，这就比之前的理解”promise比setTimeout快，异步先执行promise，再执行setTimeout”就深刻的多。 因为promise所建立的回掉函数是压入了<code>mircroTasks</code>队列中，它仍然属于当前的Task，而<code>setTimeout</code>则是相当于在Task序列中添加了新的任务</p>\n<h2 id=\"一个更复杂的例子\"><a href=\"#一个更复杂的例子\" class=\"headerlink\" title=\"一个更复杂的例子\"></a>一个更复杂的例子</h2><p>好了，有了刚才的认识和铺垫，接下来通过一个更加复杂的例子来熟悉JS事件处理的一个过程。</p>\n<p>现在有这样一个页面结构：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"outer\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"inner\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/8/5/1650914100613dfd?w=225&amp;h=194&amp;f=png&amp;s=1245\" alt=\"\"><br>js代码如下,现在如果点击里面的方块，控制台会输出什么呢？<a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly\" target=\"_blank\" rel=\"noopener\">在线实例</a><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Let's get hold of those elements</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> outer = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.outer'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> inner = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.inner'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Let's listen for attribute changes on the</span></span><br><span class=\"line\"><span class=\"comment\">// outer element</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> MutationObserver(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'mutate'</span>);</span><br><span class=\"line\">&#125;).observe(outer, &#123;</span><br><span class=\"line\">  attributes: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Here's a click listener…</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onClick</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'click'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'timeout'</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  outer.setAttribute(<span class=\"string\">'data-random'</span>, <span class=\"built_in\">Math</span>.random());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// …which we'll attach to both elements</span></span><br><span class=\"line\">inner.addEventListener(<span class=\"string\">'click'</span>, onClick);</span><br><span class=\"line\">outer.addEventListener(<span class=\"string\">'click'</span>, onClick);</span><br></pre></td></tr></table></figure></p>\n<p>这里先把正确答案公布，按照之前的理论，正确答案应该是：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">click</span><br><span class=\"line\">promise</span><br><span class=\"line\">mutate</span><br><span class=\"line\">click</span><br><span class=\"line\">promise</span><br><span class=\"line\">mutate</span><br><span class=\"line\">timeout</span><br><span class=\"line\">timeout</span><br></pre></td></tr></table></figure></p>\n<p>当然，不同浏览器，对于event loop的实现会稍有不同，这个是chrome下打印出来的结果，具体的其他形式还是推荐大家看原文了。</p>\n<p>下面分析下，为什么是上面的顺序呢？</p>\n<h3 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h3><p>按照刚才的结论：</p>\n<p>click事件显然是一个Task，Mutation observer和Promise是在microTasks队列中的，而setTimeout会被安排在Tasks之中。 因此</p>\n<p>1、点击事件触发</p>\n<ul>\n<li>Tasks: Dispatch click</li>\n<li>Microtasks: </li>\n<li>JS stack:</li>\n</ul>\n<p>2、触发点击事件的函数，函数执行，压入JS stack</p>\n<ul>\n<li>Tasks: Dispatch click</li>\n<li>Microtasks: </li>\n<li>JS stack: onClick</li>\n<li>Log: ‘click’</li>\n</ul>\n<p>3、遇到setTimeout，压入Tasks队列</p>\n<ul>\n<li>Tasks: Dispatch click | setTimeout callBack</li>\n<li>Microtasks: </li>\n<li>JS stack: onClick</li>\n<li>Log: ‘click’</li>\n</ul>\n<p>4、遇到promise，压入Microtasks</p>\n<ul>\n<li>Tasks: Dispatch click | setTimeout callBack</li>\n<li>Microtasks: Promise.then</li>\n<li>JS stack: onClick</li>\n<li>Log: ‘click’</li>\n</ul>\n<p>5、遇到 outer.setAttribute，触发mutation</p>\n<ul>\n<li>Tasks: Dispatch click | setTimeout callBack</li>\n<li>Microtasks: Promise.then | Mutation observers</li>\n<li>JS stack: onClick</li>\n<li>Log: ‘click’</li>\n</ul>\n<p>6、onclick函数执行完毕，出JS stack</p>\n<ul>\n<li>Tasks: Dispatch click | setTimeout callBack</li>\n<li>Microtasks: Promise.then | Mutation observers</li>\n<li>JS stack:</li>\n<li>Log: ‘click’</li>\n</ul>\n<p>7、这个时候，JS stack为空，执行Microtasks</p>\n<ul>\n<li>Tasks: Dispatch click | setTimeout callBack</li>\n<li>Microtasks: Promise.then | Mutation observers</li>\n<li>JS stack: PromiseCallback</li>\n<li>Log: ‘click’ ‘promise’</li>\n</ul>\n<p>8、microtasks顺序执行</p>\n<ul>\n<li>Tasks: Dispatch click | setTimeout callBack</li>\n<li>Microtasks:  Mutation observers</li>\n<li>JS stack: Mutation callback</li>\n<li>Log: ‘click’ ‘promise’ ‘mutate’</li>\n</ul>\n<p>接下来是重点，当microtasks为空，该执行下一个Tasks(setTimeout)了吗？并没有，因为js事件流中的冒泡被触发，也就是在外面的一层Div也会触发click函数，因此我们把刚才的步骤再走一遍。</p>\n<p>过程省略，结果为<br>9、冒泡走一遍的结果为</p>\n<ul>\n<li>Tasks: Dispatch click | setTimeout callBack | setTmeout callback(outer)</li>\n<li>Microtasks:  Mutation observers</li>\n<li>JS stack: Mutation callback</li>\n<li>Log: <code>click</code> <code>promise</code> <code>mutate</code> <code>click</code>  <code>promise</code> <code>mutate</code> </li>\n</ul>\n<p>10、 第一个Tasks完成，出栈</p>\n<ul>\n<li>Tasks: setTimeout callBack | setTmeout callback(outer)</li>\n<li>Microtasks: </li>\n<li>JS stack: setTimeout callback</li>\n<li>Log: <code>click</code> <code>promise</code> <code>mutate</code> <code>click</code>  <code>promise</code> <code>mutate</code> <code>timeout</code></li>\n</ul>\n<p>11、 第二个Tasks完成，出栈</p>\n<ul>\n<li>Tasks: setTmeout callback(outer)</li>\n<li>Microtasks: </li>\n<li>JS stack: setTimeout(outer) callback</li>\n<li>Log: <code>click</code> <code>promise</code> <code>mutate</code> <code>click</code>  <code>promise</code> <code>mutate</code> <code>timeout</code> <code>timeout</code></li>\n</ul>\n<p>结束了</p>\n<p>所以这里的重点是什么？ 是<strong>MicroTasks的执行时机： 见缝插针，它不一定就必须在Tasks的最后，只要JS stack为空，就可以执行</strong>  这条规则出处在</p>\n<blockquote>\n<p>If the stack of script settings objects is now empty, perform a microtask checkpoint<br>— HTML: Cleaning up after a callback step 3</p>\n</blockquote>\n<p>另一方面，ECMA也对此有过说明</p>\n<blockquote>\n<p>Execution of a Job can be initiated only when there is no running execution context and the execution context stack is empty…<br>   — ECMAScript: Jobs and Job Queues</p>\n</blockquote>\n<p><strong>但是对于其他浏览器(firefox  safari ie)同样的代码，得出的结果是不同的哦。关键在于，对与 <code>job</code>和<code>microTasks</code>之间的一个联系是很模糊的。  但是我们就按照Chrome的实现来理解吧。</strong></p>\n<h3 id=\"最后一关\"><a href=\"#最后一关\" class=\"headerlink\" title=\"最后一关\"></a>最后一关</h3><p> 还是刚才那道题，只不过，我不用鼠标点击了，而是直接执行函数</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inner.click()</span><br></pre></td></tr></table></figure>\n<p> 如果这样，结果会一样吗？</p>\n<p> 答案是:<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">click</span><br><span class=\"line\">click</span><br><span class=\"line\">promise</span><br><span class=\"line\">mutate</span><br><span class=\"line\">promise</span><br><span class=\"line\">timeout </span><br><span class=\"line\">timeout</span><br></pre></td></tr></table></figure></p>\n<p> What！！？？我怎么感觉我白学了？ 不着急，看下这次的过程是这样的，首先最大的不同在于，我们在函数最底部加了一个执行<code>inner.click()</code>，这样子，这个函数执行的过程，都是同步序列里的，所以这次的task的起点就在Run scripts:</p>\n<p>1、不同与鼠标点击，我们执行函数后，进入函数内部执行</p>\n<ul>\n<li>Tasks: Run scripts</li>\n<li>Microtasks: </li>\n<li>JS stack: script | onClick</li>\n<li>Log: <code>click</code></li>\n</ul>\n<p>2、遇到setTimeout和promise&amp;mutation</p>\n<ul>\n<li>Tasks: Run scripts | setTimeout callback</li>\n<li>Microtasks: Promise.then | Mutation Observers</li>\n<li>JS stack: script | onClick</li>\n<li>Log: <code>click</code></li>\n</ul>\n<p>3、接下来关键，冒泡的时候，因为我们并没有执行完当前的script,还在<code>inner.click()</code>这个函数执行之中，因此当<code>onclick</code>结束，开始冒泡时，script并没有结束</p>\n<ul>\n<li>Tasks: Run scripts | setTimeout callback</li>\n<li>Microtasks: Promise.then | Mutation Observers</li>\n<li>JS stack: script | onClick(这是冒泡的click，第一次click已经结束)</li>\n<li>Log: <code>click</code> <code>click</code> </li>\n</ul>\n<p>4、冒泡阶段重复之前内容</p>\n<ul>\n<li>Tasks: Run scripts | setTimeout callback |setTimeout callback(outer)</li>\n<li>Microtasks: Promise.then | Mutation Observers |promise.then</li>\n<li>JS stack: script | onClick(这是冒泡的click，第一次click已经结束)</li>\n<li>Log: <code>click</code> <code>click</code></li>\n</ul>\n<p>注意第二次没有增加mutation，因为已经有一个在渲染的了</p>\n<p>5、inner.click()执行完毕,执行Microtasks</p>\n<ul>\n<li>Tasks: Run scripts | setTimeout callback |setTimeout callback(outer)</li>\n<li>Microtasks: Promise.then | Mutation Observers |promise.then</li>\n<li>JS stack: </li>\n<li>Log: <code>click</code> <code>click</code> <code>promise</code></li>\n</ul>\n<p>6、按理论执行</p>\n<ul>\n<li>Tasks: Run scripts | setTimeout callback |setTimeout callback(outer)</li>\n<li>Microtasks: Mutation Observers |promise.then</li>\n<li>JS stack: </li>\n<li>Log: <code>click</code> <code>click</code> <code>promise</code> <code>mutate</code>….</li>\n</ul>\n<p>后面的就不解释了，Microtasks依次出栈，接着Tasks顺序执行。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Jake老师的文章，对这个的解析和深入实在令人佩服，我也在面试中因把event loop解释的较为详尽而被面试官肯定，所以如果对异步以及event loop有疑惑的，可以好好的消化下这个内容，一起进步!</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>面试和笔试题目中，经常会出现’promise’,’setTimeout’等函数混合出现时候的运行顺序问题。 我们都知道这些异步的方法会在当前任务执行结束之后调用，但为什么’promise’会在’setTimeout’之前执行？ 具体的实现原理是什么？</p>\n</blockquote>\n<h2 id=\"问题的提出\"><a href=\"#问题的提出\" class=\"headerlink\" title=\"问题的提出\"></a>问题的提出</h2><p>上面问题的答案，都在文章<a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly\" target=\"_blank\" rel=\"noopener\">《Tasks, microtasks, queues and schedules》</a>讲的非常透彻。 建议英文可以的同学直接看这篇文章，就不要看我这个“笔记”了。( <em>之所以叫笔记，因为大部分内容出自文章，但是又不是按字翻译</em> )</p>\n<p>以下的题目是我们刷题可以经常看到的一个常规题目：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script start'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'setTimeout'</span>);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise1'</span>);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise2'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'script end'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>几乎每个前端er都可以毫不犹豫的给出答案:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">script start</span><br><span class=\"line\">script end</span><br><span class=\"line\">promise1</span><br><span class=\"line\">promise2</span><br><span class=\"line\">setTimeout</span><br></pre></td></tr></table></figure></p>\n<p>问题来了，为什么<code>promise</code>的异步执行会在<code>setTimeout</code>之前，甚至<code>setTimeout</code>设置的延时是0都不行。 还有在Vue中，我们常用的nextTick()函数原理中，说的microtasks是什么东西？ 一切的解释都在开头给的文章中。 </p>\n<p>ps： 再次再次声明，这篇文章仍然是我记得笔记，原文比我写的好得多，英文可以的小伙伴强烈推荐看原文。</p>\n<h2 id=\"js异步实现原理\"><a href=\"#js异步实现原理\" class=\"headerlink\" title=\"js异步实现原理\"></a>js异步实现原理</h2><p>我们多多少少都应该听说过event loop，js是单线程的，通过异步它变得非常强大，而实现异步主要就是通过将异步的内容压入tasks，当前任务执行结束之后，再执行tasks中的callback。</p>\n<p><strong>Tasks</strong>，是一个任务队列，Js在执行同步任务的时候，只要遇到了异步执行和函数，都会把这个内容压入Tasks中，然后在当前同步任务完成后，再去Tasks中执行相应的回调。 举个例子，比如刚才代码中的<code>setTimeout</code>，当遇到这个函数，总会跟一个异步执行的任务(callback)，那么这个时候，Tasks队列里，除了当前正在执行的script之外，会在后面压入一个<code>setTimeout callback</code>， 而这个callback的调用时机，就是在当前同步任务完成之后，才会调用。这就是为什么,’setTimeout’ 会出现在’script end’之后了。</p>\n<p><strong>MicroTasks</strong>，说一些这个，这个和<code>setTimeout</code>不同，因为它是在当前Task完成后，就立即执行的，或者可以理解成，’microTasks总是在当前任务的最后执行’。  另外，还有一个非常重要的特性是： <strong>如果当前JS stack如果为空的时候(比如我们绑定了click事件后，等待和监听click时间的时候，JS stack就是空的),一会立即执行。</strong> 关于这一点，之后有个例子会具体说明，先往下看。</p>\n<p>那么MicroTasks队列主要是promise和mutation observer 的回掉函数生成</p>\n<h3 id=\"用新的理论来解释下\"><a href=\"#用新的理论来解释下\" class=\"headerlink\" title=\"用新的理论来解释下\"></a>用新的理论来解释下</h3><p>好了，刚才大概说了几个概念，那么一开始的例子，到底发生了什么？</p>\n<p><code>talk is cheap, show me a animation!!</code>—我自己说的</p>\n<p>下面的<a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly\" target=\"_blank\" rel=\"noopener\">动画</a>说明对整个过程进行了说明:</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/8/5/1650827c4eb4d2a5?w=420&amp;h=306&amp;f=gif&amp;s=441671\" alt=\"原文中的动态演示\"></p>\n<p>1、 程序执行  <code>log: script start</code></p>\n<ul>\n<li>Tasks: Run script</li>\n<li>JS stack: script</li>\n</ul>\n<p>2、 遇到setTimeout  <code>log: script start</code></p>\n<ul>\n<li>Tasks： Run script | setTimeout callback</li>\n<li>JS stack: script</li>\n</ul>\n<p>3、 遇到Promise</p>\n<ul>\n<li>Tasks: Run script | setTimeout callback</li>\n<li>Microtasks: promise then</li>\n<li>JS stack: script</li>\n</ul>\n<p>4、 执行最后一行 <code>log: script start | script end</code></p>\n<ul>\n<li>Tasks: Run script | setTimeout callback</li>\n<li>Microtasks: promise then</li>\n<li>JS stack: script</li>\n</ul>\n<p>4、 同步任务执行完毕，弹出相应的stack <code>log: script start | script end</code></p>\n<ul>\n<li>Tasks: Run script | setTimeout callback</li>\n<li>Microtasks: promise then</li>\n<li>JS stack:</li>\n</ul>\n<p>5、 同步任务最后是microTasks，JS stack压入callback <code>log: script start | script end | promise1</code></p>\n<ul>\n<li>Tasks: Run script | setTimeout callback</li>\n<li>Microtasks: promise then | promise then</li>\n<li>JS stack: promise1 calback<br>6、 promise返回新的promise，压入microTasks，继续执行 <code>log: script start | script end | promise1 | promise2</code></li>\n<li>Tasks: Run script | setTimeout callback</li>\n<li>Microtasks:  promise then</li>\n<li>JS stack: promise2 calback</li>\n</ul>\n<p>8、 第一个Tasks结束,弹出 <code>log: script start | script end | promise1 | promise2</code></p>\n<ul>\n<li>Tasks: setTimeout callback</li>\n<li>Microtasks:</li>\n<li>JS stack:</li>\n</ul>\n<p>9、 下一个Tasks <code>log: script start | script end | promise1 | promise2 | setTimeout</code></p>\n<ul>\n<li>Tasks: setTimeout callback</li>\n<li>Microtasks:</li>\n<li>JS stack: setTimeout callback</li>\n</ul>\n<p>好了，结束了，这就比之前的理解”promise比setTimeout快，异步先执行promise，再执行setTimeout”就深刻的多。 因为promise所建立的回掉函数是压入了<code>mircroTasks</code>队列中，它仍然属于当前的Task，而<code>setTimeout</code>则是相当于在Task序列中添加了新的任务</p>\n<h2 id=\"一个更复杂的例子\"><a href=\"#一个更复杂的例子\" class=\"headerlink\" title=\"一个更复杂的例子\"></a>一个更复杂的例子</h2><p>好了，有了刚才的认识和铺垫，接下来通过一个更加复杂的例子来熟悉JS事件处理的一个过程。</p>\n<p>现在有这样一个页面结构：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"outer\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"inner\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/8/5/1650914100613dfd?w=225&amp;h=194&amp;f=png&amp;s=1245\" alt=\"\"><br>js代码如下,现在如果点击里面的方块，控制台会输出什么呢？<a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly\" target=\"_blank\" rel=\"noopener\">在线实例</a><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Let's get hold of those elements</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> outer = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.outer'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> inner = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.inner'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Let's listen for attribute changes on the</span></span><br><span class=\"line\"><span class=\"comment\">// outer element</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> MutationObserver(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'mutate'</span>);</span><br><span class=\"line\">&#125;).observe(outer, &#123;</span><br><span class=\"line\">  attributes: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Here's a click listener…</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onClick</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'click'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'timeout'</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'promise'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  outer.setAttribute(<span class=\"string\">'data-random'</span>, <span class=\"built_in\">Math</span>.random());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// …which we'll attach to both elements</span></span><br><span class=\"line\">inner.addEventListener(<span class=\"string\">'click'</span>, onClick);</span><br><span class=\"line\">outer.addEventListener(<span class=\"string\">'click'</span>, onClick);</span><br></pre></td></tr></table></figure></p>\n<p>这里先把正确答案公布，按照之前的理论，正确答案应该是：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">click</span><br><span class=\"line\">promise</span><br><span class=\"line\">mutate</span><br><span class=\"line\">click</span><br><span class=\"line\">promise</span><br><span class=\"line\">mutate</span><br><span class=\"line\">timeout</span><br><span class=\"line\">timeout</span><br></pre></td></tr></table></figure></p>\n<p>当然，不同浏览器，对于event loop的实现会稍有不同，这个是chrome下打印出来的结果，具体的其他形式还是推荐大家看原文了。</p>\n<p>下面分析下，为什么是上面的顺序呢？</p>\n<h3 id=\"代码分析\"><a href=\"#代码分析\" class=\"headerlink\" title=\"代码分析\"></a>代码分析</h3><p>按照刚才的结论：</p>\n<p>click事件显然是一个Task，Mutation observer和Promise是在microTasks队列中的，而setTimeout会被安排在Tasks之中。 因此</p>\n<p>1、点击事件触发</p>\n<ul>\n<li>Tasks: Dispatch click</li>\n<li>Microtasks: </li>\n<li>JS stack:</li>\n</ul>\n<p>2、触发点击事件的函数，函数执行，压入JS stack</p>\n<ul>\n<li>Tasks: Dispatch click</li>\n<li>Microtasks: </li>\n<li>JS stack: onClick</li>\n<li>Log: ‘click’</li>\n</ul>\n<p>3、遇到setTimeout，压入Tasks队列</p>\n<ul>\n<li>Tasks: Dispatch click | setTimeout callBack</li>\n<li>Microtasks: </li>\n<li>JS stack: onClick</li>\n<li>Log: ‘click’</li>\n</ul>\n<p>4、遇到promise，压入Microtasks</p>\n<ul>\n<li>Tasks: Dispatch click | setTimeout callBack</li>\n<li>Microtasks: Promise.then</li>\n<li>JS stack: onClick</li>\n<li>Log: ‘click’</li>\n</ul>\n<p>5、遇到 outer.setAttribute，触发mutation</p>\n<ul>\n<li>Tasks: Dispatch click | setTimeout callBack</li>\n<li>Microtasks: Promise.then | Mutation observers</li>\n<li>JS stack: onClick</li>\n<li>Log: ‘click’</li>\n</ul>\n<p>6、onclick函数执行完毕，出JS stack</p>\n<ul>\n<li>Tasks: Dispatch click | setTimeout callBack</li>\n<li>Microtasks: Promise.then | Mutation observers</li>\n<li>JS stack:</li>\n<li>Log: ‘click’</li>\n</ul>\n<p>7、这个时候，JS stack为空，执行Microtasks</p>\n<ul>\n<li>Tasks: Dispatch click | setTimeout callBack</li>\n<li>Microtasks: Promise.then | Mutation observers</li>\n<li>JS stack: PromiseCallback</li>\n<li>Log: ‘click’ ‘promise’</li>\n</ul>\n<p>8、microtasks顺序执行</p>\n<ul>\n<li>Tasks: Dispatch click | setTimeout callBack</li>\n<li>Microtasks:  Mutation observers</li>\n<li>JS stack: Mutation callback</li>\n<li>Log: ‘click’ ‘promise’ ‘mutate’</li>\n</ul>\n<p>接下来是重点，当microtasks为空，该执行下一个Tasks(setTimeout)了吗？并没有，因为js事件流中的冒泡被触发，也就是在外面的一层Div也会触发click函数，因此我们把刚才的步骤再走一遍。</p>\n<p>过程省略，结果为<br>9、冒泡走一遍的结果为</p>\n<ul>\n<li>Tasks: Dispatch click | setTimeout callBack | setTmeout callback(outer)</li>\n<li>Microtasks:  Mutation observers</li>\n<li>JS stack: Mutation callback</li>\n<li>Log: <code>click</code> <code>promise</code> <code>mutate</code> <code>click</code>  <code>promise</code> <code>mutate</code> </li>\n</ul>\n<p>10、 第一个Tasks完成，出栈</p>\n<ul>\n<li>Tasks: setTimeout callBack | setTmeout callback(outer)</li>\n<li>Microtasks: </li>\n<li>JS stack: setTimeout callback</li>\n<li>Log: <code>click</code> <code>promise</code> <code>mutate</code> <code>click</code>  <code>promise</code> <code>mutate</code> <code>timeout</code></li>\n</ul>\n<p>11、 第二个Tasks完成，出栈</p>\n<ul>\n<li>Tasks: setTmeout callback(outer)</li>\n<li>Microtasks: </li>\n<li>JS stack: setTimeout(outer) callback</li>\n<li>Log: <code>click</code> <code>promise</code> <code>mutate</code> <code>click</code>  <code>promise</code> <code>mutate</code> <code>timeout</code> <code>timeout</code></li>\n</ul>\n<p>结束了</p>\n<p>所以这里的重点是什么？ 是<strong>MicroTasks的执行时机： 见缝插针，它不一定就必须在Tasks的最后，只要JS stack为空，就可以执行</strong>  这条规则出处在</p>\n<blockquote>\n<p>If the stack of script settings objects is now empty, perform a microtask checkpoint<br>— HTML: Cleaning up after a callback step 3</p>\n</blockquote>\n<p>另一方面，ECMA也对此有过说明</p>\n<blockquote>\n<p>Execution of a Job can be initiated only when there is no running execution context and the execution context stack is empty…<br>   — ECMAScript: Jobs and Job Queues</p>\n</blockquote>\n<p><strong>但是对于其他浏览器(firefox  safari ie)同样的代码，得出的结果是不同的哦。关键在于，对与 <code>job</code>和<code>microTasks</code>之间的一个联系是很模糊的。  但是我们就按照Chrome的实现来理解吧。</strong></p>\n<h3 id=\"最后一关\"><a href=\"#最后一关\" class=\"headerlink\" title=\"最后一关\"></a>最后一关</h3><p> 还是刚才那道题，只不过，我不用鼠标点击了，而是直接执行函数</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inner.click()</span><br></pre></td></tr></table></figure>\n<p> 如果这样，结果会一样吗？</p>\n<p> 答案是:<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">click</span><br><span class=\"line\">click</span><br><span class=\"line\">promise</span><br><span class=\"line\">mutate</span><br><span class=\"line\">promise</span><br><span class=\"line\">timeout </span><br><span class=\"line\">timeout</span><br></pre></td></tr></table></figure></p>\n<p> What！！？？我怎么感觉我白学了？ 不着急，看下这次的过程是这样的，首先最大的不同在于，我们在函数最底部加了一个执行<code>inner.click()</code>，这样子，这个函数执行的过程，都是同步序列里的，所以这次的task的起点就在Run scripts:</p>\n<p>1、不同与鼠标点击，我们执行函数后，进入函数内部执行</p>\n<ul>\n<li>Tasks: Run scripts</li>\n<li>Microtasks: </li>\n<li>JS stack: script | onClick</li>\n<li>Log: <code>click</code></li>\n</ul>\n<p>2、遇到setTimeout和promise&amp;mutation</p>\n<ul>\n<li>Tasks: Run scripts | setTimeout callback</li>\n<li>Microtasks: Promise.then | Mutation Observers</li>\n<li>JS stack: script | onClick</li>\n<li>Log: <code>click</code></li>\n</ul>\n<p>3、接下来关键，冒泡的时候，因为我们并没有执行完当前的script,还在<code>inner.click()</code>这个函数执行之中，因此当<code>onclick</code>结束，开始冒泡时，script并没有结束</p>\n<ul>\n<li>Tasks: Run scripts | setTimeout callback</li>\n<li>Microtasks: Promise.then | Mutation Observers</li>\n<li>JS stack: script | onClick(这是冒泡的click，第一次click已经结束)</li>\n<li>Log: <code>click</code> <code>click</code> </li>\n</ul>\n<p>4、冒泡阶段重复之前内容</p>\n<ul>\n<li>Tasks: Run scripts | setTimeout callback |setTimeout callback(outer)</li>\n<li>Microtasks: Promise.then | Mutation Observers |promise.then</li>\n<li>JS stack: script | onClick(这是冒泡的click，第一次click已经结束)</li>\n<li>Log: <code>click</code> <code>click</code></li>\n</ul>\n<p>注意第二次没有增加mutation，因为已经有一个在渲染的了</p>\n<p>5、inner.click()执行完毕,执行Microtasks</p>\n<ul>\n<li>Tasks: Run scripts | setTimeout callback |setTimeout callback(outer)</li>\n<li>Microtasks: Promise.then | Mutation Observers |promise.then</li>\n<li>JS stack: </li>\n<li>Log: <code>click</code> <code>click</code> <code>promise</code></li>\n</ul>\n<p>6、按理论执行</p>\n<ul>\n<li>Tasks: Run scripts | setTimeout callback |setTimeout callback(outer)</li>\n<li>Microtasks: Mutation Observers |promise.then</li>\n<li>JS stack: </li>\n<li>Log: <code>click</code> <code>click</code> <code>promise</code> <code>mutate</code>….</li>\n</ul>\n<p>后面的就不解释了，Microtasks依次出栈，接着Tasks顺序执行。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Jake老师的文章，对这个的解析和深入实在令人佩服，我也在面试中因把event loop解释的较为详尽而被面试官肯定，所以如果对异步以及event loop有疑惑的，可以好好的消化下这个内容，一起进步!</p>\n"},{"layout":"post","title":"学生时代的最后一个教师节","subtitle":"The last teacher's day in school-days","date":"2018-09-10T04:00:00.000Z","author":"VK","_content":"\n> 我一直都在扮演着别人口中的角色，一路上我遇到的每个恩师，似乎都能看出我这种“虚伪”, 于是他们每次把我说的异常优秀：\"成绩好、自我约束力强、管理能力强、能成大器\"，然后我就不自觉地尝试出演他们口中所说的高闻灿，一直到今天....\n\n<!--more-->\n\n## 终得贵人助\n\n一月，在重庆璧山的一个古巷中，偶得一签，签曰：“.........  终得贵人助”\n\n前面的话我已经记不清楚了，于是在本该充满欢声笑语中新年氛围中，我也不禁皱眉，心想: 今年找工作会一帆风顺吗？\n\n我一直都不自信，唯一自信的来源是别人对我的描述和信任，我会为了不辜负这份信任，不惜拼尽一切去维护好这份信任。于是我一直都在扮演着别人口中的角色，一路上我遇到的每个恩师，似乎都能看出我这种“虚伪”, 于是他们每次把我说的异常优秀：\"成绩好、自我约束力强、管理能力强、能成大器\"，然后我就不自觉地尝试出演他们口中所说的高闻灿，一直到今天....\n\n## 暑假\n\n今年暑假，不算酷暑，却丝毫没有凉意\n\n实习从未间断，每天挤地铁、晚回家，在后半阶段，实习的同时还得时时关注秋招进展，确实是人困马乏。\n\n未能见亲人一眼，可至少结局不负有心人\n\n8月底，看着手上的几个Offer，会心一笑，当初的焦虑也减轻了不少，心想：”终于可以继续维护了那些人对我的期望和信任...“\n\n## 教师节\n\n有那么一瞬间，自己心里也会恍惚一下：“ 那么久了，第一时间想到的竟然还是别人的评价、信任和责任 ”\n\n但是这些却都是潜意识的，因为这个高闻灿，是父母教育、恩师指导和贵人帮助所共同“创造”出来的。\n\n初中的郭老师、谢老师、王老师成功的让一个调皮的学生变得有追求、有理想；\n\n高中的黄老师则是给予该学生自信、理念和赋予价值观的第一人，熊爷、池哥、陆哥、加强哥、帆哥等育才精英共同让他成长为一个完整的人；\n\n大学，川大测控系老师，则表现出”海纳百川、有容乃大“的情怀，让学生初探象牙塔内的光环；\n\n而现在，若不是导师在4月份提前放行实习，学生也没机会在7、8月份顺利的找工作\n\n......\n\n## 总遇贵人\n\n时间匆匆的溜到了在校时期的最后一个教师节\n\n回想过往，感想颇多\n\n现在很少矫情的去写日志或什么\n\n但是总觉得走到今天，是我一路总遇贵人\n\n矫情也好、肉麻也罢\n\n在此，感谢所有的老师，谢谢\n\n没能像往日朝夕相处，但能每年一念，望保重身体，来日一聚！\n\n这些恩师，是贵人中的贵人","source":"_posts/2018-09-10-Teachers' day.md","raw":"---\nlayout:     post\ntitle:      \"学生时代的最后一个教师节\"\nsubtitle:   \"The last teacher's day in school-days\"\ndate:       2018-09-10 12:00:00\nauthor:     \"VK\"\n#photos: [\"images/forrestgump.png\"]\ntags:\n    - 感悟\n    - 随笔\n---\n\n> 我一直都在扮演着别人口中的角色，一路上我遇到的每个恩师，似乎都能看出我这种“虚伪”, 于是他们每次把我说的异常优秀：\"成绩好、自我约束力强、管理能力强、能成大器\"，然后我就不自觉地尝试出演他们口中所说的高闻灿，一直到今天....\n\n<!--more-->\n\n## 终得贵人助\n\n一月，在重庆璧山的一个古巷中，偶得一签，签曰：“.........  终得贵人助”\n\n前面的话我已经记不清楚了，于是在本该充满欢声笑语中新年氛围中，我也不禁皱眉，心想: 今年找工作会一帆风顺吗？\n\n我一直都不自信，唯一自信的来源是别人对我的描述和信任，我会为了不辜负这份信任，不惜拼尽一切去维护好这份信任。于是我一直都在扮演着别人口中的角色，一路上我遇到的每个恩师，似乎都能看出我这种“虚伪”, 于是他们每次把我说的异常优秀：\"成绩好、自我约束力强、管理能力强、能成大器\"，然后我就不自觉地尝试出演他们口中所说的高闻灿，一直到今天....\n\n## 暑假\n\n今年暑假，不算酷暑，却丝毫没有凉意\n\n实习从未间断，每天挤地铁、晚回家，在后半阶段，实习的同时还得时时关注秋招进展，确实是人困马乏。\n\n未能见亲人一眼，可至少结局不负有心人\n\n8月底，看着手上的几个Offer，会心一笑，当初的焦虑也减轻了不少，心想：”终于可以继续维护了那些人对我的期望和信任...“\n\n## 教师节\n\n有那么一瞬间，自己心里也会恍惚一下：“ 那么久了，第一时间想到的竟然还是别人的评价、信任和责任 ”\n\n但是这些却都是潜意识的，因为这个高闻灿，是父母教育、恩师指导和贵人帮助所共同“创造”出来的。\n\n初中的郭老师、谢老师、王老师成功的让一个调皮的学生变得有追求、有理想；\n\n高中的黄老师则是给予该学生自信、理念和赋予价值观的第一人，熊爷、池哥、陆哥、加强哥、帆哥等育才精英共同让他成长为一个完整的人；\n\n大学，川大测控系老师，则表现出”海纳百川、有容乃大“的情怀，让学生初探象牙塔内的光环；\n\n而现在，若不是导师在4月份提前放行实习，学生也没机会在7、8月份顺利的找工作\n\n......\n\n## 总遇贵人\n\n时间匆匆的溜到了在校时期的最后一个教师节\n\n回想过往，感想颇多\n\n现在很少矫情的去写日志或什么\n\n但是总觉得走到今天，是我一路总遇贵人\n\n矫情也好、肉麻也罢\n\n在此，感谢所有的老师，谢谢\n\n没能像往日朝夕相处，但能每年一念，望保重身体，来日一聚！\n\n这些恩师，是贵人中的贵人","slug":"2018-09-10-Teachers-day","published":1,"updated":"2022-08-17T07:53:21.232Z","comments":1,"photos":[],"link":"","_id":"cl6xbhzjx000ezk08887qfgp4","content":"<blockquote>\n<p>我一直都在扮演着别人口中的角色，一路上我遇到的每个恩师，似乎都能看出我这种“虚伪”, 于是他们每次把我说的异常优秀：”成绩好、自我约束力强、管理能力强、能成大器”，然后我就不自觉地尝试出演他们口中所说的高闻灿，一直到今天….</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"终得贵人助\"><a href=\"#终得贵人助\" class=\"headerlink\" title=\"终得贵人助\"></a>终得贵人助</h2><p>一月，在重庆璧山的一个古巷中，偶得一签，签曰：“………  终得贵人助”</p>\n<p>前面的话我已经记不清楚了，于是在本该充满欢声笑语中新年氛围中，我也不禁皱眉，心想: 今年找工作会一帆风顺吗？</p>\n<p>我一直都不自信，唯一自信的来源是别人对我的描述和信任，我会为了不辜负这份信任，不惜拼尽一切去维护好这份信任。于是我一直都在扮演着别人口中的角色，一路上我遇到的每个恩师，似乎都能看出我这种“虚伪”, 于是他们每次把我说的异常优秀：”成绩好、自我约束力强、管理能力强、能成大器”，然后我就不自觉地尝试出演他们口中所说的高闻灿，一直到今天….</p>\n<h2 id=\"暑假\"><a href=\"#暑假\" class=\"headerlink\" title=\"暑假\"></a>暑假</h2><p>今年暑假，不算酷暑，却丝毫没有凉意</p>\n<p>实习从未间断，每天挤地铁、晚回家，在后半阶段，实习的同时还得时时关注秋招进展，确实是人困马乏。</p>\n<p>未能见亲人一眼，可至少结局不负有心人</p>\n<p>8月底，看着手上的几个Offer，会心一笑，当初的焦虑也减轻了不少，心想：”终于可以继续维护了那些人对我的期望和信任…“</p>\n<h2 id=\"教师节\"><a href=\"#教师节\" class=\"headerlink\" title=\"教师节\"></a>教师节</h2><p>有那么一瞬间，自己心里也会恍惚一下：“ 那么久了，第一时间想到的竟然还是别人的评价、信任和责任 ”</p>\n<p>但是这些却都是潜意识的，因为这个高闻灿，是父母教育、恩师指导和贵人帮助所共同“创造”出来的。</p>\n<p>初中的郭老师、谢老师、王老师成功的让一个调皮的学生变得有追求、有理想；</p>\n<p>高中的黄老师则是给予该学生自信、理念和赋予价值观的第一人，熊爷、池哥、陆哥、加强哥、帆哥等育才精英共同让他成长为一个完整的人；</p>\n<p>大学，川大测控系老师，则表现出”海纳百川、有容乃大“的情怀，让学生初探象牙塔内的光环；</p>\n<p>而现在，若不是导师在4月份提前放行实习，学生也没机会在7、8月份顺利的找工作</p>\n<p>……</p>\n<h2 id=\"总遇贵人\"><a href=\"#总遇贵人\" class=\"headerlink\" title=\"总遇贵人\"></a>总遇贵人</h2><p>时间匆匆的溜到了在校时期的最后一个教师节</p>\n<p>回想过往，感想颇多</p>\n<p>现在很少矫情的去写日志或什么</p>\n<p>但是总觉得走到今天，是我一路总遇贵人</p>\n<p>矫情也好、肉麻也罢</p>\n<p>在此，感谢所有的老师，谢谢</p>\n<p>没能像往日朝夕相处，但能每年一念，望保重身体，来日一聚！</p>\n<p>这些恩师，是贵人中的贵人</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>我一直都在扮演着别人口中的角色，一路上我遇到的每个恩师，似乎都能看出我这种“虚伪”, 于是他们每次把我说的异常优秀：”成绩好、自我约束力强、管理能力强、能成大器”，然后我就不自觉地尝试出演他们口中所说的高闻灿，一直到今天….</p>\n</blockquote>","more":"<h2 id=\"终得贵人助\"><a href=\"#终得贵人助\" class=\"headerlink\" title=\"终得贵人助\"></a>终得贵人助</h2><p>一月，在重庆璧山的一个古巷中，偶得一签，签曰：“………  终得贵人助”</p>\n<p>前面的话我已经记不清楚了，于是在本该充满欢声笑语中新年氛围中，我也不禁皱眉，心想: 今年找工作会一帆风顺吗？</p>\n<p>我一直都不自信，唯一自信的来源是别人对我的描述和信任，我会为了不辜负这份信任，不惜拼尽一切去维护好这份信任。于是我一直都在扮演着别人口中的角色，一路上我遇到的每个恩师，似乎都能看出我这种“虚伪”, 于是他们每次把我说的异常优秀：”成绩好、自我约束力强、管理能力强、能成大器”，然后我就不自觉地尝试出演他们口中所说的高闻灿，一直到今天….</p>\n<h2 id=\"暑假\"><a href=\"#暑假\" class=\"headerlink\" title=\"暑假\"></a>暑假</h2><p>今年暑假，不算酷暑，却丝毫没有凉意</p>\n<p>实习从未间断，每天挤地铁、晚回家，在后半阶段，实习的同时还得时时关注秋招进展，确实是人困马乏。</p>\n<p>未能见亲人一眼，可至少结局不负有心人</p>\n<p>8月底，看着手上的几个Offer，会心一笑，当初的焦虑也减轻了不少，心想：”终于可以继续维护了那些人对我的期望和信任…“</p>\n<h2 id=\"教师节\"><a href=\"#教师节\" class=\"headerlink\" title=\"教师节\"></a>教师节</h2><p>有那么一瞬间，自己心里也会恍惚一下：“ 那么久了，第一时间想到的竟然还是别人的评价、信任和责任 ”</p>\n<p>但是这些却都是潜意识的，因为这个高闻灿，是父母教育、恩师指导和贵人帮助所共同“创造”出来的。</p>\n<p>初中的郭老师、谢老师、王老师成功的让一个调皮的学生变得有追求、有理想；</p>\n<p>高中的黄老师则是给予该学生自信、理念和赋予价值观的第一人，熊爷、池哥、陆哥、加强哥、帆哥等育才精英共同让他成长为一个完整的人；</p>\n<p>大学，川大测控系老师，则表现出”海纳百川、有容乃大“的情怀，让学生初探象牙塔内的光环；</p>\n<p>而现在，若不是导师在4月份提前放行实习，学生也没机会在7、8月份顺利的找工作</p>\n<p>……</p>\n<h2 id=\"总遇贵人\"><a href=\"#总遇贵人\" class=\"headerlink\" title=\"总遇贵人\"></a>总遇贵人</h2><p>时间匆匆的溜到了在校时期的最后一个教师节</p>\n<p>回想过往，感想颇多</p>\n<p>现在很少矫情的去写日志或什么</p>\n<p>但是总觉得走到今天，是我一路总遇贵人</p>\n<p>矫情也好、肉麻也罢</p>\n<p>在此，感谢所有的老师，谢谢</p>\n<p>没能像往日朝夕相处，但能每年一念，望保重身体，来日一聚！</p>\n<p>这些恩师，是贵人中的贵人</p>"},{"layout":"post","title":"[转载]Class vs Factory function: exploring the way forward","subtitle":"","date":"2018-09-06T04:00:00.000Z","author":"Vinecnt Ko","header-img":"img/post-bg-e2e-ux.jpg","header-mask":0.3,"catalog":true,"_content":"\n\n\n一直以为ES6出了后，新特性都是值得推广、使用的，直到看了这篇文章，甚有醍醐灌顶之感，来不及翻译，直接转载过来（原文需要翻墙查看）\n\n原文地址：[**Class vs Factory function: exploring the way forward**](https://medium.freecodecamp.org/class-vs-factory-function-exploring-the-way-forward-73258b6a8d15)\n\n---\n\nECMAScript 2015 (aka ES6) comes with the class syntax, so now we have two competing patterns for creating objects. In order to compare them, I’ll create the same object definition (TodoModel) as a class, and then as a factory function.\n\n[**TodoModel as a Class**](https://jsfiddle.net/cristi_salcescu/m9dhpzfx/)\n\n```\nclass TodoModel {\n    constructor(){\n        this.todos = [];\n        this.lastChange = null;\n    }\n    \n    addToPrivateList(){\n        console.log(\"addToPrivateList\"); \n    }\n    add() { console.log(\"add\"); }\n    reload(){}\n}\n```\n\n[**TodoModel as a Factory Function**](https://jsfiddle.net/cristi_salcescu/bcta6yyv/)\n\n```\nfunction TodoModel(){\n    var todos = [];\n    var lastChange = null;\n        \n    function addToPrivateList(){\n        console.log(\"addToPrivateList\"); \n    }\n    function add() { console.log(\"add\"); }\n    function reload(){}\n    \n    return Object.freeze({\n        add,\n        reload\n    });\n}\n```\n\n### Encapsulation\n\nThe first thing we notice is that all members, fields, and methods of a class object are public.\n\n```\nvar todoModel = new TodoModel();\nconsole.log(todoModel.todos);     //[]\nconsole.log(todoModel.lastChange) //null\ntodoModel.addToPrivateList();     //addToPrivateList\n```\n\nThe lack of encapsulation may create security problems. Take the example of a global object that can be modified directly from the Developer Console.\n\nWhen using factory function, only the methods we expose are public, everything else is encapsulated.\n\n```\nvar todoModel = TodoModel();\nconsole.log(todoModel.todos);     //undefined\nconsole.log(todoModel.lastChange) //undefined\ntodoModel.addToPrivateList();     //taskModel.addToPrivateList\n                                    is not a function\n```\n\n### this\n\n`this` losing context problems are still there when using class. For example, `this` is losing context in nested functions. It is not only annoying during coding, but it’s also a constant source of bugs.\n\n```\nclass TodoModel {\n    constructor(){\n        this.todos = [];\n    }\n    \n    reload(){ \n        setTimeout(function log() { \n           console.log(this.todos);    //undefined\n        }, 0);\n    }\n}\ntodoModel.reload();                   //undefined\n```\n\nor `this` is losing context when the method is used as a callback, like on a DOM event.\n\n```\n$(\"#btn\").click(todoModel.reload);    //undefined\n```\n\nThere are no such problems when using a factory function, as it doesn’t use `this` at all.\n\n```\nfunction TodoModel(){\n    var todos = [];\n        \n    function reload(){ \n        setTimeout(function log() { \n           console.log(todos);        //[]\n       }, 0);\n    }\n}\ntodoModel.reload();                   //[]\n$(\"#btn\").click(todoModel.reload);    //[]\n```\n\n#### this and arrow function\n\nThe arrow function partially solves the `this` loosing context issues in classes, but at the same time creates a new problem:\n\n- `this` is no longer loosing context in nested functions\n- `this` is loosing context when the method is used as a callback\n- arrow function promotes the use of anonymous functions\n\n[I refactored the ](https://jsfiddle.net/cristi_salcescu/y0k18og2/)`TodoModel`[ using the arrow function](https://jsfiddle.net/cristi_salcescu/y0k18og2/). It’s important to note that in the process of refactoring to the arrow function we can loose something very important for readability, the function name. [Look for example](https://jsfiddle.net/cristi_salcescu/y0k18og2/) at:\n\n```\n//using function name to express intent\nsetTimeout(function renderTodosForReview() { \n      /* code */ \n}, 0);\n//versus using an anonymous function\nsetTimeout(() => { \n      /* code */ \n}, 0);\n```\n\n### Immutable API\n\nOnce the object is created, I’m expecting its API to be immutable. I can easily change the implementation of a public method to do something else when it was created using a class.\n\n```\ntodoModel.reload = function() { console.log(\"a new reload\"); }\ntodoModel.reload();            //a new reload\n```\n\n[This problem can be solved](https://jsfiddle.net/cristi_salcescu/y0k18og2/) by calling `Object.freeze(TodoModel.prototype)`after the class definition.\n\nThe API of the object created using a factory function is immutable. Notice the use of `Object.freeze()` on the returned object containing only the public methods. The private data of the object can be modified, but only through these public methods.\n\n```\ntodoModel.reload = function() { console.log(\"a new reload\"); }\ntodoModel.reload();            //reload\n```\n\n### new\n\n`new` should be used when creating objects using classes.\n\n`new` is not required when creating objects with factory functions, but if that makes it more readable, you can go for it, there is no harm.\n\n```\nvar todoModel= new TodoModel();\n```\n\n[**Using** ](https://jsfiddle.net/cristi_salcescu/4j8wpfhx/)`new`[ **with a factory function**](https://jsfiddle.net/cristi_salcescu/4j8wpfhx/) **will just return the object created by the factory.**\n\n### Composition over inheritance\n\nClasses support both inheritance and composition.\n\nBelow is an [example of inheritance](https://jsfiddle.net/cristi_salcescu/1xo96yt8/) where `SpecialService` class inherits from `Service` class:\n\n```\nclass Service {\n  doSomething(){ console.log(\"doSomething\"); }\n}\nclass SpecialService extends Service {\n  doSomethingElse(){ console.log(\"doSomethingElse\"); }  \n}\nvar specialService = new SpecialService();\nspecialService.doSomething();\nspecialService.doSomethingElse();\n```\n\n[Here is another example](https://jsfiddle.net/cristi_salcescu/vwdwvvov/) where `SpecialService` reuses member of `Service`using composition:\n\n```\nclass Service {\n  doSomething(){ console.log(\"doSomething\"); }\n}\nclass SpecialService{\n  constructor(args){\n    this.service = args.service;\n  }\n  doSomething() { this.service.doSomething(); } \n  \n  doSomethingElse(){ console.log(\"doSomethingElse\"); }\n}\nvar specialService = new SpecialService({\n   service : new Service()\n});\nspecialService.doSomething();\nspecialService.doSomethingElse();\n```\n\nFactory functions promote composition over inheritance. [Take a look at the next example](https://jsfiddle.net/cristi_salcescu/jgbhkb4o/) where `SpecialService` reuses members of `Service` :\n\n```\nfunction Service() {\n  function doSomething(){ console.log(\"doSomething\"); }\n  return Object.freeze({\n    doSomething\n  });\n}\nfunction SpecialService(args){\n  var service = args.service;\n  function doSomethingElse(){ console.log(\"doSomethingElse\"); }\n  return Object.freeze({\n    doSomething : service.doSomething,\n    doSomethingElse\n  });\n}\nvar specialService = SpecialService({\n   service : Service()\n});\nspecialService.doSomething();\nspecialService.doSomethingElse();\n```\n\n### Memory\n\nClasses are better at memory conservation, as they are implemented over the prototype system. All methods will be created only once in the prototype object and shared by all instances.\n\nThe memory cost of the factory function is noticeable when creating thousands of the same object.\n\n[Here is the page used for testing the memory cost](https://plnkr.co/edit/4cxGfN?p=info) when using factory function.\n\n```\nThe memory cost (in Chrome)\n+-----------+------------+------------+\n| Instances | 10 methods | 20 methods |\n+-----------+---------------+---------+\n| 10        | 0          |  0         |\n| 100       | 0.1Mb      |  0.1Mb     |\n| 1000      | 0.7Mb      |  1.4Mb     |\n| 10000     | 7.3Mb      | 14.2Mb     |\n+-----------+------------+------------+\n```\n\n### Objects vs Data Structures\n\nBefore analyzing the memory cost any further, a distinction should be made between two kinds of objects:\n\n- OOP Objects\n- Data Objects (aka Data Structures)\n\n> Objects expose behavior and hide data.\n>\n> Data Structures expose data and have no significant behavior.\n>\n> — [Robert Martin “Clean Code”](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882)\n\nI’ll take a look again at the `TodoModel` example and explain these two kinds of objects.\n\n```\nfunction TodoModel(){\n    var todos = [];\n           \n    function add() { }\n    function reload(){ }\n       \n    return Object.freeze({\n        add,\n        reload\n    });\n}\n```\n\n- `TodoModel` is responsible for storing and managing the list of `todos`. `TodoModel` is the OOP Object, the one exposing behavior and hiding data. There will be only one instance of it in the application, so there’s no extra memory cost when using the factory function.\n- The `todos` objects represent the Data Structures. There may be a lot of these objects, but they are just plain JavaScript objects. We are not interested in keeping their methods private — rather we actually want to expose all their data and methods. So all these objects will be built over the prototype system, and they will benefit from the memory conservation. They can be built using a simple object literal or `Object.create()` .\n\n#### UI Components\n\nIn the application, there may be hundreds or thousands of instances of a UI component. This is a situation where we need to make a trade-off between encapsulation and memory conservation.\n\nComponents will be built according to the component framework practice. For example, object literals will be used for Vue, or classes for React. Each component’s members will be public, but they will benefit from the memory conservation of the prototype system.\n\n### Conclusion\n\nThe strong points of class are its familiarity for people coming from a class-based background and its nicer syntax over the prototype system. However, its security problems and the usage of `this`, a continuous source of losing context bugs, makes it a second option. As an exception, classes will be used if required by the component’s framework, as in the case of React.\n\nFactory function is not only the better option for creating secured, encapsulated, and flexible OOP Objects but also opens the door for a new, unique to JavaScript, programming paradigm.\n\n> I think Class Free Object Oriented Programming is JavaScript’s gift to humanity.                                          \n>\n> — [Douglas Crockford “The Better Parts”](https://www.youtube.com/watch?v=DxnYQRuLX7Q&feature=youtu.be&t=45m41s)","source":"_posts/2018-09-06-Class vs Factory function.md","raw":"---\nlayout:     post\ntitle:      \"[转载]Class vs Factory function: exploring the way forward\"\nsubtitle:   \"\"\ndate:       2018-09-06 12:00:00\nauthor:     \"Vinecnt Ko\"\nheader-img: \"img/post-bg-e2e-ux.jpg\"\nheader-mask: 0.3\ncatalog:    true\ntags:\n    - 转载\n    - JavaScript\n    - ES6\n---\n\n\n\n一直以为ES6出了后，新特性都是值得推广、使用的，直到看了这篇文章，甚有醍醐灌顶之感，来不及翻译，直接转载过来（原文需要翻墙查看）\n\n原文地址：[**Class vs Factory function: exploring the way forward**](https://medium.freecodecamp.org/class-vs-factory-function-exploring-the-way-forward-73258b6a8d15)\n\n---\n\nECMAScript 2015 (aka ES6) comes with the class syntax, so now we have two competing patterns for creating objects. In order to compare them, I’ll create the same object definition (TodoModel) as a class, and then as a factory function.\n\n[**TodoModel as a Class**](https://jsfiddle.net/cristi_salcescu/m9dhpzfx/)\n\n```\nclass TodoModel {\n    constructor(){\n        this.todos = [];\n        this.lastChange = null;\n    }\n    \n    addToPrivateList(){\n        console.log(\"addToPrivateList\"); \n    }\n    add() { console.log(\"add\"); }\n    reload(){}\n}\n```\n\n[**TodoModel as a Factory Function**](https://jsfiddle.net/cristi_salcescu/bcta6yyv/)\n\n```\nfunction TodoModel(){\n    var todos = [];\n    var lastChange = null;\n        \n    function addToPrivateList(){\n        console.log(\"addToPrivateList\"); \n    }\n    function add() { console.log(\"add\"); }\n    function reload(){}\n    \n    return Object.freeze({\n        add,\n        reload\n    });\n}\n```\n\n### Encapsulation\n\nThe first thing we notice is that all members, fields, and methods of a class object are public.\n\n```\nvar todoModel = new TodoModel();\nconsole.log(todoModel.todos);     //[]\nconsole.log(todoModel.lastChange) //null\ntodoModel.addToPrivateList();     //addToPrivateList\n```\n\nThe lack of encapsulation may create security problems. Take the example of a global object that can be modified directly from the Developer Console.\n\nWhen using factory function, only the methods we expose are public, everything else is encapsulated.\n\n```\nvar todoModel = TodoModel();\nconsole.log(todoModel.todos);     //undefined\nconsole.log(todoModel.lastChange) //undefined\ntodoModel.addToPrivateList();     //taskModel.addToPrivateList\n                                    is not a function\n```\n\n### this\n\n`this` losing context problems are still there when using class. For example, `this` is losing context in nested functions. It is not only annoying during coding, but it’s also a constant source of bugs.\n\n```\nclass TodoModel {\n    constructor(){\n        this.todos = [];\n    }\n    \n    reload(){ \n        setTimeout(function log() { \n           console.log(this.todos);    //undefined\n        }, 0);\n    }\n}\ntodoModel.reload();                   //undefined\n```\n\nor `this` is losing context when the method is used as a callback, like on a DOM event.\n\n```\n$(\"#btn\").click(todoModel.reload);    //undefined\n```\n\nThere are no such problems when using a factory function, as it doesn’t use `this` at all.\n\n```\nfunction TodoModel(){\n    var todos = [];\n        \n    function reload(){ \n        setTimeout(function log() { \n           console.log(todos);        //[]\n       }, 0);\n    }\n}\ntodoModel.reload();                   //[]\n$(\"#btn\").click(todoModel.reload);    //[]\n```\n\n#### this and arrow function\n\nThe arrow function partially solves the `this` loosing context issues in classes, but at the same time creates a new problem:\n\n- `this` is no longer loosing context in nested functions\n- `this` is loosing context when the method is used as a callback\n- arrow function promotes the use of anonymous functions\n\n[I refactored the ](https://jsfiddle.net/cristi_salcescu/y0k18og2/)`TodoModel`[ using the arrow function](https://jsfiddle.net/cristi_salcescu/y0k18og2/). It’s important to note that in the process of refactoring to the arrow function we can loose something very important for readability, the function name. [Look for example](https://jsfiddle.net/cristi_salcescu/y0k18og2/) at:\n\n```\n//using function name to express intent\nsetTimeout(function renderTodosForReview() { \n      /* code */ \n}, 0);\n//versus using an anonymous function\nsetTimeout(() => { \n      /* code */ \n}, 0);\n```\n\n### Immutable API\n\nOnce the object is created, I’m expecting its API to be immutable. I can easily change the implementation of a public method to do something else when it was created using a class.\n\n```\ntodoModel.reload = function() { console.log(\"a new reload\"); }\ntodoModel.reload();            //a new reload\n```\n\n[This problem can be solved](https://jsfiddle.net/cristi_salcescu/y0k18og2/) by calling `Object.freeze(TodoModel.prototype)`after the class definition.\n\nThe API of the object created using a factory function is immutable. Notice the use of `Object.freeze()` on the returned object containing only the public methods. The private data of the object can be modified, but only through these public methods.\n\n```\ntodoModel.reload = function() { console.log(\"a new reload\"); }\ntodoModel.reload();            //reload\n```\n\n### new\n\n`new` should be used when creating objects using classes.\n\n`new` is not required when creating objects with factory functions, but if that makes it more readable, you can go for it, there is no harm.\n\n```\nvar todoModel= new TodoModel();\n```\n\n[**Using** ](https://jsfiddle.net/cristi_salcescu/4j8wpfhx/)`new`[ **with a factory function**](https://jsfiddle.net/cristi_salcescu/4j8wpfhx/) **will just return the object created by the factory.**\n\n### Composition over inheritance\n\nClasses support both inheritance and composition.\n\nBelow is an [example of inheritance](https://jsfiddle.net/cristi_salcescu/1xo96yt8/) where `SpecialService` class inherits from `Service` class:\n\n```\nclass Service {\n  doSomething(){ console.log(\"doSomething\"); }\n}\nclass SpecialService extends Service {\n  doSomethingElse(){ console.log(\"doSomethingElse\"); }  \n}\nvar specialService = new SpecialService();\nspecialService.doSomething();\nspecialService.doSomethingElse();\n```\n\n[Here is another example](https://jsfiddle.net/cristi_salcescu/vwdwvvov/) where `SpecialService` reuses member of `Service`using composition:\n\n```\nclass Service {\n  doSomething(){ console.log(\"doSomething\"); }\n}\nclass SpecialService{\n  constructor(args){\n    this.service = args.service;\n  }\n  doSomething() { this.service.doSomething(); } \n  \n  doSomethingElse(){ console.log(\"doSomethingElse\"); }\n}\nvar specialService = new SpecialService({\n   service : new Service()\n});\nspecialService.doSomething();\nspecialService.doSomethingElse();\n```\n\nFactory functions promote composition over inheritance. [Take a look at the next example](https://jsfiddle.net/cristi_salcescu/jgbhkb4o/) where `SpecialService` reuses members of `Service` :\n\n```\nfunction Service() {\n  function doSomething(){ console.log(\"doSomething\"); }\n  return Object.freeze({\n    doSomething\n  });\n}\nfunction SpecialService(args){\n  var service = args.service;\n  function doSomethingElse(){ console.log(\"doSomethingElse\"); }\n  return Object.freeze({\n    doSomething : service.doSomething,\n    doSomethingElse\n  });\n}\nvar specialService = SpecialService({\n   service : Service()\n});\nspecialService.doSomething();\nspecialService.doSomethingElse();\n```\n\n### Memory\n\nClasses are better at memory conservation, as they are implemented over the prototype system. All methods will be created only once in the prototype object and shared by all instances.\n\nThe memory cost of the factory function is noticeable when creating thousands of the same object.\n\n[Here is the page used for testing the memory cost](https://plnkr.co/edit/4cxGfN?p=info) when using factory function.\n\n```\nThe memory cost (in Chrome)\n+-----------+------------+------------+\n| Instances | 10 methods | 20 methods |\n+-----------+---------------+---------+\n| 10        | 0          |  0         |\n| 100       | 0.1Mb      |  0.1Mb     |\n| 1000      | 0.7Mb      |  1.4Mb     |\n| 10000     | 7.3Mb      | 14.2Mb     |\n+-----------+------------+------------+\n```\n\n### Objects vs Data Structures\n\nBefore analyzing the memory cost any further, a distinction should be made between two kinds of objects:\n\n- OOP Objects\n- Data Objects (aka Data Structures)\n\n> Objects expose behavior and hide data.\n>\n> Data Structures expose data and have no significant behavior.\n>\n> — [Robert Martin “Clean Code”](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882)\n\nI’ll take a look again at the `TodoModel` example and explain these two kinds of objects.\n\n```\nfunction TodoModel(){\n    var todos = [];\n           \n    function add() { }\n    function reload(){ }\n       \n    return Object.freeze({\n        add,\n        reload\n    });\n}\n```\n\n- `TodoModel` is responsible for storing and managing the list of `todos`. `TodoModel` is the OOP Object, the one exposing behavior and hiding data. There will be only one instance of it in the application, so there’s no extra memory cost when using the factory function.\n- The `todos` objects represent the Data Structures. There may be a lot of these objects, but they are just plain JavaScript objects. We are not interested in keeping their methods private — rather we actually want to expose all their data and methods. So all these objects will be built over the prototype system, and they will benefit from the memory conservation. They can be built using a simple object literal or `Object.create()` .\n\n#### UI Components\n\nIn the application, there may be hundreds or thousands of instances of a UI component. This is a situation where we need to make a trade-off between encapsulation and memory conservation.\n\nComponents will be built according to the component framework practice. For example, object literals will be used for Vue, or classes for React. Each component’s members will be public, but they will benefit from the memory conservation of the prototype system.\n\n### Conclusion\n\nThe strong points of class are its familiarity for people coming from a class-based background and its nicer syntax over the prototype system. However, its security problems and the usage of `this`, a continuous source of losing context bugs, makes it a second option. As an exception, classes will be used if required by the component’s framework, as in the case of React.\n\nFactory function is not only the better option for creating secured, encapsulated, and flexible OOP Objects but also opens the door for a new, unique to JavaScript, programming paradigm.\n\n> I think Class Free Object Oriented Programming is JavaScript’s gift to humanity.                                          \n>\n> — [Douglas Crockford “The Better Parts”](https://www.youtube.com/watch?v=DxnYQRuLX7Q&feature=youtu.be&t=45m41s)","slug":"2018-09-06-Class-vs-Factory-function","published":1,"updated":"2022-08-17T07:53:21.232Z","comments":1,"photos":[],"link":"","_id":"cl6xbhzjy000fzk08zqid2e2d","content":"<p>一直以为ES6出了后，新特性都是值得推广、使用的，直到看了这篇文章，甚有醍醐灌顶之感，来不及翻译，直接转载过来（原文需要翻墙查看）</p>\n<p>原文地址：<a href=\"https://medium.freecodecamp.org/class-vs-factory-function-exploring-the-way-forward-73258b6a8d15\" target=\"_blank\" rel=\"noopener\"><strong>Class vs Factory function: exploring the way forward</strong></a></p>\n<hr>\n<p>ECMAScript 2015 (aka ES6) comes with the class syntax, so now we have two competing patterns for creating objects. In order to compare them, I’ll create the same object definition (TodoModel) as a class, and then as a factory function.</p>\n<p><a href=\"https://jsfiddle.net/cristi_salcescu/m9dhpzfx/\" target=\"_blank\" rel=\"noopener\"><strong>TodoModel as a Class</strong></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TodoModel &#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        this.todos = [];</span><br><span class=\"line\">        this.lastChange = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    addToPrivateList()&#123;</span><br><span class=\"line\">        console.log(&quot;addToPrivateList&quot;); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    add() &#123; console.log(&quot;add&quot;); &#125;</span><br><span class=\"line\">    reload()&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://jsfiddle.net/cristi_salcescu/bcta6yyv/\" target=\"_blank\" rel=\"noopener\"><strong>TodoModel as a Factory Function</strong></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function TodoModel()&#123;</span><br><span class=\"line\">    var todos = [];</span><br><span class=\"line\">    var lastChange = null;</span><br><span class=\"line\">        </span><br><span class=\"line\">    function addToPrivateList()&#123;</span><br><span class=\"line\">        console.log(&quot;addToPrivateList&quot;); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function add() &#123; console.log(&quot;add&quot;); &#125;</span><br><span class=\"line\">    function reload()&#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return Object.freeze(&#123;</span><br><span class=\"line\">        add,</span><br><span class=\"line\">        reload</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Encapsulation\"><a href=\"#Encapsulation\" class=\"headerlink\" title=\"Encapsulation\"></a>Encapsulation</h3><p>The first thing we notice is that all members, fields, and methods of a class object are public.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var todoModel = new TodoModel();</span><br><span class=\"line\">console.log(todoModel.todos);     //[]</span><br><span class=\"line\">console.log(todoModel.lastChange) //null</span><br><span class=\"line\">todoModel.addToPrivateList();     //addToPrivateList</span><br></pre></td></tr></table></figure>\n<p>The lack of encapsulation may create security problems. Take the example of a global object that can be modified directly from the Developer Console.</p>\n<p>When using factory function, only the methods we expose are public, everything else is encapsulated.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var todoModel = TodoModel();</span><br><span class=\"line\">console.log(todoModel.todos);     //undefined</span><br><span class=\"line\">console.log(todoModel.lastChange) //undefined</span><br><span class=\"line\">todoModel.addToPrivateList();     //taskModel.addToPrivateList</span><br><span class=\"line\">                                    is not a function</span><br></pre></td></tr></table></figure>\n<h3 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h3><p><code>this</code> losing context problems are still there when using class. For example, <code>this</code> is losing context in nested functions. It is not only annoying during coding, but it’s also a constant source of bugs.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TodoModel &#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        this.todos = [];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    reload()&#123; </span><br><span class=\"line\">        setTimeout(function log() &#123; </span><br><span class=\"line\">           console.log(this.todos);    //undefined</span><br><span class=\"line\">        &#125;, 0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">todoModel.reload();                   //undefined</span><br></pre></td></tr></table></figure>\n<p>or <code>this</code> is losing context when the method is used as a callback, like on a DOM event.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&quot;#btn&quot;).click(todoModel.reload);    //undefined</span><br></pre></td></tr></table></figure>\n<p>There are no such problems when using a factory function, as it doesn’t use <code>this</code> at all.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function TodoModel()&#123;</span><br><span class=\"line\">    var todos = [];</span><br><span class=\"line\">        </span><br><span class=\"line\">    function reload()&#123; </span><br><span class=\"line\">        setTimeout(function log() &#123; </span><br><span class=\"line\">           console.log(todos);        //[]</span><br><span class=\"line\">       &#125;, 0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">todoModel.reload();                   //[]</span><br><span class=\"line\">$(&quot;#btn&quot;).click(todoModel.reload);    //[]</span><br></pre></td></tr></table></figure>\n<h4 id=\"this-and-arrow-function\"><a href=\"#this-and-arrow-function\" class=\"headerlink\" title=\"this and arrow function\"></a>this and arrow function</h4><p>The arrow function partially solves the <code>this</code> loosing context issues in classes, but at the same time creates a new problem:</p>\n<ul>\n<li><code>this</code> is no longer loosing context in nested functions</li>\n<li><code>this</code> is loosing context when the method is used as a callback</li>\n<li>arrow function promotes the use of anonymous functions</li>\n</ul>\n<p><a href=\"https://jsfiddle.net/cristi_salcescu/y0k18og2/\" target=\"_blank\" rel=\"noopener\">I refactored the </a><code>TodoModel</code><a href=\"https://jsfiddle.net/cristi_salcescu/y0k18og2/\" target=\"_blank\" rel=\"noopener\"> using the arrow function</a>. It’s important to note that in the process of refactoring to the arrow function we can loose something very important for readability, the function name. <a href=\"https://jsfiddle.net/cristi_salcescu/y0k18og2/\" target=\"_blank\" rel=\"noopener\">Look for example</a> at:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//using function name to express intent</span><br><span class=\"line\">setTimeout(function renderTodosForReview() &#123; </span><br><span class=\"line\">      /* code */ </span><br><span class=\"line\">&#125;, 0);</span><br><span class=\"line\">//versus using an anonymous function</span><br><span class=\"line\">setTimeout(() =&gt; &#123; </span><br><span class=\"line\">      /* code */ </span><br><span class=\"line\">&#125;, 0);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Immutable-API\"><a href=\"#Immutable-API\" class=\"headerlink\" title=\"Immutable API\"></a>Immutable API</h3><p>Once the object is created, I’m expecting its API to be immutable. I can easily change the implementation of a public method to do something else when it was created using a class.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">todoModel.reload = function() &#123; console.log(&quot;a new reload&quot;); &#125;</span><br><span class=\"line\">todoModel.reload();            //a new reload</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://jsfiddle.net/cristi_salcescu/y0k18og2/\" target=\"_blank\" rel=\"noopener\">This problem can be solved</a> by calling <code>Object.freeze(TodoModel.prototype)</code>after the class definition.</p>\n<p>The API of the object created using a factory function is immutable. Notice the use of <code>Object.freeze()</code> on the returned object containing only the public methods. The private data of the object can be modified, but only through these public methods.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">todoModel.reload = function() &#123; console.log(&quot;a new reload&quot;); &#125;</span><br><span class=\"line\">todoModel.reload();            //reload</span><br></pre></td></tr></table></figure>\n<h3 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new\"></a>new</h3><p><code>new</code> should be used when creating objects using classes.</p>\n<p><code>new</code> is not required when creating objects with factory functions, but if that makes it more readable, you can go for it, there is no harm.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var todoModel= new TodoModel();</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://jsfiddle.net/cristi_salcescu/4j8wpfhx/\" target=\"_blank\" rel=\"noopener\"><strong>Using</strong> </a><code>new</code><a href=\"https://jsfiddle.net/cristi_salcescu/4j8wpfhx/\" target=\"_blank\" rel=\"noopener\"> <strong>with a factory function</strong></a> <strong>will just return the object created by the factory.</strong></p>\n<h3 id=\"Composition-over-inheritance\"><a href=\"#Composition-over-inheritance\" class=\"headerlink\" title=\"Composition over inheritance\"></a>Composition over inheritance</h3><p>Classes support both inheritance and composition.</p>\n<p>Below is an <a href=\"https://jsfiddle.net/cristi_salcescu/1xo96yt8/\" target=\"_blank\" rel=\"noopener\">example of inheritance</a> where <code>SpecialService</code> class inherits from <code>Service</code> class:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Service &#123;</span><br><span class=\"line\">  doSomething()&#123; console.log(&quot;doSomething&quot;); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class SpecialService extends Service &#123;</span><br><span class=\"line\">  doSomethingElse()&#123; console.log(&quot;doSomethingElse&quot;); &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var specialService = new SpecialService();</span><br><span class=\"line\">specialService.doSomething();</span><br><span class=\"line\">specialService.doSomethingElse();</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://jsfiddle.net/cristi_salcescu/vwdwvvov/\" target=\"_blank\" rel=\"noopener\">Here is another example</a> where <code>SpecialService</code> reuses member of <code>Service</code>using composition:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Service &#123;</span><br><span class=\"line\">  doSomething()&#123; console.log(&quot;doSomething&quot;); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class SpecialService&#123;</span><br><span class=\"line\">  constructor(args)&#123;</span><br><span class=\"line\">    this.service = args.service;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  doSomething() &#123; this.service.doSomething(); &#125; </span><br><span class=\"line\">  </span><br><span class=\"line\">  doSomethingElse()&#123; console.log(&quot;doSomethingElse&quot;); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var specialService = new SpecialService(&#123;</span><br><span class=\"line\">   service : new Service()</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">specialService.doSomething();</span><br><span class=\"line\">specialService.doSomethingElse();</span><br></pre></td></tr></table></figure>\n<p>Factory functions promote composition over inheritance. <a href=\"https://jsfiddle.net/cristi_salcescu/jgbhkb4o/\" target=\"_blank\" rel=\"noopener\">Take a look at the next example</a> where <code>SpecialService</code> reuses members of <code>Service</code> :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Service() &#123;</span><br><span class=\"line\">  function doSomething()&#123; console.log(&quot;doSomething&quot;); &#125;</span><br><span class=\"line\">  return Object.freeze(&#123;</span><br><span class=\"line\">    doSomething</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function SpecialService(args)&#123;</span><br><span class=\"line\">  var service = args.service;</span><br><span class=\"line\">  function doSomethingElse()&#123; console.log(&quot;doSomethingElse&quot;); &#125;</span><br><span class=\"line\">  return Object.freeze(&#123;</span><br><span class=\"line\">    doSomething : service.doSomething,</span><br><span class=\"line\">    doSomethingElse</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var specialService = SpecialService(&#123;</span><br><span class=\"line\">   service : Service()</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">specialService.doSomething();</span><br><span class=\"line\">specialService.doSomethingElse();</span><br></pre></td></tr></table></figure>\n<h3 id=\"Memory\"><a href=\"#Memory\" class=\"headerlink\" title=\"Memory\"></a>Memory</h3><p>Classes are better at memory conservation, as they are implemented over the prototype system. All methods will be created only once in the prototype object and shared by all instances.</p>\n<p>The memory cost of the factory function is noticeable when creating thousands of the same object.</p>\n<p><a href=\"https://plnkr.co/edit/4cxGfN?p=info\" target=\"_blank\" rel=\"noopener\">Here is the page used for testing the memory cost</a> when using factory function.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The memory cost (in Chrome)</span><br><span class=\"line\">+-----------+------------+------------+</span><br><span class=\"line\">| Instances | 10 methods | 20 methods |</span><br><span class=\"line\">+-----------+---------------+---------+</span><br><span class=\"line\">| 10        | 0          |  0         |</span><br><span class=\"line\">| 100       | 0.1Mb      |  0.1Mb     |</span><br><span class=\"line\">| 1000      | 0.7Mb      |  1.4Mb     |</span><br><span class=\"line\">| 10000     | 7.3Mb      | 14.2Mb     |</span><br><span class=\"line\">+-----------+------------+------------+</span><br></pre></td></tr></table></figure>\n<h3 id=\"Objects-vs-Data-Structures\"><a href=\"#Objects-vs-Data-Structures\" class=\"headerlink\" title=\"Objects vs Data Structures\"></a>Objects vs Data Structures</h3><p>Before analyzing the memory cost any further, a distinction should be made between two kinds of objects:</p>\n<ul>\n<li>OOP Objects</li>\n<li>Data Objects (aka Data Structures)</li>\n</ul>\n<blockquote>\n<p>Objects expose behavior and hide data.</p>\n<p>Data Structures expose data and have no significant behavior.</p>\n<p>— <a href=\"https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882\" target=\"_blank\" rel=\"noopener\">Robert Martin “Clean Code”</a></p>\n</blockquote>\n<p>I’ll take a look again at the <code>TodoModel</code> example and explain these two kinds of objects.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function TodoModel()&#123;</span><br><span class=\"line\">    var todos = [];</span><br><span class=\"line\">           </span><br><span class=\"line\">    function add() &#123; &#125;</span><br><span class=\"line\">    function reload()&#123; &#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">    return Object.freeze(&#123;</span><br><span class=\"line\">        add,</span><br><span class=\"line\">        reload</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>TodoModel</code> is responsible for storing and managing the list of <code>todos</code>. <code>TodoModel</code> is the OOP Object, the one exposing behavior and hiding data. There will be only one instance of it in the application, so there’s no extra memory cost when using the factory function.</li>\n<li>The <code>todos</code> objects represent the Data Structures. There may be a lot of these objects, but they are just plain JavaScript objects. We are not interested in keeping their methods private — rather we actually want to expose all their data and methods. So all these objects will be built over the prototype system, and they will benefit from the memory conservation. They can be built using a simple object literal or <code>Object.create()</code> .</li>\n</ul>\n<h4 id=\"UI-Components\"><a href=\"#UI-Components\" class=\"headerlink\" title=\"UI Components\"></a>UI Components</h4><p>In the application, there may be hundreds or thousands of instances of a UI component. This is a situation where we need to make a trade-off between encapsulation and memory conservation.</p>\n<p>Components will be built according to the component framework practice. For example, object literals will be used for Vue, or classes for React. Each component’s members will be public, but they will benefit from the memory conservation of the prototype system.</p>\n<h3 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h3><p>The strong points of class are its familiarity for people coming from a class-based background and its nicer syntax over the prototype system. However, its security problems and the usage of <code>this</code>, a continuous source of losing context bugs, makes it a second option. As an exception, classes will be used if required by the component’s framework, as in the case of React.</p>\n<p>Factory function is not only the better option for creating secured, encapsulated, and flexible OOP Objects but also opens the door for a new, unique to JavaScript, programming paradigm.</p>\n<blockquote>\n<p>I think Class Free Object Oriented Programming is JavaScript’s gift to humanity.                                          </p>\n<p>— <a href=\"https://www.youtube.com/watch?v=DxnYQRuLX7Q&amp;feature=youtu.be&amp;t=45m41s\" target=\"_blank\" rel=\"noopener\">Douglas Crockford “The Better Parts”</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>一直以为ES6出了后，新特性都是值得推广、使用的，直到看了这篇文章，甚有醍醐灌顶之感，来不及翻译，直接转载过来（原文需要翻墙查看）</p>\n<p>原文地址：<a href=\"https://medium.freecodecamp.org/class-vs-factory-function-exploring-the-way-forward-73258b6a8d15\" target=\"_blank\" rel=\"noopener\"><strong>Class vs Factory function: exploring the way forward</strong></a></p>\n<hr>\n<p>ECMAScript 2015 (aka ES6) comes with the class syntax, so now we have two competing patterns for creating objects. In order to compare them, I’ll create the same object definition (TodoModel) as a class, and then as a factory function.</p>\n<p><a href=\"https://jsfiddle.net/cristi_salcescu/m9dhpzfx/\" target=\"_blank\" rel=\"noopener\"><strong>TodoModel as a Class</strong></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TodoModel &#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        this.todos = [];</span><br><span class=\"line\">        this.lastChange = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    addToPrivateList()&#123;</span><br><span class=\"line\">        console.log(&quot;addToPrivateList&quot;); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    add() &#123; console.log(&quot;add&quot;); &#125;</span><br><span class=\"line\">    reload()&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://jsfiddle.net/cristi_salcescu/bcta6yyv/\" target=\"_blank\" rel=\"noopener\"><strong>TodoModel as a Factory Function</strong></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function TodoModel()&#123;</span><br><span class=\"line\">    var todos = [];</span><br><span class=\"line\">    var lastChange = null;</span><br><span class=\"line\">        </span><br><span class=\"line\">    function addToPrivateList()&#123;</span><br><span class=\"line\">        console.log(&quot;addToPrivateList&quot;); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    function add() &#123; console.log(&quot;add&quot;); &#125;</span><br><span class=\"line\">    function reload()&#123;&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return Object.freeze(&#123;</span><br><span class=\"line\">        add,</span><br><span class=\"line\">        reload</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Encapsulation\"><a href=\"#Encapsulation\" class=\"headerlink\" title=\"Encapsulation\"></a>Encapsulation</h3><p>The first thing we notice is that all members, fields, and methods of a class object are public.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var todoModel = new TodoModel();</span><br><span class=\"line\">console.log(todoModel.todos);     //[]</span><br><span class=\"line\">console.log(todoModel.lastChange) //null</span><br><span class=\"line\">todoModel.addToPrivateList();     //addToPrivateList</span><br></pre></td></tr></table></figure>\n<p>The lack of encapsulation may create security problems. Take the example of a global object that can be modified directly from the Developer Console.</p>\n<p>When using factory function, only the methods we expose are public, everything else is encapsulated.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var todoModel = TodoModel();</span><br><span class=\"line\">console.log(todoModel.todos);     //undefined</span><br><span class=\"line\">console.log(todoModel.lastChange) //undefined</span><br><span class=\"line\">todoModel.addToPrivateList();     //taskModel.addToPrivateList</span><br><span class=\"line\">                                    is not a function</span><br></pre></td></tr></table></figure>\n<h3 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h3><p><code>this</code> losing context problems are still there when using class. For example, <code>this</code> is losing context in nested functions. It is not only annoying during coding, but it’s also a constant source of bugs.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class TodoModel &#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        this.todos = [];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    reload()&#123; </span><br><span class=\"line\">        setTimeout(function log() &#123; </span><br><span class=\"line\">           console.log(this.todos);    //undefined</span><br><span class=\"line\">        &#125;, 0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">todoModel.reload();                   //undefined</span><br></pre></td></tr></table></figure>\n<p>or <code>this</code> is losing context when the method is used as a callback, like on a DOM event.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$(&quot;#btn&quot;).click(todoModel.reload);    //undefined</span><br></pre></td></tr></table></figure>\n<p>There are no such problems when using a factory function, as it doesn’t use <code>this</code> at all.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function TodoModel()&#123;</span><br><span class=\"line\">    var todos = [];</span><br><span class=\"line\">        </span><br><span class=\"line\">    function reload()&#123; </span><br><span class=\"line\">        setTimeout(function log() &#123; </span><br><span class=\"line\">           console.log(todos);        //[]</span><br><span class=\"line\">       &#125;, 0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">todoModel.reload();                   //[]</span><br><span class=\"line\">$(&quot;#btn&quot;).click(todoModel.reload);    //[]</span><br></pre></td></tr></table></figure>\n<h4 id=\"this-and-arrow-function\"><a href=\"#this-and-arrow-function\" class=\"headerlink\" title=\"this and arrow function\"></a>this and arrow function</h4><p>The arrow function partially solves the <code>this</code> loosing context issues in classes, but at the same time creates a new problem:</p>\n<ul>\n<li><code>this</code> is no longer loosing context in nested functions</li>\n<li><code>this</code> is loosing context when the method is used as a callback</li>\n<li>arrow function promotes the use of anonymous functions</li>\n</ul>\n<p><a href=\"https://jsfiddle.net/cristi_salcescu/y0k18og2/\" target=\"_blank\" rel=\"noopener\">I refactored the </a><code>TodoModel</code><a href=\"https://jsfiddle.net/cristi_salcescu/y0k18og2/\" target=\"_blank\" rel=\"noopener\"> using the arrow function</a>. It’s important to note that in the process of refactoring to the arrow function we can loose something very important for readability, the function name. <a href=\"https://jsfiddle.net/cristi_salcescu/y0k18og2/\" target=\"_blank\" rel=\"noopener\">Look for example</a> at:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//using function name to express intent</span><br><span class=\"line\">setTimeout(function renderTodosForReview() &#123; </span><br><span class=\"line\">      /* code */ </span><br><span class=\"line\">&#125;, 0);</span><br><span class=\"line\">//versus using an anonymous function</span><br><span class=\"line\">setTimeout(() =&gt; &#123; </span><br><span class=\"line\">      /* code */ </span><br><span class=\"line\">&#125;, 0);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Immutable-API\"><a href=\"#Immutable-API\" class=\"headerlink\" title=\"Immutable API\"></a>Immutable API</h3><p>Once the object is created, I’m expecting its API to be immutable. I can easily change the implementation of a public method to do something else when it was created using a class.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">todoModel.reload = function() &#123; console.log(&quot;a new reload&quot;); &#125;</span><br><span class=\"line\">todoModel.reload();            //a new reload</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://jsfiddle.net/cristi_salcescu/y0k18og2/\" target=\"_blank\" rel=\"noopener\">This problem can be solved</a> by calling <code>Object.freeze(TodoModel.prototype)</code>after the class definition.</p>\n<p>The API of the object created using a factory function is immutable. Notice the use of <code>Object.freeze()</code> on the returned object containing only the public methods. The private data of the object can be modified, but only through these public methods.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">todoModel.reload = function() &#123; console.log(&quot;a new reload&quot;); &#125;</span><br><span class=\"line\">todoModel.reload();            //reload</span><br></pre></td></tr></table></figure>\n<h3 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new\"></a>new</h3><p><code>new</code> should be used when creating objects using classes.</p>\n<p><code>new</code> is not required when creating objects with factory functions, but if that makes it more readable, you can go for it, there is no harm.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var todoModel= new TodoModel();</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://jsfiddle.net/cristi_salcescu/4j8wpfhx/\" target=\"_blank\" rel=\"noopener\"><strong>Using</strong> </a><code>new</code><a href=\"https://jsfiddle.net/cristi_salcescu/4j8wpfhx/\" target=\"_blank\" rel=\"noopener\"> <strong>with a factory function</strong></a> <strong>will just return the object created by the factory.</strong></p>\n<h3 id=\"Composition-over-inheritance\"><a href=\"#Composition-over-inheritance\" class=\"headerlink\" title=\"Composition over inheritance\"></a>Composition over inheritance</h3><p>Classes support both inheritance and composition.</p>\n<p>Below is an <a href=\"https://jsfiddle.net/cristi_salcescu/1xo96yt8/\" target=\"_blank\" rel=\"noopener\">example of inheritance</a> where <code>SpecialService</code> class inherits from <code>Service</code> class:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Service &#123;</span><br><span class=\"line\">  doSomething()&#123; console.log(&quot;doSomething&quot;); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class SpecialService extends Service &#123;</span><br><span class=\"line\">  doSomethingElse()&#123; console.log(&quot;doSomethingElse&quot;); &#125;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var specialService = new SpecialService();</span><br><span class=\"line\">specialService.doSomething();</span><br><span class=\"line\">specialService.doSomethingElse();</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://jsfiddle.net/cristi_salcescu/vwdwvvov/\" target=\"_blank\" rel=\"noopener\">Here is another example</a> where <code>SpecialService</code> reuses member of <code>Service</code>using composition:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Service &#123;</span><br><span class=\"line\">  doSomething()&#123; console.log(&quot;doSomething&quot;); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class SpecialService&#123;</span><br><span class=\"line\">  constructor(args)&#123;</span><br><span class=\"line\">    this.service = args.service;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  doSomething() &#123; this.service.doSomething(); &#125; </span><br><span class=\"line\">  </span><br><span class=\"line\">  doSomethingElse()&#123; console.log(&quot;doSomethingElse&quot;); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var specialService = new SpecialService(&#123;</span><br><span class=\"line\">   service : new Service()</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">specialService.doSomething();</span><br><span class=\"line\">specialService.doSomethingElse();</span><br></pre></td></tr></table></figure>\n<p>Factory functions promote composition over inheritance. <a href=\"https://jsfiddle.net/cristi_salcescu/jgbhkb4o/\" target=\"_blank\" rel=\"noopener\">Take a look at the next example</a> where <code>SpecialService</code> reuses members of <code>Service</code> :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Service() &#123;</span><br><span class=\"line\">  function doSomething()&#123; console.log(&quot;doSomething&quot;); &#125;</span><br><span class=\"line\">  return Object.freeze(&#123;</span><br><span class=\"line\">    doSomething</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function SpecialService(args)&#123;</span><br><span class=\"line\">  var service = args.service;</span><br><span class=\"line\">  function doSomethingElse()&#123; console.log(&quot;doSomethingElse&quot;); &#125;</span><br><span class=\"line\">  return Object.freeze(&#123;</span><br><span class=\"line\">    doSomething : service.doSomething,</span><br><span class=\"line\">    doSomethingElse</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var specialService = SpecialService(&#123;</span><br><span class=\"line\">   service : Service()</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">specialService.doSomething();</span><br><span class=\"line\">specialService.doSomethingElse();</span><br></pre></td></tr></table></figure>\n<h3 id=\"Memory\"><a href=\"#Memory\" class=\"headerlink\" title=\"Memory\"></a>Memory</h3><p>Classes are better at memory conservation, as they are implemented over the prototype system. All methods will be created only once in the prototype object and shared by all instances.</p>\n<p>The memory cost of the factory function is noticeable when creating thousands of the same object.</p>\n<p><a href=\"https://plnkr.co/edit/4cxGfN?p=info\" target=\"_blank\" rel=\"noopener\">Here is the page used for testing the memory cost</a> when using factory function.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The memory cost (in Chrome)</span><br><span class=\"line\">+-----------+------------+------------+</span><br><span class=\"line\">| Instances | 10 methods | 20 methods |</span><br><span class=\"line\">+-----------+---------------+---------+</span><br><span class=\"line\">| 10        | 0          |  0         |</span><br><span class=\"line\">| 100       | 0.1Mb      |  0.1Mb     |</span><br><span class=\"line\">| 1000      | 0.7Mb      |  1.4Mb     |</span><br><span class=\"line\">| 10000     | 7.3Mb      | 14.2Mb     |</span><br><span class=\"line\">+-----------+------------+------------+</span><br></pre></td></tr></table></figure>\n<h3 id=\"Objects-vs-Data-Structures\"><a href=\"#Objects-vs-Data-Structures\" class=\"headerlink\" title=\"Objects vs Data Structures\"></a>Objects vs Data Structures</h3><p>Before analyzing the memory cost any further, a distinction should be made between two kinds of objects:</p>\n<ul>\n<li>OOP Objects</li>\n<li>Data Objects (aka Data Structures)</li>\n</ul>\n<blockquote>\n<p>Objects expose behavior and hide data.</p>\n<p>Data Structures expose data and have no significant behavior.</p>\n<p>— <a href=\"https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882\" target=\"_blank\" rel=\"noopener\">Robert Martin “Clean Code”</a></p>\n</blockquote>\n<p>I’ll take a look again at the <code>TodoModel</code> example and explain these two kinds of objects.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function TodoModel()&#123;</span><br><span class=\"line\">    var todos = [];</span><br><span class=\"line\">           </span><br><span class=\"line\">    function add() &#123; &#125;</span><br><span class=\"line\">    function reload()&#123; &#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">    return Object.freeze(&#123;</span><br><span class=\"line\">        add,</span><br><span class=\"line\">        reload</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>TodoModel</code> is responsible for storing and managing the list of <code>todos</code>. <code>TodoModel</code> is the OOP Object, the one exposing behavior and hiding data. There will be only one instance of it in the application, so there’s no extra memory cost when using the factory function.</li>\n<li>The <code>todos</code> objects represent the Data Structures. There may be a lot of these objects, but they are just plain JavaScript objects. We are not interested in keeping their methods private — rather we actually want to expose all their data and methods. So all these objects will be built over the prototype system, and they will benefit from the memory conservation. They can be built using a simple object literal or <code>Object.create()</code> .</li>\n</ul>\n<h4 id=\"UI-Components\"><a href=\"#UI-Components\" class=\"headerlink\" title=\"UI Components\"></a>UI Components</h4><p>In the application, there may be hundreds or thousands of instances of a UI component. This is a situation where we need to make a trade-off between encapsulation and memory conservation.</p>\n<p>Components will be built according to the component framework practice. For example, object literals will be used for Vue, or classes for React. Each component’s members will be public, but they will benefit from the memory conservation of the prototype system.</p>\n<h3 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h3><p>The strong points of class are its familiarity for people coming from a class-based background and its nicer syntax over the prototype system. However, its security problems and the usage of <code>this</code>, a continuous source of losing context bugs, makes it a second option. As an exception, classes will be used if required by the component’s framework, as in the case of React.</p>\n<p>Factory function is not only the better option for creating secured, encapsulated, and flexible OOP Objects but also opens the door for a new, unique to JavaScript, programming paradigm.</p>\n<blockquote>\n<p>I think Class Free Object Oriented Programming is JavaScript’s gift to humanity.                                          </p>\n<p>— <a href=\"https://www.youtube.com/watch?v=DxnYQRuLX7Q&amp;feature=youtu.be&amp;t=45m41s\" target=\"_blank\" rel=\"noopener\">Douglas Crockford “The Better Parts”</a></p>\n</blockquote>\n"},{"layout":"post","title":"VK的秋招前端奇遇记(四)","subtitle":"","date":"2018-09-04T14:11:00.000Z","author":"Vinecnt Ko","header-img":"img/home-bg-o.jpg","header-mask":0.3,"catalog":true,"_content":"\n\n\n嗯，上次写blog已经是几周前的事情了，其实已经积攒了很多小问题需要记录和分享了。但是在8月底，VK我一次经历了了携程、拼多多、腾讯、网易等多轮面试轰炸，忙得不可开交，有喜有忧的同时，还是赶快记录了不足，把一些充满迷惑性的问题继续记录和学习。\n\nJavaScript总是给人以惊喜，学习不止，进步不断，今天继续补充JS容易搞错的几道笔试/面试题，为了秋招继续努力，欢迎一起为秋招努力的小伙伴共勉\n\n系列笔记：\n\n[1.VK的秋招前端奇遇记(一)](https://forrany.github.io/2018/08/10/VK-mistake(1)/)\n\n[2.VK的秋招前端奇遇记(二)](https://forrany.github.io/2018/08/11/VK-mistake(2)/)\n\n[3.VK的秋招前端奇遇记(三)](https://forrany.github.io/2018/08/12/VK-mistake(3)/)\n\n[4.VK的秋招前端奇遇记(四)](https://forrany.github.io/2018/09/04/VK-mistake(4)/)\n\n[5.番外篇：前端面试&笔试算法 Algorithm](https://forrany.github.io/2018/08/21/front-end-interview-algorithm/)\n\n---\n\n### 面试&常识题\n\n#### Q1. forEach 与 map的区别？ forEach不支持中断循环？\n\n**这是一道巨坑的题目**\n\n先看下很多博客、文章总结的一个关于循环的区别是怎么说的\n\n> 1. map可以做链式操作、forEach不可以\n> 2. map有返回值,return、 forEach没有返回值\n> 3. for循环不用担心兼容性问题，可以break跳出循环，是基础循环\n> 4. forEach不支持continue和break，是不能退出循环本身的。\n\n上面这些比较，本身没有什么问题，但是当第三点和第四点结合的时候，就很容易让人有个推论：\n\n**map是可以跳出循环的，可以提前中断**\n\n然而，也的确有些面试官，认为`forEach不能break，map是可以的跳出的`。 真的是这样的？\n\n首先，众所周知，`forEach`是不能用break提前中断循环的，如果使用了，会直接报错。比如以下：\n\n```javascript\nvar list = [1,2,3,4];\nlist.forEach(item => {\n    if(item === 2) {\n        break;\n    }\n} )\n```\n\n但是，如果真的想要中止？ 因为会报错，这也提供给我们一个思路，那就是用`try..catch`把它保住，捕获错误。 但是，个人认为真是多此一举，应该没人会这么用。就不多做讨论了。\n\n那么`map`可以用break吗？\n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fuxwu0ajqyj20l107074h.jpg)\n\n很显然，它也不行。所以如果有面试官问你，甚至告诉你\"forEach和map的不同，forEach不可以中止\"时，你真的可以大胆回击：\n\n* 想要用`Array.prototype.map`实现break,也是完全不可能的\n* map中文翻译为映射，所谓映射，当然是把数组中每个值进行映射处理，有何理由中断循环，特殊处理？\n\n#### Q2. 对象与继承\n\n请问以下程序中，`person1`和`person2`哪个是Person的实例？其`__proto__`分别指向谁?\n\n```javascript\nfunction Person(name) {\n    this.name = name;\n    return {name: name}\n}\nvar person1 = new Person('sam');\nvar person2 = Person('Lily')\n```\n\n##### Ans\n\n```javascript\nperson1和person2都不是Person的实例\n它们的'__proto__'指向Object\n```\n\n这题题目的关键就是理解`new`的过程，这也是常见的面试题之一了。如果遇到关键字`new`，那么，函数就不单单是一个函数了：\n\n* 函数执行，首先隐式建立对象`this`\n* 执行，绑定this相关的属性,本例中`this.name = name`\n* 函数最后，隐式的return`this`\n\n当然，这里简化了这个过程，但是核心是这几步。 但是如果在隐式返回`this`之前，提前返回了一个对象，那么就会退出函数了。 要知道，只有这个`this`才是实例本身，它的`__proto__`才指向构造函数，如果不能把`this`返回出去，那么一切都是徒劳的。因此，这里无论是否`new`，都返回的是一个新对象`{}`。\n\n#### Q3. 垃圾回收机制方式及内存管理（爱奇艺2018提前批二面）\n\n这里，自己当时回答的不好，就引用别人博客整理的内容啦.\n\n##### 回收机制方式\n\n1. 定义和用法：垃圾回收机制(GC:Garbage Collection),执行环境负责管理代码执行过程中使用的内存。\n\n2. 原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。\n\n3. 实例如下：\n\n```javascript\nfunction fn1() {\n    var obj = {name: 'hanzichi', age: 10};\n}\nfunction fn2() {\n    var obj = {name:'hanzichi', age: 10};\n   return obj;\n}\nvar a = fn1();\nvar b = fn2();\n```\n\nfn1中定义的obj为局部变量，而当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放；在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放。\n\n4. 垃圾回收策略：标记清除(较为常用)和引用计数。\n\n**标记清除：**\n\n定义和用法：当变量进入环境时，将变量标记\"进入环境\"，当变量离开环境时，标记为：\"离开环境\"。某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量。\n\n到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。\n\n**引用计数：**\n\n定义和用法：引用计数是跟踪记录每个值被引用的次数。\n\n基本原理：就是变量的引用次数，被引用一次则加1，当这个引用计数为0时，被视为准备回收的对象。\n\n##### 内存管理\n\n1. 什么时候触发垃圾回收？\n\n垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。\n\nIE6的垃圾回收是根据内存分配量运行的，当环境中的变量，对象，字符串达到一定数量时触发垃圾回收。垃圾回收器一直处于工作状态，严重影响浏览器性能。\n\nIE7中，垃圾回收器会根据内存分配量与程序占用内存的比例进行动态调整，开始回收工作。\n\n2. 合理的GC方案：(1)、遍历所有可访问的对象; (2)、回收已不可访问的对象。\n3. GC缺陷：(1)、停止响应其他操作；\n4. GC优化策略：(1)、分代回收（Generation GC）;(2)、增量GC\n\n说实话，这一块，自己没有很好的整理，但是目前准备秋招和毕设，没有更多的经历，只能待有空再深入学习研究了。\n\n### 编程题\n\n#### Q1. 表格排序\n\n请将以下表格，按年龄进行排序，使用原生JS，不允许使用任何第三方工具。\n\n```html\n<table>\n        <thead>\n            <tr>\n                <th>name</th>\n                <th>age</th>\n            </tr>\n        </thead>\n        <tbody>\n            <tr>\n                <td>张三</td>\n                <td>17</td>\n            </tr>\n            <tr>\n                <td>李四</td>\n                <td>43</td>\n            </tr>\n            <tr>\n                <td>王五</td>\n                <td>22</td>\n            </tr>\n            <tr>\n                <td>小刘</td>\n                <td>9</td>\n            </tr>\n            <tr>\n                <td>黄三</td>\n                <td>20</td>\n            </tr>\n        </tbody>\n    </table>\n```\n\n##### Ans:\n\n这个其实很easy了，只是我在写的时候，还是调试了好几次，这里主要两点：\n\n* 通过`document.getElementsBytagNames`选择的对象，在dom的映射机制下，是双双绑定的；\n* 使用`dom.appendChild()`方法，要保证参数是node节点。\n* `Array.sort()`方法，注意，只能用在Array上。\n\n```javascript\nvar sortByAge = function () {\n            var tbody = document.getElementsByTagName('tbody')[0];\n            var items = tbody.getElementsByTagName('tr');\n            let arrayI = Array(...items); //将类数组转化为数组，使用sort方法\n            arrayI.sort((a,b)=> {\n                let ageA = a.getElementsByTagName('td')[1].innerText;\n                let ageB = b.getElementsByTagName('td')[1].innerText;\n                return ageA - ageB;\n            })\n           for(let i = 0; i<items.length; i++) {\n               tbody.appendChild(arrayI[i]); //依次插入，这里arrayI的每一个元素都是原来的dom映射过来的实例。所以并不是“创造”出了复制品，而是重新排序了\n           }\n        }\nsortByAge();\n```\n\n#### Q2.时间'0101'转换为正常时间值(杭州有赞2018秋招二面在线编程)\n\n一天24小时，我们将其折为每30分钟为一段，这样一天共有48段。我们用1表示这段时间有效，0表示无效，比如`10...`  表示开始时间为`00:00` 持续了半个小时,技术时间为`00:30`。`111001..` 则表示`00:00~01:30` `02:30~03:00`两个时间段。\n\n要求写一个函数，对时间码进行转换：\n\n输入：`110100000000000000000000000000000000000000000000`\n\n输出： `[\"00:30~01:30\", \"01:00~02:00\"]`\n\n##### Ans\n\n这个是我视频面试时的一道编程题，由于时间紧，面对面试官有点小压力，所以就用了比较笨的方法实现了，后来也没有重新思考和优化，有好的思路和简单的方法的小伙伴欢迎交流。\n\n以下思路：\n\n* 遍历输入字符串\n* 当为1，判断是否为第一次，如果是第一次，根据index，记录`startTime`；如果不是第一次，进行`time`累加\n* 当为0，判断之前是否为1，如果之前是1，则根据`time`值进行累加，计算`endTime`，并将时间段push到数组\n* 判断是否为第一次、判断之前是否为1，主要通过一个flag进行记录。\n\n根据上面思路，代码如下:\n\n```javascript\nfunction timeTransfer(str) {\n            var flag = false,  //flag，判断是否第一次为1\n                time = 0,   //时间记录值\n                n = str.length,\n                startTime, //开始时间\n                startHour, //开始的小时\n                startMin,  //开始的分钟\n                endTime,  //结束时间\n                endHour,  //结束的小时\n                endMin,  //结束的分钟\n                retTime = [];  //最终返回的数组\n            for(let i = 0 ; i < n; i++) {\n                if(str[i] === '1') {\n                    if(flag === false) {  //判断是否为第一个1，如果是，根据i设定开始时间\n                        startHour = parseInt(i/2);\n                        startMin = i % 2 ? 0:30;\n                        startTime = `${startHour > 9? startHour: '0' + startHour}:${startMin > 9 ? startMin : '0' + startMin}`;\n                        flag = true;   //置位 flag\n                    }\n                    time += 0.5;  //时间累加\n                    if(i === n-1) {  //如果已经遍历到最后，那么计算结束时间(当str的末尾为1时，需要处理)\n                        endHour = startHour + parseInt(time);\n                        endMin = startMin + (time % 2 ? 0 : 30);\n                        endTime = `${endHour > 9 ? endHour : '0' + endHour}:${endMin > 9 ? endMin : '0' + endMin}`;\n                        retTime.push(`${startTime}~${endTime}`);\n                    }\n                } else if (str[i] === '0') {\n                    if(flag === false) { //如果为flase，代表前面不是1，继续下次循环\n                        continue;\n                    } else {   //否则，计算结束时间\n                        flag = false;\n                        endHour = startHour + parseInt(time);\n                        endMin = startMin + (time % 2 ? 0 : 30);\n                        endTime = `${endHour > 9 ? endHour : '0' + endHour}:${endMin > 9 ? endMin : '0' + endMin}`;\n                        retTime.push(`${startTime}~${endTime}`);\n                    }\n                }\n            }\n            return retTime;\n        }\n```\n\n以上程序，是跑通了的，虽然有点笨，但是勉强满足要求。\n\n\n\n### 参考资料\n\n1. [csdn wdlhao的博客](https://blog.csdn.net/wdlhao/article/details/79079660)","source":"_posts/2018-09-04-VK-mistake(4).md","raw":"---\nlayout:     post\ntitle:      \"VK的秋招前端奇遇记(四)\"\nsubtitle:   \"\"\ndate:       2018-09-04 22:11:00\nauthor:     \"Vinecnt Ko\"\nheader-img: \"img/home-bg-o.jpg\"\nheader-mask: 0.3\ncatalog:    true\ntags:\n    - 前端面试\n    - JavaScript\n    - 前端笔试\n---\n\n\n\n嗯，上次写blog已经是几周前的事情了，其实已经积攒了很多小问题需要记录和分享了。但是在8月底，VK我一次经历了了携程、拼多多、腾讯、网易等多轮面试轰炸，忙得不可开交，有喜有忧的同时，还是赶快记录了不足，把一些充满迷惑性的问题继续记录和学习。\n\nJavaScript总是给人以惊喜，学习不止，进步不断，今天继续补充JS容易搞错的几道笔试/面试题，为了秋招继续努力，欢迎一起为秋招努力的小伙伴共勉\n\n系列笔记：\n\n[1.VK的秋招前端奇遇记(一)](https://forrany.github.io/2018/08/10/VK-mistake(1)/)\n\n[2.VK的秋招前端奇遇记(二)](https://forrany.github.io/2018/08/11/VK-mistake(2)/)\n\n[3.VK的秋招前端奇遇记(三)](https://forrany.github.io/2018/08/12/VK-mistake(3)/)\n\n[4.VK的秋招前端奇遇记(四)](https://forrany.github.io/2018/09/04/VK-mistake(4)/)\n\n[5.番外篇：前端面试&笔试算法 Algorithm](https://forrany.github.io/2018/08/21/front-end-interview-algorithm/)\n\n---\n\n### 面试&常识题\n\n#### Q1. forEach 与 map的区别？ forEach不支持中断循环？\n\n**这是一道巨坑的题目**\n\n先看下很多博客、文章总结的一个关于循环的区别是怎么说的\n\n> 1. map可以做链式操作、forEach不可以\n> 2. map有返回值,return、 forEach没有返回值\n> 3. for循环不用担心兼容性问题，可以break跳出循环，是基础循环\n> 4. forEach不支持continue和break，是不能退出循环本身的。\n\n上面这些比较，本身没有什么问题，但是当第三点和第四点结合的时候，就很容易让人有个推论：\n\n**map是可以跳出循环的，可以提前中断**\n\n然而，也的确有些面试官，认为`forEach不能break，map是可以的跳出的`。 真的是这样的？\n\n首先，众所周知，`forEach`是不能用break提前中断循环的，如果使用了，会直接报错。比如以下：\n\n```javascript\nvar list = [1,2,3,4];\nlist.forEach(item => {\n    if(item === 2) {\n        break;\n    }\n} )\n```\n\n但是，如果真的想要中止？ 因为会报错，这也提供给我们一个思路，那就是用`try..catch`把它保住，捕获错误。 但是，个人认为真是多此一举，应该没人会这么用。就不多做讨论了。\n\n那么`map`可以用break吗？\n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fuxwu0ajqyj20l107074h.jpg)\n\n很显然，它也不行。所以如果有面试官问你，甚至告诉你\"forEach和map的不同，forEach不可以中止\"时，你真的可以大胆回击：\n\n* 想要用`Array.prototype.map`实现break,也是完全不可能的\n* map中文翻译为映射，所谓映射，当然是把数组中每个值进行映射处理，有何理由中断循环，特殊处理？\n\n#### Q2. 对象与继承\n\n请问以下程序中，`person1`和`person2`哪个是Person的实例？其`__proto__`分别指向谁?\n\n```javascript\nfunction Person(name) {\n    this.name = name;\n    return {name: name}\n}\nvar person1 = new Person('sam');\nvar person2 = Person('Lily')\n```\n\n##### Ans\n\n```javascript\nperson1和person2都不是Person的实例\n它们的'__proto__'指向Object\n```\n\n这题题目的关键就是理解`new`的过程，这也是常见的面试题之一了。如果遇到关键字`new`，那么，函数就不单单是一个函数了：\n\n* 函数执行，首先隐式建立对象`this`\n* 执行，绑定this相关的属性,本例中`this.name = name`\n* 函数最后，隐式的return`this`\n\n当然，这里简化了这个过程，但是核心是这几步。 但是如果在隐式返回`this`之前，提前返回了一个对象，那么就会退出函数了。 要知道，只有这个`this`才是实例本身，它的`__proto__`才指向构造函数，如果不能把`this`返回出去，那么一切都是徒劳的。因此，这里无论是否`new`，都返回的是一个新对象`{}`。\n\n#### Q3. 垃圾回收机制方式及内存管理（爱奇艺2018提前批二面）\n\n这里，自己当时回答的不好，就引用别人博客整理的内容啦.\n\n##### 回收机制方式\n\n1. 定义和用法：垃圾回收机制(GC:Garbage Collection),执行环境负责管理代码执行过程中使用的内存。\n\n2. 原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。\n\n3. 实例如下：\n\n```javascript\nfunction fn1() {\n    var obj = {name: 'hanzichi', age: 10};\n}\nfunction fn2() {\n    var obj = {name:'hanzichi', age: 10};\n   return obj;\n}\nvar a = fn1();\nvar b = fn2();\n```\n\nfn1中定义的obj为局部变量，而当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放；在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放。\n\n4. 垃圾回收策略：标记清除(较为常用)和引用计数。\n\n**标记清除：**\n\n定义和用法：当变量进入环境时，将变量标记\"进入环境\"，当变量离开环境时，标记为：\"离开环境\"。某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量。\n\n到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。\n\n**引用计数：**\n\n定义和用法：引用计数是跟踪记录每个值被引用的次数。\n\n基本原理：就是变量的引用次数，被引用一次则加1，当这个引用计数为0时，被视为准备回收的对象。\n\n##### 内存管理\n\n1. 什么时候触发垃圾回收？\n\n垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。\n\nIE6的垃圾回收是根据内存分配量运行的，当环境中的变量，对象，字符串达到一定数量时触发垃圾回收。垃圾回收器一直处于工作状态，严重影响浏览器性能。\n\nIE7中，垃圾回收器会根据内存分配量与程序占用内存的比例进行动态调整，开始回收工作。\n\n2. 合理的GC方案：(1)、遍历所有可访问的对象; (2)、回收已不可访问的对象。\n3. GC缺陷：(1)、停止响应其他操作；\n4. GC优化策略：(1)、分代回收（Generation GC）;(2)、增量GC\n\n说实话，这一块，自己没有很好的整理，但是目前准备秋招和毕设，没有更多的经历，只能待有空再深入学习研究了。\n\n### 编程题\n\n#### Q1. 表格排序\n\n请将以下表格，按年龄进行排序，使用原生JS，不允许使用任何第三方工具。\n\n```html\n<table>\n        <thead>\n            <tr>\n                <th>name</th>\n                <th>age</th>\n            </tr>\n        </thead>\n        <tbody>\n            <tr>\n                <td>张三</td>\n                <td>17</td>\n            </tr>\n            <tr>\n                <td>李四</td>\n                <td>43</td>\n            </tr>\n            <tr>\n                <td>王五</td>\n                <td>22</td>\n            </tr>\n            <tr>\n                <td>小刘</td>\n                <td>9</td>\n            </tr>\n            <tr>\n                <td>黄三</td>\n                <td>20</td>\n            </tr>\n        </tbody>\n    </table>\n```\n\n##### Ans:\n\n这个其实很easy了，只是我在写的时候，还是调试了好几次，这里主要两点：\n\n* 通过`document.getElementsBytagNames`选择的对象，在dom的映射机制下，是双双绑定的；\n* 使用`dom.appendChild()`方法，要保证参数是node节点。\n* `Array.sort()`方法，注意，只能用在Array上。\n\n```javascript\nvar sortByAge = function () {\n            var tbody = document.getElementsByTagName('tbody')[0];\n            var items = tbody.getElementsByTagName('tr');\n            let arrayI = Array(...items); //将类数组转化为数组，使用sort方法\n            arrayI.sort((a,b)=> {\n                let ageA = a.getElementsByTagName('td')[1].innerText;\n                let ageB = b.getElementsByTagName('td')[1].innerText;\n                return ageA - ageB;\n            })\n           for(let i = 0; i<items.length; i++) {\n               tbody.appendChild(arrayI[i]); //依次插入，这里arrayI的每一个元素都是原来的dom映射过来的实例。所以并不是“创造”出了复制品，而是重新排序了\n           }\n        }\nsortByAge();\n```\n\n#### Q2.时间'0101'转换为正常时间值(杭州有赞2018秋招二面在线编程)\n\n一天24小时，我们将其折为每30分钟为一段，这样一天共有48段。我们用1表示这段时间有效，0表示无效，比如`10...`  表示开始时间为`00:00` 持续了半个小时,技术时间为`00:30`。`111001..` 则表示`00:00~01:30` `02:30~03:00`两个时间段。\n\n要求写一个函数，对时间码进行转换：\n\n输入：`110100000000000000000000000000000000000000000000`\n\n输出： `[\"00:30~01:30\", \"01:00~02:00\"]`\n\n##### Ans\n\n这个是我视频面试时的一道编程题，由于时间紧，面对面试官有点小压力，所以就用了比较笨的方法实现了，后来也没有重新思考和优化，有好的思路和简单的方法的小伙伴欢迎交流。\n\n以下思路：\n\n* 遍历输入字符串\n* 当为1，判断是否为第一次，如果是第一次，根据index，记录`startTime`；如果不是第一次，进行`time`累加\n* 当为0，判断之前是否为1，如果之前是1，则根据`time`值进行累加，计算`endTime`，并将时间段push到数组\n* 判断是否为第一次、判断之前是否为1，主要通过一个flag进行记录。\n\n根据上面思路，代码如下:\n\n```javascript\nfunction timeTransfer(str) {\n            var flag = false,  //flag，判断是否第一次为1\n                time = 0,   //时间记录值\n                n = str.length,\n                startTime, //开始时间\n                startHour, //开始的小时\n                startMin,  //开始的分钟\n                endTime,  //结束时间\n                endHour,  //结束的小时\n                endMin,  //结束的分钟\n                retTime = [];  //最终返回的数组\n            for(let i = 0 ; i < n; i++) {\n                if(str[i] === '1') {\n                    if(flag === false) {  //判断是否为第一个1，如果是，根据i设定开始时间\n                        startHour = parseInt(i/2);\n                        startMin = i % 2 ? 0:30;\n                        startTime = `${startHour > 9? startHour: '0' + startHour}:${startMin > 9 ? startMin : '0' + startMin}`;\n                        flag = true;   //置位 flag\n                    }\n                    time += 0.5;  //时间累加\n                    if(i === n-1) {  //如果已经遍历到最后，那么计算结束时间(当str的末尾为1时，需要处理)\n                        endHour = startHour + parseInt(time);\n                        endMin = startMin + (time % 2 ? 0 : 30);\n                        endTime = `${endHour > 9 ? endHour : '0' + endHour}:${endMin > 9 ? endMin : '0' + endMin}`;\n                        retTime.push(`${startTime}~${endTime}`);\n                    }\n                } else if (str[i] === '0') {\n                    if(flag === false) { //如果为flase，代表前面不是1，继续下次循环\n                        continue;\n                    } else {   //否则，计算结束时间\n                        flag = false;\n                        endHour = startHour + parseInt(time);\n                        endMin = startMin + (time % 2 ? 0 : 30);\n                        endTime = `${endHour > 9 ? endHour : '0' + endHour}:${endMin > 9 ? endMin : '0' + endMin}`;\n                        retTime.push(`${startTime}~${endTime}`);\n                    }\n                }\n            }\n            return retTime;\n        }\n```\n\n以上程序，是跑通了的，虽然有点笨，但是勉强满足要求。\n\n\n\n### 参考资料\n\n1. [csdn wdlhao的博客](https://blog.csdn.net/wdlhao/article/details/79079660)","slug":"2018-09-04-VK-mistake-4","published":1,"updated":"2022-08-17T07:53:21.232Z","comments":1,"photos":[],"link":"","_id":"cl6xbhzk1000hzk08wqje27an","content":"<p>嗯，上次写blog已经是几周前的事情了，其实已经积攒了很多小问题需要记录和分享了。但是在8月底，VK我一次经历了了携程、拼多多、腾讯、网易等多轮面试轰炸，忙得不可开交，有喜有忧的同时，还是赶快记录了不足，把一些充满迷惑性的问题继续记录和学习。</p>\n<p>JavaScript总是给人以惊喜，学习不止，进步不断，今天继续补充JS容易搞错的几道笔试/面试题，为了秋招继续努力，欢迎一起为秋招努力的小伙伴共勉</p>\n<p>系列笔记：</p>\n<p><a href=\"https://forrany.github.io/2018/08/10/VK-mistake(1\" target=\"_blank\" rel=\"noopener\">1.VK的秋招前端奇遇记(一)</a>/)</p>\n<p><a href=\"https://forrany.github.io/2018/08/11/VK-mistake(2\" target=\"_blank\" rel=\"noopener\">2.VK的秋招前端奇遇记(二)</a>/)</p>\n<p><a href=\"https://forrany.github.io/2018/08/12/VK-mistake(3\" target=\"_blank\" rel=\"noopener\">3.VK的秋招前端奇遇记(三)</a>/)</p>\n<p><a href=\"https://forrany.github.io/2018/09/04/VK-mistake(4\" target=\"_blank\" rel=\"noopener\">4.VK的秋招前端奇遇记(四)</a>/)</p>\n<p><a href=\"https://forrany.github.io/2018/08/21/front-end-interview-algorithm/\" target=\"_blank\" rel=\"noopener\">5.番外篇：前端面试&amp;笔试算法 Algorithm</a></p>\n<hr>\n<h3 id=\"面试-amp-常识题\"><a href=\"#面试-amp-常识题\" class=\"headerlink\" title=\"面试&amp;常识题\"></a>面试&amp;常识题</h3><h4 id=\"Q1-forEach-与-map的区别？-forEach不支持中断循环？\"><a href=\"#Q1-forEach-与-map的区别？-forEach不支持中断循环？\" class=\"headerlink\" title=\"Q1. forEach 与 map的区别？ forEach不支持中断循环？\"></a>Q1. forEach 与 map的区别？ forEach不支持中断循环？</h4><p><strong>这是一道巨坑的题目</strong></p>\n<p>先看下很多博客、文章总结的一个关于循环的区别是怎么说的</p>\n<blockquote>\n<ol>\n<li>map可以做链式操作、forEach不可以</li>\n<li>map有返回值,return、 forEach没有返回值</li>\n<li>for循环不用担心兼容性问题，可以break跳出循环，是基础循环</li>\n<li>forEach不支持continue和break，是不能退出循环本身的。</li>\n</ol>\n</blockquote>\n<p>上面这些比较，本身没有什么问题，但是当第三点和第四点结合的时候，就很容易让人有个推论：</p>\n<p><strong>map是可以跳出循环的，可以提前中断</strong></p>\n<p>然而，也的确有些面试官，认为<code>forEach不能break，map是可以的跳出的</code>。 真的是这样的？</p>\n<p>首先，众所周知，<code>forEach</code>是不能用break提前中断循环的，如果使用了，会直接报错。比如以下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\">list.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(item === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; )</span><br></pre></td></tr></table></figure>\n<p>但是，如果真的想要中止？ 因为会报错，这也提供给我们一个思路，那就是用<code>try..catch</code>把它保住，捕获错误。 但是，个人认为真是多此一举，应该没人会这么用。就不多做讨论了。</p>\n<p>那么<code>map</code>可以用break吗？</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fuxwu0ajqyj20l107074h.jpg\" alt=\"\"></p>\n<p>很显然，它也不行。所以如果有面试官问你，甚至告诉你”forEach和map的不同，forEach不可以中止”时，你真的可以大胆回击：</p>\n<ul>\n<li>想要用<code>Array.prototype.map</code>实现break,也是完全不可能的</li>\n<li>map中文翻译为映射，所谓映射，当然是把数组中每个值进行映射处理，有何理由中断循环，特殊处理？</li>\n</ul>\n<h4 id=\"Q2-对象与继承\"><a href=\"#Q2-对象与继承\" class=\"headerlink\" title=\"Q2. 对象与继承\"></a>Q2. 对象与继承</h4><p>请问以下程序中，<code>person1</code>和<code>person2</code>哪个是Person的实例？其<code>__proto__</code>分别指向谁?</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"attr\">name</span>: name&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'sam'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = Person(<span class=\"string\">'Lily'</span>)</span><br></pre></td></tr></table></figure>\n<h5 id=\"Ans\"><a href=\"#Ans\" class=\"headerlink\" title=\"Ans\"></a>Ans</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">person1和person2都不是Person的实例</span><br><span class=\"line\">它们的<span class=\"string\">'__proto__'</span>指向<span class=\"built_in\">Object</span></span><br></pre></td></tr></table></figure>\n<p>这题题目的关键就是理解<code>new</code>的过程，这也是常见的面试题之一了。如果遇到关键字<code>new</code>，那么，函数就不单单是一个函数了：</p>\n<ul>\n<li>函数执行，首先隐式建立对象<code>this</code></li>\n<li>执行，绑定this相关的属性,本例中<code>this.name = name</code></li>\n<li>函数最后，隐式的return<code>this</code></li>\n</ul>\n<p>当然，这里简化了这个过程，但是核心是这几步。 但是如果在隐式返回<code>this</code>之前，提前返回了一个对象，那么就会退出函数了。 要知道，只有这个<code>this</code>才是实例本身，它的<code>__proto__</code>才指向构造函数，如果不能把<code>this</code>返回出去，那么一切都是徒劳的。因此，这里无论是否<code>new</code>，都返回的是一个新对象<code>{}</code>。</p>\n<h4 id=\"Q3-垃圾回收机制方式及内存管理（爱奇艺2018提前批二面）\"><a href=\"#Q3-垃圾回收机制方式及内存管理（爱奇艺2018提前批二面）\" class=\"headerlink\" title=\"Q3. 垃圾回收机制方式及内存管理（爱奇艺2018提前批二面）\"></a>Q3. 垃圾回收机制方式及内存管理（爱奇艺2018提前批二面）</h4><p>这里，自己当时回答的不好，就引用别人博客整理的内容啦.</p>\n<h5 id=\"回收机制方式\"><a href=\"#回收机制方式\" class=\"headerlink\" title=\"回收机制方式\"></a>回收机制方式</h5><ol>\n<li><p>定义和用法：垃圾回收机制(GC:Garbage Collection),执行环境负责管理代码执行过程中使用的内存。</p>\n</li>\n<li><p>原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。</p>\n</li>\n<li><p>实例如下：</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">name</span>: <span class=\"string\">'hanzichi'</span>, <span class=\"attr\">age</span>: <span class=\"number\">10</span>&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">name</span>:<span class=\"string\">'hanzichi'</span>, <span class=\"attr\">age</span>: <span class=\"number\">10</span>&#125;;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = fn1();</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = fn2();</span><br></pre></td></tr></table></figure>\n<p>fn1中定义的obj为局部变量，而当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放；在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放。</p>\n<ol start=\"4\">\n<li>垃圾回收策略：标记清除(较为常用)和引用计数。</li>\n</ol>\n<p><strong>标记清除：</strong></p>\n<p>定义和用法：当变量进入环境时，将变量标记”进入环境”，当变量离开环境时，标记为：”离开环境”。某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量。</p>\n<p>到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。</p>\n<p><strong>引用计数：</strong></p>\n<p>定义和用法：引用计数是跟踪记录每个值被引用的次数。</p>\n<p>基本原理：就是变量的引用次数，被引用一次则加1，当这个引用计数为0时，被视为准备回收的对象。</p>\n<h5 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h5><ol>\n<li>什么时候触发垃圾回收？</li>\n</ol>\n<p>垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。</p>\n<p>IE6的垃圾回收是根据内存分配量运行的，当环境中的变量，对象，字符串达到一定数量时触发垃圾回收。垃圾回收器一直处于工作状态，严重影响浏览器性能。</p>\n<p>IE7中，垃圾回收器会根据内存分配量与程序占用内存的比例进行动态调整，开始回收工作。</p>\n<ol start=\"2\">\n<li>合理的GC方案：(1)、遍历所有可访问的对象; (2)、回收已不可访问的对象。</li>\n<li>GC缺陷：(1)、停止响应其他操作；</li>\n<li>GC优化策略：(1)、分代回收（Generation GC）;(2)、增量GC</li>\n</ol>\n<p>说实话，这一块，自己没有很好的整理，但是目前准备秋招和毕设，没有更多的经历，只能待有空再深入学习研究了。</p>\n<h3 id=\"编程题\"><a href=\"#编程题\" class=\"headerlink\" title=\"编程题\"></a>编程题</h3><h4 id=\"Q1-表格排序\"><a href=\"#Q1-表格排序\" class=\"headerlink\" title=\"Q1. 表格排序\"></a>Q1. 表格排序</h4><p>请将以下表格，按年龄进行排序，使用原生JS，不允许使用任何第三方工具。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">thead</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>name<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>age<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">thead</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tbody</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>张三<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>17<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>李四<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>43<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>王五<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>22<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>小刘<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>9<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>黄三<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>20<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">tbody</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"Ans-1\"><a href=\"#Ans-1\" class=\"headerlink\" title=\"Ans:\"></a>Ans:</h5><p>这个其实很easy了，只是我在写的时候，还是调试了好几次，这里主要两点：</p>\n<ul>\n<li>通过<code>document.getElementsBytagNames</code>选择的对象，在dom的映射机制下，是双双绑定的；</li>\n<li>使用<code>dom.appendChild()</code>方法，要保证参数是node节点。</li>\n<li><code>Array.sort()</code>方法，注意，只能用在Array上。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sortByAge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> tbody = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'tbody'</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">var</span> items = tbody.getElementsByTagName(<span class=\"string\">'tr'</span>);</span><br><span class=\"line\">            <span class=\"keyword\">let</span> arrayI = <span class=\"built_in\">Array</span>(...items); <span class=\"comment\">//将类数组转化为数组，使用sort方法</span></span><br><span class=\"line\">            arrayI.sort(<span class=\"function\">(<span class=\"params\">a,b</span>)=&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> ageA = a.getElementsByTagName(<span class=\"string\">'td'</span>)[<span class=\"number\">1</span>].innerText;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> ageB = b.getElementsByTagName(<span class=\"string\">'td'</span>)[<span class=\"number\">1</span>].innerText;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ageA - ageB;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">           <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i&lt;items.length; i++) &#123;</span><br><span class=\"line\">               tbody.appendChild(arrayI[i]); <span class=\"comment\">//依次插入，这里arrayI的每一个元素都是原来的dom映射过来的实例。所以并不是“创造”出了复制品，而是重新排序了</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">sortByAge();</span><br></pre></td></tr></table></figure>\n<h4 id=\"Q2-时间’0101’转换为正常时间值-杭州有赞2018秋招二面在线编程\"><a href=\"#Q2-时间’0101’转换为正常时间值-杭州有赞2018秋招二面在线编程\" class=\"headerlink\" title=\"Q2.时间’0101’转换为正常时间值(杭州有赞2018秋招二面在线编程)\"></a>Q2.时间’0101’转换为正常时间值(杭州有赞2018秋招二面在线编程)</h4><p>一天24小时，我们将其折为每30分钟为一段，这样一天共有48段。我们用1表示这段时间有效，0表示无效，比如<code>10...</code>  表示开始时间为<code>00:00</code> 持续了半个小时,技术时间为<code>00:30</code>。<code>111001..</code> 则表示<code>00:00~01:30</code> <code>02:30~03:00</code>两个时间段。</p>\n<p>要求写一个函数，对时间码进行转换：</p>\n<p>输入：<code>110100000000000000000000000000000000000000000000</code></p>\n<p>输出： <code>[&quot;00:30~01:30&quot;, &quot;01:00~02:00&quot;]</code></p>\n<h5 id=\"Ans-2\"><a href=\"#Ans-2\" class=\"headerlink\" title=\"Ans\"></a>Ans</h5><p>这个是我视频面试时的一道编程题，由于时间紧，面对面试官有点小压力，所以就用了比较笨的方法实现了，后来也没有重新思考和优化，有好的思路和简单的方法的小伙伴欢迎交流。</p>\n<p>以下思路：</p>\n<ul>\n<li>遍历输入字符串</li>\n<li>当为1，判断是否为第一次，如果是第一次，根据index，记录<code>startTime</code>；如果不是第一次，进行<code>time</code>累加</li>\n<li>当为0，判断之前是否为1，如果之前是1，则根据<code>time</code>值进行累加，计算<code>endTime</code>，并将时间段push到数组</li>\n<li>判断是否为第一次、判断之前是否为1，主要通过一个flag进行记录。</li>\n</ul>\n<p>根据上面思路，代码如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeTransfer</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> flag = <span class=\"literal\">false</span>,  <span class=\"comment\">//flag，判断是否第一次为1</span></span><br><span class=\"line\">                time = <span class=\"number\">0</span>,   <span class=\"comment\">//时间记录值</span></span><br><span class=\"line\">                n = str.length,</span><br><span class=\"line\">                startTime, <span class=\"comment\">//开始时间</span></span><br><span class=\"line\">                startHour, <span class=\"comment\">//开始的小时</span></span><br><span class=\"line\">                startMin,  <span class=\"comment\">//开始的分钟</span></span><br><span class=\"line\">                endTime,  <span class=\"comment\">//结束时间</span></span><br><span class=\"line\">                endHour,  <span class=\"comment\">//结束的小时</span></span><br><span class=\"line\">                endMin,  <span class=\"comment\">//结束的分钟</span></span><br><span class=\"line\">                retTime = [];  <span class=\"comment\">//最终返回的数组</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span> ; i &lt; n; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str[i] === <span class=\"string\">'1'</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(flag === <span class=\"literal\">false</span>) &#123;  <span class=\"comment\">//判断是否为第一个1，如果是，根据i设定开始时间</span></span><br><span class=\"line\">                        startHour = <span class=\"built_in\">parseInt</span>(i/<span class=\"number\">2</span>);</span><br><span class=\"line\">                        startMin = i % <span class=\"number\">2</span> ? <span class=\"number\">0</span>:<span class=\"number\">30</span>;</span><br><span class=\"line\">                        startTime = <span class=\"string\">`<span class=\"subst\">$&#123;startHour &gt; <span class=\"number\">9</span>? startHour: <span class=\"string\">'0'</span> + startHour&#125;</span>:<span class=\"subst\">$&#123;startMin &gt; <span class=\"number\">9</span> ? startMin : <span class=\"string\">'0'</span> + startMin&#125;</span>`</span>;</span><br><span class=\"line\">                        flag = <span class=\"literal\">true</span>;   <span class=\"comment\">//置位 flag</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    time += <span class=\"number\">0.5</span>;  <span class=\"comment\">//时间累加</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(i === n<span class=\"number\">-1</span>) &#123;  <span class=\"comment\">//如果已经遍历到最后，那么计算结束时间(当str的末尾为1时，需要处理)</span></span><br><span class=\"line\">                        endHour = startHour + <span class=\"built_in\">parseInt</span>(time);</span><br><span class=\"line\">                        endMin = startMin + (time % <span class=\"number\">2</span> ? <span class=\"number\">0</span> : <span class=\"number\">30</span>);</span><br><span class=\"line\">                        endTime = <span class=\"string\">`<span class=\"subst\">$&#123;endHour &gt; <span class=\"number\">9</span> ? endHour : <span class=\"string\">'0'</span> + endHour&#125;</span>:<span class=\"subst\">$&#123;endMin &gt; <span class=\"number\">9</span> ? endMin : <span class=\"string\">'0'</span> + endMin&#125;</span>`</span>;</span><br><span class=\"line\">                        retTime.push(<span class=\"string\">`<span class=\"subst\">$&#123;startTime&#125;</span>~<span class=\"subst\">$&#123;endTime&#125;</span>`</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (str[i] === <span class=\"string\">'0'</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(flag === <span class=\"literal\">false</span>) &#123; <span class=\"comment\">//如果为flase，代表前面不是1，继续下次循环</span></span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;   <span class=\"comment\">//否则，计算结束时间</span></span><br><span class=\"line\">                        flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                        endHour = startHour + <span class=\"built_in\">parseInt</span>(time);</span><br><span class=\"line\">                        endMin = startMin + (time % <span class=\"number\">2</span> ? <span class=\"number\">0</span> : <span class=\"number\">30</span>);</span><br><span class=\"line\">                        endTime = <span class=\"string\">`<span class=\"subst\">$&#123;endHour &gt; <span class=\"number\">9</span> ? endHour : <span class=\"string\">'0'</span> + endHour&#125;</span>:<span class=\"subst\">$&#123;endMin &gt; <span class=\"number\">9</span> ? endMin : <span class=\"string\">'0'</span> + endMin&#125;</span>`</span>;</span><br><span class=\"line\">                        retTime.push(<span class=\"string\">`<span class=\"subst\">$&#123;startTime&#125;</span>~<span class=\"subst\">$&#123;endTime&#125;</span>`</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> retTime;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>以上程序，是跑通了的，虽然有点笨，但是勉强满足要求。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ol>\n<li><a href=\"https://blog.csdn.net/wdlhao/article/details/79079660\" target=\"_blank\" rel=\"noopener\">csdn wdlhao的博客</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>嗯，上次写blog已经是几周前的事情了，其实已经积攒了很多小问题需要记录和分享了。但是在8月底，VK我一次经历了了携程、拼多多、腾讯、网易等多轮面试轰炸，忙得不可开交，有喜有忧的同时，还是赶快记录了不足，把一些充满迷惑性的问题继续记录和学习。</p>\n<p>JavaScript总是给人以惊喜，学习不止，进步不断，今天继续补充JS容易搞错的几道笔试/面试题，为了秋招继续努力，欢迎一起为秋招努力的小伙伴共勉</p>\n<p>系列笔记：</p>\n<p><a href=\"https://forrany.github.io/2018/08/10/VK-mistake(1\" target=\"_blank\" rel=\"noopener\">1.VK的秋招前端奇遇记(一)</a>/)</p>\n<p><a href=\"https://forrany.github.io/2018/08/11/VK-mistake(2\" target=\"_blank\" rel=\"noopener\">2.VK的秋招前端奇遇记(二)</a>/)</p>\n<p><a href=\"https://forrany.github.io/2018/08/12/VK-mistake(3\" target=\"_blank\" rel=\"noopener\">3.VK的秋招前端奇遇记(三)</a>/)</p>\n<p><a href=\"https://forrany.github.io/2018/09/04/VK-mistake(4\" target=\"_blank\" rel=\"noopener\">4.VK的秋招前端奇遇记(四)</a>/)</p>\n<p><a href=\"https://forrany.github.io/2018/08/21/front-end-interview-algorithm/\" target=\"_blank\" rel=\"noopener\">5.番外篇：前端面试&amp;笔试算法 Algorithm</a></p>\n<hr>\n<h3 id=\"面试-amp-常识题\"><a href=\"#面试-amp-常识题\" class=\"headerlink\" title=\"面试&amp;常识题\"></a>面试&amp;常识题</h3><h4 id=\"Q1-forEach-与-map的区别？-forEach不支持中断循环？\"><a href=\"#Q1-forEach-与-map的区别？-forEach不支持中断循环？\" class=\"headerlink\" title=\"Q1. forEach 与 map的区别？ forEach不支持中断循环？\"></a>Q1. forEach 与 map的区别？ forEach不支持中断循环？</h4><p><strong>这是一道巨坑的题目</strong></p>\n<p>先看下很多博客、文章总结的一个关于循环的区别是怎么说的</p>\n<blockquote>\n<ol>\n<li>map可以做链式操作、forEach不可以</li>\n<li>map有返回值,return、 forEach没有返回值</li>\n<li>for循环不用担心兼容性问题，可以break跳出循环，是基础循环</li>\n<li>forEach不支持continue和break，是不能退出循环本身的。</li>\n</ol>\n</blockquote>\n<p>上面这些比较，本身没有什么问题，但是当第三点和第四点结合的时候，就很容易让人有个推论：</p>\n<p><strong>map是可以跳出循环的，可以提前中断</strong></p>\n<p>然而，也的确有些面试官，认为<code>forEach不能break，map是可以的跳出的</code>。 真的是这样的？</p>\n<p>首先，众所周知，<code>forEach</code>是不能用break提前中断循环的，如果使用了，会直接报错。比如以下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\">list.forEach(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(item === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; )</span><br></pre></td></tr></table></figure>\n<p>但是，如果真的想要中止？ 因为会报错，这也提供给我们一个思路，那就是用<code>try..catch</code>把它保住，捕获错误。 但是，个人认为真是多此一举，应该没人会这么用。就不多做讨论了。</p>\n<p>那么<code>map</code>可以用break吗？</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fuxwu0ajqyj20l107074h.jpg\" alt=\"\"></p>\n<p>很显然，它也不行。所以如果有面试官问你，甚至告诉你”forEach和map的不同，forEach不可以中止”时，你真的可以大胆回击：</p>\n<ul>\n<li>想要用<code>Array.prototype.map</code>实现break,也是完全不可能的</li>\n<li>map中文翻译为映射，所谓映射，当然是把数组中每个值进行映射处理，有何理由中断循环，特殊处理？</li>\n</ul>\n<h4 id=\"Q2-对象与继承\"><a href=\"#Q2-对象与继承\" class=\"headerlink\" title=\"Q2. 对象与继承\"></a>Q2. 对象与继承</h4><p>请问以下程序中，<code>person1</code>和<code>person2</code>哪个是Person的实例？其<code>__proto__</code>分别指向谁?</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"attr\">name</span>: name&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'sam'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = Person(<span class=\"string\">'Lily'</span>)</span><br></pre></td></tr></table></figure>\n<h5 id=\"Ans\"><a href=\"#Ans\" class=\"headerlink\" title=\"Ans\"></a>Ans</h5><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">person1和person2都不是Person的实例</span><br><span class=\"line\">它们的<span class=\"string\">'__proto__'</span>指向<span class=\"built_in\">Object</span></span><br></pre></td></tr></table></figure>\n<p>这题题目的关键就是理解<code>new</code>的过程，这也是常见的面试题之一了。如果遇到关键字<code>new</code>，那么，函数就不单单是一个函数了：</p>\n<ul>\n<li>函数执行，首先隐式建立对象<code>this</code></li>\n<li>执行，绑定this相关的属性,本例中<code>this.name = name</code></li>\n<li>函数最后，隐式的return<code>this</code></li>\n</ul>\n<p>当然，这里简化了这个过程，但是核心是这几步。 但是如果在隐式返回<code>this</code>之前，提前返回了一个对象，那么就会退出函数了。 要知道，只有这个<code>this</code>才是实例本身，它的<code>__proto__</code>才指向构造函数，如果不能把<code>this</code>返回出去，那么一切都是徒劳的。因此，这里无论是否<code>new</code>，都返回的是一个新对象<code>{}</code>。</p>\n<h4 id=\"Q3-垃圾回收机制方式及内存管理（爱奇艺2018提前批二面）\"><a href=\"#Q3-垃圾回收机制方式及内存管理（爱奇艺2018提前批二面）\" class=\"headerlink\" title=\"Q3. 垃圾回收机制方式及内存管理（爱奇艺2018提前批二面）\"></a>Q3. 垃圾回收机制方式及内存管理（爱奇艺2018提前批二面）</h4><p>这里，自己当时回答的不好，就引用别人博客整理的内容啦.</p>\n<h5 id=\"回收机制方式\"><a href=\"#回收机制方式\" class=\"headerlink\" title=\"回收机制方式\"></a>回收机制方式</h5><ol>\n<li><p>定义和用法：垃圾回收机制(GC:Garbage Collection),执行环境负责管理代码执行过程中使用的内存。</p>\n</li>\n<li><p>原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。</p>\n</li>\n<li><p>实例如下：</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">name</span>: <span class=\"string\">'hanzichi'</span>, <span class=\"attr\">age</span>: <span class=\"number\">10</span>&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">name</span>:<span class=\"string\">'hanzichi'</span>, <span class=\"attr\">age</span>: <span class=\"number\">10</span>&#125;;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = fn1();</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = fn2();</span><br></pre></td></tr></table></figure>\n<p>fn1中定义的obj为局部变量，而当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放；在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放。</p>\n<ol start=\"4\">\n<li>垃圾回收策略：标记清除(较为常用)和引用计数。</li>\n</ol>\n<p><strong>标记清除：</strong></p>\n<p>定义和用法：当变量进入环境时，将变量标记”进入环境”，当变量离开环境时，标记为：”离开环境”。某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量。</p>\n<p>到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。</p>\n<p><strong>引用计数：</strong></p>\n<p>定义和用法：引用计数是跟踪记录每个值被引用的次数。</p>\n<p>基本原理：就是变量的引用次数，被引用一次则加1，当这个引用计数为0时，被视为准备回收的对象。</p>\n<h5 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h5><ol>\n<li>什么时候触发垃圾回收？</li>\n</ol>\n<p>垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。</p>\n<p>IE6的垃圾回收是根据内存分配量运行的，当环境中的变量，对象，字符串达到一定数量时触发垃圾回收。垃圾回收器一直处于工作状态，严重影响浏览器性能。</p>\n<p>IE7中，垃圾回收器会根据内存分配量与程序占用内存的比例进行动态调整，开始回收工作。</p>\n<ol start=\"2\">\n<li>合理的GC方案：(1)、遍历所有可访问的对象; (2)、回收已不可访问的对象。</li>\n<li>GC缺陷：(1)、停止响应其他操作；</li>\n<li>GC优化策略：(1)、分代回收（Generation GC）;(2)、增量GC</li>\n</ol>\n<p>说实话，这一块，自己没有很好的整理，但是目前准备秋招和毕设，没有更多的经历，只能待有空再深入学习研究了。</p>\n<h3 id=\"编程题\"><a href=\"#编程题\" class=\"headerlink\" title=\"编程题\"></a>编程题</h3><h4 id=\"Q1-表格排序\"><a href=\"#Q1-表格排序\" class=\"headerlink\" title=\"Q1. 表格排序\"></a>Q1. 表格排序</h4><p>请将以下表格，按年龄进行排序，使用原生JS，不允许使用任何第三方工具。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">thead</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>name<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">th</span>&gt;</span>age<span class=\"tag\">&lt;/<span class=\"name\">th</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">thead</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tbody</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>张三<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>17<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>李四<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>43<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>王五<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>22<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>小刘<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>9<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>黄三<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">td</span>&gt;</span>20<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">tbody</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"Ans-1\"><a href=\"#Ans-1\" class=\"headerlink\" title=\"Ans:\"></a>Ans:</h5><p>这个其实很easy了，只是我在写的时候，还是调试了好几次，这里主要两点：</p>\n<ul>\n<li>通过<code>document.getElementsBytagNames</code>选择的对象，在dom的映射机制下，是双双绑定的；</li>\n<li>使用<code>dom.appendChild()</code>方法，要保证参数是node节点。</li>\n<li><code>Array.sort()</code>方法，注意，只能用在Array上。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sortByAge = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> tbody = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'tbody'</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">var</span> items = tbody.getElementsByTagName(<span class=\"string\">'tr'</span>);</span><br><span class=\"line\">            <span class=\"keyword\">let</span> arrayI = <span class=\"built_in\">Array</span>(...items); <span class=\"comment\">//将类数组转化为数组，使用sort方法</span></span><br><span class=\"line\">            arrayI.sort(<span class=\"function\">(<span class=\"params\">a,b</span>)=&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> ageA = a.getElementsByTagName(<span class=\"string\">'td'</span>)[<span class=\"number\">1</span>].innerText;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> ageB = b.getElementsByTagName(<span class=\"string\">'td'</span>)[<span class=\"number\">1</span>].innerText;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ageA - ageB;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">           <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i&lt;items.length; i++) &#123;</span><br><span class=\"line\">               tbody.appendChild(arrayI[i]); <span class=\"comment\">//依次插入，这里arrayI的每一个元素都是原来的dom映射过来的实例。所以并不是“创造”出了复制品，而是重新排序了</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">sortByAge();</span><br></pre></td></tr></table></figure>\n<h4 id=\"Q2-时间’0101’转换为正常时间值-杭州有赞2018秋招二面在线编程\"><a href=\"#Q2-时间’0101’转换为正常时间值-杭州有赞2018秋招二面在线编程\" class=\"headerlink\" title=\"Q2.时间’0101’转换为正常时间值(杭州有赞2018秋招二面在线编程)\"></a>Q2.时间’0101’转换为正常时间值(杭州有赞2018秋招二面在线编程)</h4><p>一天24小时，我们将其折为每30分钟为一段，这样一天共有48段。我们用1表示这段时间有效，0表示无效，比如<code>10...</code>  表示开始时间为<code>00:00</code> 持续了半个小时,技术时间为<code>00:30</code>。<code>111001..</code> 则表示<code>00:00~01:30</code> <code>02:30~03:00</code>两个时间段。</p>\n<p>要求写一个函数，对时间码进行转换：</p>\n<p>输入：<code>110100000000000000000000000000000000000000000000</code></p>\n<p>输出： <code>[&quot;00:30~01:30&quot;, &quot;01:00~02:00&quot;]</code></p>\n<h5 id=\"Ans-2\"><a href=\"#Ans-2\" class=\"headerlink\" title=\"Ans\"></a>Ans</h5><p>这个是我视频面试时的一道编程题，由于时间紧，面对面试官有点小压力，所以就用了比较笨的方法实现了，后来也没有重新思考和优化，有好的思路和简单的方法的小伙伴欢迎交流。</p>\n<p>以下思路：</p>\n<ul>\n<li>遍历输入字符串</li>\n<li>当为1，判断是否为第一次，如果是第一次，根据index，记录<code>startTime</code>；如果不是第一次，进行<code>time</code>累加</li>\n<li>当为0，判断之前是否为1，如果之前是1，则根据<code>time</code>值进行累加，计算<code>endTime</code>，并将时间段push到数组</li>\n<li>判断是否为第一次、判断之前是否为1，主要通过一个flag进行记录。</li>\n</ul>\n<p>根据上面思路，代码如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeTransfer</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> flag = <span class=\"literal\">false</span>,  <span class=\"comment\">//flag，判断是否第一次为1</span></span><br><span class=\"line\">                time = <span class=\"number\">0</span>,   <span class=\"comment\">//时间记录值</span></span><br><span class=\"line\">                n = str.length,</span><br><span class=\"line\">                startTime, <span class=\"comment\">//开始时间</span></span><br><span class=\"line\">                startHour, <span class=\"comment\">//开始的小时</span></span><br><span class=\"line\">                startMin,  <span class=\"comment\">//开始的分钟</span></span><br><span class=\"line\">                endTime,  <span class=\"comment\">//结束时间</span></span><br><span class=\"line\">                endHour,  <span class=\"comment\">//结束的小时</span></span><br><span class=\"line\">                endMin,  <span class=\"comment\">//结束的分钟</span></span><br><span class=\"line\">                retTime = [];  <span class=\"comment\">//最终返回的数组</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span> ; i &lt; n; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str[i] === <span class=\"string\">'1'</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(flag === <span class=\"literal\">false</span>) &#123;  <span class=\"comment\">//判断是否为第一个1，如果是，根据i设定开始时间</span></span><br><span class=\"line\">                        startHour = <span class=\"built_in\">parseInt</span>(i/<span class=\"number\">2</span>);</span><br><span class=\"line\">                        startMin = i % <span class=\"number\">2</span> ? <span class=\"number\">0</span>:<span class=\"number\">30</span>;</span><br><span class=\"line\">                        startTime = <span class=\"string\">`<span class=\"subst\">$&#123;startHour &gt; <span class=\"number\">9</span>? startHour: <span class=\"string\">'0'</span> + startHour&#125;</span>:<span class=\"subst\">$&#123;startMin &gt; <span class=\"number\">9</span> ? startMin : <span class=\"string\">'0'</span> + startMin&#125;</span>`</span>;</span><br><span class=\"line\">                        flag = <span class=\"literal\">true</span>;   <span class=\"comment\">//置位 flag</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    time += <span class=\"number\">0.5</span>;  <span class=\"comment\">//时间累加</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(i === n<span class=\"number\">-1</span>) &#123;  <span class=\"comment\">//如果已经遍历到最后，那么计算结束时间(当str的末尾为1时，需要处理)</span></span><br><span class=\"line\">                        endHour = startHour + <span class=\"built_in\">parseInt</span>(time);</span><br><span class=\"line\">                        endMin = startMin + (time % <span class=\"number\">2</span> ? <span class=\"number\">0</span> : <span class=\"number\">30</span>);</span><br><span class=\"line\">                        endTime = <span class=\"string\">`<span class=\"subst\">$&#123;endHour &gt; <span class=\"number\">9</span> ? endHour : <span class=\"string\">'0'</span> + endHour&#125;</span>:<span class=\"subst\">$&#123;endMin &gt; <span class=\"number\">9</span> ? endMin : <span class=\"string\">'0'</span> + endMin&#125;</span>`</span>;</span><br><span class=\"line\">                        retTime.push(<span class=\"string\">`<span class=\"subst\">$&#123;startTime&#125;</span>~<span class=\"subst\">$&#123;endTime&#125;</span>`</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (str[i] === <span class=\"string\">'0'</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(flag === <span class=\"literal\">false</span>) &#123; <span class=\"comment\">//如果为flase，代表前面不是1，继续下次循环</span></span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;   <span class=\"comment\">//否则，计算结束时间</span></span><br><span class=\"line\">                        flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                        endHour = startHour + <span class=\"built_in\">parseInt</span>(time);</span><br><span class=\"line\">                        endMin = startMin + (time % <span class=\"number\">2</span> ? <span class=\"number\">0</span> : <span class=\"number\">30</span>);</span><br><span class=\"line\">                        endTime = <span class=\"string\">`<span class=\"subst\">$&#123;endHour &gt; <span class=\"number\">9</span> ? endHour : <span class=\"string\">'0'</span> + endHour&#125;</span>:<span class=\"subst\">$&#123;endMin &gt; <span class=\"number\">9</span> ? endMin : <span class=\"string\">'0'</span> + endMin&#125;</span>`</span>;</span><br><span class=\"line\">                        retTime.push(<span class=\"string\">`<span class=\"subst\">$&#123;startTime&#125;</span>~<span class=\"subst\">$&#123;endTime&#125;</span>`</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> retTime;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<p>以上程序，是跑通了的，虽然有点笨，但是勉强满足要求。</p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ol>\n<li><a href=\"https://blog.csdn.net/wdlhao/article/details/79079660\" target=\"_blank\" rel=\"noopener\">csdn wdlhao的博客</a></li>\n</ol>\n"},{"layout":"post","title":"前端面试&笔试爬坑算法 Algorithm","subtitle":"Front end interview Algorithm...","date":"2018-08-21T04:00:00.000Z","author":"Vinecnt Ko","header-img":"img/post-bg-nextgen-web-pwa.jpg","header-mask":0.3,"catalog":true,"_content":"\n终于来了，算法相关的。 其实个人理解，前端岗位对于算法的要求与其他IT岗位相比，是低得多的。 但是小白我经历了如蚂蚁金服、网易这样的大厂教做人之后，还是觉得，对于一些基本算法、思想的掌握还是必须的。 然后，就把自己遇到的、学到的算法相关的再总结一下，方便自己随时备战面试。\n\n系列笔记：\n\n[1.VK的秋招前端奇遇记(一)](https://forrany.github.io/2018/08/10/2018-08-10-VK-mistake-1/)\n\n[2.VK的秋招前端奇遇记(二)](https://forrany.github.io/2018/08/11/2018-08-11-VK-mistake-2/)\n\n[3.VK的秋招前端奇遇记(三)](https://forrany.github.io/2018/08/12/2018-08-12-VK-mistake-3/)\n\n[4.VK的秋招前端奇遇记(四)](https://forrany.github.io/2018/09/04/2018-09-04-VK-mistake-4/)\n\n[5.番外篇：前端面试&笔试算法 Algorithm](https://forrany.github.io/2018/08/21/2018-08-21-front-end-interview-algorithm/)\n\n---\n\n## 排序\n\nJS本身数组的sort方法，可以满足日常业务操作中很多的场景了，所以我认为这也是为什么基本面试会直接让写一个`快速排序`，因为好像其他排序方法在JS中似乎没什么意义了。 \n\n但是在拼多多的面试中，面试官还是让我手写`选择排序` `冒泡排序` 和`快速排序` 的伪代码。 既然有机会总结，干脆就全部写一遍好了，从基本排序到高级排序来说。\n\n### 基本排序算法\n\n基本排序的基本思想非常类似，重排列时用的技术基本都是一组嵌套的for循环: 外循环遍历数组的每一项，内循环则用于比较元素。\n\n#### 冒泡排序\n\n最笨最基本最经典点的方法，不管学什么语言，说到排序，第一个接触的就是它了吧。基本思想什么的太经典了，就不复数了，直接用例子说明过程吧：\n\n```javascrip\t\nE A D B H\n```\n\n经过一次排列后，变成\n\n```javascript\nA E D B H\n```\n\n前两个元素互换了，接下来变成：\n\n```javascript\nA D E B H\n```\n\n第二个和第三个互换，继续：\n\n```javascript\nA D B E H\n```\n\n第三个和第四个互换，最后，第二个和第三个元素还会互换一次，得到最终的顺序为：\n\n```javascript\nA B D E H\n```\n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fu93tfy076g20le06aazd.gif)\n\n好了，其实基本思想就是逐个的比较，下面就实现一下：\n\n```javascript\nfunction bubleSort(arr) {\n    var len = arr.length;\n    for (let outer = len ; outer >= 2; outer--) {\n        for(let inner = 0; inner <=outer - 1; inner++) {\n            if(arr[inner] > arr[inner + 1]) {\n                let temp = arr[inner];\n                arr[inner] = arr[inner + 1];\n                arr[inner + 1] = temp;\n            }\n        }\n    }\n    return arr;\n}\n```\n\n这里有两点需要注意：\n\n1. 外层循环，从最大值开始递减，因为内层是两两比较，因此最外层当`>=2`时即可停止；\n2. 内层是两两比较，从0开始，比较`inner`与`inner+1`，因此，临界条件是`inner<outer -1`\n\n在比较交换的时候，就是计算机中最经典的交换策略，用临时变量`temp`保存值，但是面试官问过我，**ES6有没有简单的方法实现？** 有的，如下：\n\n```javascript\narr2 = [1,2,3,4];\n[arr2[0],arr2[1]] = [arr2[1],arr2[0]]  //ES6解构赋值\nconsole.log(arr2)  // [2, 1, 3, 4]\n```\n\n所以，刚才的冒牌排序可以优化如下：\n\n```javascript\nfunction bubleSort(arr) {\n    var len = arr.length;\n    for (let outer = len ; outer >= 2; outer--) {\n        for(let inner = 0; inner <=outer - 1; inner++) {\n            if(arr[inner] > arr[inner + 1]) {\n                [arr[inner],arr[inner+1]] = [arr[inner+1],arr[inner]]\n            }\n        }\n    }\n    return arr;\n}\n```\n\n#### 选择排序\n\n选择排序是从数组的开头开始，将第一个元素和其他元素作比较，检查完所有的元素后，最小的放在第一个位置，接下来再开始从第二个元素开始，重复以上一直到最后。\n\n![](http://img.mp.itc.cn/upload/20160923/c705c53489b8455090ccb67199465387_th.jpg)\n\n有了刚才的铺垫，我觉得不用再演示了，很简单嘛： 外层循环从0开始到`length-1`， 然后内层比较，最小的放开头，走你：\n\n```javascript\nfunction selectSort(arr) {\n    var len = arr.length;\n    for(let i = 0 ;i < len - 1; i++) {\n        for(let j = i ; j<len; j++) {\n            if(arr[j] < arr[i]) {\n                [arr[i],arr[j]] = [arr[j],arr[i]];\n            }\n        }\n    }\n    return arr\n}\n```\n\n简单说两句：\n\n* 外层循环的`i`表示第几轮，`arr[i]`就表示当前轮次最靠前(小)的位置；\n* 内层从`i`开始，依次往后数，找到比开头小的，互换位置即可\n\n结束，收工！！\n\n#### 插入排序\n\n插入排序核心--扑克牌思想： **就想着自己在打扑克牌，接起来一张，放哪里无所谓，再接起来一张，比第一张小，放左边，继续接，可能是中间数，就插在中间....依次**\n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fu93uujulog20le0ejtyb.gif)\n\n其实每种算法，主要是理解其原理，至于写代码，都是在原理之上顺理成章的事情：\n\n* 首先将待排序的第一个记录作为一个有序段\n* 从第二个开始，到最后一个，依次和前面的有序段进行比较，确定插入位置\n\n```javascript\nfunction insertSort(arr) {\n    for(let i = 1; i < arr.length; i++) {  //外循环从1开始，默认arr[0]是有序段\n        for(let j = i; j > 0; j--) {  //j = i,将arr[j]依次插入有序段中\n            if(arr[j] < arr[j-1]) {\n                [arr[j],arr[j-1]] = [arr[j-1],arr[j]];\n            } else {\n                break;\n            }\n        }\n    }\n    return arr;\n}\n```\n\n分析： 注意这里两次循环中，`i`和`j`的含义：\n\n1. `i`是外循环，依次把后面的数插入前面的有序序列中，默认`arr[0]`为有序的，`i`就从1开始\n2. `j`进来后，依次与前面队列的数进行比较，因为前面的序列是有序的，因此只需要循环比较、交换即可\n3. 注意这里的`break`，因为前面是都是有序的序列，所以如果当前要插入的值`arr[j]`大于或等于`arr[j-1]`，则无需继续比较，直接下一次循环就可以了。\n\n#### 时间复杂度\n\n乍一看，好像插入排序速度还不慢，但是要知道： 当序列正好逆序的时候，每次插入都要一次次交换，这个速度和冒泡排序是一样的，时间复杂度O(n²)； 当然运气好，前面是有序的，那时间复杂度就只有O(n)了，直接插入即可。\n\n| 排序算法     | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 是否稳定 |\n| ------------ | :------------: | :------------: | :--------: | :------: |\n| 冒泡排序     |     O(n²)      |     O(n²)      |    O(1)    |    是    |\n| 选择排序     |     O(n²)      |     O(n²)      |    O(1)    |   不是   |\n| 直接插入排序 |     O(n²)      |     O(n²)      |    O(1)    |    是    |\n\n好了，这张表如何快速记忆呢？ 方法就是一开始写的**基本排序算法** 。 一开始就说到，基本思想就是两层循环嵌套，第一遍找元素O(n),第二遍找位置O(n)，所以这几种方法，时间复杂度就可以这么简便记忆啦!\n\n---\n\n### 高级排序算法\n\n如果所有排序都像上面的基本方法一样，那么对于大量数据的处理，将是灾难性的，老哥，只是让你排个序，你都用了O(n²)。 好吧，所以接下来这些高级排序算法，在大数据上，可以大大的减少复杂度。 \n\n#### 快速排序\n\n快速排序可以说是对于前端最最最最重要的排序算法，没有之一了，面试官问到排序算法，快排的概率能有80%以上(我瞎统计的...信不信由你)。\n\n所以快排是什么呢？\n\n> 快排是处理大数据最快的排序算法之一。它是一种分而治之的算法，通过递归的方式将数据依次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤直至所有数据都是有序的。\n\n简单说： 找到一个数作为参考，比这个数字大的放在数字左边，比它小的放在右边； 然后分别再对左边和右变的序列做相同的操作:\n\n1. 选择一个基准元素，将列表分割成两个子序列；\n2. 对列表重新排序，将所有小于基准值的元素放在基准值前面，所有大于基准值的元素放在基准值的后面；\n3. 分别对较小元素的子序列和较大元素的子序列重复步骤1和2\n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fu942wgi1tg20kz071k8b.gif)\n\n```javascript\nfunction quickSort(arr) {\n    if(arr.length <= 1) {\n        return arr;  //递归出口\n    }\n    var left = [],\n        right = [],\n        current = arr.splice(0,1); //注意splice后，数组长度少了一个\n    for(let i = 0; i < arr.length; i++) {\n        if(arr[i] < current) {\n            left.push(arr[i])  //放在左边\n        } else {\n            right.push(arr[i]) //放在右边\n        }\n    }\n    return quickSort(left).concat(current,quickSort(right)); //递归\n}\n```\n\n#### 希尔排序\n\n希尔排序是插入排序的改良算法，但是核心理念与插入算法又不同，它会先比较距离较远的元素，而非相邻的元素。文字太枯燥，还是看下面的动图吧：\n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fu9cru5iyjg20ih082n4c.gif)\n\n在实现之前，先看下刚才插入排序怎么写的：\n\n```javascript\nfunction insertSort(arr) {\n    for(let i = 1; i < arr.length - 1; i++) {  //外循环从1开始，默认arr[0]是有序段\n        for(let j = i; j > 0; j--) {  //j = i,将arr[j]依次插入有序段中\n            if(arr[j] < arr[j-1]) {\n                [arr[j],arr[j-1]] = [arr[j-1],arr[j]];\n            } else {\n                continue;\n            }\n        }\n    }\n    return arr;\n}\n```\n\n现在，不同之处是在上面的基础上，让步长按照3、2、1来进行比较，相当于是三层循环和嵌套啦。\n\n```javascript\ninsertSort(arr,[3,2,1]);\nfunction shellSort(arr,gap) {\n    console.log(arr)//为了方便观察过程，使用时去除\n    for(let i = 0; i<gap.length; i++) {  //最外层循环，一次取不同的步长，步长需要预先给出\n        let n = gap[i]; //步长为n\n        for(let j = i + n; j < arr.length; j++) { //接下类和插入排序一样，j循环依次取后面的数\n            for(let k = j; k > 0; k-=n) { //k循环进行比较，和直接插入的唯一区别是1变为了n\n                if(arr[k] < arr[k-n]) {\n                    [arr[k],arr[k-n]] = [arr[k-n],arr[k]];\n                    console.log(`当前序列为[${arr}] \\n 交换了${arr[k]}和${arr[k-n]}`)//为了观察过程\n                } else {\n                    continue;\n                }\n            }\n        }\n    }\n    return arr;\n}\n```\n\n直接看这个三层循环嵌套的内容，会稍显复杂，这也是为什么先把插入排序写在前面做一个对照。 其实三层循环的内两层完全就是一个插入排序，只不过原来插入排序间隔为`1`，而希尔排序的间隔是变换的`n`， 如果把`n`修改为`1`，就会发现是完全一样的了。\n\n运行一下看看\n\n```javascript\nvar arr = [3, 2, 45, 6, 55, 23, 5, 4, 8, 9, 19, 0];\nvar gap = [3,2,1];\nconsole.log(shellSort(arr,gap))\n```\n\n结果如下:\n\n```javascript\n(12) [3, 2, 45, 6, 55, 23, 5, 4, 8, 9, 19, 0] //初始值\n当前序列为[3,2,23,6,55,45,5,4,8,9,19,0] \n 交换了45和23\n当前序列为[3,2,23,5,55,45,6,4,8,9,19,0] \n 交换了6和5\n当前序列为[3,2,23,5,4,45,6,55,8,9,19,0] \n 交换了55和4\n当前序列为[3,2,23,5,4,8,6,55,45,9,19,0] \n 交换了45和8\n当前序列为[3,2,8,5,4,23,6,55,45,9,19,0] \n 交换了23和8\n当前序列为[3,2,8,5,4,23,6,19,45,9,55,0] \n 交换了55和19\n当前序列为[3,2,8,5,4,23,6,19,0,9,55,45] \n 交换了45和0\n当前序列为[3,2,8,5,4,0,6,19,23,9,55,45] \n 交换了23和0\n当前序列为[3,2,0,5,4,8,6,19,23,9,55,45] \n 交换了8和0\n当前序列为[0,2,3,5,4,8,6,19,23,9,55,45] \n 交换了3和0\n当前序列为[0,2,3,5,4,8,6,9,23,19,55,45] \n 交换了19和9\n当前序列为[0,2,3,4,5,8,6,9,23,19,55,45] \n 交换了5和4\n当前序列为[0,2,3,4,5,6,8,9,23,19,55,45] \n 交换了8和6\n当前序列为[0,2,3,4,5,6,8,9,19,23,55,45] \n 交换了23和19\n当前序列为[0,2,3,4,5,6,8,9,19,23,45,55] \n 交换了55和45\n```\n\n#### 时间复杂度总结\n\nwait？ 不是还有很多排序算法的吗？怎么不继续了？ 是的，其实排序是很深奥的问题，如果研究透各个方法的实现、性能等等，内容恐怕多到爆炸了...而且这个也主要是为**前端常见算法** 问题的总结，个人觉得到这里就差不多了\n\n| 排序算法     | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 是否稳定 |\n| ------------ | :------------: | :------------: | :--------: | :------: |\n| 冒泡排序     |     O(n²)      |     O(n²)      |    O(1)    |    是    |\n| 选择排序     |     O(n²)      |     O(n²)      |    O(1)    |   不是   |\n| 直接插入排序 |     O(n²)      |     O(n²)      |    O(1)    |    是    |\n| 快速排序     |    O(nlogn)    |     O(n²)      |  O(logn)   |   不是   |\n| 希尔排序     |    O(nlogn)    |     O(n^s)     |    O(1)    |   不是   |\n\n##### 是否稳定\n\n如果不考虑稳定性，快排似乎是接近完美的一种方法，但可惜它是不稳定的。 那什么是稳定性呢？\n\n通俗的讲**有两个相同的数A和B，在排序之前A在B的前面，而经过排序之后，B跑到了A的前面，对于这种情况的发生，我们管他叫做排序的不稳定性**，而快速排序在对存在相同数进行排序时就有可能发生这种情况。 \n\n```javascript\n/*\n比如对(5，3A，6，3B ) 进行排序，排序之前相同的数3A与3B，A在B的前面，经过排序之后会变成  \n\t（3B，3A，5，6）\n所以说快速排序是一个不稳定的排序\n/*\n```\n\n稳定性有什么意义？ 个人理解对于前端来说，比如我们熟知框架中的虚拟DOM的比较，我们对一个`<ul>`列表进行渲染，当数据改变后需要比较变化时，不稳定排序或操作将会使本身不需要变化的东西变化，导致重新渲染，带来性能的损耗。 \n\n##### 辅助记忆\n\n* 时间复杂度记忆\n  * 冒泡、选择、直接 排序需要两个for循环，每次只关注一个元素，平均时间复杂度为O(n²)(一遍找元素O(n)，一遍找位置O(n)）\n  * 快速、归并、希尔、堆基于二分思想，log以2为底，平均时间复杂度为O(nlogn)(一遍找元素O(n)，一遍找位置O(logn))\n* 稳定性记忆-“快希选堆”（快牺牲稳定性） \n* \n\n\n\n---\n\n## 递归\n\n递归，其实就是自己调用自己。\n\n很多时候我们自己觉得麻烦或者感觉 \"想象不过来\"，主要是自己和自己较真，因为交给递归，它自己会帮你完成需要做的。\n\n递归步骤：\n\n* 寻找出口，递归一定有一个出口，锁定出口，保证不会死循环\n* 递归条件，符合递归条件，自己调用自己。\n\n> talk is cheap，show me code！\n\n斐波那契数列，每个语言讲递归都会从这个开始，但是既然搞前端，就搞点不一样的吧，从对象的深度克隆(deep clone)说起\n\n**Deep Clone** ：实现对一个对象(object)的深度克隆\n\n```javascript\n//所谓深度克隆，就是当对象的某个属性值为object或array的时候，要获得一份copy，而不是直接拿到引用值\nfunction deepClone(origin,target) {  //origin是被克隆对象，target是我们获得copy\n    var target = target || {}; //定义target\n    for(var key in origin) {  //遍历原对象\n        if(origin.hasOwnProperty(key)) {\n            if(Array.isArray(origin[key])) { //如果是数组\n                target[key] = [];\n                deepClone(origin[key],target[key]) //递归\n            } else if (typeof origin[key] === 'object' && origin[key] !== null) {\n                target[key] = {};\n                deepClone(origin[key],target[key]) //递归\n            } else {\n                target[key] = origin[key];\n            }\n        }\n    }\n    return target;\n}\n```\n\n这个可以说是前端笔试/面试中经常经常遇到的问题了，思路是很清晰的：\n\n* 出口： 遍历对象结束后return\n* 递归条件： 遇到引用值Array 或 Object\n\n剩下的事情，交给JS自己处理就好了，我们不用考虑内部的层层嵌套，想太多\n\n### 实战例题\n\n接下来，列举一些自己在最近笔试、面试中遇到的，需要使用递归实现的问题\n\n#### Q1：Array数组的flat方法实现(2018网易雷火&伏羲前端秋招笔试)\n\nArray的方法flat很多浏览器还未能实现，请写一个flat方法，实现扁平化嵌套数组，如：\n\n```javascript\nArray\nvar arr1 = [1, 2, [3, 4]];\narr1.flat(); \n// [1, 2, 3, 4]\n```\n\n这个问题的实现思路和Deep Clone非常相似，这里实现如下：\n\n```javascript\nArray.prototype.flat = function() {\n    var arr = [];\n    this.forEach((item,idx) => {\n        if(Array.isArray(item)) {\n            arr = arr.concat(item.flat()); //递归去处理数组元素\n        } else {\n            arr.push(item)   //非数组直接push进去\n        }\n    })\n    return arr;   //递归出口\n}\n```\n\n好了，可以测试一下：\n\n```javascript\narr = [[2],[[2,3],[2]],3,4]\narr.flat()\n// [2, 2, 3, 2, 3, 4]\n```\n\n**神秘力量的新解法**\n\n在评论区的一位小伙伴，提出了更好的办法，很简洁、方便，只用一句话就可以实现需求哦(不过你这样去解答一道网易的“编程题”,不觉得让人家有点难堪嘛~哈哈)\n```javascript\narr.prototype.flat = function() {\n    this.toString().split(',').map(item=> +item )\n}\n```\n好了，惊叹完之后，大概说下实现吧：\n\n1. toString方法，连接数组并返回一个字符串 `'2,2,3,2,3,4'`\n2. split方法分割字符串，变成数组`['2','2','3','2','3','4']`\n3. map方法，将string映射成为number类型`2,2,3,2,3,4`\n\n#### Q2 实现简易版的co，自动执行generator\n\n这个问题，详细的解释可以在我之前的文章([从Co剖析和解释generator的异步原理](https://juejin.im/post/5b5f169fe51d4518e311ba78))去看一下，如果对ES6的iterator和generator不太了解的，可以跳过这个问题。\n\n比如实现如下的功能:\n```javascript  \nconst co = require('co');\nco(function *() {\n    const url = 'http://jasonplacerholder.typecoder.com/posts/1';\n    const response = yield fetch(url);\n    const post = yield response.json();\n    const title = post.title;\n    console.log('Title: ',title);\n})\n```\n\n剖析：\n* 第一步找出口，执行器返回的iterator如果状态为`done`，代表结束，可以出去\n* 递归条件： 取到下一个iterator，进行递归，自我调用\n\n```javascript\nfunction run(generat) {\n    const iterator = generat();\n    function autoRun(iteration) {\n        if(iteration.done) {return iteration.value}  //出口\n        const anotherPromise = iteration.value;\n        anoterPromise.then(x => {\n            return autoRun(iterator.next(x))  //递归条件\n        })\n    }\n    return autoRun(iterator.next()) \n}\n\n```\n\n#### Q3. 爬楼梯问题\n\n有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？\n\n**分析**： 这个问题要倒过来看，要到达n级楼梯，只有两种方式，从（n-1）级 或 （n-2）级到达的。所以可以用递推的思想去想这题，假设有一个数组s[n], 那么s[1] = 1（由于一开始就在第一级，只有一种方法）， s[2] = 1（只能从s[1]上去 没有其他方法）。\n\n那么就可以推出s[3] ~ s[n]了。\n\n下面继续模拟一下， s[3] = s[1] + s[2]， 因为只能从第一级跨两步， 或者第二级跨一步。\n\n```javascript\nfunction cStairs(n) {\n    if(n === 1 || n === 2) {\n        return 1;\n    } else {\n        return cStairs(n-1) + cStairs(n-2)\n    }\n}\n```\n\n嗯嗯，没错呢，其实就是斐波纳契数列没跑了\n\n#### Q4.二分查找\n\n二分查找，是在一个有序的序列里查找某一个值，与小时候玩的猜数字游戏非常相啦：\n\n```\nA: 0 ~ 100 猜一个数字\nB: 50\nA: 大了\nB: 25\nA: 对头，就是25\n```\n\n因此，思路也就非常清楚了，这里有递归和非递归两种写法，先说下递归的方法吧：\n\n* 设定区间,low和high\n* 找出口： 找到target，返回target；\n* 否则寻找，当前次序没有找到，把区间缩小后递归\n\n```javascript\nfunction binaryFind(arr,target,low = 0,high = arr.length - 1) {\n    const n = Math.floor((low+high) /2);\n    const cur = arr[n];\n    if(cur === target) {\n        return `找到了${target},在第${n+1}个`;\n    } else if(cur > target) {\n        return binaryFind(arr,target,low, n-1);\n    } else if (cur < target) {\n        return binaryFind(arr,target,n+1,high);\n    }\n    return -1;\n}\n```\n\n接下来，使用循环来做一下二分查找，其实思路基本一致：\n\n```javascript\nfunction binaryFind(arr, target) {\n    var low = 0,\n        high = arr.length - 1,\n        mid;\n    while (low <= high) {\n        mid = Math.floor((low + high) / 2);\n        if (target === arr[mid]) {\n            return `找到了${target},在第${mid + 1}个`\n        }\n        if (target > arr[mid]) {\n            low = mid + 1;\n        } else if (target < arr[mid]) {\n            high = mid - 1;\n        }\n    }\n    return -1\n}\n```\n\n\n\n## 二叉树和二叉查找树\n\n### 树的基本概念\n\n这里对基本概念就不详细复习了，在各大资料中有更详尽的介绍，这里就只简单介绍基本概念和术语，然后使用JavaScript实现一个二叉树，并封装其方法。\n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fufxqalweej20r20fmwii.jpg)\n\n如图所示，一棵树最上面的几点称为根节点，如果一个节点下面连接多个节点，那么该节点成为父节点，它下面的节点称为子节点，一个节点可以有0个、1个或更多节点，没有子节点的节点叫叶子节点。\n\n**二叉树**，是一种特殊的树，即子节点最多只有两个，这个限制可以使得写出高效的插入、删除、和查找数据。在二叉树中，子节点分别叫左节点和右节点。 \n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fufy2mm3fsj20pn08wgnf.jpg)\n\n### 二叉查找树\n\n二叉查找树是一种特殊的二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中，这一特性使得查找的效率很高，对于数值型和非数值型数据，比如字母和字符串，都是如此。现在通过JS实现一个二叉查找树。\n\n#### 节点\n\n二叉树的最小元素是节点，所以先定义一个节点\n\n```javascript\nfunction Node(data,left,right) {\n    this.left = left;\n    this.right = right;\n    this.data = data;\n    this.show = () => {return this.data}\n}\n```\n\n这个就是二叉树的最小结构单元\n\n#### 二叉树\n\n```javascript\nfunction BST() {\n    this.root = null //初始化,root为null\n}\n```\n\nBST初始化时，只有一个根节点，且没有任何数据。 接下来，我们利用二叉查找树的规则，定义一个插入方法，这个方法的基本思想是:\n\n1. 如果`BST.root === null` ，那么就将节点作为根节点\n2. 如果`BST.root !==null` ，将插入节点进行一个比较，小于根节点，拿到左边的节点，否则拿右边，再次比较、递归。\n\n这里就出现了递归了，因为，总是要把较小的放在靠左的分支。换言之\n\n**最左变的叶子节点是最小的数，最右的叶子节点是最大的数**\n\n```javascript\nfunction insert(data) {\n    var node = new Node(data,null,null);\n    if(this.root === null) {\n        this.root = node\n    } else {\n        var current = this.root;\n        var parent;\n        while(true) {\n            parent = current;\n            if(data < current.data) {\n                current = current.left; //到左子树\n                if(current === null) {  //如果左子树为空，说明可以将node插入在这里\n                    parent.left = node;\n                    break;  //跳出while循环\n                }\n            } else {\n                current = current.right;\n                if(current === null) {\n                    parent.right = node;\n                    break;\n                }\n            }\n        }\n    }\n}\n```\n\n这里，是使用了一个循环方法，不断的去向子树寻找正确的位置。 循环和递归都有一个核心，就是找到出口，这里的出口就是当current 为null的时候，代表没有内容，可以插入。\n\n接下来，将此方法写入BST即可:\n\n```javascript\nfunction BST() {\n    this.root = null;\n    this.insert = insert;\n}\n```\n\n这样子，就可以使用二叉树这个自建的数据结构了:\n\n```javascript\nvar bst = new BST()；\nbst.insert(10);\nbst.insert(8);\nbst.insert(2);\nbst.insert(7);\nbst.insert(5);\n```\n\n但是这个时候，想要看树中的数据，不是那么清晰，所以接下来，就要用到遍历了。\n\n#### 二叉树的遍历\n\n我们知道，树的遍历主要包括\n\n* 前序遍历 (根左右)\n* 中序遍历 (左根右)\n* 后序遍历 (左右根)\n\n这个只是为了好记忆，我们拿下面的图做一个遍历\n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fug0jaukqpj209k057jrx.jpg)\n\n前序遍历: 56 22 10 30 81 77 92\n\n中序遍历: 10 22 30 56 77 81 92\n\n后序遍历: 10 30 22 77 92 81 56\n\n这里发现了一些规律：\n\n1. 前序遍历，因为是根左右，所以最后一个一定是最大的； 第一个一定是root节点；\n2. 中序遍历，在查找二叉树中，一定是从小到大的顺序； 根节点`56`左边(10/22/30)的一定是左子树的，右边的(77/81/92)一定是右子树的。\n3. 后序遍历，根节点一定在最后\n\n##### 中序遍历的实现\n\n这里就又用到之前的递归了，中序遍历要求: **左！根！右**\n\n```javascript\nfunction inOrder(node) {\n    if(node !== null) {\n        //如果不是null，就一直查找左变，因此递归\n        inOrder(node.left);\n        //递归结束，打印当前值\n        console.log(node.show());\n        //上一次递归已经把左边搞完了，右边\n        inOrder(node.right);\n    }\n}\n\n//在刚才已有bst的基础上执行命令\ninOrder(bst.root);\n```\n\n通过递归，实现了中序遍历，上面打印出的结果如下:\n\n```\n2\n5\n7\n8\n10\n```\n\n##### 前序遍历&后序遍历\n\n如果刚才的递归过程搞清楚，那这个就再简单不过了\n\n```javascript\nfunction preOrder(node) {\n    if(node !== null) {\n        //根左右\n        console.log(node.show());\n        preOrder(node.left);\n        preOrder(node.right);\n    }\n}\n```\n\nok,趁热打铁，就把后序遍历的方法也一并写入，如下:\n\n```javascript\nfunction postOrder(node) {\n    if(node !== null) {\n        //左右根\n        postOrder(node.left);\n        postOrder(node.right);\n        console.log(node.show())\n    }\n}\n```\n\n好了，可以去尝试两种方法打印出来的结果了:\n\n```javascript\npreOrder(bst.root);\npostOrder(bst.root);\n```\n\n### 二叉树的查找\n\n在二叉树这种数据结构中进行数据查找是最方便的，现在我们就对查找最小值、最大值和特定值进行一个梳理：\n\n* 最小值： 最左子树的叶子节点\n* 最大值： 最右子树的叶子节点\n* 特定值： target与current进行比较，如果比current大，在current.right进行查找，反之类似。\n\n清楚思路后，就动手来写：\n\n```javascript\n//最小值\nfunction getMin(bst) {\n    var current = bst.root;\n    while(current.left !== null) {\n        current = current.left;\n    }\n    return current.data;\n}\n\n//最大值\nfunction getMax(bst) {\n    var current = bst.root;\n    while(current.right !== null) {\n        current = current.right;\n    }\n    return current.data;\n}\n```\n\n最大、最小值都是非常简单的，下面主要看下如何通过\n\n```javascript\nfunction find(target,bst) {\n    var current = bst.root;\n    while(current !== null) {\n        if(target === current.data) {\n            return true;\n        }\n        else if(target > current.data) {\n            current = current.right;\n        } else if(target < current.data) {\n            current = current.left;\n        }\n    }\n    return -1;\n}\n```\n\n其实核心，仍然是通过一个循环和判断，来不断的向下去寻找，这里的思想其实和二分查找是有点类似的。\n\n哇...\n\n没想到今天去整理排序 花了这么久...嗯..然而这篇文章已经够长了\n\n接下来我会把之前笔试遇到的题目和一些常用的算法问题，一一记录，前端很多算法都是和数组、字符串处理息息相关的，所以对正则表达式、数组常用方法的掌握也很重要，简单总结下知识点：\n\n* 正则表达式\n  * 字符串相关方法\n  * str.split()\n  * str.replace()\n  * str.match()\n  * reg.test()\n  * reg.exec()\n* 数组方法\n  * Array.map()  映射，有返回值，不改变数组本身\n  * Array.forEach() 遍历，无返回值\n  * Array.filter() 过滤，返回true时返回,false时不返回\n  * Array.splice/slice/join等\n  * for...of 遍历,iterator相关知识点\n\n\n\n### 未完待续....\n\n内容会持续更新，最快的当然还是在github上，然后会同步到掘金，[github传送门](https://github.com/forrany/Web-Project)\n\n\n\n### 参考资料\n\n1. [排序算法时间复杂度、空间复杂度、稳定性比较](https://blog.csdn.net/yushiyi6453/article/details/76407640)\n2. [算法学习记录--希尔排序](https://www.cnblogs.com/jsgnadsj/p/3458054.html)\n3. [快速排序简单理解](https://blog.csdn.net/tizzzzzz/article/details/79610375)\n4. [数据结构与算法Javascript描述](https://book.douban.com/subject/25945449/)","source":"_posts/2018-08-21-front end interview algorithm.md","raw":"---\nlayout:     post\ntitle:      \"前端面试&笔试爬坑算法 Algorithm\"\nsubtitle:   \"Front end interview Algorithm...\"\ndate:       2018-08-21 12:00:00\nauthor:     \"Vinecnt Ko\"\nheader-img: \"img/post-bg-nextgen-web-pwa.jpg\"\nheader-mask: 0.3\ncatalog:    true\ntags:\n    - 前端面试\n    - JavaScript\n    - 算法\n---\n\n终于来了，算法相关的。 其实个人理解，前端岗位对于算法的要求与其他IT岗位相比，是低得多的。 但是小白我经历了如蚂蚁金服、网易这样的大厂教做人之后，还是觉得，对于一些基本算法、思想的掌握还是必须的。 然后，就把自己遇到的、学到的算法相关的再总结一下，方便自己随时备战面试。\n\n系列笔记：\n\n[1.VK的秋招前端奇遇记(一)](https://forrany.github.io/2018/08/10/2018-08-10-VK-mistake-1/)\n\n[2.VK的秋招前端奇遇记(二)](https://forrany.github.io/2018/08/11/2018-08-11-VK-mistake-2/)\n\n[3.VK的秋招前端奇遇记(三)](https://forrany.github.io/2018/08/12/2018-08-12-VK-mistake-3/)\n\n[4.VK的秋招前端奇遇记(四)](https://forrany.github.io/2018/09/04/2018-09-04-VK-mistake-4/)\n\n[5.番外篇：前端面试&笔试算法 Algorithm](https://forrany.github.io/2018/08/21/2018-08-21-front-end-interview-algorithm/)\n\n---\n\n## 排序\n\nJS本身数组的sort方法，可以满足日常业务操作中很多的场景了，所以我认为这也是为什么基本面试会直接让写一个`快速排序`，因为好像其他排序方法在JS中似乎没什么意义了。 \n\n但是在拼多多的面试中，面试官还是让我手写`选择排序` `冒泡排序` 和`快速排序` 的伪代码。 既然有机会总结，干脆就全部写一遍好了，从基本排序到高级排序来说。\n\n### 基本排序算法\n\n基本排序的基本思想非常类似，重排列时用的技术基本都是一组嵌套的for循环: 外循环遍历数组的每一项，内循环则用于比较元素。\n\n#### 冒泡排序\n\n最笨最基本最经典点的方法，不管学什么语言，说到排序，第一个接触的就是它了吧。基本思想什么的太经典了，就不复数了，直接用例子说明过程吧：\n\n```javascrip\t\nE A D B H\n```\n\n经过一次排列后，变成\n\n```javascript\nA E D B H\n```\n\n前两个元素互换了，接下来变成：\n\n```javascript\nA D E B H\n```\n\n第二个和第三个互换，继续：\n\n```javascript\nA D B E H\n```\n\n第三个和第四个互换，最后，第二个和第三个元素还会互换一次，得到最终的顺序为：\n\n```javascript\nA B D E H\n```\n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fu93tfy076g20le06aazd.gif)\n\n好了，其实基本思想就是逐个的比较，下面就实现一下：\n\n```javascript\nfunction bubleSort(arr) {\n    var len = arr.length;\n    for (let outer = len ; outer >= 2; outer--) {\n        for(let inner = 0; inner <=outer - 1; inner++) {\n            if(arr[inner] > arr[inner + 1]) {\n                let temp = arr[inner];\n                arr[inner] = arr[inner + 1];\n                arr[inner + 1] = temp;\n            }\n        }\n    }\n    return arr;\n}\n```\n\n这里有两点需要注意：\n\n1. 外层循环，从最大值开始递减，因为内层是两两比较，因此最外层当`>=2`时即可停止；\n2. 内层是两两比较，从0开始，比较`inner`与`inner+1`，因此，临界条件是`inner<outer -1`\n\n在比较交换的时候，就是计算机中最经典的交换策略，用临时变量`temp`保存值，但是面试官问过我，**ES6有没有简单的方法实现？** 有的，如下：\n\n```javascript\narr2 = [1,2,3,4];\n[arr2[0],arr2[1]] = [arr2[1],arr2[0]]  //ES6解构赋值\nconsole.log(arr2)  // [2, 1, 3, 4]\n```\n\n所以，刚才的冒牌排序可以优化如下：\n\n```javascript\nfunction bubleSort(arr) {\n    var len = arr.length;\n    for (let outer = len ; outer >= 2; outer--) {\n        for(let inner = 0; inner <=outer - 1; inner++) {\n            if(arr[inner] > arr[inner + 1]) {\n                [arr[inner],arr[inner+1]] = [arr[inner+1],arr[inner]]\n            }\n        }\n    }\n    return arr;\n}\n```\n\n#### 选择排序\n\n选择排序是从数组的开头开始，将第一个元素和其他元素作比较，检查完所有的元素后，最小的放在第一个位置，接下来再开始从第二个元素开始，重复以上一直到最后。\n\n![](http://img.mp.itc.cn/upload/20160923/c705c53489b8455090ccb67199465387_th.jpg)\n\n有了刚才的铺垫，我觉得不用再演示了，很简单嘛： 外层循环从0开始到`length-1`， 然后内层比较，最小的放开头，走你：\n\n```javascript\nfunction selectSort(arr) {\n    var len = arr.length;\n    for(let i = 0 ;i < len - 1; i++) {\n        for(let j = i ; j<len; j++) {\n            if(arr[j] < arr[i]) {\n                [arr[i],arr[j]] = [arr[j],arr[i]];\n            }\n        }\n    }\n    return arr\n}\n```\n\n简单说两句：\n\n* 外层循环的`i`表示第几轮，`arr[i]`就表示当前轮次最靠前(小)的位置；\n* 内层从`i`开始，依次往后数，找到比开头小的，互换位置即可\n\n结束，收工！！\n\n#### 插入排序\n\n插入排序核心--扑克牌思想： **就想着自己在打扑克牌，接起来一张，放哪里无所谓，再接起来一张，比第一张小，放左边，继续接，可能是中间数，就插在中间....依次**\n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fu93uujulog20le0ejtyb.gif)\n\n其实每种算法，主要是理解其原理，至于写代码，都是在原理之上顺理成章的事情：\n\n* 首先将待排序的第一个记录作为一个有序段\n* 从第二个开始，到最后一个，依次和前面的有序段进行比较，确定插入位置\n\n```javascript\nfunction insertSort(arr) {\n    for(let i = 1; i < arr.length; i++) {  //外循环从1开始，默认arr[0]是有序段\n        for(let j = i; j > 0; j--) {  //j = i,将arr[j]依次插入有序段中\n            if(arr[j] < arr[j-1]) {\n                [arr[j],arr[j-1]] = [arr[j-1],arr[j]];\n            } else {\n                break;\n            }\n        }\n    }\n    return arr;\n}\n```\n\n分析： 注意这里两次循环中，`i`和`j`的含义：\n\n1. `i`是外循环，依次把后面的数插入前面的有序序列中，默认`arr[0]`为有序的，`i`就从1开始\n2. `j`进来后，依次与前面队列的数进行比较，因为前面的序列是有序的，因此只需要循环比较、交换即可\n3. 注意这里的`break`，因为前面是都是有序的序列，所以如果当前要插入的值`arr[j]`大于或等于`arr[j-1]`，则无需继续比较，直接下一次循环就可以了。\n\n#### 时间复杂度\n\n乍一看，好像插入排序速度还不慢，但是要知道： 当序列正好逆序的时候，每次插入都要一次次交换，这个速度和冒泡排序是一样的，时间复杂度O(n²)； 当然运气好，前面是有序的，那时间复杂度就只有O(n)了，直接插入即可。\n\n| 排序算法     | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 是否稳定 |\n| ------------ | :------------: | :------------: | :--------: | :------: |\n| 冒泡排序     |     O(n²)      |     O(n²)      |    O(1)    |    是    |\n| 选择排序     |     O(n²)      |     O(n²)      |    O(1)    |   不是   |\n| 直接插入排序 |     O(n²)      |     O(n²)      |    O(1)    |    是    |\n\n好了，这张表如何快速记忆呢？ 方法就是一开始写的**基本排序算法** 。 一开始就说到，基本思想就是两层循环嵌套，第一遍找元素O(n),第二遍找位置O(n)，所以这几种方法，时间复杂度就可以这么简便记忆啦!\n\n---\n\n### 高级排序算法\n\n如果所有排序都像上面的基本方法一样，那么对于大量数据的处理，将是灾难性的，老哥，只是让你排个序，你都用了O(n²)。 好吧，所以接下来这些高级排序算法，在大数据上，可以大大的减少复杂度。 \n\n#### 快速排序\n\n快速排序可以说是对于前端最最最最重要的排序算法，没有之一了，面试官问到排序算法，快排的概率能有80%以上(我瞎统计的...信不信由你)。\n\n所以快排是什么呢？\n\n> 快排是处理大数据最快的排序算法之一。它是一种分而治之的算法，通过递归的方式将数据依次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤直至所有数据都是有序的。\n\n简单说： 找到一个数作为参考，比这个数字大的放在数字左边，比它小的放在右边； 然后分别再对左边和右变的序列做相同的操作:\n\n1. 选择一个基准元素，将列表分割成两个子序列；\n2. 对列表重新排序，将所有小于基准值的元素放在基准值前面，所有大于基准值的元素放在基准值的后面；\n3. 分别对较小元素的子序列和较大元素的子序列重复步骤1和2\n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fu942wgi1tg20kz071k8b.gif)\n\n```javascript\nfunction quickSort(arr) {\n    if(arr.length <= 1) {\n        return arr;  //递归出口\n    }\n    var left = [],\n        right = [],\n        current = arr.splice(0,1); //注意splice后，数组长度少了一个\n    for(let i = 0; i < arr.length; i++) {\n        if(arr[i] < current) {\n            left.push(arr[i])  //放在左边\n        } else {\n            right.push(arr[i]) //放在右边\n        }\n    }\n    return quickSort(left).concat(current,quickSort(right)); //递归\n}\n```\n\n#### 希尔排序\n\n希尔排序是插入排序的改良算法，但是核心理念与插入算法又不同，它会先比较距离较远的元素，而非相邻的元素。文字太枯燥，还是看下面的动图吧：\n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fu9cru5iyjg20ih082n4c.gif)\n\n在实现之前，先看下刚才插入排序怎么写的：\n\n```javascript\nfunction insertSort(arr) {\n    for(let i = 1; i < arr.length - 1; i++) {  //外循环从1开始，默认arr[0]是有序段\n        for(let j = i; j > 0; j--) {  //j = i,将arr[j]依次插入有序段中\n            if(arr[j] < arr[j-1]) {\n                [arr[j],arr[j-1]] = [arr[j-1],arr[j]];\n            } else {\n                continue;\n            }\n        }\n    }\n    return arr;\n}\n```\n\n现在，不同之处是在上面的基础上，让步长按照3、2、1来进行比较，相当于是三层循环和嵌套啦。\n\n```javascript\ninsertSort(arr,[3,2,1]);\nfunction shellSort(arr,gap) {\n    console.log(arr)//为了方便观察过程，使用时去除\n    for(let i = 0; i<gap.length; i++) {  //最外层循环，一次取不同的步长，步长需要预先给出\n        let n = gap[i]; //步长为n\n        for(let j = i + n; j < arr.length; j++) { //接下类和插入排序一样，j循环依次取后面的数\n            for(let k = j; k > 0; k-=n) { //k循环进行比较，和直接插入的唯一区别是1变为了n\n                if(arr[k] < arr[k-n]) {\n                    [arr[k],arr[k-n]] = [arr[k-n],arr[k]];\n                    console.log(`当前序列为[${arr}] \\n 交换了${arr[k]}和${arr[k-n]}`)//为了观察过程\n                } else {\n                    continue;\n                }\n            }\n        }\n    }\n    return arr;\n}\n```\n\n直接看这个三层循环嵌套的内容，会稍显复杂，这也是为什么先把插入排序写在前面做一个对照。 其实三层循环的内两层完全就是一个插入排序，只不过原来插入排序间隔为`1`，而希尔排序的间隔是变换的`n`， 如果把`n`修改为`1`，就会发现是完全一样的了。\n\n运行一下看看\n\n```javascript\nvar arr = [3, 2, 45, 6, 55, 23, 5, 4, 8, 9, 19, 0];\nvar gap = [3,2,1];\nconsole.log(shellSort(arr,gap))\n```\n\n结果如下:\n\n```javascript\n(12) [3, 2, 45, 6, 55, 23, 5, 4, 8, 9, 19, 0] //初始值\n当前序列为[3,2,23,6,55,45,5,4,8,9,19,0] \n 交换了45和23\n当前序列为[3,2,23,5,55,45,6,4,8,9,19,0] \n 交换了6和5\n当前序列为[3,2,23,5,4,45,6,55,8,9,19,0] \n 交换了55和4\n当前序列为[3,2,23,5,4,8,6,55,45,9,19,0] \n 交换了45和8\n当前序列为[3,2,8,5,4,23,6,55,45,9,19,0] \n 交换了23和8\n当前序列为[3,2,8,5,4,23,6,19,45,9,55,0] \n 交换了55和19\n当前序列为[3,2,8,5,4,23,6,19,0,9,55,45] \n 交换了45和0\n当前序列为[3,2,8,5,4,0,6,19,23,9,55,45] \n 交换了23和0\n当前序列为[3,2,0,5,4,8,6,19,23,9,55,45] \n 交换了8和0\n当前序列为[0,2,3,5,4,8,6,19,23,9,55,45] \n 交换了3和0\n当前序列为[0,2,3,5,4,8,6,9,23,19,55,45] \n 交换了19和9\n当前序列为[0,2,3,4,5,8,6,9,23,19,55,45] \n 交换了5和4\n当前序列为[0,2,3,4,5,6,8,9,23,19,55,45] \n 交换了8和6\n当前序列为[0,2,3,4,5,6,8,9,19,23,55,45] \n 交换了23和19\n当前序列为[0,2,3,4,5,6,8,9,19,23,45,55] \n 交换了55和45\n```\n\n#### 时间复杂度总结\n\nwait？ 不是还有很多排序算法的吗？怎么不继续了？ 是的，其实排序是很深奥的问题，如果研究透各个方法的实现、性能等等，内容恐怕多到爆炸了...而且这个也主要是为**前端常见算法** 问题的总结，个人觉得到这里就差不多了\n\n| 排序算法     | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 是否稳定 |\n| ------------ | :------------: | :------------: | :--------: | :------: |\n| 冒泡排序     |     O(n²)      |     O(n²)      |    O(1)    |    是    |\n| 选择排序     |     O(n²)      |     O(n²)      |    O(1)    |   不是   |\n| 直接插入排序 |     O(n²)      |     O(n²)      |    O(1)    |    是    |\n| 快速排序     |    O(nlogn)    |     O(n²)      |  O(logn)   |   不是   |\n| 希尔排序     |    O(nlogn)    |     O(n^s)     |    O(1)    |   不是   |\n\n##### 是否稳定\n\n如果不考虑稳定性，快排似乎是接近完美的一种方法，但可惜它是不稳定的。 那什么是稳定性呢？\n\n通俗的讲**有两个相同的数A和B，在排序之前A在B的前面，而经过排序之后，B跑到了A的前面，对于这种情况的发生，我们管他叫做排序的不稳定性**，而快速排序在对存在相同数进行排序时就有可能发生这种情况。 \n\n```javascript\n/*\n比如对(5，3A，6，3B ) 进行排序，排序之前相同的数3A与3B，A在B的前面，经过排序之后会变成  \n\t（3B，3A，5，6）\n所以说快速排序是一个不稳定的排序\n/*\n```\n\n稳定性有什么意义？ 个人理解对于前端来说，比如我们熟知框架中的虚拟DOM的比较，我们对一个`<ul>`列表进行渲染，当数据改变后需要比较变化时，不稳定排序或操作将会使本身不需要变化的东西变化，导致重新渲染，带来性能的损耗。 \n\n##### 辅助记忆\n\n* 时间复杂度记忆\n  * 冒泡、选择、直接 排序需要两个for循环，每次只关注一个元素，平均时间复杂度为O(n²)(一遍找元素O(n)，一遍找位置O(n)）\n  * 快速、归并、希尔、堆基于二分思想，log以2为底，平均时间复杂度为O(nlogn)(一遍找元素O(n)，一遍找位置O(logn))\n* 稳定性记忆-“快希选堆”（快牺牲稳定性） \n* \n\n\n\n---\n\n## 递归\n\n递归，其实就是自己调用自己。\n\n很多时候我们自己觉得麻烦或者感觉 \"想象不过来\"，主要是自己和自己较真，因为交给递归，它自己会帮你完成需要做的。\n\n递归步骤：\n\n* 寻找出口，递归一定有一个出口，锁定出口，保证不会死循环\n* 递归条件，符合递归条件，自己调用自己。\n\n> talk is cheap，show me code！\n\n斐波那契数列，每个语言讲递归都会从这个开始，但是既然搞前端，就搞点不一样的吧，从对象的深度克隆(deep clone)说起\n\n**Deep Clone** ：实现对一个对象(object)的深度克隆\n\n```javascript\n//所谓深度克隆，就是当对象的某个属性值为object或array的时候，要获得一份copy，而不是直接拿到引用值\nfunction deepClone(origin,target) {  //origin是被克隆对象，target是我们获得copy\n    var target = target || {}; //定义target\n    for(var key in origin) {  //遍历原对象\n        if(origin.hasOwnProperty(key)) {\n            if(Array.isArray(origin[key])) { //如果是数组\n                target[key] = [];\n                deepClone(origin[key],target[key]) //递归\n            } else if (typeof origin[key] === 'object' && origin[key] !== null) {\n                target[key] = {};\n                deepClone(origin[key],target[key]) //递归\n            } else {\n                target[key] = origin[key];\n            }\n        }\n    }\n    return target;\n}\n```\n\n这个可以说是前端笔试/面试中经常经常遇到的问题了，思路是很清晰的：\n\n* 出口： 遍历对象结束后return\n* 递归条件： 遇到引用值Array 或 Object\n\n剩下的事情，交给JS自己处理就好了，我们不用考虑内部的层层嵌套，想太多\n\n### 实战例题\n\n接下来，列举一些自己在最近笔试、面试中遇到的，需要使用递归实现的问题\n\n#### Q1：Array数组的flat方法实现(2018网易雷火&伏羲前端秋招笔试)\n\nArray的方法flat很多浏览器还未能实现，请写一个flat方法，实现扁平化嵌套数组，如：\n\n```javascript\nArray\nvar arr1 = [1, 2, [3, 4]];\narr1.flat(); \n// [1, 2, 3, 4]\n```\n\n这个问题的实现思路和Deep Clone非常相似，这里实现如下：\n\n```javascript\nArray.prototype.flat = function() {\n    var arr = [];\n    this.forEach((item,idx) => {\n        if(Array.isArray(item)) {\n            arr = arr.concat(item.flat()); //递归去处理数组元素\n        } else {\n            arr.push(item)   //非数组直接push进去\n        }\n    })\n    return arr;   //递归出口\n}\n```\n\n好了，可以测试一下：\n\n```javascript\narr = [[2],[[2,3],[2]],3,4]\narr.flat()\n// [2, 2, 3, 2, 3, 4]\n```\n\n**神秘力量的新解法**\n\n在评论区的一位小伙伴，提出了更好的办法，很简洁、方便，只用一句话就可以实现需求哦(不过你这样去解答一道网易的“编程题”,不觉得让人家有点难堪嘛~哈哈)\n```javascript\narr.prototype.flat = function() {\n    this.toString().split(',').map(item=> +item )\n}\n```\n好了，惊叹完之后，大概说下实现吧：\n\n1. toString方法，连接数组并返回一个字符串 `'2,2,3,2,3,4'`\n2. split方法分割字符串，变成数组`['2','2','3','2','3','4']`\n3. map方法，将string映射成为number类型`2,2,3,2,3,4`\n\n#### Q2 实现简易版的co，自动执行generator\n\n这个问题，详细的解释可以在我之前的文章([从Co剖析和解释generator的异步原理](https://juejin.im/post/5b5f169fe51d4518e311ba78))去看一下，如果对ES6的iterator和generator不太了解的，可以跳过这个问题。\n\n比如实现如下的功能:\n```javascript  \nconst co = require('co');\nco(function *() {\n    const url = 'http://jasonplacerholder.typecoder.com/posts/1';\n    const response = yield fetch(url);\n    const post = yield response.json();\n    const title = post.title;\n    console.log('Title: ',title);\n})\n```\n\n剖析：\n* 第一步找出口，执行器返回的iterator如果状态为`done`，代表结束，可以出去\n* 递归条件： 取到下一个iterator，进行递归，自我调用\n\n```javascript\nfunction run(generat) {\n    const iterator = generat();\n    function autoRun(iteration) {\n        if(iteration.done) {return iteration.value}  //出口\n        const anotherPromise = iteration.value;\n        anoterPromise.then(x => {\n            return autoRun(iterator.next(x))  //递归条件\n        })\n    }\n    return autoRun(iterator.next()) \n}\n\n```\n\n#### Q3. 爬楼梯问题\n\n有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？\n\n**分析**： 这个问题要倒过来看，要到达n级楼梯，只有两种方式，从（n-1）级 或 （n-2）级到达的。所以可以用递推的思想去想这题，假设有一个数组s[n], 那么s[1] = 1（由于一开始就在第一级，只有一种方法）， s[2] = 1（只能从s[1]上去 没有其他方法）。\n\n那么就可以推出s[3] ~ s[n]了。\n\n下面继续模拟一下， s[3] = s[1] + s[2]， 因为只能从第一级跨两步， 或者第二级跨一步。\n\n```javascript\nfunction cStairs(n) {\n    if(n === 1 || n === 2) {\n        return 1;\n    } else {\n        return cStairs(n-1) + cStairs(n-2)\n    }\n}\n```\n\n嗯嗯，没错呢，其实就是斐波纳契数列没跑了\n\n#### Q4.二分查找\n\n二分查找，是在一个有序的序列里查找某一个值，与小时候玩的猜数字游戏非常相啦：\n\n```\nA: 0 ~ 100 猜一个数字\nB: 50\nA: 大了\nB: 25\nA: 对头，就是25\n```\n\n因此，思路也就非常清楚了，这里有递归和非递归两种写法，先说下递归的方法吧：\n\n* 设定区间,low和high\n* 找出口： 找到target，返回target；\n* 否则寻找，当前次序没有找到，把区间缩小后递归\n\n```javascript\nfunction binaryFind(arr,target,low = 0,high = arr.length - 1) {\n    const n = Math.floor((low+high) /2);\n    const cur = arr[n];\n    if(cur === target) {\n        return `找到了${target},在第${n+1}个`;\n    } else if(cur > target) {\n        return binaryFind(arr,target,low, n-1);\n    } else if (cur < target) {\n        return binaryFind(arr,target,n+1,high);\n    }\n    return -1;\n}\n```\n\n接下来，使用循环来做一下二分查找，其实思路基本一致：\n\n```javascript\nfunction binaryFind(arr, target) {\n    var low = 0,\n        high = arr.length - 1,\n        mid;\n    while (low <= high) {\n        mid = Math.floor((low + high) / 2);\n        if (target === arr[mid]) {\n            return `找到了${target},在第${mid + 1}个`\n        }\n        if (target > arr[mid]) {\n            low = mid + 1;\n        } else if (target < arr[mid]) {\n            high = mid - 1;\n        }\n    }\n    return -1\n}\n```\n\n\n\n## 二叉树和二叉查找树\n\n### 树的基本概念\n\n这里对基本概念就不详细复习了，在各大资料中有更详尽的介绍，这里就只简单介绍基本概念和术语，然后使用JavaScript实现一个二叉树，并封装其方法。\n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fufxqalweej20r20fmwii.jpg)\n\n如图所示，一棵树最上面的几点称为根节点，如果一个节点下面连接多个节点，那么该节点成为父节点，它下面的节点称为子节点，一个节点可以有0个、1个或更多节点，没有子节点的节点叫叶子节点。\n\n**二叉树**，是一种特殊的树，即子节点最多只有两个，这个限制可以使得写出高效的插入、删除、和查找数据。在二叉树中，子节点分别叫左节点和右节点。 \n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fufy2mm3fsj20pn08wgnf.jpg)\n\n### 二叉查找树\n\n二叉查找树是一种特殊的二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中，这一特性使得查找的效率很高，对于数值型和非数值型数据，比如字母和字符串，都是如此。现在通过JS实现一个二叉查找树。\n\n#### 节点\n\n二叉树的最小元素是节点，所以先定义一个节点\n\n```javascript\nfunction Node(data,left,right) {\n    this.left = left;\n    this.right = right;\n    this.data = data;\n    this.show = () => {return this.data}\n}\n```\n\n这个就是二叉树的最小结构单元\n\n#### 二叉树\n\n```javascript\nfunction BST() {\n    this.root = null //初始化,root为null\n}\n```\n\nBST初始化时，只有一个根节点，且没有任何数据。 接下来，我们利用二叉查找树的规则，定义一个插入方法，这个方法的基本思想是:\n\n1. 如果`BST.root === null` ，那么就将节点作为根节点\n2. 如果`BST.root !==null` ，将插入节点进行一个比较，小于根节点，拿到左边的节点，否则拿右边，再次比较、递归。\n\n这里就出现了递归了，因为，总是要把较小的放在靠左的分支。换言之\n\n**最左变的叶子节点是最小的数，最右的叶子节点是最大的数**\n\n```javascript\nfunction insert(data) {\n    var node = new Node(data,null,null);\n    if(this.root === null) {\n        this.root = node\n    } else {\n        var current = this.root;\n        var parent;\n        while(true) {\n            parent = current;\n            if(data < current.data) {\n                current = current.left; //到左子树\n                if(current === null) {  //如果左子树为空，说明可以将node插入在这里\n                    parent.left = node;\n                    break;  //跳出while循环\n                }\n            } else {\n                current = current.right;\n                if(current === null) {\n                    parent.right = node;\n                    break;\n                }\n            }\n        }\n    }\n}\n```\n\n这里，是使用了一个循环方法，不断的去向子树寻找正确的位置。 循环和递归都有一个核心，就是找到出口，这里的出口就是当current 为null的时候，代表没有内容，可以插入。\n\n接下来，将此方法写入BST即可:\n\n```javascript\nfunction BST() {\n    this.root = null;\n    this.insert = insert;\n}\n```\n\n这样子，就可以使用二叉树这个自建的数据结构了:\n\n```javascript\nvar bst = new BST()；\nbst.insert(10);\nbst.insert(8);\nbst.insert(2);\nbst.insert(7);\nbst.insert(5);\n```\n\n但是这个时候，想要看树中的数据，不是那么清晰，所以接下来，就要用到遍历了。\n\n#### 二叉树的遍历\n\n我们知道，树的遍历主要包括\n\n* 前序遍历 (根左右)\n* 中序遍历 (左根右)\n* 后序遍历 (左右根)\n\n这个只是为了好记忆，我们拿下面的图做一个遍历\n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fug0jaukqpj209k057jrx.jpg)\n\n前序遍历: 56 22 10 30 81 77 92\n\n中序遍历: 10 22 30 56 77 81 92\n\n后序遍历: 10 30 22 77 92 81 56\n\n这里发现了一些规律：\n\n1. 前序遍历，因为是根左右，所以最后一个一定是最大的； 第一个一定是root节点；\n2. 中序遍历，在查找二叉树中，一定是从小到大的顺序； 根节点`56`左边(10/22/30)的一定是左子树的，右边的(77/81/92)一定是右子树的。\n3. 后序遍历，根节点一定在最后\n\n##### 中序遍历的实现\n\n这里就又用到之前的递归了，中序遍历要求: **左！根！右**\n\n```javascript\nfunction inOrder(node) {\n    if(node !== null) {\n        //如果不是null，就一直查找左变，因此递归\n        inOrder(node.left);\n        //递归结束，打印当前值\n        console.log(node.show());\n        //上一次递归已经把左边搞完了，右边\n        inOrder(node.right);\n    }\n}\n\n//在刚才已有bst的基础上执行命令\ninOrder(bst.root);\n```\n\n通过递归，实现了中序遍历，上面打印出的结果如下:\n\n```\n2\n5\n7\n8\n10\n```\n\n##### 前序遍历&后序遍历\n\n如果刚才的递归过程搞清楚，那这个就再简单不过了\n\n```javascript\nfunction preOrder(node) {\n    if(node !== null) {\n        //根左右\n        console.log(node.show());\n        preOrder(node.left);\n        preOrder(node.right);\n    }\n}\n```\n\nok,趁热打铁，就把后序遍历的方法也一并写入，如下:\n\n```javascript\nfunction postOrder(node) {\n    if(node !== null) {\n        //左右根\n        postOrder(node.left);\n        postOrder(node.right);\n        console.log(node.show())\n    }\n}\n```\n\n好了，可以去尝试两种方法打印出来的结果了:\n\n```javascript\npreOrder(bst.root);\npostOrder(bst.root);\n```\n\n### 二叉树的查找\n\n在二叉树这种数据结构中进行数据查找是最方便的，现在我们就对查找最小值、最大值和特定值进行一个梳理：\n\n* 最小值： 最左子树的叶子节点\n* 最大值： 最右子树的叶子节点\n* 特定值： target与current进行比较，如果比current大，在current.right进行查找，反之类似。\n\n清楚思路后，就动手来写：\n\n```javascript\n//最小值\nfunction getMin(bst) {\n    var current = bst.root;\n    while(current.left !== null) {\n        current = current.left;\n    }\n    return current.data;\n}\n\n//最大值\nfunction getMax(bst) {\n    var current = bst.root;\n    while(current.right !== null) {\n        current = current.right;\n    }\n    return current.data;\n}\n```\n\n最大、最小值都是非常简单的，下面主要看下如何通过\n\n```javascript\nfunction find(target,bst) {\n    var current = bst.root;\n    while(current !== null) {\n        if(target === current.data) {\n            return true;\n        }\n        else if(target > current.data) {\n            current = current.right;\n        } else if(target < current.data) {\n            current = current.left;\n        }\n    }\n    return -1;\n}\n```\n\n其实核心，仍然是通过一个循环和判断，来不断的向下去寻找，这里的思想其实和二分查找是有点类似的。\n\n哇...\n\n没想到今天去整理排序 花了这么久...嗯..然而这篇文章已经够长了\n\n接下来我会把之前笔试遇到的题目和一些常用的算法问题，一一记录，前端很多算法都是和数组、字符串处理息息相关的，所以对正则表达式、数组常用方法的掌握也很重要，简单总结下知识点：\n\n* 正则表达式\n  * 字符串相关方法\n  * str.split()\n  * str.replace()\n  * str.match()\n  * reg.test()\n  * reg.exec()\n* 数组方法\n  * Array.map()  映射，有返回值，不改变数组本身\n  * Array.forEach() 遍历，无返回值\n  * Array.filter() 过滤，返回true时返回,false时不返回\n  * Array.splice/slice/join等\n  * for...of 遍历,iterator相关知识点\n\n\n\n### 未完待续....\n\n内容会持续更新，最快的当然还是在github上，然后会同步到掘金，[github传送门](https://github.com/forrany/Web-Project)\n\n\n\n### 参考资料\n\n1. [排序算法时间复杂度、空间复杂度、稳定性比较](https://blog.csdn.net/yushiyi6453/article/details/76407640)\n2. [算法学习记录--希尔排序](https://www.cnblogs.com/jsgnadsj/p/3458054.html)\n3. [快速排序简单理解](https://blog.csdn.net/tizzzzzz/article/details/79610375)\n4. [数据结构与算法Javascript描述](https://book.douban.com/subject/25945449/)","slug":"2018-08-21-front-end-interview-algorithm","published":1,"updated":"2022-08-17T07:53:21.232Z","comments":1,"photos":[],"link":"","_id":"cl6xbhzk2000jzk084v3qh5nr","content":"<p>终于来了，算法相关的。 其实个人理解，前端岗位对于算法的要求与其他IT岗位相比，是低得多的。 但是小白我经历了如蚂蚁金服、网易这样的大厂教做人之后，还是觉得，对于一些基本算法、思想的掌握还是必须的。 然后，就把自己遇到的、学到的算法相关的再总结一下，方便自己随时备战面试。</p>\n<p>系列笔记：</p>\n<p><a href=\"https://forrany.github.io/2018/08/10/2018-08-10-VK-mistake-1/\" target=\"_blank\" rel=\"noopener\">1.VK的秋招前端奇遇记(一)</a></p>\n<p><a href=\"https://forrany.github.io/2018/08/11/2018-08-11-VK-mistake-2/\" target=\"_blank\" rel=\"noopener\">2.VK的秋招前端奇遇记(二)</a></p>\n<p><a href=\"https://forrany.github.io/2018/08/12/2018-08-12-VK-mistake-3/\" target=\"_blank\" rel=\"noopener\">3.VK的秋招前端奇遇记(三)</a></p>\n<p><a href=\"https://forrany.github.io/2018/09/04/2018-09-04-VK-mistake-4/\" target=\"_blank\" rel=\"noopener\">4.VK的秋招前端奇遇记(四)</a></p>\n<p><a href=\"https://forrany.github.io/2018/08/21/2018-08-21-front-end-interview-algorithm/\" target=\"_blank\" rel=\"noopener\">5.番外篇：前端面试&amp;笔试算法 Algorithm</a></p>\n<hr>\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><p>JS本身数组的sort方法，可以满足日常业务操作中很多的场景了，所以我认为这也是为什么基本面试会直接让写一个<code>快速排序</code>，因为好像其他排序方法在JS中似乎没什么意义了。 </p>\n<p>但是在拼多多的面试中，面试官还是让我手写<code>选择排序</code> <code>冒泡排序</code> 和<code>快速排序</code> 的伪代码。 既然有机会总结，干脆就全部写一遍好了，从基本排序到高级排序来说。</p>\n<h3 id=\"基本排序算法\"><a href=\"#基本排序算法\" class=\"headerlink\" title=\"基本排序算法\"></a>基本排序算法</h3><p>基本排序的基本思想非常类似，重排列时用的技术基本都是一组嵌套的for循环: 外循环遍历数组的每一项，内循环则用于比较元素。</p>\n<h4 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h4><p>最笨最基本最经典点的方法，不管学什么语言，说到排序，第一个接触的就是它了吧。基本思想什么的太经典了，就不复数了，直接用例子说明过程吧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">E A D B H</span><br></pre></td></tr></table></figure>\n<p>经过一次排列后，变成</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A E D B H</span><br></pre></td></tr></table></figure>\n<p>前两个元素互换了，接下来变成：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A D E B H</span><br></pre></td></tr></table></figure>\n<p>第二个和第三个互换，继续：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A D B E H</span><br></pre></td></tr></table></figure>\n<p>第三个和第四个互换，最后，第二个和第三个元素还会互换一次，得到最终的顺序为：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A B D E H</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fu93tfy076g20le06aazd.gif\" alt=\"\"></p>\n<p>好了，其实基本思想就是逐个的比较，下面就实现一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubleSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> outer = len ; outer &gt;= <span class=\"number\">2</span>; outer--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> inner = <span class=\"number\">0</span>; inner &lt;=outer - <span class=\"number\">1</span>; inner++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[inner] &gt; arr[inner + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> temp = arr[inner];</span><br><span class=\"line\">                arr[inner] = arr[inner + <span class=\"number\">1</span>];</span><br><span class=\"line\">                arr[inner + <span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有两点需要注意：</p>\n<ol>\n<li>外层循环，从最大值开始递减，因为内层是两两比较，因此最外层当<code>&gt;=2</code>时即可停止；</li>\n<li>内层是两两比较，从0开始，比较<code>inner</code>与<code>inner+1</code>，因此，临界条件是<code>inner&lt;outer -1</code></li>\n</ol>\n<p>在比较交换的时候，就是计算机中最经典的交换策略，用临时变量<code>temp</code>保存值，但是面试官问过我，<strong>ES6有没有简单的方法实现？</strong> 有的，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr2 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\">[arr2[<span class=\"number\">0</span>],arr2[<span class=\"number\">1</span>]] = [arr2[<span class=\"number\">1</span>],arr2[<span class=\"number\">0</span>]]  <span class=\"comment\">//ES6解构赋值</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2)  <span class=\"comment\">// [2, 1, 3, 4]</span></span><br></pre></td></tr></table></figure>\n<p>所以，刚才的冒牌排序可以优化如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubleSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> outer = len ; outer &gt;= <span class=\"number\">2</span>; outer--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> inner = <span class=\"number\">0</span>; inner &lt;=outer - <span class=\"number\">1</span>; inner++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[inner] &gt; arr[inner + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                [arr[inner],arr[inner+<span class=\"number\">1</span>]] = [arr[inner+<span class=\"number\">1</span>],arr[inner]]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h4><p>选择排序是从数组的开头开始，将第一个元素和其他元素作比较，检查完所有的元素后，最小的放在第一个位置，接下来再开始从第二个元素开始，重复以上一直到最后。</p>\n<p><img src=\"http://img.mp.itc.cn/upload/20160923/c705c53489b8455090ccb67199465387_th.jpg\" alt=\"\"></p>\n<p>有了刚才的铺垫，我觉得不用再演示了，很简单嘛： 外层循环从0开始到<code>length-1</code>， 然后内层比较，最小的放开头，走你：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span> ;i &lt; len - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = i ; j&lt;len; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[j] &lt; arr[i]) &#123;</span><br><span class=\"line\">                [arr[i],arr[j]] = [arr[j],arr[i]];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简单说两句：</p>\n<ul>\n<li>外层循环的<code>i</code>表示第几轮，<code>arr[i]</code>就表示当前轮次最靠前(小)的位置；</li>\n<li>内层从<code>i</code>开始，依次往后数，找到比开头小的，互换位置即可</li>\n</ul>\n<p>结束，收工！！</p>\n<h4 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h4><p>插入排序核心–扑克牌思想： <strong>就想着自己在打扑克牌，接起来一张，放哪里无所谓，再接起来一张，比第一张小，放左边，继续接，可能是中间数，就插在中间….依次</strong></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fu93uujulog20le0ejtyb.gif\" alt=\"\"></p>\n<p>其实每种算法，主要是理解其原理，至于写代码，都是在原理之上顺理成章的事情：</p>\n<ul>\n<li>首先将待排序的第一个记录作为一个有序段</li>\n<li>从第二个开始，到最后一个，依次和前面的有序段进行比较，确定插入位置</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; arr.length; i++) &#123;  <span class=\"comment\">//外循环从1开始，默认arr[0]是有序段</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = i; j &gt; <span class=\"number\">0</span>; j--) &#123;  <span class=\"comment\">//j = i,将arr[j]依次插入有序段中</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[j] &lt; arr[j<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                [arr[j],arr[j<span class=\"number\">-1</span>]] = [arr[j<span class=\"number\">-1</span>],arr[j]];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析： 注意这里两次循环中，<code>i</code>和<code>j</code>的含义：</p>\n<ol>\n<li><code>i</code>是外循环，依次把后面的数插入前面的有序序列中，默认<code>arr[0]</code>为有序的，<code>i</code>就从1开始</li>\n<li><code>j</code>进来后，依次与前面队列的数进行比较，因为前面的序列是有序的，因此只需要循环比较、交换即可</li>\n<li>注意这里的<code>break</code>，因为前面是都是有序的序列，所以如果当前要插入的值<code>arr[j]</code>大于或等于<code>arr[j-1]</code>，则无需继续比较，直接下一次循环就可以了。</li>\n</ol>\n<h4 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h4><p>乍一看，好像插入排序速度还不慢，但是要知道： 当序列正好逆序的时候，每次插入都要一次次交换，这个速度和冒泡排序是一样的，时间复杂度O(n²)； 当然运气好，前面是有序的，那时间复杂度就只有O(n)了，直接插入即可。</p>\n<table>\n<thead>\n<tr>\n<th>排序算法</th>\n<th style=\"text-align:center\">平均时间复杂度</th>\n<th style=\"text-align:center\">最坏时间复杂度</th>\n<th style=\"text-align:center\">空间复杂度</th>\n<th style=\"text-align:center\">是否稳定</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>冒泡排序</td>\n<td style=\"text-align:center\">O(n²)</td>\n<td style=\"text-align:center\">O(n²)</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">是</td>\n</tr>\n<tr>\n<td>选择排序</td>\n<td style=\"text-align:center\">O(n²)</td>\n<td style=\"text-align:center\">O(n²)</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">不是</td>\n</tr>\n<tr>\n<td>直接插入排序</td>\n<td style=\"text-align:center\">O(n²)</td>\n<td style=\"text-align:center\">O(n²)</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">是</td>\n</tr>\n</tbody>\n</table>\n<p>好了，这张表如何快速记忆呢？ 方法就是一开始写的<strong>基本排序算法</strong> 。 一开始就说到，基本思想就是两层循环嵌套，第一遍找元素O(n),第二遍找位置O(n)，所以这几种方法，时间复杂度就可以这么简便记忆啦!</p>\n<hr>\n<h3 id=\"高级排序算法\"><a href=\"#高级排序算法\" class=\"headerlink\" title=\"高级排序算法\"></a>高级排序算法</h3><p>如果所有排序都像上面的基本方法一样，那么对于大量数据的处理，将是灾难性的，老哥，只是让你排个序，你都用了O(n²)。 好吧，所以接下来这些高级排序算法，在大数据上，可以大大的减少复杂度。 </p>\n<h4 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h4><p>快速排序可以说是对于前端最最最最重要的排序算法，没有之一了，面试官问到排序算法，快排的概率能有80%以上(我瞎统计的…信不信由你)。</p>\n<p>所以快排是什么呢？</p>\n<blockquote>\n<p>快排是处理大数据最快的排序算法之一。它是一种分而治之的算法，通过递归的方式将数据依次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤直至所有数据都是有序的。</p>\n</blockquote>\n<p>简单说： 找到一个数作为参考，比这个数字大的放在数字左边，比它小的放在右边； 然后分别再对左边和右变的序列做相同的操作:</p>\n<ol>\n<li>选择一个基准元素，将列表分割成两个子序列；</li>\n<li>对列表重新排序，将所有小于基准值的元素放在基准值前面，所有大于基准值的元素放在基准值的后面；</li>\n<li>分别对较小元素的子序列和较大元素的子序列重复步骤1和2</li>\n</ol>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fu942wgi1tg20kz071k8b.gif\" alt=\"\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quickSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(arr.length &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arr;  <span class=\"comment\">//递归出口</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> left = [],</span><br><span class=\"line\">        right = [],</span><br><span class=\"line\">        current = arr.splice(<span class=\"number\">0</span>,<span class=\"number\">1</span>); <span class=\"comment\">//注意splice后，数组长度少了一个</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(arr[i] &lt; current) &#123;</span><br><span class=\"line\">            left.push(arr[i])  <span class=\"comment\">//放在左边</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            right.push(arr[i]) <span class=\"comment\">//放在右边</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> quickSort(left).concat(current,quickSort(right)); <span class=\"comment\">//递归</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h4><p>希尔排序是插入排序的改良算法，但是核心理念与插入算法又不同，它会先比较距离较远的元素，而非相邻的元素。文字太枯燥，还是看下面的动图吧：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fu9cru5iyjg20ih082n4c.gif\" alt=\"\"></p>\n<p>在实现之前，先看下刚才插入排序怎么写的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; arr.length - <span class=\"number\">1</span>; i++) &#123;  <span class=\"comment\">//外循环从1开始，默认arr[0]是有序段</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = i; j &gt; <span class=\"number\">0</span>; j--) &#123;  <span class=\"comment\">//j = i,将arr[j]依次插入有序段中</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[j] &lt; arr[j<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                [arr[j],arr[j<span class=\"number\">-1</span>]] = [arr[j<span class=\"number\">-1</span>],arr[j]];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，不同之处是在上面的基础上，让步长按照3、2、1来进行比较，相当于是三层循环和嵌套啦。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">insertSort(arr,[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shellSort</span>(<span class=\"params\">arr,gap</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(arr)<span class=\"comment\">//为了方便观察过程，使用时去除</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i&lt;gap.length; i++) &#123;  <span class=\"comment\">//最外层循环，一次取不同的步长，步长需要预先给出</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> n = gap[i]; <span class=\"comment\">//步长为n</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = i + n; j &lt; arr.length; j++) &#123; <span class=\"comment\">//接下类和插入排序一样，j循环依次取后面的数</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> k = j; k &gt; <span class=\"number\">0</span>; k-=n) &#123; <span class=\"comment\">//k循环进行比较，和直接插入的唯一区别是1变为了n</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(arr[k] &lt; arr[k-n]) &#123;</span><br><span class=\"line\">                    [arr[k],arr[k-n]] = [arr[k-n],arr[k]];</span><br><span class=\"line\">                    <span class=\"built_in\">console</span>.log(<span class=\"string\">`当前序列为[<span class=\"subst\">$&#123;arr&#125;</span>] \\n 交换了<span class=\"subst\">$&#123;arr[k]&#125;</span>和<span class=\"subst\">$&#123;arr[k-n]&#125;</span>`</span>)<span class=\"comment\">//为了观察过程</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>直接看这个三层循环嵌套的内容，会稍显复杂，这也是为什么先把插入排序写在前面做一个对照。 其实三层循环的内两层完全就是一个插入排序，只不过原来插入排序间隔为<code>1</code>，而希尔排序的间隔是变换的<code>n</code>， 如果把<code>n</code>修改为<code>1</code>，就会发现是完全一样的了。</p>\n<p>运行一下看看</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">45</span>, <span class=\"number\">6</span>, <span class=\"number\">55</span>, <span class=\"number\">23</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">19</span>, <span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> gap = [<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(shellSort(arr,gap))</span><br></pre></td></tr></table></figure>\n<p>结果如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">12</span>) [<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">45</span>, <span class=\"number\">6</span>, <span class=\"number\">55</span>, <span class=\"number\">23</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">19</span>, <span class=\"number\">0</span>] <span class=\"comment\">//初始值</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">23</span>,<span class=\"number\">6</span>,<span class=\"number\">55</span>,<span class=\"number\">45</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">19</span>,<span class=\"number\">0</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">45</span>和<span class=\"number\">23</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">23</span>,<span class=\"number\">5</span>,<span class=\"number\">55</span>,<span class=\"number\">45</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">19</span>,<span class=\"number\">0</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">6</span>和<span class=\"number\">5</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">23</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">45</span>,<span class=\"number\">6</span>,<span class=\"number\">55</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">19</span>,<span class=\"number\">0</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">55</span>和<span class=\"number\">4</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">23</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">8</span>,<span class=\"number\">6</span>,<span class=\"number\">55</span>,<span class=\"number\">45</span>,<span class=\"number\">9</span>,<span class=\"number\">19</span>,<span class=\"number\">0</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">45</span>和<span class=\"number\">8</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">23</span>,<span class=\"number\">6</span>,<span class=\"number\">55</span>,<span class=\"number\">45</span>,<span class=\"number\">9</span>,<span class=\"number\">19</span>,<span class=\"number\">0</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">23</span>和<span class=\"number\">8</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">23</span>,<span class=\"number\">6</span>,<span class=\"number\">19</span>,<span class=\"number\">45</span>,<span class=\"number\">9</span>,<span class=\"number\">55</span>,<span class=\"number\">0</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">55</span>和<span class=\"number\">19</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">23</span>,<span class=\"number\">6</span>,<span class=\"number\">19</span>,<span class=\"number\">0</span>,<span class=\"number\">9</span>,<span class=\"number\">55</span>,<span class=\"number\">45</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">45</span>和<span class=\"number\">0</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">0</span>,<span class=\"number\">6</span>,<span class=\"number\">19</span>,<span class=\"number\">23</span>,<span class=\"number\">9</span>,<span class=\"number\">55</span>,<span class=\"number\">45</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">23</span>和<span class=\"number\">0</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">8</span>,<span class=\"number\">6</span>,<span class=\"number\">19</span>,<span class=\"number\">23</span>,<span class=\"number\">9</span>,<span class=\"number\">55</span>,<span class=\"number\">45</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">8</span>和<span class=\"number\">0</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">8</span>,<span class=\"number\">6</span>,<span class=\"number\">19</span>,<span class=\"number\">23</span>,<span class=\"number\">9</span>,<span class=\"number\">55</span>,<span class=\"number\">45</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">3</span>和<span class=\"number\">0</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">8</span>,<span class=\"number\">6</span>,<span class=\"number\">9</span>,<span class=\"number\">23</span>,<span class=\"number\">19</span>,<span class=\"number\">55</span>,<span class=\"number\">45</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">19</span>和<span class=\"number\">9</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">6</span>,<span class=\"number\">9</span>,<span class=\"number\">23</span>,<span class=\"number\">19</span>,<span class=\"number\">55</span>,<span class=\"number\">45</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">5</span>和<span class=\"number\">4</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">23</span>,<span class=\"number\">19</span>,<span class=\"number\">55</span>,<span class=\"number\">45</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">8</span>和<span class=\"number\">6</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">19</span>,<span class=\"number\">23</span>,<span class=\"number\">55</span>,<span class=\"number\">45</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">23</span>和<span class=\"number\">19</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">19</span>,<span class=\"number\">23</span>,<span class=\"number\">45</span>,<span class=\"number\">55</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">55</span>和<span class=\"number\">45</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"时间复杂度总结\"><a href=\"#时间复杂度总结\" class=\"headerlink\" title=\"时间复杂度总结\"></a>时间复杂度总结</h4><p>wait？ 不是还有很多排序算法的吗？怎么不继续了？ 是的，其实排序是很深奥的问题，如果研究透各个方法的实现、性能等等，内容恐怕多到爆炸了…而且这个也主要是为<strong>前端常见算法</strong> 问题的总结，个人觉得到这里就差不多了</p>\n<table>\n<thead>\n<tr>\n<th>排序算法</th>\n<th style=\"text-align:center\">平均时间复杂度</th>\n<th style=\"text-align:center\">最坏时间复杂度</th>\n<th style=\"text-align:center\">空间复杂度</th>\n<th style=\"text-align:center\">是否稳定</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>冒泡排序</td>\n<td style=\"text-align:center\">O(n²)</td>\n<td style=\"text-align:center\">O(n²)</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">是</td>\n</tr>\n<tr>\n<td>选择排序</td>\n<td style=\"text-align:center\">O(n²)</td>\n<td style=\"text-align:center\">O(n²)</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">不是</td>\n</tr>\n<tr>\n<td>直接插入排序</td>\n<td style=\"text-align:center\">O(n²)</td>\n<td style=\"text-align:center\">O(n²)</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">是</td>\n</tr>\n<tr>\n<td>快速排序</td>\n<td style=\"text-align:center\">O(nlogn)</td>\n<td style=\"text-align:center\">O(n²)</td>\n<td style=\"text-align:center\">O(logn)</td>\n<td style=\"text-align:center\">不是</td>\n</tr>\n<tr>\n<td>希尔排序</td>\n<td style=\"text-align:center\">O(nlogn)</td>\n<td style=\"text-align:center\">O(n^s)</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">不是</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"是否稳定\"><a href=\"#是否稳定\" class=\"headerlink\" title=\"是否稳定\"></a>是否稳定</h5><p>如果不考虑稳定性，快排似乎是接近完美的一种方法，但可惜它是不稳定的。 那什么是稳定性呢？</p>\n<p>通俗的讲<strong>有两个相同的数A和B，在排序之前A在B的前面，而经过排序之后，B跑到了A的前面，对于这种情况的发生，我们管他叫做排序的不稳定性</strong>，而快速排序在对存在相同数进行排序时就有可能发生这种情况。 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">比如对(5，3A，6，3B ) 进行排序，排序之前相同的数3A与3B，A在B的前面，经过排序之后会变成  </span></span><br><span class=\"line\"><span class=\"comment\">\t（3B，3A，5，6）</span></span><br><span class=\"line\"><span class=\"comment\">所以说快速排序是一个不稳定的排序</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br></pre></td></tr></table></figure>\n<p>稳定性有什么意义？ 个人理解对于前端来说，比如我们熟知框架中的虚拟DOM的比较，我们对一个<code>&lt;ul&gt;</code>列表进行渲染，当数据改变后需要比较变化时，不稳定排序或操作将会使本身不需要变化的东西变化，导致重新渲染，带来性能的损耗。 </p>\n<h5 id=\"辅助记忆\"><a href=\"#辅助记忆\" class=\"headerlink\" title=\"辅助记忆\"></a>辅助记忆</h5><ul>\n<li>时间复杂度记忆<ul>\n<li>冒泡、选择、直接 排序需要两个for循环，每次只关注一个元素，平均时间复杂度为O(n²)(一遍找元素O(n)，一遍找位置O(n)）</li>\n<li>快速、归并、希尔、堆基于二分思想，log以2为底，平均时间复杂度为O(nlogn)(一遍找元素O(n)，一遍找位置O(logn))</li>\n</ul>\n</li>\n<li>稳定性记忆-“快希选堆”（快牺牲稳定性） </li>\n<li></li>\n</ul>\n<hr>\n<h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>递归，其实就是自己调用自己。</p>\n<p>很多时候我们自己觉得麻烦或者感觉 “想象不过来”，主要是自己和自己较真，因为交给递归，它自己会帮你完成需要做的。</p>\n<p>递归步骤：</p>\n<ul>\n<li>寻找出口，递归一定有一个出口，锁定出口，保证不会死循环</li>\n<li>递归条件，符合递归条件，自己调用自己。</li>\n</ul>\n<blockquote>\n<p>talk is cheap，show me code！</p>\n</blockquote>\n<p>斐波那契数列，每个语言讲递归都会从这个开始，但是既然搞前端，就搞点不一样的吧，从对象的深度克隆(deep clone)说起</p>\n<p><strong>Deep Clone</strong> ：实现对一个对象(object)的深度克隆</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//所谓深度克隆，就是当对象的某个属性值为object或array的时候，要获得一份copy，而不是直接拿到引用值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">origin,target</span>) </span>&#123;  <span class=\"comment\">//origin是被克隆对象，target是我们获得copy</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> target = target || &#123;&#125;; <span class=\"comment\">//定义target</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> origin) &#123;  <span class=\"comment\">//遍历原对象</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(origin.hasOwnProperty(key)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"built_in\">Array</span>.isArray(origin[key])) &#123; <span class=\"comment\">//如果是数组</span></span><br><span class=\"line\">                target[key] = [];</span><br><span class=\"line\">                deepClone(origin[key],target[key]) <span class=\"comment\">//递归</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> origin[key] === <span class=\"string\">'object'</span> &amp;&amp; origin[key] !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                target[key] = &#123;&#125;;</span><br><span class=\"line\">                deepClone(origin[key],target[key]) <span class=\"comment\">//递归</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                target[key] = origin[key];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个可以说是前端笔试/面试中经常经常遇到的问题了，思路是很清晰的：</p>\n<ul>\n<li>出口： 遍历对象结束后return</li>\n<li>递归条件： 遇到引用值Array 或 Object</li>\n</ul>\n<p>剩下的事情，交给JS自己处理就好了，我们不用考虑内部的层层嵌套，想太多</p>\n<h3 id=\"实战例题\"><a href=\"#实战例题\" class=\"headerlink\" title=\"实战例题\"></a>实战例题</h3><p>接下来，列举一些自己在最近笔试、面试中遇到的，需要使用递归实现的问题</p>\n<h4 id=\"Q1：Array数组的flat方法实现-2018网易雷火-amp-伏羲前端秋招笔试\"><a href=\"#Q1：Array数组的flat方法实现-2018网易雷火-amp-伏羲前端秋招笔试\" class=\"headerlink\" title=\"Q1：Array数组的flat方法实现(2018网易雷火&amp;伏羲前端秋招笔试)\"></a>Q1：Array数组的flat方法实现(2018网易雷火&amp;伏羲前端秋招笔试)</h4><p>Array的方法flat很多浏览器还未能实现，请写一个flat方法，实现扁平化嵌套数组，如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]];</span><br><span class=\"line\">arr1.flat(); </span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n<p>这个问题的实现思路和Deep Clone非常相似，这里实现如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.flat = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.forEach(<span class=\"function\">(<span class=\"params\">item,idx</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">Array</span>.isArray(item)) &#123;</span><br><span class=\"line\">            arr = arr.concat(item.flat()); <span class=\"comment\">//递归去处理数组元素</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            arr.push(item)   <span class=\"comment\">//非数组直接push进去</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;   <span class=\"comment\">//递归出口</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好了，可以测试一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr = [[<span class=\"number\">2</span>],[[<span class=\"number\">2</span>,<span class=\"number\">3</span>],[<span class=\"number\">2</span>]],<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\">arr.flat()</span><br><span class=\"line\"><span class=\"comment\">// [2, 2, 3, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n<p><strong>神秘力量的新解法</strong></p>\n<p>在评论区的一位小伙伴，提出了更好的办法，很简洁、方便，只用一句话就可以实现需求哦(不过你这样去解答一道网易的“编程题”,不觉得让人家有点难堪嘛~哈哈)<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.prototype.flat = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.toString().split(<span class=\"string\">','</span>).map(<span class=\"function\"><span class=\"params\">item</span>=&gt;</span> +item )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>好了，惊叹完之后，大概说下实现吧：</p>\n<ol>\n<li>toString方法，连接数组并返回一个字符串 <code>&#39;2,2,3,2,3,4&#39;</code></li>\n<li>split方法分割字符串，变成数组<code>[&#39;2&#39;,&#39;2&#39;,&#39;3&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;]</code></li>\n<li>map方法，将string映射成为number类型<code>2,2,3,2,3,4</code></li>\n</ol>\n<h4 id=\"Q2-实现简易版的co，自动执行generator\"><a href=\"#Q2-实现简易版的co，自动执行generator\" class=\"headerlink\" title=\"Q2 实现简易版的co，自动执行generator\"></a>Q2 实现简易版的co，自动执行generator</h4><p>这个问题，详细的解释可以在我之前的文章(<a href=\"https://juejin.im/post/5b5f169fe51d4518e311ba78\" target=\"_blank\" rel=\"noopener\">从Co剖析和解释generator的异步原理</a>)去看一下，如果对ES6的iterator和generator不太了解的，可以跳过这个问题。</p>\n<p>比如实现如下的功能:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> co = <span class=\"built_in\">require</span>(<span class=\"string\">'co'</span>);</span><br><span class=\"line\">co(<span class=\"function\"><span class=\"keyword\">function</span> *(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> url = <span class=\"string\">'http://jasonplacerholder.typecoder.com/posts/1'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">yield</span> fetch(url);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> post = <span class=\"keyword\">yield</span> response.json();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> title = post.title;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Title: '</span>,title);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>剖析：</p>\n<ul>\n<li>第一步找出口，执行器返回的iterator如果状态为<code>done</code>，代表结束，可以出去</li>\n<li>递归条件： 取到下一个iterator，进行递归，自我调用</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\">generat</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> iterator = generat();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">autoRun</span>(<span class=\"params\">iteration</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(iteration.done) &#123;<span class=\"keyword\">return</span> iteration.value&#125;  <span class=\"comment\">//出口</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> anotherPromise = iteration.value;</span><br><span class=\"line\">        anoterPromise.then(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> autoRun(iterator.next(x))  <span class=\"comment\">//递归条件</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> autoRun(iterator.next()) </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Q3-爬楼梯问题\"><a href=\"#Q3-爬楼梯问题\" class=\"headerlink\" title=\"Q3. 爬楼梯问题\"></a>Q3. 爬楼梯问题</h4><p>有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？</p>\n<p><strong>分析</strong>： 这个问题要倒过来看，要到达n级楼梯，只有两种方式，从（n-1）级 或 （n-2）级到达的。所以可以用递推的思想去想这题，假设有一个数组s[n], 那么s[1] = 1（由于一开始就在第一级，只有一种方法）， s[2] = 1（只能从s[1]上去 没有其他方法）。</p>\n<p>那么就可以推出s[3] ~ s[n]了。</p>\n<p>下面继续模拟一下， s[3] = s[1] + s[2]， 因为只能从第一级跨两步， 或者第二级跨一步。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cStairs</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cStairs(n<span class=\"number\">-1</span>) + cStairs(n<span class=\"number\">-2</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>嗯嗯，没错呢，其实就是斐波纳契数列没跑了</p>\n<h4 id=\"Q4-二分查找\"><a href=\"#Q4-二分查找\" class=\"headerlink\" title=\"Q4.二分查找\"></a>Q4.二分查找</h4><p>二分查找，是在一个有序的序列里查找某一个值，与小时候玩的猜数字游戏非常相啦：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A: 0 ~ 100 猜一个数字</span><br><span class=\"line\">B: 50</span><br><span class=\"line\">A: 大了</span><br><span class=\"line\">B: 25</span><br><span class=\"line\">A: 对头，就是25</span><br></pre></td></tr></table></figure>\n<p>因此，思路也就非常清楚了，这里有递归和非递归两种写法，先说下递归的方法吧：</p>\n<ul>\n<li>设定区间,low和high</li>\n<li>找出口： 找到target，返回target；</li>\n<li>否则寻找，当前次序没有找到，把区间缩小后递归</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">binaryFind</span>(<span class=\"params\">arr,target,low = <span class=\"number\">0</span>,high = arr.length - <span class=\"number\">1</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> n = <span class=\"built_in\">Math</span>.floor((low+high) /<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> cur = arr[n];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(cur === target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">`找到了<span class=\"subst\">$&#123;target&#125;</span>,在第<span class=\"subst\">$&#123;n+<span class=\"number\">1</span>&#125;</span>个`</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(cur &gt; target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> binaryFind(arr,target,low, n<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cur &lt; target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> binaryFind(arr,target,n+<span class=\"number\">1</span>,high);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来，使用循环来做一下二分查找，其实思路基本一致：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">binaryFind</span>(<span class=\"params\">arr, target</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> low = <span class=\"number\">0</span>,</span><br><span class=\"line\">        high = arr.length - <span class=\"number\">1</span>,</span><br><span class=\"line\">        mid;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt;= high) &#123;</span><br><span class=\"line\">        mid = <span class=\"built_in\">Math</span>.floor((low + high) / <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (target === arr[mid]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">`找到了<span class=\"subst\">$&#123;target&#125;</span>,在第<span class=\"subst\">$&#123;mid + <span class=\"number\">1</span>&#125;</span>个`</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (target &gt; arr[mid]) &#123;</span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &lt; arr[mid]) &#123;</span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二叉树和二叉查找树\"><a href=\"#二叉树和二叉查找树\" class=\"headerlink\" title=\"二叉树和二叉查找树\"></a>二叉树和二叉查找树</h2><h3 id=\"树的基本概念\"><a href=\"#树的基本概念\" class=\"headerlink\" title=\"树的基本概念\"></a>树的基本概念</h3><p>这里对基本概念就不详细复习了，在各大资料中有更详尽的介绍，这里就只简单介绍基本概念和术语，然后使用JavaScript实现一个二叉树，并封装其方法。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fufxqalweej20r20fmwii.jpg\" alt=\"\"></p>\n<p>如图所示，一棵树最上面的几点称为根节点，如果一个节点下面连接多个节点，那么该节点成为父节点，它下面的节点称为子节点，一个节点可以有0个、1个或更多节点，没有子节点的节点叫叶子节点。</p>\n<p><strong>二叉树</strong>，是一种特殊的树，即子节点最多只有两个，这个限制可以使得写出高效的插入、删除、和查找数据。在二叉树中，子节点分别叫左节点和右节点。 </p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fufy2mm3fsj20pn08wgnf.jpg\" alt=\"\"></p>\n<h3 id=\"二叉查找树\"><a href=\"#二叉查找树\" class=\"headerlink\" title=\"二叉查找树\"></a>二叉查找树</h3><p>二叉查找树是一种特殊的二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中，这一特性使得查找的效率很高，对于数值型和非数值型数据，比如字母和字符串，都是如此。现在通过JS实现一个二叉查找树。</p>\n<h4 id=\"节点\"><a href=\"#节点\" class=\"headerlink\" title=\"节点\"></a>节点</h4><p>二叉树的最小元素是节点，所以先定义一个节点</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Node</span>(<span class=\"params\">data,left,right</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.left = left;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.right = right;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.show = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.data&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个就是二叉树的最小结构单元</p>\n<h4 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BST</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.root = <span class=\"literal\">null</span> <span class=\"comment\">//初始化,root为null</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>BST初始化时，只有一个根节点，且没有任何数据。 接下来，我们利用二叉查找树的规则，定义一个插入方法，这个方法的基本思想是:</p>\n<ol>\n<li>如果<code>BST.root === null</code> ，那么就将节点作为根节点</li>\n<li>如果<code>BST.root !==null</code> ，将插入节点进行一个比较，小于根节点，拿到左边的节点，否则拿右边，再次比较、递归。</li>\n</ol>\n<p>这里就出现了递归了，因为，总是要把较小的放在靠左的分支。换言之</p>\n<p><strong>最左变的叶子节点是最小的数，最右的叶子节点是最大的数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insert</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> node = <span class=\"keyword\">new</span> Node(data,<span class=\"literal\">null</span>,<span class=\"literal\">null</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.root === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.root = node</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> current = <span class=\"keyword\">this</span>.root;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> parent;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            parent = current;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(data &lt; current.data) &#123;</span><br><span class=\"line\">                current = current.left; <span class=\"comment\">//到左子树</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(current === <span class=\"literal\">null</span>) &#123;  <span class=\"comment\">//如果左子树为空，说明可以将node插入在这里</span></span><br><span class=\"line\">                    parent.left = node;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;  <span class=\"comment\">//跳出while循环</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                current = current.right;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(current === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    parent.right = node;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里，是使用了一个循环方法，不断的去向子树寻找正确的位置。 循环和递归都有一个核心，就是找到出口，这里的出口就是当current 为null的时候，代表没有内容，可以插入。</p>\n<p>接下来，将此方法写入BST即可:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BST</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.root = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.insert = insert;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样子，就可以使用二叉树这个自建的数据结构了:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bst = <span class=\"keyword\">new</span> BST()；</span><br><span class=\"line\">bst.insert(<span class=\"number\">10</span>);</span><br><span class=\"line\">bst.insert(<span class=\"number\">8</span>);</span><br><span class=\"line\">bst.insert(<span class=\"number\">2</span>);</span><br><span class=\"line\">bst.insert(<span class=\"number\">7</span>);</span><br><span class=\"line\">bst.insert(<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n<p>但是这个时候，想要看树中的数据，不是那么清晰，所以接下来，就要用到遍历了。</p>\n<h4 id=\"二叉树的遍历\"><a href=\"#二叉树的遍历\" class=\"headerlink\" title=\"二叉树的遍历\"></a>二叉树的遍历</h4><p>我们知道，树的遍历主要包括</p>\n<ul>\n<li>前序遍历 (根左右)</li>\n<li>中序遍历 (左根右)</li>\n<li>后序遍历 (左右根)</li>\n</ul>\n<p>这个只是为了好记忆，我们拿下面的图做一个遍历</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fug0jaukqpj209k057jrx.jpg\" alt=\"\"></p>\n<p>前序遍历: 56 22 10 30 81 77 92</p>\n<p>中序遍历: 10 22 30 56 77 81 92</p>\n<p>后序遍历: 10 30 22 77 92 81 56</p>\n<p>这里发现了一些规律：</p>\n<ol>\n<li>前序遍历，因为是根左右，所以最后一个一定是最大的； 第一个一定是root节点；</li>\n<li>中序遍历，在查找二叉树中，一定是从小到大的顺序； 根节点<code>56</code>左边(10/22/30)的一定是左子树的，右边的(77/81/92)一定是右子树的。</li>\n<li>后序遍历，根节点一定在最后</li>\n</ol>\n<h5 id=\"中序遍历的实现\"><a href=\"#中序遍历的实现\" class=\"headerlink\" title=\"中序遍历的实现\"></a>中序遍历的实现</h5><p>这里就又用到之前的递归了，中序遍历要求: <strong>左！根！右</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inOrder</span>(<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(node !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果不是null，就一直查找左变，因此递归</span></span><br><span class=\"line\">        inOrder(node.left);</span><br><span class=\"line\">        <span class=\"comment\">//递归结束，打印当前值</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(node.show());</span><br><span class=\"line\">        <span class=\"comment\">//上一次递归已经把左边搞完了，右边</span></span><br><span class=\"line\">        inOrder(node.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在刚才已有bst的基础上执行命令</span></span><br><span class=\"line\">inOrder(bst.root);</span><br></pre></td></tr></table></figure>\n<p>通过递归，实现了中序遍历，上面打印出的结果如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">5</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n<h5 id=\"前序遍历-amp-后序遍历\"><a href=\"#前序遍历-amp-后序遍历\" class=\"headerlink\" title=\"前序遍历&amp;后序遍历\"></a>前序遍历&amp;后序遍历</h5><p>如果刚才的递归过程搞清楚，那这个就再简单不过了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">preOrder</span>(<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(node !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//根左右</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(node.show());</span><br><span class=\"line\">        preOrder(node.left);</span><br><span class=\"line\">        preOrder(node.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ok,趁热打铁，就把后序遍历的方法也一并写入，如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">postOrder</span>(<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(node !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//左右根</span></span><br><span class=\"line\">        postOrder(node.left);</span><br><span class=\"line\">        postOrder(node.right);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(node.show())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好了，可以去尝试两种方法打印出来的结果了:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">preOrder(bst.root);</span><br><span class=\"line\">postOrder(bst.root);</span><br></pre></td></tr></table></figure>\n<h3 id=\"二叉树的查找\"><a href=\"#二叉树的查找\" class=\"headerlink\" title=\"二叉树的查找\"></a>二叉树的查找</h3><p>在二叉树这种数据结构中进行数据查找是最方便的，现在我们就对查找最小值、最大值和特定值进行一个梳理：</p>\n<ul>\n<li>最小值： 最左子树的叶子节点</li>\n<li>最大值： 最右子树的叶子节点</li>\n<li>特定值： target与current进行比较，如果比current大，在current.right进行查找，反之类似。</li>\n</ul>\n<p>清楚思路后，就动手来写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//最小值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getMin</span>(<span class=\"params\">bst</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> current = bst.root;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(current.left !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        current = current.left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> current.data;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//最大值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getMax</span>(<span class=\"params\">bst</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> current = bst.root;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(current.right !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        current = current.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> current.data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最大、最小值都是非常简单的，下面主要看下如何通过</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">find</span>(<span class=\"params\">target,bst</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> current = bst.root;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(current !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(target === current.data) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(target &gt; current.data) &#123;</span><br><span class=\"line\">            current = current.right;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(target &lt; current.data) &#123;</span><br><span class=\"line\">            current = current.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其实核心，仍然是通过一个循环和判断，来不断的向下去寻找，这里的思想其实和二分查找是有点类似的。</p>\n<p>哇…</p>\n<p>没想到今天去整理排序 花了这么久…嗯..然而这篇文章已经够长了</p>\n<p>接下来我会把之前笔试遇到的题目和一些常用的算法问题，一一记录，前端很多算法都是和数组、字符串处理息息相关的，所以对正则表达式、数组常用方法的掌握也很重要，简单总结下知识点：</p>\n<ul>\n<li>正则表达式<ul>\n<li>字符串相关方法</li>\n<li>str.split()</li>\n<li>str.replace()</li>\n<li>str.match()</li>\n<li>reg.test()</li>\n<li>reg.exec()</li>\n</ul>\n</li>\n<li>数组方法<ul>\n<li>Array.map()  映射，有返回值，不改变数组本身</li>\n<li>Array.forEach() 遍历，无返回值</li>\n<li>Array.filter() 过滤，返回true时返回,false时不返回</li>\n<li>Array.splice/slice/join等</li>\n<li>for…of 遍历,iterator相关知识点</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"未完待续…\"><a href=\"#未完待续…\" class=\"headerlink\" title=\"未完待续….\"></a>未完待续….</h3><p>内容会持续更新，最快的当然还是在github上，然后会同步到掘金，<a href=\"https://github.com/forrany/Web-Project\" target=\"_blank\" rel=\"noopener\">github传送门</a></p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ol>\n<li><a href=\"https://blog.csdn.net/yushiyi6453/article/details/76407640\" target=\"_blank\" rel=\"noopener\">排序算法时间复杂度、空间复杂度、稳定性比较</a></li>\n<li><a href=\"https://www.cnblogs.com/jsgnadsj/p/3458054.html\" target=\"_blank\" rel=\"noopener\">算法学习记录–希尔排序</a></li>\n<li><a href=\"https://blog.csdn.net/tizzzzzz/article/details/79610375\" target=\"_blank\" rel=\"noopener\">快速排序简单理解</a></li>\n<li><a href=\"https://book.douban.com/subject/25945449/\" target=\"_blank\" rel=\"noopener\">数据结构与算法Javascript描述</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>终于来了，算法相关的。 其实个人理解，前端岗位对于算法的要求与其他IT岗位相比，是低得多的。 但是小白我经历了如蚂蚁金服、网易这样的大厂教做人之后，还是觉得，对于一些基本算法、思想的掌握还是必须的。 然后，就把自己遇到的、学到的算法相关的再总结一下，方便自己随时备战面试。</p>\n<p>系列笔记：</p>\n<p><a href=\"https://forrany.github.io/2018/08/10/2018-08-10-VK-mistake-1/\" target=\"_blank\" rel=\"noopener\">1.VK的秋招前端奇遇记(一)</a></p>\n<p><a href=\"https://forrany.github.io/2018/08/11/2018-08-11-VK-mistake-2/\" target=\"_blank\" rel=\"noopener\">2.VK的秋招前端奇遇记(二)</a></p>\n<p><a href=\"https://forrany.github.io/2018/08/12/2018-08-12-VK-mistake-3/\" target=\"_blank\" rel=\"noopener\">3.VK的秋招前端奇遇记(三)</a></p>\n<p><a href=\"https://forrany.github.io/2018/09/04/2018-09-04-VK-mistake-4/\" target=\"_blank\" rel=\"noopener\">4.VK的秋招前端奇遇记(四)</a></p>\n<p><a href=\"https://forrany.github.io/2018/08/21/2018-08-21-front-end-interview-algorithm/\" target=\"_blank\" rel=\"noopener\">5.番外篇：前端面试&amp;笔试算法 Algorithm</a></p>\n<hr>\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><p>JS本身数组的sort方法，可以满足日常业务操作中很多的场景了，所以我认为这也是为什么基本面试会直接让写一个<code>快速排序</code>，因为好像其他排序方法在JS中似乎没什么意义了。 </p>\n<p>但是在拼多多的面试中，面试官还是让我手写<code>选择排序</code> <code>冒泡排序</code> 和<code>快速排序</code> 的伪代码。 既然有机会总结，干脆就全部写一遍好了，从基本排序到高级排序来说。</p>\n<h3 id=\"基本排序算法\"><a href=\"#基本排序算法\" class=\"headerlink\" title=\"基本排序算法\"></a>基本排序算法</h3><p>基本排序的基本思想非常类似，重排列时用的技术基本都是一组嵌套的for循环: 外循环遍历数组的每一项，内循环则用于比较元素。</p>\n<h4 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h4><p>最笨最基本最经典点的方法，不管学什么语言，说到排序，第一个接触的就是它了吧。基本思想什么的太经典了，就不复数了，直接用例子说明过程吧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">E A D B H</span><br></pre></td></tr></table></figure>\n<p>经过一次排列后，变成</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A E D B H</span><br></pre></td></tr></table></figure>\n<p>前两个元素互换了，接下来变成：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A D E B H</span><br></pre></td></tr></table></figure>\n<p>第二个和第三个互换，继续：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A D B E H</span><br></pre></td></tr></table></figure>\n<p>第三个和第四个互换，最后，第二个和第三个元素还会互换一次，得到最终的顺序为：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A B D E H</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fu93tfy076g20le06aazd.gif\" alt=\"\"></p>\n<p>好了，其实基本思想就是逐个的比较，下面就实现一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubleSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> outer = len ; outer &gt;= <span class=\"number\">2</span>; outer--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> inner = <span class=\"number\">0</span>; inner &lt;=outer - <span class=\"number\">1</span>; inner++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[inner] &gt; arr[inner + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">let</span> temp = arr[inner];</span><br><span class=\"line\">                arr[inner] = arr[inner + <span class=\"number\">1</span>];</span><br><span class=\"line\">                arr[inner + <span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里有两点需要注意：</p>\n<ol>\n<li>外层循环，从最大值开始递减，因为内层是两两比较，因此最外层当<code>&gt;=2</code>时即可停止；</li>\n<li>内层是两两比较，从0开始，比较<code>inner</code>与<code>inner+1</code>，因此，临界条件是<code>inner&lt;outer -1</code></li>\n</ol>\n<p>在比较交换的时候，就是计算机中最经典的交换策略，用临时变量<code>temp</code>保存值，但是面试官问过我，<strong>ES6有没有简单的方法实现？</strong> 有的，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr2 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\">[arr2[<span class=\"number\">0</span>],arr2[<span class=\"number\">1</span>]] = [arr2[<span class=\"number\">1</span>],arr2[<span class=\"number\">0</span>]]  <span class=\"comment\">//ES6解构赋值</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2)  <span class=\"comment\">// [2, 1, 3, 4]</span></span><br></pre></td></tr></table></figure>\n<p>所以，刚才的冒牌排序可以优化如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubleSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> outer = len ; outer &gt;= <span class=\"number\">2</span>; outer--) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> inner = <span class=\"number\">0</span>; inner &lt;=outer - <span class=\"number\">1</span>; inner++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[inner] &gt; arr[inner + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                [arr[inner],arr[inner+<span class=\"number\">1</span>]] = [arr[inner+<span class=\"number\">1</span>],arr[inner]]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h4><p>选择排序是从数组的开头开始，将第一个元素和其他元素作比较，检查完所有的元素后，最小的放在第一个位置，接下来再开始从第二个元素开始，重复以上一直到最后。</p>\n<p><img src=\"http://img.mp.itc.cn/upload/20160923/c705c53489b8455090ccb67199465387_th.jpg\" alt=\"\"></p>\n<p>有了刚才的铺垫，我觉得不用再演示了，很简单嘛： 外层循环从0开始到<code>length-1</code>， 然后内层比较，最小的放开头，走你：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> len = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span> ;i &lt; len - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = i ; j&lt;len; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[j] &lt; arr[i]) &#123;</span><br><span class=\"line\">                [arr[i],arr[j]] = [arr[j],arr[i]];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>简单说两句：</p>\n<ul>\n<li>外层循环的<code>i</code>表示第几轮，<code>arr[i]</code>就表示当前轮次最靠前(小)的位置；</li>\n<li>内层从<code>i</code>开始，依次往后数，找到比开头小的，互换位置即可</li>\n</ul>\n<p>结束，收工！！</p>\n<h4 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h4><p>插入排序核心–扑克牌思想： <strong>就想着自己在打扑克牌，接起来一张，放哪里无所谓，再接起来一张，比第一张小，放左边，继续接，可能是中间数，就插在中间….依次</strong></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fu93uujulog20le0ejtyb.gif\" alt=\"\"></p>\n<p>其实每种算法，主要是理解其原理，至于写代码，都是在原理之上顺理成章的事情：</p>\n<ul>\n<li>首先将待排序的第一个记录作为一个有序段</li>\n<li>从第二个开始，到最后一个，依次和前面的有序段进行比较，确定插入位置</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; arr.length; i++) &#123;  <span class=\"comment\">//外循环从1开始，默认arr[0]是有序段</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = i; j &gt; <span class=\"number\">0</span>; j--) &#123;  <span class=\"comment\">//j = i,将arr[j]依次插入有序段中</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[j] &lt; arr[j<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                [arr[j],arr[j<span class=\"number\">-1</span>]] = [arr[j<span class=\"number\">-1</span>],arr[j]];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析： 注意这里两次循环中，<code>i</code>和<code>j</code>的含义：</p>\n<ol>\n<li><code>i</code>是外循环，依次把后面的数插入前面的有序序列中，默认<code>arr[0]</code>为有序的，<code>i</code>就从1开始</li>\n<li><code>j</code>进来后，依次与前面队列的数进行比较，因为前面的序列是有序的，因此只需要循环比较、交换即可</li>\n<li>注意这里的<code>break</code>，因为前面是都是有序的序列，所以如果当前要插入的值<code>arr[j]</code>大于或等于<code>arr[j-1]</code>，则无需继续比较，直接下一次循环就可以了。</li>\n</ol>\n<h4 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h4><p>乍一看，好像插入排序速度还不慢，但是要知道： 当序列正好逆序的时候，每次插入都要一次次交换，这个速度和冒泡排序是一样的，时间复杂度O(n²)； 当然运气好，前面是有序的，那时间复杂度就只有O(n)了，直接插入即可。</p>\n<table>\n<thead>\n<tr>\n<th>排序算法</th>\n<th style=\"text-align:center\">平均时间复杂度</th>\n<th style=\"text-align:center\">最坏时间复杂度</th>\n<th style=\"text-align:center\">空间复杂度</th>\n<th style=\"text-align:center\">是否稳定</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>冒泡排序</td>\n<td style=\"text-align:center\">O(n²)</td>\n<td style=\"text-align:center\">O(n²)</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">是</td>\n</tr>\n<tr>\n<td>选择排序</td>\n<td style=\"text-align:center\">O(n²)</td>\n<td style=\"text-align:center\">O(n²)</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">不是</td>\n</tr>\n<tr>\n<td>直接插入排序</td>\n<td style=\"text-align:center\">O(n²)</td>\n<td style=\"text-align:center\">O(n²)</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">是</td>\n</tr>\n</tbody>\n</table>\n<p>好了，这张表如何快速记忆呢？ 方法就是一开始写的<strong>基本排序算法</strong> 。 一开始就说到，基本思想就是两层循环嵌套，第一遍找元素O(n),第二遍找位置O(n)，所以这几种方法，时间复杂度就可以这么简便记忆啦!</p>\n<hr>\n<h3 id=\"高级排序算法\"><a href=\"#高级排序算法\" class=\"headerlink\" title=\"高级排序算法\"></a>高级排序算法</h3><p>如果所有排序都像上面的基本方法一样，那么对于大量数据的处理，将是灾难性的，老哥，只是让你排个序，你都用了O(n²)。 好吧，所以接下来这些高级排序算法，在大数据上，可以大大的减少复杂度。 </p>\n<h4 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h4><p>快速排序可以说是对于前端最最最最重要的排序算法，没有之一了，面试官问到排序算法，快排的概率能有80%以上(我瞎统计的…信不信由你)。</p>\n<p>所以快排是什么呢？</p>\n<blockquote>\n<p>快排是处理大数据最快的排序算法之一。它是一种分而治之的算法，通过递归的方式将数据依次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤直至所有数据都是有序的。</p>\n</blockquote>\n<p>简单说： 找到一个数作为参考，比这个数字大的放在数字左边，比它小的放在右边； 然后分别再对左边和右变的序列做相同的操作:</p>\n<ol>\n<li>选择一个基准元素，将列表分割成两个子序列；</li>\n<li>对列表重新排序，将所有小于基准值的元素放在基准值前面，所有大于基准值的元素放在基准值的后面；</li>\n<li>分别对较小元素的子序列和较大元素的子序列重复步骤1和2</li>\n</ol>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fu942wgi1tg20kz071k8b.gif\" alt=\"\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quickSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(arr.length &lt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arr;  <span class=\"comment\">//递归出口</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> left = [],</span><br><span class=\"line\">        right = [],</span><br><span class=\"line\">        current = arr.splice(<span class=\"number\">0</span>,<span class=\"number\">1</span>); <span class=\"comment\">//注意splice后，数组长度少了一个</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(arr[i] &lt; current) &#123;</span><br><span class=\"line\">            left.push(arr[i])  <span class=\"comment\">//放在左边</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            right.push(arr[i]) <span class=\"comment\">//放在右边</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> quickSort(left).concat(current,quickSort(right)); <span class=\"comment\">//递归</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h4><p>希尔排序是插入排序的改良算法，但是核心理念与插入算法又不同，它会先比较距离较远的元素，而非相邻的元素。文字太枯燥，还是看下面的动图吧：</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fu9cru5iyjg20ih082n4c.gif\" alt=\"\"></p>\n<p>在实现之前，先看下刚才插入排序怎么写的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; arr.length - <span class=\"number\">1</span>; i++) &#123;  <span class=\"comment\">//外循环从1开始，默认arr[0]是有序段</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = i; j &gt; <span class=\"number\">0</span>; j--) &#123;  <span class=\"comment\">//j = i,将arr[j]依次插入有序段中</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(arr[j] &lt; arr[j<span class=\"number\">-1</span>]) &#123;</span><br><span class=\"line\">                [arr[j],arr[j<span class=\"number\">-1</span>]] = [arr[j<span class=\"number\">-1</span>],arr[j]];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在，不同之处是在上面的基础上，让步长按照3、2、1来进行比较，相当于是三层循环和嵌套啦。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">insertSort(arr,[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shellSort</span>(<span class=\"params\">arr,gap</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(arr)<span class=\"comment\">//为了方便观察过程，使用时去除</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i&lt;gap.length; i++) &#123;  <span class=\"comment\">//最外层循环，一次取不同的步长，步长需要预先给出</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> n = gap[i]; <span class=\"comment\">//步长为n</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> j = i + n; j &lt; arr.length; j++) &#123; <span class=\"comment\">//接下类和插入排序一样，j循环依次取后面的数</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> k = j; k &gt; <span class=\"number\">0</span>; k-=n) &#123; <span class=\"comment\">//k循环进行比较，和直接插入的唯一区别是1变为了n</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(arr[k] &lt; arr[k-n]) &#123;</span><br><span class=\"line\">                    [arr[k],arr[k-n]] = [arr[k-n],arr[k]];</span><br><span class=\"line\">                    <span class=\"built_in\">console</span>.log(<span class=\"string\">`当前序列为[<span class=\"subst\">$&#123;arr&#125;</span>] \\n 交换了<span class=\"subst\">$&#123;arr[k]&#125;</span>和<span class=\"subst\">$&#123;arr[k-n]&#125;</span>`</span>)<span class=\"comment\">//为了观察过程</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>直接看这个三层循环嵌套的内容，会稍显复杂，这也是为什么先把插入排序写在前面做一个对照。 其实三层循环的内两层完全就是一个插入排序，只不过原来插入排序间隔为<code>1</code>，而希尔排序的间隔是变换的<code>n</code>， 如果把<code>n</code>修改为<code>1</code>，就会发现是完全一样的了。</p>\n<p>运行一下看看</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">45</span>, <span class=\"number\">6</span>, <span class=\"number\">55</span>, <span class=\"number\">23</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">19</span>, <span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> gap = [<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(shellSort(arr,gap))</span><br></pre></td></tr></table></figure>\n<p>结果如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"number\">12</span>) [<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">45</span>, <span class=\"number\">6</span>, <span class=\"number\">55</span>, <span class=\"number\">23</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">19</span>, <span class=\"number\">0</span>] <span class=\"comment\">//初始值</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">23</span>,<span class=\"number\">6</span>,<span class=\"number\">55</span>,<span class=\"number\">45</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">19</span>,<span class=\"number\">0</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">45</span>和<span class=\"number\">23</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">23</span>,<span class=\"number\">5</span>,<span class=\"number\">55</span>,<span class=\"number\">45</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">19</span>,<span class=\"number\">0</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">6</span>和<span class=\"number\">5</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">23</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">45</span>,<span class=\"number\">6</span>,<span class=\"number\">55</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">19</span>,<span class=\"number\">0</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">55</span>和<span class=\"number\">4</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">23</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">8</span>,<span class=\"number\">6</span>,<span class=\"number\">55</span>,<span class=\"number\">45</span>,<span class=\"number\">9</span>,<span class=\"number\">19</span>,<span class=\"number\">0</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">45</span>和<span class=\"number\">8</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">23</span>,<span class=\"number\">6</span>,<span class=\"number\">55</span>,<span class=\"number\">45</span>,<span class=\"number\">9</span>,<span class=\"number\">19</span>,<span class=\"number\">0</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">23</span>和<span class=\"number\">8</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">23</span>,<span class=\"number\">6</span>,<span class=\"number\">19</span>,<span class=\"number\">45</span>,<span class=\"number\">9</span>,<span class=\"number\">55</span>,<span class=\"number\">0</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">55</span>和<span class=\"number\">19</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">23</span>,<span class=\"number\">6</span>,<span class=\"number\">19</span>,<span class=\"number\">0</span>,<span class=\"number\">9</span>,<span class=\"number\">55</span>,<span class=\"number\">45</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">45</span>和<span class=\"number\">0</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">0</span>,<span class=\"number\">6</span>,<span class=\"number\">19</span>,<span class=\"number\">23</span>,<span class=\"number\">9</span>,<span class=\"number\">55</span>,<span class=\"number\">45</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">23</span>和<span class=\"number\">0</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">8</span>,<span class=\"number\">6</span>,<span class=\"number\">19</span>,<span class=\"number\">23</span>,<span class=\"number\">9</span>,<span class=\"number\">55</span>,<span class=\"number\">45</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">8</span>和<span class=\"number\">0</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">8</span>,<span class=\"number\">6</span>,<span class=\"number\">19</span>,<span class=\"number\">23</span>,<span class=\"number\">9</span>,<span class=\"number\">55</span>,<span class=\"number\">45</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">3</span>和<span class=\"number\">0</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">8</span>,<span class=\"number\">6</span>,<span class=\"number\">9</span>,<span class=\"number\">23</span>,<span class=\"number\">19</span>,<span class=\"number\">55</span>,<span class=\"number\">45</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">19</span>和<span class=\"number\">9</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">6</span>,<span class=\"number\">9</span>,<span class=\"number\">23</span>,<span class=\"number\">19</span>,<span class=\"number\">55</span>,<span class=\"number\">45</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">5</span>和<span class=\"number\">4</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">23</span>,<span class=\"number\">19</span>,<span class=\"number\">55</span>,<span class=\"number\">45</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">8</span>和<span class=\"number\">6</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">19</span>,<span class=\"number\">23</span>,<span class=\"number\">55</span>,<span class=\"number\">45</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">23</span>和<span class=\"number\">19</span></span><br><span class=\"line\">当前序列为[<span class=\"number\">0</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">19</span>,<span class=\"number\">23</span>,<span class=\"number\">45</span>,<span class=\"number\">55</span>] </span><br><span class=\"line\"> 交换了<span class=\"number\">55</span>和<span class=\"number\">45</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"时间复杂度总结\"><a href=\"#时间复杂度总结\" class=\"headerlink\" title=\"时间复杂度总结\"></a>时间复杂度总结</h4><p>wait？ 不是还有很多排序算法的吗？怎么不继续了？ 是的，其实排序是很深奥的问题，如果研究透各个方法的实现、性能等等，内容恐怕多到爆炸了…而且这个也主要是为<strong>前端常见算法</strong> 问题的总结，个人觉得到这里就差不多了</p>\n<table>\n<thead>\n<tr>\n<th>排序算法</th>\n<th style=\"text-align:center\">平均时间复杂度</th>\n<th style=\"text-align:center\">最坏时间复杂度</th>\n<th style=\"text-align:center\">空间复杂度</th>\n<th style=\"text-align:center\">是否稳定</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>冒泡排序</td>\n<td style=\"text-align:center\">O(n²)</td>\n<td style=\"text-align:center\">O(n²)</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">是</td>\n</tr>\n<tr>\n<td>选择排序</td>\n<td style=\"text-align:center\">O(n²)</td>\n<td style=\"text-align:center\">O(n²)</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">不是</td>\n</tr>\n<tr>\n<td>直接插入排序</td>\n<td style=\"text-align:center\">O(n²)</td>\n<td style=\"text-align:center\">O(n²)</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">是</td>\n</tr>\n<tr>\n<td>快速排序</td>\n<td style=\"text-align:center\">O(nlogn)</td>\n<td style=\"text-align:center\">O(n²)</td>\n<td style=\"text-align:center\">O(logn)</td>\n<td style=\"text-align:center\">不是</td>\n</tr>\n<tr>\n<td>希尔排序</td>\n<td style=\"text-align:center\">O(nlogn)</td>\n<td style=\"text-align:center\">O(n^s)</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">不是</td>\n</tr>\n</tbody>\n</table>\n<h5 id=\"是否稳定\"><a href=\"#是否稳定\" class=\"headerlink\" title=\"是否稳定\"></a>是否稳定</h5><p>如果不考虑稳定性，快排似乎是接近完美的一种方法，但可惜它是不稳定的。 那什么是稳定性呢？</p>\n<p>通俗的讲<strong>有两个相同的数A和B，在排序之前A在B的前面，而经过排序之后，B跑到了A的前面，对于这种情况的发生，我们管他叫做排序的不稳定性</strong>，而快速排序在对存在相同数进行排序时就有可能发生这种情况。 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">比如对(5，3A，6，3B ) 进行排序，排序之前相同的数3A与3B，A在B的前面，经过排序之后会变成  </span></span><br><span class=\"line\"><span class=\"comment\">\t（3B，3A，5，6）</span></span><br><span class=\"line\"><span class=\"comment\">所以说快速排序是一个不稳定的排序</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br></pre></td></tr></table></figure>\n<p>稳定性有什么意义？ 个人理解对于前端来说，比如我们熟知框架中的虚拟DOM的比较，我们对一个<code>&lt;ul&gt;</code>列表进行渲染，当数据改变后需要比较变化时，不稳定排序或操作将会使本身不需要变化的东西变化，导致重新渲染，带来性能的损耗。 </p>\n<h5 id=\"辅助记忆\"><a href=\"#辅助记忆\" class=\"headerlink\" title=\"辅助记忆\"></a>辅助记忆</h5><ul>\n<li>时间复杂度记忆<ul>\n<li>冒泡、选择、直接 排序需要两个for循环，每次只关注一个元素，平均时间复杂度为O(n²)(一遍找元素O(n)，一遍找位置O(n)）</li>\n<li>快速、归并、希尔、堆基于二分思想，log以2为底，平均时间复杂度为O(nlogn)(一遍找元素O(n)，一遍找位置O(logn))</li>\n</ul>\n</li>\n<li>稳定性记忆-“快希选堆”（快牺牲稳定性） </li>\n<li></li>\n</ul>\n<hr>\n<h2 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h2><p>递归，其实就是自己调用自己。</p>\n<p>很多时候我们自己觉得麻烦或者感觉 “想象不过来”，主要是自己和自己较真，因为交给递归，它自己会帮你完成需要做的。</p>\n<p>递归步骤：</p>\n<ul>\n<li>寻找出口，递归一定有一个出口，锁定出口，保证不会死循环</li>\n<li>递归条件，符合递归条件，自己调用自己。</li>\n</ul>\n<blockquote>\n<p>talk is cheap，show me code！</p>\n</blockquote>\n<p>斐波那契数列，每个语言讲递归都会从这个开始，但是既然搞前端，就搞点不一样的吧，从对象的深度克隆(deep clone)说起</p>\n<p><strong>Deep Clone</strong> ：实现对一个对象(object)的深度克隆</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//所谓深度克隆，就是当对象的某个属性值为object或array的时候，要获得一份copy，而不是直接拿到引用值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">origin,target</span>) </span>&#123;  <span class=\"comment\">//origin是被克隆对象，target是我们获得copy</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> target = target || &#123;&#125;; <span class=\"comment\">//定义target</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> origin) &#123;  <span class=\"comment\">//遍历原对象</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(origin.hasOwnProperty(key)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"built_in\">Array</span>.isArray(origin[key])) &#123; <span class=\"comment\">//如果是数组</span></span><br><span class=\"line\">                target[key] = [];</span><br><span class=\"line\">                deepClone(origin[key],target[key]) <span class=\"comment\">//递归</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> origin[key] === <span class=\"string\">'object'</span> &amp;&amp; origin[key] !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                target[key] = &#123;&#125;;</span><br><span class=\"line\">                deepClone(origin[key],target[key]) <span class=\"comment\">//递归</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                target[key] = origin[key];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个可以说是前端笔试/面试中经常经常遇到的问题了，思路是很清晰的：</p>\n<ul>\n<li>出口： 遍历对象结束后return</li>\n<li>递归条件： 遇到引用值Array 或 Object</li>\n</ul>\n<p>剩下的事情，交给JS自己处理就好了，我们不用考虑内部的层层嵌套，想太多</p>\n<h3 id=\"实战例题\"><a href=\"#实战例题\" class=\"headerlink\" title=\"实战例题\"></a>实战例题</h3><p>接下来，列举一些自己在最近笔试、面试中遇到的，需要使用递归实现的问题</p>\n<h4 id=\"Q1：Array数组的flat方法实现-2018网易雷火-amp-伏羲前端秋招笔试\"><a href=\"#Q1：Array数组的flat方法实现-2018网易雷火-amp-伏羲前端秋招笔试\" class=\"headerlink\" title=\"Q1：Array数组的flat方法实现(2018网易雷火&amp;伏羲前端秋招笔试)\"></a>Q1：Array数组的flat方法实现(2018网易雷火&amp;伏羲前端秋招笔试)</h4><p>Array的方法flat很多浏览器还未能实现，请写一个flat方法，实现扁平化嵌套数组，如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, [<span class=\"number\">3</span>, <span class=\"number\">4</span>]];</span><br><span class=\"line\">arr1.flat(); </span><br><span class=\"line\"><span class=\"comment\">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n<p>这个问题的实现思路和Deep Clone非常相似，这里实现如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.flat = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.forEach(<span class=\"function\">(<span class=\"params\">item,idx</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">Array</span>.isArray(item)) &#123;</span><br><span class=\"line\">            arr = arr.concat(item.flat()); <span class=\"comment\">//递归去处理数组元素</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            arr.push(item)   <span class=\"comment\">//非数组直接push进去</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;   <span class=\"comment\">//递归出口</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好了，可以测试一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr = [[<span class=\"number\">2</span>],[[<span class=\"number\">2</span>,<span class=\"number\">3</span>],[<span class=\"number\">2</span>]],<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\">arr.flat()</span><br><span class=\"line\"><span class=\"comment\">// [2, 2, 3, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n<p><strong>神秘力量的新解法</strong></p>\n<p>在评论区的一位小伙伴，提出了更好的办法，很简洁、方便，只用一句话就可以实现需求哦(不过你这样去解答一道网易的“编程题”,不觉得让人家有点难堪嘛~哈哈)<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.prototype.flat = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.toString().split(<span class=\"string\">','</span>).map(<span class=\"function\"><span class=\"params\">item</span>=&gt;</span> +item )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>好了，惊叹完之后，大概说下实现吧：</p>\n<ol>\n<li>toString方法，连接数组并返回一个字符串 <code>&#39;2,2,3,2,3,4&#39;</code></li>\n<li>split方法分割字符串，变成数组<code>[&#39;2&#39;,&#39;2&#39;,&#39;3&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;]</code></li>\n<li>map方法，将string映射成为number类型<code>2,2,3,2,3,4</code></li>\n</ol>\n<h4 id=\"Q2-实现简易版的co，自动执行generator\"><a href=\"#Q2-实现简易版的co，自动执行generator\" class=\"headerlink\" title=\"Q2 实现简易版的co，自动执行generator\"></a>Q2 实现简易版的co，自动执行generator</h4><p>这个问题，详细的解释可以在我之前的文章(<a href=\"https://juejin.im/post/5b5f169fe51d4518e311ba78\" target=\"_blank\" rel=\"noopener\">从Co剖析和解释generator的异步原理</a>)去看一下，如果对ES6的iterator和generator不太了解的，可以跳过这个问题。</p>\n<p>比如实现如下的功能:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> co = <span class=\"built_in\">require</span>(<span class=\"string\">'co'</span>);</span><br><span class=\"line\">co(<span class=\"function\"><span class=\"keyword\">function</span> *(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> url = <span class=\"string\">'http://jasonplacerholder.typecoder.com/posts/1'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">yield</span> fetch(url);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> post = <span class=\"keyword\">yield</span> response.json();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> title = post.title;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Title: '</span>,title);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>剖析：</p>\n<ul>\n<li>第一步找出口，执行器返回的iterator如果状态为<code>done</code>，代表结束，可以出去</li>\n<li>递归条件： 取到下一个iterator，进行递归，自我调用</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\">generat</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> iterator = generat();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">autoRun</span>(<span class=\"params\">iteration</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(iteration.done) &#123;<span class=\"keyword\">return</span> iteration.value&#125;  <span class=\"comment\">//出口</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> anotherPromise = iteration.value;</span><br><span class=\"line\">        anoterPromise.then(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> autoRun(iterator.next(x))  <span class=\"comment\">//递归条件</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> autoRun(iterator.next()) </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Q3-爬楼梯问题\"><a href=\"#Q3-爬楼梯问题\" class=\"headerlink\" title=\"Q3. 爬楼梯问题\"></a>Q3. 爬楼梯问题</h4><p>有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？</p>\n<p><strong>分析</strong>： 这个问题要倒过来看，要到达n级楼梯，只有两种方式，从（n-1）级 或 （n-2）级到达的。所以可以用递推的思想去想这题，假设有一个数组s[n], 那么s[1] = 1（由于一开始就在第一级，只有一种方法）， s[2] = 1（只能从s[1]上去 没有其他方法）。</p>\n<p>那么就可以推出s[3] ~ s[n]了。</p>\n<p>下面继续模拟一下， s[3] = s[1] + s[2]， 因为只能从第一级跨两步， 或者第二级跨一步。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">cStairs</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n === <span class=\"number\">1</span> || n === <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cStairs(n<span class=\"number\">-1</span>) + cStairs(n<span class=\"number\">-2</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>嗯嗯，没错呢，其实就是斐波纳契数列没跑了</p>\n<h4 id=\"Q4-二分查找\"><a href=\"#Q4-二分查找\" class=\"headerlink\" title=\"Q4.二分查找\"></a>Q4.二分查找</h4><p>二分查找，是在一个有序的序列里查找某一个值，与小时候玩的猜数字游戏非常相啦：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A: 0 ~ 100 猜一个数字</span><br><span class=\"line\">B: 50</span><br><span class=\"line\">A: 大了</span><br><span class=\"line\">B: 25</span><br><span class=\"line\">A: 对头，就是25</span><br></pre></td></tr></table></figure>\n<p>因此，思路也就非常清楚了，这里有递归和非递归两种写法，先说下递归的方法吧：</p>\n<ul>\n<li>设定区间,low和high</li>\n<li>找出口： 找到target，返回target；</li>\n<li>否则寻找，当前次序没有找到，把区间缩小后递归</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">binaryFind</span>(<span class=\"params\">arr,target,low = <span class=\"number\">0</span>,high = arr.length - <span class=\"number\">1</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> n = <span class=\"built_in\">Math</span>.floor((low+high) /<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> cur = arr[n];</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(cur === target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">`找到了<span class=\"subst\">$&#123;target&#125;</span>,在第<span class=\"subst\">$&#123;n+<span class=\"number\">1</span>&#125;</span>个`</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(cur &gt; target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> binaryFind(arr,target,low, n<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cur &lt; target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> binaryFind(arr,target,n+<span class=\"number\">1</span>,high);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来，使用循环来做一下二分查找，其实思路基本一致：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">binaryFind</span>(<span class=\"params\">arr, target</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> low = <span class=\"number\">0</span>,</span><br><span class=\"line\">        high = arr.length - <span class=\"number\">1</span>,</span><br><span class=\"line\">        mid;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (low &lt;= high) &#123;</span><br><span class=\"line\">        mid = <span class=\"built_in\">Math</span>.floor((low + high) / <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (target === arr[mid]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">`找到了<span class=\"subst\">$&#123;target&#125;</span>,在第<span class=\"subst\">$&#123;mid + <span class=\"number\">1</span>&#125;</span>个`</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (target &gt; arr[mid]) &#123;</span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (target &lt; arr[mid]) &#123;</span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二叉树和二叉查找树\"><a href=\"#二叉树和二叉查找树\" class=\"headerlink\" title=\"二叉树和二叉查找树\"></a>二叉树和二叉查找树</h2><h3 id=\"树的基本概念\"><a href=\"#树的基本概念\" class=\"headerlink\" title=\"树的基本概念\"></a>树的基本概念</h3><p>这里对基本概念就不详细复习了，在各大资料中有更详尽的介绍，这里就只简单介绍基本概念和术语，然后使用JavaScript实现一个二叉树，并封装其方法。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fufxqalweej20r20fmwii.jpg\" alt=\"\"></p>\n<p>如图所示，一棵树最上面的几点称为根节点，如果一个节点下面连接多个节点，那么该节点成为父节点，它下面的节点称为子节点，一个节点可以有0个、1个或更多节点，没有子节点的节点叫叶子节点。</p>\n<p><strong>二叉树</strong>，是一种特殊的树，即子节点最多只有两个，这个限制可以使得写出高效的插入、删除、和查找数据。在二叉树中，子节点分别叫左节点和右节点。 </p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fufy2mm3fsj20pn08wgnf.jpg\" alt=\"\"></p>\n<h3 id=\"二叉查找树\"><a href=\"#二叉查找树\" class=\"headerlink\" title=\"二叉查找树\"></a>二叉查找树</h3><p>二叉查找树是一种特殊的二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中，这一特性使得查找的效率很高，对于数值型和非数值型数据，比如字母和字符串，都是如此。现在通过JS实现一个二叉查找树。</p>\n<h4 id=\"节点\"><a href=\"#节点\" class=\"headerlink\" title=\"节点\"></a>节点</h4><p>二叉树的最小元素是节点，所以先定义一个节点</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Node</span>(<span class=\"params\">data,left,right</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.left = left;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.right = right;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.show = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.data&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个就是二叉树的最小结构单元</p>\n<h4 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BST</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.root = <span class=\"literal\">null</span> <span class=\"comment\">//初始化,root为null</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>BST初始化时，只有一个根节点，且没有任何数据。 接下来，我们利用二叉查找树的规则，定义一个插入方法，这个方法的基本思想是:</p>\n<ol>\n<li>如果<code>BST.root === null</code> ，那么就将节点作为根节点</li>\n<li>如果<code>BST.root !==null</code> ，将插入节点进行一个比较，小于根节点，拿到左边的节点，否则拿右边，再次比较、递归。</li>\n</ol>\n<p>这里就出现了递归了，因为，总是要把较小的放在靠左的分支。换言之</p>\n<p><strong>最左变的叶子节点是最小的数，最右的叶子节点是最大的数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insert</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> node = <span class=\"keyword\">new</span> Node(data,<span class=\"literal\">null</span>,<span class=\"literal\">null</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.root === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.root = node</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> current = <span class=\"keyword\">this</span>.root;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> parent;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            parent = current;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(data &lt; current.data) &#123;</span><br><span class=\"line\">                current = current.left; <span class=\"comment\">//到左子树</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(current === <span class=\"literal\">null</span>) &#123;  <span class=\"comment\">//如果左子树为空，说明可以将node插入在这里</span></span><br><span class=\"line\">                    parent.left = node;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;  <span class=\"comment\">//跳出while循环</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                current = current.right;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(current === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    parent.right = node;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里，是使用了一个循环方法，不断的去向子树寻找正确的位置。 循环和递归都有一个核心，就是找到出口，这里的出口就是当current 为null的时候，代表没有内容，可以插入。</p>\n<p>接下来，将此方法写入BST即可:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">BST</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.root = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.insert = insert;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样子，就可以使用二叉树这个自建的数据结构了:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bst = <span class=\"keyword\">new</span> BST()；</span><br><span class=\"line\">bst.insert(<span class=\"number\">10</span>);</span><br><span class=\"line\">bst.insert(<span class=\"number\">8</span>);</span><br><span class=\"line\">bst.insert(<span class=\"number\">2</span>);</span><br><span class=\"line\">bst.insert(<span class=\"number\">7</span>);</span><br><span class=\"line\">bst.insert(<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n<p>但是这个时候，想要看树中的数据，不是那么清晰，所以接下来，就要用到遍历了。</p>\n<h4 id=\"二叉树的遍历\"><a href=\"#二叉树的遍历\" class=\"headerlink\" title=\"二叉树的遍历\"></a>二叉树的遍历</h4><p>我们知道，树的遍历主要包括</p>\n<ul>\n<li>前序遍历 (根左右)</li>\n<li>中序遍历 (左根右)</li>\n<li>后序遍历 (左右根)</li>\n</ul>\n<p>这个只是为了好记忆，我们拿下面的图做一个遍历</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fug0jaukqpj209k057jrx.jpg\" alt=\"\"></p>\n<p>前序遍历: 56 22 10 30 81 77 92</p>\n<p>中序遍历: 10 22 30 56 77 81 92</p>\n<p>后序遍历: 10 30 22 77 92 81 56</p>\n<p>这里发现了一些规律：</p>\n<ol>\n<li>前序遍历，因为是根左右，所以最后一个一定是最大的； 第一个一定是root节点；</li>\n<li>中序遍历，在查找二叉树中，一定是从小到大的顺序； 根节点<code>56</code>左边(10/22/30)的一定是左子树的，右边的(77/81/92)一定是右子树的。</li>\n<li>后序遍历，根节点一定在最后</li>\n</ol>\n<h5 id=\"中序遍历的实现\"><a href=\"#中序遍历的实现\" class=\"headerlink\" title=\"中序遍历的实现\"></a>中序遍历的实现</h5><p>这里就又用到之前的递归了，中序遍历要求: <strong>左！根！右</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inOrder</span>(<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(node !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果不是null，就一直查找左变，因此递归</span></span><br><span class=\"line\">        inOrder(node.left);</span><br><span class=\"line\">        <span class=\"comment\">//递归结束，打印当前值</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(node.show());</span><br><span class=\"line\">        <span class=\"comment\">//上一次递归已经把左边搞完了，右边</span></span><br><span class=\"line\">        inOrder(node.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在刚才已有bst的基础上执行命令</span></span><br><span class=\"line\">inOrder(bst.root);</span><br></pre></td></tr></table></figure>\n<p>通过递归，实现了中序遍历，上面打印出的结果如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2</span><br><span class=\"line\">5</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">10</span><br></pre></td></tr></table></figure>\n<h5 id=\"前序遍历-amp-后序遍历\"><a href=\"#前序遍历-amp-后序遍历\" class=\"headerlink\" title=\"前序遍历&amp;后序遍历\"></a>前序遍历&amp;后序遍历</h5><p>如果刚才的递归过程搞清楚，那这个就再简单不过了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">preOrder</span>(<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(node !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//根左右</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(node.show());</span><br><span class=\"line\">        preOrder(node.left);</span><br><span class=\"line\">        preOrder(node.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>ok,趁热打铁，就把后序遍历的方法也一并写入，如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">postOrder</span>(<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(node !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//左右根</span></span><br><span class=\"line\">        postOrder(node.left);</span><br><span class=\"line\">        postOrder(node.right);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(node.show())</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>好了，可以去尝试两种方法打印出来的结果了:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">preOrder(bst.root);</span><br><span class=\"line\">postOrder(bst.root);</span><br></pre></td></tr></table></figure>\n<h3 id=\"二叉树的查找\"><a href=\"#二叉树的查找\" class=\"headerlink\" title=\"二叉树的查找\"></a>二叉树的查找</h3><p>在二叉树这种数据结构中进行数据查找是最方便的，现在我们就对查找最小值、最大值和特定值进行一个梳理：</p>\n<ul>\n<li>最小值： 最左子树的叶子节点</li>\n<li>最大值： 最右子树的叶子节点</li>\n<li>特定值： target与current进行比较，如果比current大，在current.right进行查找，反之类似。</li>\n</ul>\n<p>清楚思路后，就动手来写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//最小值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getMin</span>(<span class=\"params\">bst</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> current = bst.root;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(current.left !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        current = current.left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> current.data;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//最大值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getMax</span>(<span class=\"params\">bst</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> current = bst.root;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(current.right !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        current = current.right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> current.data;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最大、最小值都是非常简单的，下面主要看下如何通过</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">find</span>(<span class=\"params\">target,bst</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> current = bst.root;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(current !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(target === current.data) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(target &gt; current.data) &#123;</span><br><span class=\"line\">            current = current.right;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(target &lt; current.data) &#123;</span><br><span class=\"line\">            current = current.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其实核心，仍然是通过一个循环和判断，来不断的向下去寻找，这里的思想其实和二分查找是有点类似的。</p>\n<p>哇…</p>\n<p>没想到今天去整理排序 花了这么久…嗯..然而这篇文章已经够长了</p>\n<p>接下来我会把之前笔试遇到的题目和一些常用的算法问题，一一记录，前端很多算法都是和数组、字符串处理息息相关的，所以对正则表达式、数组常用方法的掌握也很重要，简单总结下知识点：</p>\n<ul>\n<li>正则表达式<ul>\n<li>字符串相关方法</li>\n<li>str.split()</li>\n<li>str.replace()</li>\n<li>str.match()</li>\n<li>reg.test()</li>\n<li>reg.exec()</li>\n</ul>\n</li>\n<li>数组方法<ul>\n<li>Array.map()  映射，有返回值，不改变数组本身</li>\n<li>Array.forEach() 遍历，无返回值</li>\n<li>Array.filter() 过滤，返回true时返回,false时不返回</li>\n<li>Array.splice/slice/join等</li>\n<li>for…of 遍历,iterator相关知识点</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"未完待续…\"><a href=\"#未完待续…\" class=\"headerlink\" title=\"未完待续….\"></a>未完待续….</h3><p>内容会持续更新，最快的当然还是在github上，然后会同步到掘金，<a href=\"https://github.com/forrany/Web-Project\" target=\"_blank\" rel=\"noopener\">github传送门</a></p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><ol>\n<li><a href=\"https://blog.csdn.net/yushiyi6453/article/details/76407640\" target=\"_blank\" rel=\"noopener\">排序算法时间复杂度、空间复杂度、稳定性比较</a></li>\n<li><a href=\"https://www.cnblogs.com/jsgnadsj/p/3458054.html\" target=\"_blank\" rel=\"noopener\">算法学习记录–希尔排序</a></li>\n<li><a href=\"https://blog.csdn.net/tizzzzzz/article/details/79610375\" target=\"_blank\" rel=\"noopener\">快速排序简单理解</a></li>\n<li><a href=\"https://book.douban.com/subject/25945449/\" target=\"_blank\" rel=\"noopener\">数据结构与算法Javascript描述</a></li>\n</ol>\n"},{"layout":"post","title":"JavaScript中的几种设计模式","subtitle":null,"date":"2018-12-16T04:00:00.000Z","author":"Vinecnt Ko","header-img":"img/post-bg-unix-linux.jpg","header-mask":0.3,"catalog":true,"_content":"\n##  单例模式\n\n```javascript\n \nvar person = {\n\tname : \"Tom\",\n\tage: 12\n}\n\nvar person1 = {\n\tname : \"toony\",\n\tage : \"11\"\n}\n\n```\n\n这就是单例模式\n - 作用： 实现分组，把描述同一个事物的属性和方法放在了同一个空间中，起到了分组的作用，避免了相同变量名之间的干扰\n - 在单例模式中，我们把对象名叫**命名空间**\n - 单例模式是我们项目中常用的模式，因为可以利用它进行模块化开发。\n\n```javascript\n//同样都用change方法，为了避免污染\nvar sideBar = {\n\tchange : function (){}\n}\n\nvar headBar = {\n\tchange : function (){}\n}\n\n```\n\n## 工厂模式\n为了实现”低冗余，高聚合“的方式，为了批量生产，于是有了工厂模式。 \n\n```javascript\n\nfunction creatPerson(name,age){\n\tvar obj = {};\n\tobj.name = name;\n\tobj.age = age;\n\tobj.writeJs = function () {\n\t\tconsole.log('ha' + obj.name + 'can write JS');\n\t}\n\treturn obj;\n}\n\n```\n于是，不用像单例模式那样，进行多次的重复的写内容了\n\n```javascript\nvar person1 = creatPerson(\"tom\",15);\nvar person2 = creatPerson(\"tony\",22);\n\n```\n**特点**：\n 1. 把实现相同功能的代码放到一个函数中，以后再想实现这个功能，不需要重新编写代码，只要运行代码即可   >>>我们把这个叫**函数的封装**    ==低耦合，高内聚==\n\n### 面向对象的编程语言\n - 封装   封装已经实现，就是函数\n - 继承   通过原型链实现\n - 多态   当前方法和类的多种姿态，包括 重载和重写\n\n#### 多态之重载\n方法名相同，参数类型、个数不同。\n但是，JS中没有重载，因为当重复写的时候，会被覆盖\n\n```javascript\nfunction sum (num,num){}\nfunction sum (num) {}\n```\n这是不行的，因此JS是没有重载的(overload)！！\n但是可以通过if语句判断，来模拟实现重载(overload)\n**但是JS有多态，因为有重写**\n\n### 构造函数模式\n\n```javascript\nfunction CreatPerson (name,age) {\n\tthis.name = name;\n\tthis.age = age;\n\tthis.writeJs = function (){\n\t\tconsole.log(\"my name is \" + this.name + \"I can write JS\"); \n\t\t}\n\n}\n\nvar tom = CreatPerson(\"tom\",12);\n```\n这就是构造函数设计模式，注意方面里面的this是在调用的时候，才知道指向谁； 而前面的属性上的this，则是在构造函数时，指向实例。 因为构造函数，遇到new 的时候，会自己创建一个this对象，最后再自动返回this对象。\n\n这种，在内建对象中，也有类似的模式，比如创建数组：\n```javascript\nvar arr = [];\nvar arr1 = new Array();\n```\n不管哪组方式，arr都是 Array的实例。\n但是注意： 不同实例的方法虽然名称相同，但是是不同的东西，那是各自实例的私有属性，单独的个体。\n#### 这个不是单例模式，而是构造函数模式\n有的时候，面试官认为这个是单例模式，实际上，这并不是，这个是构造函数模式，也创造了单独的对象，但是在W3C中是可以查询的！\n 1. JS中，所有类都是函数数据类型的，它与函数没有很大的区别。只不过在new的时候，会自动创建一个this对象，最后再自动返回。 (注意，实例都是object类型)\n\n 2. 构造函数中，this.xxx中的this都是指向实例本身。 在方法中，this需要等待调用才有所指代\n\n 3. p1和p2中都是同一个类的实力，都有相同的方法，但是那是私有属性，是单独个体，不相等。\n\n#### 还有一些特点(扩展)\n- var p1 = new CreatPerson 在构造函数中，如果没有参数，括号可以省略.  但是函数执行是不可以省略的\n- 如果提前return了一个对象，则会返回新的对象；如果返回一个基本数据类型，则没有任何影响\n- 测一个实例是否是一个类的实力  `instanceof`  \n\n```javascript\nconsole.log(p1 instanceof CreatPerson);  //true\nconsole.log(p1 instanceof(CreatPerson)); //true\nconsole.log(p1 instanceof Array) ;  //false\nconsole.log(p1 instanceof Object) ; //true\n```\n\n检测数据类型来说，typeof不能准确检测Array的具体类型(只能返回object)。 可以使用`istanceof`\n\n```javascript\nvar arr = [];\nconsole.log(arr istanceof Array);  //true\n//也可以使用Object下的\nconsole.log(Object.prototype.toString(arr)) //返回[object Array]\n```\n\n- 检测某一个实例是否有某个属性  `in`\n\n```javascript\nvar obj = {\n\tname : \"tom\",\n\tage : 12\n}\nconsole.log(\"age\" in obj) //true;\n```\n注意in无论是共有(prototype)还是私有的，都会返回。 因此，为了检测私有属性，有hasOwnProperty\n\n- 检测某一个属性是否是私有属性 `hasOwnProperty`\n\n```javascript\nconsole.log(obj.hasOwnProperty('age')) //true;\n```\n\n- 检测某一个实例是否有某个属性  `in`\n\n\n```javascript\nfunction hasPubProperty (obj,property) {\n\treturn property in obj && !obj.hasOwnProperty(property);\n}\n```\n\n\n### 原型链模式\n\n\n- 数组去重,链式写法\n\n```javascript\nArray.prototype.myUnique = function () {\n\tvar obj = {};\n\tfor(var i = 0; i < this.length; i++ ){\n\t\tvar cur = this[i];\n\t\tif(obj[cur] == cur){\n\t\t\tthis[i] = this[this.length -1];\n\t\t\tthis.length--;\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\tobj[cur] = cur;\n\t}\n\treturn this;  //实现链式写法\n}\n```\n- 写一个mySlice方法\n\n```javascript\nArray.prototype.mySlice = function (start,end) {\n\tvar arr = [],\n\t\trArr = [];\n\tstart < 0? start += this.length : start;\n\tend < 0? end += this.length : end;\n\tend >= this.length? end = this.length : end;\n\tfor(var i = 0; i< this.length - 1 ; i++){\n\t\tif(start <= i){\n\t\t\tarr[arr.length] = this[i];\n\t\t}\n\t\tif(end == i-1){\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn arr;\t\t\n}\n```\n\n#### 原型链批量设置共有属性的小问题\n\n当有多项属性、方法需要在原型链上配置的时候，可以使用批量设置，但是注意，一定要设置好constuctor\n\n```javascript\nMyfun.prototype = {\n\tconstructor: Myfun,\n\tthis.show: function () {\n\t\tconsole.log(this.name);\n\t},\n\t...\n\n}\n```\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fy8tozcht2j21510m415m.jpg)\n**记住这张图中的内容，这种设置方式相当于新开辟的一个内存地址来保存prototype，如果没有设置contructor，这个时候，constructor 就会指向Object。**\n\n另一方面，如果直接内置的类上批量添加，因为会覆盖原有的很多方法，因此浏览器会屏蔽这种设置方法\n\n```javascript\nArray.prototype = {}\n//这种方法无效\n```\n\n\n## 原型继承\n1. 最常用的方法；\n2. 子类B想要继承父类A中所有的属性和方法（私有+共有)，让B的prototype = A的实例。`B.prototype = new A`\n3. 原型继承特点，父类私有和共有的都变成了子类私有的方法和属性。\n## 圣杯模式\n\n```javascript\nvar inherit = (function () {\n\tvar function F() {}\n\treturn function (Origin,Target){\n\t\tF.prototype = Origin.prototype;\n\t\tTarget.prototype = new F；\n\t\tTarget.prototype.constructor = Target;\n\t\tTarget.prototype.uber = Origin;\n}\n} ())\n\n```\n## 中间类继承\n这个比较特殊，主要用在一个问题上:\n> 当遇到argument[]这种类数组时，无法使用数组的方法，很蛋疼。比如想封装一个平均值的方法\n\n```javascript\nfunction avgFn() {\n\tvar sum;\n\tArray.prototype.sort.call(arguments,function (a,b) {return a-b});  //升序排列，扔掉一个最大，一个最小\n\tArray.prototype.pop().call(arguments);\n\tArray.prototype.shift().call(arguments);\n\tfor(var i = 0; i < arguments.length; i++){\n\t\tsum += arr[i]\n\t}\n\treturn sum/arguments.length;\n}\n```\n显得很麻烦，因为要通过调用Array的方法。所以，这里可以直接修改类数组(同样也是对象)的`__proto__` 属性\n```javascript\narguments.__proto__ = Array.prototype;\n...\n```","source":"_posts/2018-12-16-inherit in javascript.md","raw":"---\nlayout:     post\ntitle:      \"JavaScript中的几种设计模式\"\nsubtitle:   \ndate:       2018-12-16 12:00:00\nauthor:     \"Vinecnt Ko\"\nheader-img: \"img/post-bg-unix-linux.jpg\"\nheader-mask: 0.3\ncatalog:    true\ntags:\n    - 前端开发\n    - JavaScript\n    - 设计模式\n---\n\n##  单例模式\n\n```javascript\n \nvar person = {\n\tname : \"Tom\",\n\tage: 12\n}\n\nvar person1 = {\n\tname : \"toony\",\n\tage : \"11\"\n}\n\n```\n\n这就是单例模式\n - 作用： 实现分组，把描述同一个事物的属性和方法放在了同一个空间中，起到了分组的作用，避免了相同变量名之间的干扰\n - 在单例模式中，我们把对象名叫**命名空间**\n - 单例模式是我们项目中常用的模式，因为可以利用它进行模块化开发。\n\n```javascript\n//同样都用change方法，为了避免污染\nvar sideBar = {\n\tchange : function (){}\n}\n\nvar headBar = {\n\tchange : function (){}\n}\n\n```\n\n## 工厂模式\n为了实现”低冗余，高聚合“的方式，为了批量生产，于是有了工厂模式。 \n\n```javascript\n\nfunction creatPerson(name,age){\n\tvar obj = {};\n\tobj.name = name;\n\tobj.age = age;\n\tobj.writeJs = function () {\n\t\tconsole.log('ha' + obj.name + 'can write JS');\n\t}\n\treturn obj;\n}\n\n```\n于是，不用像单例模式那样，进行多次的重复的写内容了\n\n```javascript\nvar person1 = creatPerson(\"tom\",15);\nvar person2 = creatPerson(\"tony\",22);\n\n```\n**特点**：\n 1. 把实现相同功能的代码放到一个函数中，以后再想实现这个功能，不需要重新编写代码，只要运行代码即可   >>>我们把这个叫**函数的封装**    ==低耦合，高内聚==\n\n### 面向对象的编程语言\n - 封装   封装已经实现，就是函数\n - 继承   通过原型链实现\n - 多态   当前方法和类的多种姿态，包括 重载和重写\n\n#### 多态之重载\n方法名相同，参数类型、个数不同。\n但是，JS中没有重载，因为当重复写的时候，会被覆盖\n\n```javascript\nfunction sum (num,num){}\nfunction sum (num) {}\n```\n这是不行的，因此JS是没有重载的(overload)！！\n但是可以通过if语句判断，来模拟实现重载(overload)\n**但是JS有多态，因为有重写**\n\n### 构造函数模式\n\n```javascript\nfunction CreatPerson (name,age) {\n\tthis.name = name;\n\tthis.age = age;\n\tthis.writeJs = function (){\n\t\tconsole.log(\"my name is \" + this.name + \"I can write JS\"); \n\t\t}\n\n}\n\nvar tom = CreatPerson(\"tom\",12);\n```\n这就是构造函数设计模式，注意方面里面的this是在调用的时候，才知道指向谁； 而前面的属性上的this，则是在构造函数时，指向实例。 因为构造函数，遇到new 的时候，会自己创建一个this对象，最后再自动返回this对象。\n\n这种，在内建对象中，也有类似的模式，比如创建数组：\n```javascript\nvar arr = [];\nvar arr1 = new Array();\n```\n不管哪组方式，arr都是 Array的实例。\n但是注意： 不同实例的方法虽然名称相同，但是是不同的东西，那是各自实例的私有属性，单独的个体。\n#### 这个不是单例模式，而是构造函数模式\n有的时候，面试官认为这个是单例模式，实际上，这并不是，这个是构造函数模式，也创造了单独的对象，但是在W3C中是可以查询的！\n 1. JS中，所有类都是函数数据类型的，它与函数没有很大的区别。只不过在new的时候，会自动创建一个this对象，最后再自动返回。 (注意，实例都是object类型)\n\n 2. 构造函数中，this.xxx中的this都是指向实例本身。 在方法中，this需要等待调用才有所指代\n\n 3. p1和p2中都是同一个类的实力，都有相同的方法，但是那是私有属性，是单独个体，不相等。\n\n#### 还有一些特点(扩展)\n- var p1 = new CreatPerson 在构造函数中，如果没有参数，括号可以省略.  但是函数执行是不可以省略的\n- 如果提前return了一个对象，则会返回新的对象；如果返回一个基本数据类型，则没有任何影响\n- 测一个实例是否是一个类的实力  `instanceof`  \n\n```javascript\nconsole.log(p1 instanceof CreatPerson);  //true\nconsole.log(p1 instanceof(CreatPerson)); //true\nconsole.log(p1 instanceof Array) ;  //false\nconsole.log(p1 instanceof Object) ; //true\n```\n\n检测数据类型来说，typeof不能准确检测Array的具体类型(只能返回object)。 可以使用`istanceof`\n\n```javascript\nvar arr = [];\nconsole.log(arr istanceof Array);  //true\n//也可以使用Object下的\nconsole.log(Object.prototype.toString(arr)) //返回[object Array]\n```\n\n- 检测某一个实例是否有某个属性  `in`\n\n```javascript\nvar obj = {\n\tname : \"tom\",\n\tage : 12\n}\nconsole.log(\"age\" in obj) //true;\n```\n注意in无论是共有(prototype)还是私有的，都会返回。 因此，为了检测私有属性，有hasOwnProperty\n\n- 检测某一个属性是否是私有属性 `hasOwnProperty`\n\n```javascript\nconsole.log(obj.hasOwnProperty('age')) //true;\n```\n\n- 检测某一个实例是否有某个属性  `in`\n\n\n```javascript\nfunction hasPubProperty (obj,property) {\n\treturn property in obj && !obj.hasOwnProperty(property);\n}\n```\n\n\n### 原型链模式\n\n\n- 数组去重,链式写法\n\n```javascript\nArray.prototype.myUnique = function () {\n\tvar obj = {};\n\tfor(var i = 0; i < this.length; i++ ){\n\t\tvar cur = this[i];\n\t\tif(obj[cur] == cur){\n\t\t\tthis[i] = this[this.length -1];\n\t\t\tthis.length--;\n\t\t\ti--;\n\t\t\tcontinue;\n\t\t}\n\t\tobj[cur] = cur;\n\t}\n\treturn this;  //实现链式写法\n}\n```\n- 写一个mySlice方法\n\n```javascript\nArray.prototype.mySlice = function (start,end) {\n\tvar arr = [],\n\t\trArr = [];\n\tstart < 0? start += this.length : start;\n\tend < 0? end += this.length : end;\n\tend >= this.length? end = this.length : end;\n\tfor(var i = 0; i< this.length - 1 ; i++){\n\t\tif(start <= i){\n\t\t\tarr[arr.length] = this[i];\n\t\t}\n\t\tif(end == i-1){\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn arr;\t\t\n}\n```\n\n#### 原型链批量设置共有属性的小问题\n\n当有多项属性、方法需要在原型链上配置的时候，可以使用批量设置，但是注意，一定要设置好constuctor\n\n```javascript\nMyfun.prototype = {\n\tconstructor: Myfun,\n\tthis.show: function () {\n\t\tconsole.log(this.name);\n\t},\n\t...\n\n}\n```\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fy8tozcht2j21510m415m.jpg)\n**记住这张图中的内容，这种设置方式相当于新开辟的一个内存地址来保存prototype，如果没有设置contructor，这个时候，constructor 就会指向Object。**\n\n另一方面，如果直接内置的类上批量添加，因为会覆盖原有的很多方法，因此浏览器会屏蔽这种设置方法\n\n```javascript\nArray.prototype = {}\n//这种方法无效\n```\n\n\n## 原型继承\n1. 最常用的方法；\n2. 子类B想要继承父类A中所有的属性和方法（私有+共有)，让B的prototype = A的实例。`B.prototype = new A`\n3. 原型继承特点，父类私有和共有的都变成了子类私有的方法和属性。\n## 圣杯模式\n\n```javascript\nvar inherit = (function () {\n\tvar function F() {}\n\treturn function (Origin,Target){\n\t\tF.prototype = Origin.prototype;\n\t\tTarget.prototype = new F；\n\t\tTarget.prototype.constructor = Target;\n\t\tTarget.prototype.uber = Origin;\n}\n} ())\n\n```\n## 中间类继承\n这个比较特殊，主要用在一个问题上:\n> 当遇到argument[]这种类数组时，无法使用数组的方法，很蛋疼。比如想封装一个平均值的方法\n\n```javascript\nfunction avgFn() {\n\tvar sum;\n\tArray.prototype.sort.call(arguments,function (a,b) {return a-b});  //升序排列，扔掉一个最大，一个最小\n\tArray.prototype.pop().call(arguments);\n\tArray.prototype.shift().call(arguments);\n\tfor(var i = 0; i < arguments.length; i++){\n\t\tsum += arr[i]\n\t}\n\treturn sum/arguments.length;\n}\n```\n显得很麻烦，因为要通过调用Array的方法。所以，这里可以直接修改类数组(同样也是对象)的`__proto__` 属性\n```javascript\narguments.__proto__ = Array.prototype;\n...\n```","slug":"2018-12-16-inherit-in-javascript","published":1,"updated":"2022-08-17T07:53:21.232Z","comments":1,"photos":[],"link":"","_id":"cl6xbhzk3000mzk08a5fcr8xd","content":"<h2 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">\tname : <span class=\"string\">\"Tom\"</span>,</span><br><span class=\"line\">\tage: <span class=\"number\">12</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = &#123;</span><br><span class=\"line\">\tname : <span class=\"string\">\"toony\"</span>,</span><br><span class=\"line\">\tage : <span class=\"string\">\"11\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这就是单例模式</p>\n<ul>\n<li>作用： 实现分组，把描述同一个事物的属性和方法放在了同一个空间中，起到了分组的作用，避免了相同变量名之间的干扰</li>\n<li>在单例模式中，我们把对象名叫<strong>命名空间</strong></li>\n<li>单例模式是我们项目中常用的模式，因为可以利用它进行模块化开发。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//同样都用change方法，为了避免污染</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sideBar = &#123;</span><br><span class=\"line\">\tchange : <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> headBar = &#123;</span><br><span class=\"line\">\tchange : <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h2><p>为了实现”低冗余，高聚合“的方式，为了批量生产，于是有了工厂模式。 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">creatPerson</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">\tobj.name = name;</span><br><span class=\"line\">\tobj.age = age;</span><br><span class=\"line\">\tobj.writeJs = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'ha'</span> + obj.name + <span class=\"string\">'can write JS'</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>于是，不用像单例模式那样，进行多次的重复的写内容了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person1 = creatPerson(<span class=\"string\">\"tom\"</span>,<span class=\"number\">15</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = creatPerson(<span class=\"string\">\"tony\"</span>,<span class=\"number\">22</span>);</span><br></pre></td></tr></table></figure>\n<p><strong>特点</strong>：</p>\n<ol>\n<li>把实现相同功能的代码放到一个函数中，以后再想实现这个功能，不需要重新编写代码，只要运行代码即可   &gt;&gt;&gt;我们把这个叫<strong>函数的封装</strong>    ==低耦合，高内聚==</li>\n</ol>\n<h3 id=\"面向对象的编程语言\"><a href=\"#面向对象的编程语言\" class=\"headerlink\" title=\"面向对象的编程语言\"></a>面向对象的编程语言</h3><ul>\n<li>封装   封装已经实现，就是函数</li>\n<li>继承   通过原型链实现</li>\n<li>多态   当前方法和类的多种姿态，包括 重载和重写</li>\n</ul>\n<h4 id=\"多态之重载\"><a href=\"#多态之重载\" class=\"headerlink\" title=\"多态之重载\"></a>多态之重载</h4><p>方法名相同，参数类型、个数不同。<br>但是，JS中没有重载，因为当重复写的时候，会被覆盖</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span> (<span class=\"params\">num,num</span>)</span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span> (<span class=\"params\">num</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>这是不行的，因此JS是没有重载的(overload)！！<br>但是可以通过if语句判断，来模拟实现重载(overload)<br><strong>但是JS有多态，因为有重写</strong></p>\n<h3 id=\"构造函数模式\"><a href=\"#构造函数模式\" class=\"headerlink\" title=\"构造函数模式\"></a>构造函数模式</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">CreatPerson</span> (<span class=\"params\">name,age</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.writeJs = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"my name is \"</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">\"I can write JS\"</span>); </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> tom = CreatPerson(<span class=\"string\">\"tom\"</span>,<span class=\"number\">12</span>);</span><br></pre></td></tr></table></figure>\n<p>这就是构造函数设计模式，注意方面里面的this是在调用的时候，才知道指向谁； 而前面的属性上的this，则是在构造函数时，指向实例。 因为构造函数，遇到new 的时候，会自己创建一个this对象，最后再自动返回this对象。</p>\n<p>这种，在内建对象中，也有类似的模式，比如创建数组：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br></pre></td></tr></table></figure></p>\n<p>不管哪组方式，arr都是 Array的实例。<br>但是注意： 不同实例的方法虽然名称相同，但是是不同的东西，那是各自实例的私有属性，单独的个体。</p>\n<h4 id=\"这个不是单例模式，而是构造函数模式\"><a href=\"#这个不是单例模式，而是构造函数模式\" class=\"headerlink\" title=\"这个不是单例模式，而是构造函数模式\"></a>这个不是单例模式，而是构造函数模式</h4><p>有的时候，面试官认为这个是单例模式，实际上，这并不是，这个是构造函数模式，也创造了单独的对象，但是在W3C中是可以查询的！</p>\n<ol>\n<li><p>JS中，所有类都是函数数据类型的，它与函数没有很大的区别。只不过在new的时候，会自动创建一个this对象，最后再自动返回。 (注意，实例都是object类型)</p>\n</li>\n<li><p>构造函数中，this.xxx中的this都是指向实例本身。 在方法中，this需要等待调用才有所指代</p>\n</li>\n<li><p>p1和p2中都是同一个类的实力，都有相同的方法，但是那是私有属性，是单独个体，不相等。</p>\n</li>\n</ol>\n<h4 id=\"还有一些特点-扩展\"><a href=\"#还有一些特点-扩展\" class=\"headerlink\" title=\"还有一些特点(扩展)\"></a>还有一些特点(扩展)</h4><ul>\n<li>var p1 = new CreatPerson 在构造函数中，如果没有参数，括号可以省略.  但是函数执行是不可以省略的</li>\n<li>如果提前return了一个对象，则会返回新的对象；如果返回一个基本数据类型，则没有任何影响</li>\n<li>测一个实例是否是一个类的实力  <code>instanceof</code>  </li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(p1 <span class=\"keyword\">instanceof</span> CreatPerson);  <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p1 <span class=\"keyword\">instanceof</span>(CreatPerson)); <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p1 <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>) ;  <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p1 <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>) ; <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>检测数据类型来说，typeof不能准确检测Array的具体类型(只能返回object)。 可以使用<code>istanceof</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr istanceof <span class=\"built_in\">Array</span>);  <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"comment\">//也可以使用Object下的</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.prototype.toString(arr)) <span class=\"comment\">//返回[object Array]</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>检测某一个实例是否有某个属性  <code>in</code></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">\tname : <span class=\"string\">\"tom\"</span>,</span><br><span class=\"line\">\tage : <span class=\"number\">12</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"age\"</span> <span class=\"keyword\">in</span> obj) <span class=\"comment\">//true;</span></span><br></pre></td></tr></table></figure>\n<p>注意in无论是共有(prototype)还是私有的，都会返回。 因此，为了检测私有属性，有hasOwnProperty</p>\n<ul>\n<li>检测某一个属性是否是私有属性 <code>hasOwnProperty</code></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.hasOwnProperty(<span class=\"string\">'age'</span>)) <span class=\"comment\">//true;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>检测某一个实例是否有某个属性  <code>in</code></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hasPubProperty</span> (<span class=\"params\">obj,property</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> property <span class=\"keyword\">in</span> obj &amp;&amp; !obj.hasOwnProperty(property);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"原型链模式\"><a href=\"#原型链模式\" class=\"headerlink\" title=\"原型链模式\"></a>原型链模式</h3><ul>\n<li>数组去重,链式写法</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.myUnique = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.length; i++ )&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> cur = <span class=\"keyword\">this</span>[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(obj[cur] == cur)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>[i] = <span class=\"keyword\">this</span>[<span class=\"keyword\">this</span>.length <span class=\"number\">-1</span>];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.length--;</span><br><span class=\"line\">\t\t\ti--;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tobj[cur] = cur;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  <span class=\"comment\">//实现链式写法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>写一个mySlice方法</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.mySlice = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">start,end</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> arr = [],</span><br><span class=\"line\">\t\trArr = [];</span><br><span class=\"line\">\tstart &lt; <span class=\"number\">0</span>? start += <span class=\"keyword\">this</span>.length : start;</span><br><span class=\"line\">\tend &lt; <span class=\"number\">0</span>? end += <span class=\"keyword\">this</span>.length : end;</span><br><span class=\"line\">\tend &gt;= <span class=\"keyword\">this</span>.length? end = <span class=\"keyword\">this</span>.length : end;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i&lt; <span class=\"keyword\">this</span>.length - <span class=\"number\">1</span> ; i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(start &lt;= i)&#123;</span><br><span class=\"line\">\t\t\tarr[arr.length] = <span class=\"keyword\">this</span>[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(end == i<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> arr;\t\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"原型链批量设置共有属性的小问题\"><a href=\"#原型链批量设置共有属性的小问题\" class=\"headerlink\" title=\"原型链批量设置共有属性的小问题\"></a>原型链批量设置共有属性的小问题</h4><p>当有多项属性、方法需要在原型链上配置的时候，可以使用批量设置，但是注意，一定要设置好constuctor</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Myfun.prototype = &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">constructor</span>: Myfun,</span><br><span class=\"line\">\tthis.show: function () &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fy8tozcht2j21510m415m.jpg\" alt=\"\"><br><strong>记住这张图中的内容，这种设置方式相当于新开辟的一个内存地址来保存prototype，如果没有设置contructor，这个时候，constructor 就会指向Object。</strong></p>\n<p>另一方面，如果直接内置的类上批量添加，因为会覆盖原有的很多方法，因此浏览器会屏蔽这种设置方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype = &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">//这种方法无效</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"原型继承\"><a href=\"#原型继承\" class=\"headerlink\" title=\"原型继承\"></a>原型继承</h2><ol>\n<li>最常用的方法；</li>\n<li>子类B想要继承父类A中所有的属性和方法（私有+共有)，让B的prototype = A的实例。<code>B.prototype = new A</code></li>\n<li>原型继承特点，父类私有和共有的都变成了子类私有的方法和属性。<h2 id=\"圣杯模式\"><a href=\"#圣杯模式\" class=\"headerlink\" title=\"圣杯模式\"></a>圣杯模式</h2></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> inherit = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Origin,Target</span>)</span>&#123;</span><br><span class=\"line\">\t\tF.prototype = Origin.prototype;</span><br><span class=\"line\">\t\tTarget.prototype = <span class=\"keyword\">new</span> F；</span><br><span class=\"line\">\t\tTarget.prototype.constructor = Target;</span><br><span class=\"line\">\t\tTarget.prototype.uber = Origin;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125; ())</span><br></pre></td></tr></table></figure>\n<h2 id=\"中间类继承\"><a href=\"#中间类继承\" class=\"headerlink\" title=\"中间类继承\"></a>中间类继承</h2><p>这个比较特殊，主要用在一个问题上:</p>\n<blockquote>\n<p>当遇到argument[]这种类数组时，无法使用数组的方法，很蛋疼。比如想封装一个平均值的方法</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">avgFn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> sum;</span><br><span class=\"line\">\t<span class=\"built_in\">Array</span>.prototype.sort.call(<span class=\"built_in\">arguments</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a,b</span>) </span>&#123;<span class=\"keyword\">return</span> a-b&#125;);  <span class=\"comment\">//升序排列，扔掉一个最大，一个最小</span></span><br><span class=\"line\">\t<span class=\"built_in\">Array</span>.prototype.pop().call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">Array</span>.prototype.shift().call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">arguments</span>.length; i++)&#123;</span><br><span class=\"line\">\t\tsum += arr[i]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum/<span class=\"built_in\">arguments</span>.length;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>显得很麻烦，因为要通过调用Array的方法。所以，这里可以直接修改类数组(同样也是对象)的<code>__proto__</code> 属性<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">arguments</span>.__proto__ = <span class=\"built_in\">Array</span>.prototype;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">\tname : <span class=\"string\">\"Tom\"</span>,</span><br><span class=\"line\">\tage: <span class=\"number\">12</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = &#123;</span><br><span class=\"line\">\tname : <span class=\"string\">\"toony\"</span>,</span><br><span class=\"line\">\tage : <span class=\"string\">\"11\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这就是单例模式</p>\n<ul>\n<li>作用： 实现分组，把描述同一个事物的属性和方法放在了同一个空间中，起到了分组的作用，避免了相同变量名之间的干扰</li>\n<li>在单例模式中，我们把对象名叫<strong>命名空间</strong></li>\n<li>单例模式是我们项目中常用的模式，因为可以利用它进行模块化开发。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//同样都用change方法，为了避免污染</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sideBar = &#123;</span><br><span class=\"line\">\tchange : <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> headBar = &#123;</span><br><span class=\"line\">\tchange : <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h2><p>为了实现”低冗余，高聚合“的方式，为了批量生产，于是有了工厂模式。 </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">creatPerson</span>(<span class=\"params\">name,age</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">\tobj.name = name;</span><br><span class=\"line\">\tobj.age = age;</span><br><span class=\"line\">\tobj.writeJs = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'ha'</span> + obj.name + <span class=\"string\">'can write JS'</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>于是，不用像单例模式那样，进行多次的重复的写内容了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person1 = creatPerson(<span class=\"string\">\"tom\"</span>,<span class=\"number\">15</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = creatPerson(<span class=\"string\">\"tony\"</span>,<span class=\"number\">22</span>);</span><br></pre></td></tr></table></figure>\n<p><strong>特点</strong>：</p>\n<ol>\n<li>把实现相同功能的代码放到一个函数中，以后再想实现这个功能，不需要重新编写代码，只要运行代码即可   &gt;&gt;&gt;我们把这个叫<strong>函数的封装</strong>    ==低耦合，高内聚==</li>\n</ol>\n<h3 id=\"面向对象的编程语言\"><a href=\"#面向对象的编程语言\" class=\"headerlink\" title=\"面向对象的编程语言\"></a>面向对象的编程语言</h3><ul>\n<li>封装   封装已经实现，就是函数</li>\n<li>继承   通过原型链实现</li>\n<li>多态   当前方法和类的多种姿态，包括 重载和重写</li>\n</ul>\n<h4 id=\"多态之重载\"><a href=\"#多态之重载\" class=\"headerlink\" title=\"多态之重载\"></a>多态之重载</h4><p>方法名相同，参数类型、个数不同。<br>但是，JS中没有重载，因为当重复写的时候，会被覆盖</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span> (<span class=\"params\">num,num</span>)</span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span> (<span class=\"params\">num</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>这是不行的，因此JS是没有重载的(overload)！！<br>但是可以通过if语句判断，来模拟实现重载(overload)<br><strong>但是JS有多态，因为有重写</strong></p>\n<h3 id=\"构造函数模式\"><a href=\"#构造函数模式\" class=\"headerlink\" title=\"构造函数模式\"></a>构造函数模式</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">CreatPerson</span> (<span class=\"params\">name,age</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.writeJs = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"my name is \"</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">\"I can write JS\"</span>); </span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> tom = CreatPerson(<span class=\"string\">\"tom\"</span>,<span class=\"number\">12</span>);</span><br></pre></td></tr></table></figure>\n<p>这就是构造函数设计模式，注意方面里面的this是在调用的时候，才知道指向谁； 而前面的属性上的this，则是在构造函数时，指向实例。 因为构造函数，遇到new 的时候，会自己创建一个this对象，最后再自动返回this对象。</p>\n<p>这种，在内建对象中，也有类似的模式，比如创建数组：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br></pre></td></tr></table></figure></p>\n<p>不管哪组方式，arr都是 Array的实例。<br>但是注意： 不同实例的方法虽然名称相同，但是是不同的东西，那是各自实例的私有属性，单独的个体。</p>\n<h4 id=\"这个不是单例模式，而是构造函数模式\"><a href=\"#这个不是单例模式，而是构造函数模式\" class=\"headerlink\" title=\"这个不是单例模式，而是构造函数模式\"></a>这个不是单例模式，而是构造函数模式</h4><p>有的时候，面试官认为这个是单例模式，实际上，这并不是，这个是构造函数模式，也创造了单独的对象，但是在W3C中是可以查询的！</p>\n<ol>\n<li><p>JS中，所有类都是函数数据类型的，它与函数没有很大的区别。只不过在new的时候，会自动创建一个this对象，最后再自动返回。 (注意，实例都是object类型)</p>\n</li>\n<li><p>构造函数中，this.xxx中的this都是指向实例本身。 在方法中，this需要等待调用才有所指代</p>\n</li>\n<li><p>p1和p2中都是同一个类的实力，都有相同的方法，但是那是私有属性，是单独个体，不相等。</p>\n</li>\n</ol>\n<h4 id=\"还有一些特点-扩展\"><a href=\"#还有一些特点-扩展\" class=\"headerlink\" title=\"还有一些特点(扩展)\"></a>还有一些特点(扩展)</h4><ul>\n<li>var p1 = new CreatPerson 在构造函数中，如果没有参数，括号可以省略.  但是函数执行是不可以省略的</li>\n<li>如果提前return了一个对象，则会返回新的对象；如果返回一个基本数据类型，则没有任何影响</li>\n<li>测一个实例是否是一个类的实力  <code>instanceof</code>  </li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(p1 <span class=\"keyword\">instanceof</span> CreatPerson);  <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p1 <span class=\"keyword\">instanceof</span>(CreatPerson)); <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p1 <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>) ;  <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p1 <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>) ; <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>检测数据类型来说，typeof不能准确检测Array的具体类型(只能返回object)。 可以使用<code>istanceof</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr istanceof <span class=\"built_in\">Array</span>);  <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"comment\">//也可以使用Object下的</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.prototype.toString(arr)) <span class=\"comment\">//返回[object Array]</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>检测某一个实例是否有某个属性  <code>in</code></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">\tname : <span class=\"string\">\"tom\"</span>,</span><br><span class=\"line\">\tage : <span class=\"number\">12</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"age\"</span> <span class=\"keyword\">in</span> obj) <span class=\"comment\">//true;</span></span><br></pre></td></tr></table></figure>\n<p>注意in无论是共有(prototype)还是私有的，都会返回。 因此，为了检测私有属性，有hasOwnProperty</p>\n<ul>\n<li>检测某一个属性是否是私有属性 <code>hasOwnProperty</code></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.hasOwnProperty(<span class=\"string\">'age'</span>)) <span class=\"comment\">//true;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>检测某一个实例是否有某个属性  <code>in</code></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hasPubProperty</span> (<span class=\"params\">obj,property</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> property <span class=\"keyword\">in</span> obj &amp;&amp; !obj.hasOwnProperty(property);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"原型链模式\"><a href=\"#原型链模式\" class=\"headerlink\" title=\"原型链模式\"></a>原型链模式</h3><ul>\n<li>数组去重,链式写法</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.myUnique = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"keyword\">this</span>.length; i++ )&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> cur = <span class=\"keyword\">this</span>[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(obj[cur] == cur)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>[i] = <span class=\"keyword\">this</span>[<span class=\"keyword\">this</span>.length <span class=\"number\">-1</span>];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">this</span>.length--;</span><br><span class=\"line\">\t\t\ti--;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">continue</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tobj[cur] = cur;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;  <span class=\"comment\">//实现链式写法</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>写一个mySlice方法</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.mySlice = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">start,end</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> arr = [],</span><br><span class=\"line\">\t\trArr = [];</span><br><span class=\"line\">\tstart &lt; <span class=\"number\">0</span>? start += <span class=\"keyword\">this</span>.length : start;</span><br><span class=\"line\">\tend &lt; <span class=\"number\">0</span>? end += <span class=\"keyword\">this</span>.length : end;</span><br><span class=\"line\">\tend &gt;= <span class=\"keyword\">this</span>.length? end = <span class=\"keyword\">this</span>.length : end;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i&lt; <span class=\"keyword\">this</span>.length - <span class=\"number\">1</span> ; i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(start &lt;= i)&#123;</span><br><span class=\"line\">\t\t\tarr[arr.length] = <span class=\"keyword\">this</span>[i];</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(end == i<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> arr;\t\t</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"原型链批量设置共有属性的小问题\"><a href=\"#原型链批量设置共有属性的小问题\" class=\"headerlink\" title=\"原型链批量设置共有属性的小问题\"></a>原型链批量设置共有属性的小问题</h4><p>当有多项属性、方法需要在原型链上配置的时候，可以使用批量设置，但是注意，一定要设置好constuctor</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Myfun.prototype = &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">constructor</span>: Myfun,</span><br><span class=\"line\">\tthis.show: function () &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fy8tozcht2j21510m415m.jpg\" alt=\"\"><br><strong>记住这张图中的内容，这种设置方式相当于新开辟的一个内存地址来保存prototype，如果没有设置contructor，这个时候，constructor 就会指向Object。</strong></p>\n<p>另一方面，如果直接内置的类上批量添加，因为会覆盖原有的很多方法，因此浏览器会屏蔽这种设置方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype = &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">//这种方法无效</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"原型继承\"><a href=\"#原型继承\" class=\"headerlink\" title=\"原型继承\"></a>原型继承</h2><ol>\n<li>最常用的方法；</li>\n<li>子类B想要继承父类A中所有的属性和方法（私有+共有)，让B的prototype = A的实例。<code>B.prototype = new A</code></li>\n<li>原型继承特点，父类私有和共有的都变成了子类私有的方法和属性。<h2 id=\"圣杯模式\"><a href=\"#圣杯模式\" class=\"headerlink\" title=\"圣杯模式\"></a>圣杯模式</h2></li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> inherit = (<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">F</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">Origin,Target</span>)</span>&#123;</span><br><span class=\"line\">\t\tF.prototype = Origin.prototype;</span><br><span class=\"line\">\t\tTarget.prototype = <span class=\"keyword\">new</span> F；</span><br><span class=\"line\">\t\tTarget.prototype.constructor = Target;</span><br><span class=\"line\">\t\tTarget.prototype.uber = Origin;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125; ())</span><br></pre></td></tr></table></figure>\n<h2 id=\"中间类继承\"><a href=\"#中间类继承\" class=\"headerlink\" title=\"中间类继承\"></a>中间类继承</h2><p>这个比较特殊，主要用在一个问题上:</p>\n<blockquote>\n<p>当遇到argument[]这种类数组时，无法使用数组的方法，很蛋疼。比如想封装一个平均值的方法</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">avgFn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> sum;</span><br><span class=\"line\">\t<span class=\"built_in\">Array</span>.prototype.sort.call(<span class=\"built_in\">arguments</span>,<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a,b</span>) </span>&#123;<span class=\"keyword\">return</span> a-b&#125;);  <span class=\"comment\">//升序排列，扔掉一个最大，一个最小</span></span><br><span class=\"line\">\t<span class=\"built_in\">Array</span>.prototype.pop().call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">Array</span>.prototype.shift().call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">arguments</span>.length; i++)&#123;</span><br><span class=\"line\">\t\tsum += arr[i]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum/<span class=\"built_in\">arguments</span>.length;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>显得很麻烦，因为要通过调用Array的方法。所以，这里可以直接修改类数组(同样也是对象)的<code>__proto__</code> 属性<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">arguments</span>.__proto__ = <span class=\"built_in\">Array</span>.prototype;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n"},{"title":"常用git命令总结","date":"2019-11-25T12:15:24.000Z","author":"Vinecnt Ko","_content":"\n> 记录在日常使用git时遇到的问题和解决方案\n\n除了最频繁的`git pull` 、 `git push` 等操作，在工作和日常使用中，还会遇到各种各样的问题和情景，在这里做一些记录，方便总结、查看\n\n\n\n### 1. Your branch is ahead of 'origin/master' by 3 commits\n\nI am getting the following when running `git status`\n\n```\nYour branch is ahead of 'origin/master' by 3 commits.\n```\n\nI have read on some other post the way to fix this is run `git pull --rebase` but what exactly is rebase, will I lose data or is this simple way to sync with master?\n\n\n\n### answers\n\n------\n\nYou get that message because you made changes in your local master and you didn't push them to remote. You have several ways to \"solve\" it and it normally depends on how your workflow looks like:\n\n- In a good workflow your remote copy of master should be the good one while your local copy of master is just a copy of the one in remote. Using this workflow you'll never get this message again.\n- If you work in another way and your local changes should be pushed then just `git push origin`assuming origin is your remote\n- If your local changes are bad then just remove them or reset your local master to the state on remote **git reset --hard origin/master**\n\n------\n\n### 2. git修改远程仓库地址\n\n方法有三种：\n\n1. 修改命令\n\n   ```\n   git remote set-url origin [url]\n   ```\n\n2. 先删后加\n\n   ```\n   git remote rm origin\n   git remote add origin [url]\n   ```\n\n3. 直接修改config文件\n\n### 3. git放弃修改&放弃增加文件\n\n1. 本地修改了一堆文件(并没有使用git add到暂存区)，想放弃修改。 \n   单个文件/文件夹：\n\n```bash\n$ git checkout -- filename\n```\n\n​\t所有文件/文件夹：\n\n```bash\n$ git checkout .\n```\n\n2. 本地新增了一堆文件(并没有git add到暂存区)，想放弃修改。 \n   单个文件/文件夹：\n\n```bash\n$ rm filename / rm dir -rf\n```\n\n所有文件/文件夹：\n\n```bash\n$ git clean -xdf\n// 删除新增的文件，如果文件已经已经git add到暂存区，并不会删除！\n```\n\n3. 本地修改/新增了一堆文件，已经git add到暂存区，想放弃修改。 \n   单个文件/文件夹：\n\n```bash\n$ git reset HEAD filename\n```\n\n​\t所有文件/文件夹：\n\n```bash\n$ git reset HEAD .\n```\n\n4. 本地通过git add & git commit 之后，想要撤销此次commit\n\n```bash\n$ git reset commit_id\n//这个id是你想要回到的那个节点，可以通过git log查看，可以只选前6位 \n// 撤销之后，你所做的已经commit的修改还在工作区！\n```\n\n```bash\n$ git reset --hard commit_id\n//这个id是你想要回到的那个节点，可以通过git log查看，可以只选前6位 \n// 撤销之后，你所做的已经commit的修改将会清除，仍在工作区/暂存区的代码不会清除！\n```\n\n### 4. 删除分支\n\n首先查看项目的分支（包括本地和远程）\n\n```bash\n$ git branch -a\n```\n\n1. 删除本地分支\n\n```bash\n$ git branch -d <branchname>\n```\n\n2. 删除远程分支\n\n```bash\n$ git push origin --delete <branchname>\n```\n\n\n\n### 5.删除远程文件\n\n> 项目开发初期由于`.gitignore` 文件配置不正确很有可能导致某些不需要的目录上传到 git 远程仓库上了，这样会导致每个开发者提交的时候这些文件每次都会不同。除了一开始提交的时候注意配置好 `.gitignore` 文件外，我们也需要了解下出现这种问题后的解决办法\n\n具体操作步骤如下：\n\n1. 预览将要删除的文件\n\n   ```\n   git rm -r -n --cached 文件/文件夹名称 \n   \n   加上 -n 这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览。\n   ```\n\n2. 确定无误后删除文件\n\n   ```\n   git rm -r --cached 文件/文件夹名称\n   ```\n\n3. 提交到本地并推送到远程服务器\n\n   ```\n   git commit -m \"提交说明\"\n   git push origin master\n   ```\n\n4. 修改本地 .gitignore 文件 并提交\n\n   ```\n     git commit -m \"提交说明\"\n     git push origin master\n   ```\n\n### 6. gitlab或github下fork后如何同步源的新更新内容？\n\n> gitlab或github下，a开发者fork了b开发者的项目后，如果b开发人员更新代码后，a开发者如何获得更新？\n\n具体步骤如下:\n\n1. 给fork配置远程库\n\n```bash\ngir remote -v\n```\n\n查看远程状态\n\n- 确定一个将被同步给 fork 远程的上游仓库\n\n```bash\ngit remote add upstream URL\n```\n\n2. 同步fork\n\n- 从上游仓库 fetch 分支和提交点，提交给本地 master，并会被存储在一个本地分支upstream/master \n\n```bash\ngit fetch upstream\n```\n\n- 切换到本地主分支\n\n```bash\ngit checkout master\n```\n\n- 把 upstream/master 分支合并到本地 master 上，这样就完成了同步，并且不会丢掉本地修的内容\n\n```bash\ngit merge upstream/master\n```\n\n\n\n### 7. 对本地commit进行还原 \n\n```bash\ngit reset --soft HEAD~1\n```\n\n注：reset命令基于最近一次提交，多次执行会回到更早以前，这可能会超出预期。\n\n### 8. 放弃修改，远程覆盖本地代码\n\n与问题1一样，本地超前远程分支，但同时不想要本地的修改，在复习下\n\n在使用Git的过程中，有些时候我们只想要git服务器中的最新版本的项目，对于本地的项目中修改不做任何理会\n\n```bash\ngit fetch --all\ngit reset --hard origin/master\ngit pull\n```\n\n","source":"_posts/Most useful git commands.md","raw":"---\ntitle: 常用git命令总结\ndate: 2019-11-25 20:15:24\nauthor:  \"Vinecnt Ko\"\ntags:\n    - git\n---\n\n> 记录在日常使用git时遇到的问题和解决方案\n\n除了最频繁的`git pull` 、 `git push` 等操作，在工作和日常使用中，还会遇到各种各样的问题和情景，在这里做一些记录，方便总结、查看\n\n\n\n### 1. Your branch is ahead of 'origin/master' by 3 commits\n\nI am getting the following when running `git status`\n\n```\nYour branch is ahead of 'origin/master' by 3 commits.\n```\n\nI have read on some other post the way to fix this is run `git pull --rebase` but what exactly is rebase, will I lose data or is this simple way to sync with master?\n\n\n\n### answers\n\n------\n\nYou get that message because you made changes in your local master and you didn't push them to remote. You have several ways to \"solve\" it and it normally depends on how your workflow looks like:\n\n- In a good workflow your remote copy of master should be the good one while your local copy of master is just a copy of the one in remote. Using this workflow you'll never get this message again.\n- If you work in another way and your local changes should be pushed then just `git push origin`assuming origin is your remote\n- If your local changes are bad then just remove them or reset your local master to the state on remote **git reset --hard origin/master**\n\n------\n\n### 2. git修改远程仓库地址\n\n方法有三种：\n\n1. 修改命令\n\n   ```\n   git remote set-url origin [url]\n   ```\n\n2. 先删后加\n\n   ```\n   git remote rm origin\n   git remote add origin [url]\n   ```\n\n3. 直接修改config文件\n\n### 3. git放弃修改&放弃增加文件\n\n1. 本地修改了一堆文件(并没有使用git add到暂存区)，想放弃修改。 \n   单个文件/文件夹：\n\n```bash\n$ git checkout -- filename\n```\n\n​\t所有文件/文件夹：\n\n```bash\n$ git checkout .\n```\n\n2. 本地新增了一堆文件(并没有git add到暂存区)，想放弃修改。 \n   单个文件/文件夹：\n\n```bash\n$ rm filename / rm dir -rf\n```\n\n所有文件/文件夹：\n\n```bash\n$ git clean -xdf\n// 删除新增的文件，如果文件已经已经git add到暂存区，并不会删除！\n```\n\n3. 本地修改/新增了一堆文件，已经git add到暂存区，想放弃修改。 \n   单个文件/文件夹：\n\n```bash\n$ git reset HEAD filename\n```\n\n​\t所有文件/文件夹：\n\n```bash\n$ git reset HEAD .\n```\n\n4. 本地通过git add & git commit 之后，想要撤销此次commit\n\n```bash\n$ git reset commit_id\n//这个id是你想要回到的那个节点，可以通过git log查看，可以只选前6位 \n// 撤销之后，你所做的已经commit的修改还在工作区！\n```\n\n```bash\n$ git reset --hard commit_id\n//这个id是你想要回到的那个节点，可以通过git log查看，可以只选前6位 \n// 撤销之后，你所做的已经commit的修改将会清除，仍在工作区/暂存区的代码不会清除！\n```\n\n### 4. 删除分支\n\n首先查看项目的分支（包括本地和远程）\n\n```bash\n$ git branch -a\n```\n\n1. 删除本地分支\n\n```bash\n$ git branch -d <branchname>\n```\n\n2. 删除远程分支\n\n```bash\n$ git push origin --delete <branchname>\n```\n\n\n\n### 5.删除远程文件\n\n> 项目开发初期由于`.gitignore` 文件配置不正确很有可能导致某些不需要的目录上传到 git 远程仓库上了，这样会导致每个开发者提交的时候这些文件每次都会不同。除了一开始提交的时候注意配置好 `.gitignore` 文件外，我们也需要了解下出现这种问题后的解决办法\n\n具体操作步骤如下：\n\n1. 预览将要删除的文件\n\n   ```\n   git rm -r -n --cached 文件/文件夹名称 \n   \n   加上 -n 这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览。\n   ```\n\n2. 确定无误后删除文件\n\n   ```\n   git rm -r --cached 文件/文件夹名称\n   ```\n\n3. 提交到本地并推送到远程服务器\n\n   ```\n   git commit -m \"提交说明\"\n   git push origin master\n   ```\n\n4. 修改本地 .gitignore 文件 并提交\n\n   ```\n     git commit -m \"提交说明\"\n     git push origin master\n   ```\n\n### 6. gitlab或github下fork后如何同步源的新更新内容？\n\n> gitlab或github下，a开发者fork了b开发者的项目后，如果b开发人员更新代码后，a开发者如何获得更新？\n\n具体步骤如下:\n\n1. 给fork配置远程库\n\n```bash\ngir remote -v\n```\n\n查看远程状态\n\n- 确定一个将被同步给 fork 远程的上游仓库\n\n```bash\ngit remote add upstream URL\n```\n\n2. 同步fork\n\n- 从上游仓库 fetch 分支和提交点，提交给本地 master，并会被存储在一个本地分支upstream/master \n\n```bash\ngit fetch upstream\n```\n\n- 切换到本地主分支\n\n```bash\ngit checkout master\n```\n\n- 把 upstream/master 分支合并到本地 master 上，这样就完成了同步，并且不会丢掉本地修的内容\n\n```bash\ngit merge upstream/master\n```\n\n\n\n### 7. 对本地commit进行还原 \n\n```bash\ngit reset --soft HEAD~1\n```\n\n注：reset命令基于最近一次提交，多次执行会回到更早以前，这可能会超出预期。\n\n### 8. 放弃修改，远程覆盖本地代码\n\n与问题1一样，本地超前远程分支，但同时不想要本地的修改，在复习下\n\n在使用Git的过程中，有些时候我们只想要git服务器中的最新版本的项目，对于本地的项目中修改不做任何理会\n\n```bash\ngit fetch --all\ngit reset --hard origin/master\ngit pull\n```\n\n","slug":"Most-useful-git-commands","published":1,"updated":"2022-08-17T07:53:21.232Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6xbhzk4000ozk0888uzrm1f","content":"<blockquote>\n<p>记录在日常使用git时遇到的问题和解决方案</p>\n</blockquote>\n<p>除了最频繁的<code>git pull</code> 、 <code>git push</code> 等操作，在工作和日常使用中，还会遇到各种各样的问题和情景，在这里做一些记录，方便总结、查看</p>\n<h3 id=\"1-Your-branch-is-ahead-of-‘origin-master’-by-3-commits\"><a href=\"#1-Your-branch-is-ahead-of-‘origin-master’-by-3-commits\" class=\"headerlink\" title=\"1. Your branch is ahead of ‘origin/master’ by 3 commits\"></a>1. Your branch is ahead of ‘origin/master’ by 3 commits</h3><p>I am getting the following when running <code>git status</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Your branch is ahead of &apos;origin/master&apos; by 3 commits.</span><br></pre></td></tr></table></figure>\n<p>I have read on some other post the way to fix this is run <code>git pull --rebase</code> but what exactly is rebase, will I lose data or is this simple way to sync with master?</p>\n<h3 id=\"answers\"><a href=\"#answers\" class=\"headerlink\" title=\"answers\"></a>answers</h3><hr>\n<p>You get that message because you made changes in your local master and you didn’t push them to remote. You have several ways to “solve” it and it normally depends on how your workflow looks like:</p>\n<ul>\n<li>In a good workflow your remote copy of master should be the good one while your local copy of master is just a copy of the one in remote. Using this workflow you’ll never get this message again.</li>\n<li>If you work in another way and your local changes should be pushed then just <code>git push origin</code>assuming origin is your remote</li>\n<li>If your local changes are bad then just remove them or reset your local master to the state on remote <strong>git reset –hard origin/master</strong></li>\n</ul>\n<hr>\n<h3 id=\"2-git修改远程仓库地址\"><a href=\"#2-git修改远程仓库地址\" class=\"headerlink\" title=\"2. git修改远程仓库地址\"></a>2. git修改远程仓库地址</h3><p>方法有三种：</p>\n<ol>\n<li><p>修改命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote set-url origin [url]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>先删后加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote rm origin</span><br><span class=\"line\">git remote add origin [url]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>直接修改config文件</p>\n</li>\n</ol>\n<h3 id=\"3-git放弃修改-amp-放弃增加文件\"><a href=\"#3-git放弃修改-amp-放弃增加文件\" class=\"headerlink\" title=\"3. git放弃修改&amp;放弃增加文件\"></a>3. git放弃修改&amp;放弃增加文件</h3><ol>\n<li>本地修改了一堆文件(并没有使用git add到暂存区)，想放弃修改。<br>单个文件/文件夹：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -- filename</span><br></pre></td></tr></table></figure>\n<p>​    所有文件/文件夹：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout .</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>本地新增了一堆文件(并没有git add到暂存区)，想放弃修改。<br>单个文件/文件夹：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rm filename / rm dir -rf</span><br></pre></td></tr></table></figure>\n<p>所有文件/文件夹：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clean -xdf</span><br><span class=\"line\">// 删除新增的文件，如果文件已经已经git add到暂存区，并不会删除！</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>本地修改/新增了一堆文件，已经git add到暂存区，想放弃修改。<br>单个文件/文件夹：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset HEAD filename</span><br></pre></td></tr></table></figure>\n<p>​    所有文件/文件夹：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset HEAD .</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>本地通过git add &amp; git commit 之后，想要撤销此次commit</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset commit_id</span><br><span class=\"line\">//这个id是你想要回到的那个节点，可以通过git <span class=\"built_in\">log</span>查看，可以只选前6位 </span><br><span class=\"line\">// 撤销之后，你所做的已经commit的修改还在工作区！</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset --hard commit_id</span><br><span class=\"line\">//这个id是你想要回到的那个节点，可以通过git <span class=\"built_in\">log</span>查看，可以只选前6位 </span><br><span class=\"line\">// 撤销之后，你所做的已经commit的修改将会清除，仍在工作区/暂存区的代码不会清除！</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-删除分支\"><a href=\"#4-删除分支\" class=\"headerlink\" title=\"4. 删除分支\"></a>4. 删除分支</h3><p>首先查看项目的分支（包括本地和远程）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -a</span><br></pre></td></tr></table></figure>\n<ol>\n<li>删除本地分支</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -d &lt;branchname&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>删除远程分支</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin --delete &lt;branchname&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-删除远程文件\"><a href=\"#5-删除远程文件\" class=\"headerlink\" title=\"5.删除远程文件\"></a>5.删除远程文件</h3><blockquote>\n<p>项目开发初期由于<code>.gitignore</code> 文件配置不正确很有可能导致某些不需要的目录上传到 git 远程仓库上了，这样会导致每个开发者提交的时候这些文件每次都会不同。除了一开始提交的时候注意配置好 <code>.gitignore</code> 文件外，我们也需要了解下出现这种问题后的解决办法</p>\n</blockquote>\n<p>具体操作步骤如下：</p>\n<ol>\n<li><p>预览将要删除的文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm -r -n --cached 文件/文件夹名称 </span><br><span class=\"line\"></span><br><span class=\"line\">加上 -n 这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>确定无误后删除文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm -r --cached 文件/文件夹名称</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>提交到本地并推送到远程服务器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;提交说明&quot;</span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改本地 .gitignore 文件 并提交</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;提交说明&quot;</span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"6-gitlab或github下fork后如何同步源的新更新内容？\"><a href=\"#6-gitlab或github下fork后如何同步源的新更新内容？\" class=\"headerlink\" title=\"6. gitlab或github下fork后如何同步源的新更新内容？\"></a>6. gitlab或github下fork后如何同步源的新更新内容？</h3><blockquote>\n<p>gitlab或github下，a开发者fork了b开发者的项目后，如果b开发人员更新代码后，a开发者如何获得更新？</p>\n</blockquote>\n<p>具体步骤如下:</p>\n<ol>\n<li>给fork配置远程库</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gir remote -v</span><br></pre></td></tr></table></figure>\n<p>查看远程状态</p>\n<ul>\n<li>确定一个将被同步给 fork 远程的上游仓库</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add upstream URL</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>同步fork</li>\n</ol>\n<ul>\n<li>从上游仓库 fetch 分支和提交点，提交给本地 master，并会被存储在一个本地分支upstream/master </li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch upstream</span><br></pre></td></tr></table></figure>\n<ul>\n<li>切换到本地主分支</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master</span><br></pre></td></tr></table></figure>\n<ul>\n<li>把 upstream/master 分支合并到本地 master 上，这样就完成了同步，并且不会丢掉本地修的内容</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge upstream/master</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-对本地commit进行还原\"><a href=\"#7-对本地commit进行还原\" class=\"headerlink\" title=\"7. 对本地commit进行还原\"></a>7. 对本地commit进行还原</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --soft HEAD~1</span><br></pre></td></tr></table></figure>\n<p>注：reset命令基于最近一次提交，多次执行会回到更早以前，这可能会超出预期。</p>\n<h3 id=\"8-放弃修改，远程覆盖本地代码\"><a href=\"#8-放弃修改，远程覆盖本地代码\" class=\"headerlink\" title=\"8. 放弃修改，远程覆盖本地代码\"></a>8. 放弃修改，远程覆盖本地代码</h3><p>与问题1一样，本地超前远程分支，但同时不想要本地的修改，在复习下</p>\n<p>在使用Git的过程中，有些时候我们只想要git服务器中的最新版本的项目，对于本地的项目中修改不做任何理会</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch --all</span><br><span class=\"line\">git reset --hard origin/master</span><br><span class=\"line\">git pull</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>记录在日常使用git时遇到的问题和解决方案</p>\n</blockquote>\n<p>除了最频繁的<code>git pull</code> 、 <code>git push</code> 等操作，在工作和日常使用中，还会遇到各种各样的问题和情景，在这里做一些记录，方便总结、查看</p>\n<h3 id=\"1-Your-branch-is-ahead-of-‘origin-master’-by-3-commits\"><a href=\"#1-Your-branch-is-ahead-of-‘origin-master’-by-3-commits\" class=\"headerlink\" title=\"1. Your branch is ahead of ‘origin/master’ by 3 commits\"></a>1. Your branch is ahead of ‘origin/master’ by 3 commits</h3><p>I am getting the following when running <code>git status</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Your branch is ahead of &apos;origin/master&apos; by 3 commits.</span><br></pre></td></tr></table></figure>\n<p>I have read on some other post the way to fix this is run <code>git pull --rebase</code> but what exactly is rebase, will I lose data or is this simple way to sync with master?</p>\n<h3 id=\"answers\"><a href=\"#answers\" class=\"headerlink\" title=\"answers\"></a>answers</h3><hr>\n<p>You get that message because you made changes in your local master and you didn’t push them to remote. You have several ways to “solve” it and it normally depends on how your workflow looks like:</p>\n<ul>\n<li>In a good workflow your remote copy of master should be the good one while your local copy of master is just a copy of the one in remote. Using this workflow you’ll never get this message again.</li>\n<li>If you work in another way and your local changes should be pushed then just <code>git push origin</code>assuming origin is your remote</li>\n<li>If your local changes are bad then just remove them or reset your local master to the state on remote <strong>git reset –hard origin/master</strong></li>\n</ul>\n<hr>\n<h3 id=\"2-git修改远程仓库地址\"><a href=\"#2-git修改远程仓库地址\" class=\"headerlink\" title=\"2. git修改远程仓库地址\"></a>2. git修改远程仓库地址</h3><p>方法有三种：</p>\n<ol>\n<li><p>修改命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote set-url origin [url]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>先删后加</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote rm origin</span><br><span class=\"line\">git remote add origin [url]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>直接修改config文件</p>\n</li>\n</ol>\n<h3 id=\"3-git放弃修改-amp-放弃增加文件\"><a href=\"#3-git放弃修改-amp-放弃增加文件\" class=\"headerlink\" title=\"3. git放弃修改&amp;放弃增加文件\"></a>3. git放弃修改&amp;放弃增加文件</h3><ol>\n<li>本地修改了一堆文件(并没有使用git add到暂存区)，想放弃修改。<br>单个文件/文件夹：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -- filename</span><br></pre></td></tr></table></figure>\n<p>​    所有文件/文件夹：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout .</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>本地新增了一堆文件(并没有git add到暂存区)，想放弃修改。<br>单个文件/文件夹：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rm filename / rm dir -rf</span><br></pre></td></tr></table></figure>\n<p>所有文件/文件夹：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clean -xdf</span><br><span class=\"line\">// 删除新增的文件，如果文件已经已经git add到暂存区，并不会删除！</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>本地修改/新增了一堆文件，已经git add到暂存区，想放弃修改。<br>单个文件/文件夹：</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset HEAD filename</span><br></pre></td></tr></table></figure>\n<p>​    所有文件/文件夹：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset HEAD .</span><br></pre></td></tr></table></figure>\n<ol start=\"4\">\n<li>本地通过git add &amp; git commit 之后，想要撤销此次commit</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset commit_id</span><br><span class=\"line\">//这个id是你想要回到的那个节点，可以通过git <span class=\"built_in\">log</span>查看，可以只选前6位 </span><br><span class=\"line\">// 撤销之后，你所做的已经commit的修改还在工作区！</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git reset --hard commit_id</span><br><span class=\"line\">//这个id是你想要回到的那个节点，可以通过git <span class=\"built_in\">log</span>查看，可以只选前6位 </span><br><span class=\"line\">// 撤销之后，你所做的已经commit的修改将会清除，仍在工作区/暂存区的代码不会清除！</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-删除分支\"><a href=\"#4-删除分支\" class=\"headerlink\" title=\"4. 删除分支\"></a>4. 删除分支</h3><p>首先查看项目的分支（包括本地和远程）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -a</span><br></pre></td></tr></table></figure>\n<ol>\n<li>删除本地分支</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -d &lt;branchname&gt;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>删除远程分支</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git push origin --delete &lt;branchname&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-删除远程文件\"><a href=\"#5-删除远程文件\" class=\"headerlink\" title=\"5.删除远程文件\"></a>5.删除远程文件</h3><blockquote>\n<p>项目开发初期由于<code>.gitignore</code> 文件配置不正确很有可能导致某些不需要的目录上传到 git 远程仓库上了，这样会导致每个开发者提交的时候这些文件每次都会不同。除了一开始提交的时候注意配置好 <code>.gitignore</code> 文件外，我们也需要了解下出现这种问题后的解决办法</p>\n</blockquote>\n<p>具体操作步骤如下：</p>\n<ol>\n<li><p>预览将要删除的文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm -r -n --cached 文件/文件夹名称 </span><br><span class=\"line\"></span><br><span class=\"line\">加上 -n 这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>确定无误后删除文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm -r --cached 文件/文件夹名称</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>提交到本地并推送到远程服务器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;提交说明&quot;</span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改本地 .gitignore 文件 并提交</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;提交说明&quot;</span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"6-gitlab或github下fork后如何同步源的新更新内容？\"><a href=\"#6-gitlab或github下fork后如何同步源的新更新内容？\" class=\"headerlink\" title=\"6. gitlab或github下fork后如何同步源的新更新内容？\"></a>6. gitlab或github下fork后如何同步源的新更新内容？</h3><blockquote>\n<p>gitlab或github下，a开发者fork了b开发者的项目后，如果b开发人员更新代码后，a开发者如何获得更新？</p>\n</blockquote>\n<p>具体步骤如下:</p>\n<ol>\n<li>给fork配置远程库</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gir remote -v</span><br></pre></td></tr></table></figure>\n<p>查看远程状态</p>\n<ul>\n<li>确定一个将被同步给 fork 远程的上游仓库</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git remote add upstream URL</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>同步fork</li>\n</ol>\n<ul>\n<li>从上游仓库 fetch 分支和提交点，提交给本地 master，并会被存储在一个本地分支upstream/master </li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch upstream</span><br></pre></td></tr></table></figure>\n<ul>\n<li>切换到本地主分支</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout master</span><br></pre></td></tr></table></figure>\n<ul>\n<li>把 upstream/master 分支合并到本地 master 上，这样就完成了同步，并且不会丢掉本地修的内容</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge upstream/master</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-对本地commit进行还原\"><a href=\"#7-对本地commit进行还原\" class=\"headerlink\" title=\"7. 对本地commit进行还原\"></a>7. 对本地commit进行还原</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git reset --soft HEAD~1</span><br></pre></td></tr></table></figure>\n<p>注：reset命令基于最近一次提交，多次执行会回到更早以前，这可能会超出预期。</p>\n<h3 id=\"8-放弃修改，远程覆盖本地代码\"><a href=\"#8-放弃修改，远程覆盖本地代码\" class=\"headerlink\" title=\"8. 放弃修改，远程覆盖本地代码\"></a>8. 放弃修改，远程覆盖本地代码</h3><p>与问题1一样，本地超前远程分支，但同时不想要本地的修改，在复习下</p>\n<p>在使用Git的过程中，有些时候我们只想要git服务器中的最新版本的项目，对于本地的项目中修改不做任何理会</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git fetch --all</span><br><span class=\"line\">git reset --hard origin/master</span><br><span class=\"line\">git pull</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"一篇帮你彻底弄懂NodeJs中的Buffer","subtitle":"Do you want a better understanding of Buffer in Node.js? Check this out.","date":"2018-10-09T04:00:00.000Z","author":"Vinecnt Ko","header-img":"img/article-bg1.jpg","header-mask":0.3,"catalog":true,"_content":"\n\n[原文链接](https://medium.freecodecamp.org/do-you-want-a-better-understanding-of-buffer-in-node-js-check-this-out-2e29de2968e8)\n\n你是不是和我一样，对Node.js中的**Buffer, Stream,** 和 **二进制数据**一直都是很模糊的印象? 或者有的时候觉得，哎，我会用就行了，这些原理、底层的东西，应该交给Node.js的工程师们去理解。\n\n的确，这些名词可能会比较初学者感到恐惧和陌生，特别是那些刚从前端转全栈，做Node.js，却没有计算机基础的同学来说。\n\n但是很遗憾，很多教程或者书籍都会直接跳过这些原理和解释的部分，直接教你怎么使用Node.js的一些库、工具或者API，但是对于核心的部分、为什么这样处理和使用，却只字未提。甚至有些直接告诉你：“你根本不需要理解这些，因为你在工作中可能**永远不会**直接使用它”\n\n是的，如果你想一辈子做一个平庸的程序员，的确可以在工作中不直接使用。\n\n然而，如果那些迷惑和模糊的概念，能引起你的好奇，并不断保持这种好奇心去学习和探索，那么你对Node.js的理解就会更上一层楼，然后你就会更愿意去学习和了解Node.js一些核心的、原理性的东西，比如**Buffer, Stream**。 这也就是我写这篇文章的原因--去帮助你更好的、更深入的去理解Node.js。\n\n当说到**Buffer**，官方是这么说的：\n\n>...JavaScript 语言没有读取或操作二进制数据流的机制。 `Buffer` 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流或文件系统操作等场景中处理二进制数据流。\n\n嗯..尴尬，除非你已经有一些计算机基础，否则上面这句话说了只能让你脑袋更大。我们尝试简化一下，把主要含义提炼一下，可以这么说：\n\n`Buffer`类被引入到Node.js的API中，让其与二进制数据流的操作和交互成为可能\n\n这样是不是简单的多了？ 但是...Buffer，streams和二进制数据又是什么东西呢？我们从后向前，一个一个解释下。\n\n### 二进制数据是什么鬼？\n\n你应该已经知道，计算机存储和表示数据使用二进制的。比如，下面这些是5个二进制数，5个不同的1和0序列：\n\n`10`, `01`, `001`, `1110`, `00101011`\n\n二进制中的每个数字，0或1叫做位(bit)，也就是**Binary digIT**的缩写。\n\n为了能够存储和表示这些数据，计算机需要将数据转换为二进制形式。比如，要存储数字12，计算机需要将12转化为二进制`1100`\n\n计算机怎么知道要如何去转换？这就完全是一个数学问题了。计算机是知道怎么去处理的，有兴趣的可以自己查阅。\n\n但是，我们日常工作的数据类型不仅仅是数字。我们还有字符、图片甚至视频。计算机是知道如何将这些表示为二进制的。就拿字符来说，比如计算机如何用二进制来表示”L“这个字母。为了将数据存储为二进制形式，无论任何类型的数据都会先被转换为数字，然后将数字转为二进制形式。所以为了表示”L“，计算机首先将**L**转换为数字表示，我们看下怎么做到这一点。\n\n打开你的浏览器控制台，然后粘贴下面的代码：`\"L\".charCodeAt(0)`。你看到了什么？数字76？这就是字母**L**的数字编码。但是计算机怎么知道具体哪个数字代表那个字母呢？\n\n#### **字符集**\n\n字符集就是定义数字所代表的字符的一个规则表，同样定义了怎样用二进制存储和表示。那么，用**多少位**来表示一个数字，这个就叫**字符编码(Character Encoding)**\n\n有一种字符编码叫做**UTF-8**。它规定了，字符应该以字节为单位来表示。一个字节是8位(bit)。所以8个1和0组成的序列，应该用二进制来存储和表示任意一个字符。\n\n为了更好的理解，举个例子： 比如之前提到的12的二进制表示是`1100`。 所以，使用UTF-8的格式来表示，应该使用一个字节，也就是8位来完整表示，也即`00001100`， 没有错吧？\n\n因此，76在计算机中的存储形式应该是`01001100`。\n\n这就是计算机将字符存储成二进制的方式。当然，计算机也有一些特殊规则，将图片、视频等存储为二进制的，总之，计算机会将无论图片、视频或其他数据都转换为二进制并存储，这就是我们说的**二进制数据**。\n\n如果你对字符编码非常感兴趣，那你可以[参考一下这篇文章](https://www.w3.org/International/questions/qa-what-is-encoding)\n\n现在我们了解了什么是二进制数据，但是我们介绍buffer的时候，说的**二进制数据流(streams of binary data)**又是什么呢？\n\n### Stream\n\n在Node.js中，流(stream)就是一系列从A点到B点移动的数据。完整点的说，就是当你有一个很大的数据需要传输、搬运时，你不需要等待所有数据都传输完成才开始下一步工作。\n\n实际上，巨型数据会被分割成小块(chunks)进行传输。所以，buffer的原始定义中所说的(“streams of binary data… in the context of… file system”)意思就是说二进制数据在文件系统中的传输。比如，将file1.txt的文字存储到file2.txt中。\n\n但是，buffer到底在流(stream)中，是如何操作二进制数据的？buffer到底是个什么呢？\n\n### Buffer\n\n我们已经知道数据流(stream of data)是从一个地方向另一个地方传输数据的过程，但是这个具体是怎么样的一个过程？\n\n通常情况下，我们传输数据往往是为了处理它，或者读它，或者基于这些数据做处理等。但是，在每次传输过程中，有一个数据量的问题。因此当数据到达的时间比数据理出的时间快的时候，这个时候我们处理数据就需要等待了。\n\n领域覅那个面，如果处理数据的时间比到达的时间快，这一时刻仅仅到达了一小部分数据，那这小部分数据需要等待剩下的数据填满，然后再送过去统一处理。\n\n这个\"等待区域\"就是buffer! 它是你电脑上的一个很小的物理地址，一般在RAM中，在这里数据暂时的存储、等待，最后在流(stream)中，发送过去并处理。\n\n我们可以把整个流(stream)和buffer的配合过程看作公交站。在一些公交站，公车在没有装满乘客前是不会发车的，或者在特定的时刻才会发车。当然，乘客也可能在不同的时间，人流量大小也会有所不同，有人多的时候，有人少的时候，乘客或公交站都无法控制人流量。\n\n不论何时，早到的乘客都必须等待，直到公车接到指令可以发车。当乘客到站，发现公车已经装满，或者已经开走，他就必须等待下一班车次。\n\n总之，这里总会有一个等待的地方，这个等待的区域就是Node.js中的**Buffer** Node.js不能控制数据什么时候传输过来，传输速度，就好像公交车站无法控制人流量一样。他只能决定什么时候发送数据。如果时间还不到，那么Node.js就会把数据放入buffer--\"等待区域\"中，一个在RAM中的地址，直到把他们发送出去进行处理。\n\n一个关于buffer很典型的例子，就是你在线看视频的时候。如果你的网络足够快，数据流(stream)就可以足够快，可以让buffer迅速填满然后发送和处理，然后处理另一个，再发送，再另一个，再发送，然后整个stream完成。\n\n但是当你网络连接很慢，当处理完当前的数据后，你的播放器就会暂停，或出现\"缓冲\"(buffer)字样，意思是正在收集更多的数据，或者等待更多的数据到来，才能下一步处理。当buffer装满并处理好，播放器就会显示数据，也就是播放视频了。在播放当前内容的时候，更多的数据也会源源不断的传输、到达和在buffer等待。\n\n如果播放器已经处理完或播放完前一个数据，buffer仍然没有填满，\"buffering\"(缓冲)字符就会再次出现，等待和收集更多的数据。\n\n这就是**Buffer！**\n\n从原始的定义，我们知道，buffer可以在stream中与二进制数据进行交互和操作。那么到底可以进行什么样的操作呢？在Node.js中又应该如何进行刚才所描述的一些东西呢？我们来瞧一瞧。\n\n#### 与Buffer共舞\n\n你甚至可以做你自己的buffer！ 在stream中，Node.js会自动帮你创建buffer之外，你可以创建自己的buffer并操作它，是不是很有趣？ 我们来搞一个！\n\n根据你的需求，这里有不同的创建方式，我们一起看一下吧：\n\n```javascript\n// 创建一个大小为10的空buffer\n// 这个buffer只能承载10个字节的内容\n\nconst buf1 = Buffer.alloc(10);\n\n// 根据内容直接创建buffer\n\nconst buf2 = Buffer.from(\"hello buffer\");\n```\n\n创建了之后，你就可以操作buffer了\n\n```javascript\n// 检查下buffer的结构\n\nbuf1.toJSON()\n// { type: 'Buffer', data: [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] }\n// 一个空的buffer\n\nbuf2.toJSON()\n// { type: 'Buffer',data: [ 104, 101, 108, 108, 111, 32, 98, 117, 102, 102, 101, 114 ] }\n// the toJSON() 方法可以将数据进行Unicode编码并展示\n   \n// 检查buffer的大小\n\nbuf1.length // 10\n\nbuf2.length //12 根据数据自动盛满并创建\n\n//写入数据到buffer\nbuf1.write(\"Buffer really rocks!\")\n\n//解码buffer\n\nbuf1.toString() // 'Buffer rea'\n\n//哦豁，因为buf1只能承载10个字节的内容，所有多处的东西会被截断\n\n//比较两个buffers\n```\n\n当然，在Node.js中，还有更多更丰富的方法来操作buffer，你可以[参考这里](https://nodejs.org/dist/latest-v8.x/docs/api/buffer.html)，然后去尝试更多的方法。\n\n最后，我想给你一个小小的挑战：去阅读[zlib.js的源码](https://github.com/nodejs/node/blob/master/lib/zlib.js)，一个Node.js的核心库，去看一下它是如何利用buffer这个神器去操作二进制数据流的。处理后，最后变成gziped文件。 当你在阅读的时候，记录下你的学习经历并在评论中分享下来吧。\n\n我希望这个介绍可以帮你更好的理解Node.js中的Buffer。\n\n如果你觉得我这篇文章还不错，为了能让更多人看到，请点个赞吧，可以让这篇文章更好的传播，让更多人看到。\n\n如果你有任何问题，或者有不同的理解，请尽情的评论提出或者通过[twitter](https://twitter.com/Daajust)找我哦。\n\n","source":"_posts/2018-10-09-Better understand Buffer in Node.js.md","raw":"---\nlayout:     post\ntitle:      \"一篇帮你彻底弄懂NodeJs中的Buffer\"\nsubtitle:   \"Do you want a better understanding of Buffer in Node.js? Check this out.\"\ndate:       2018-10-09 12:00:00\nauthor:     \"Vinecnt Ko\"\nheader-img: \"img/article-bg1.jpg\"\nheader-mask: 0.3\ncatalog:    true\ntags:\n    - 前端开发\n    - Node.js\n    - JavaScript\n    - 译文\n---\n\n\n[原文链接](https://medium.freecodecamp.org/do-you-want-a-better-understanding-of-buffer-in-node-js-check-this-out-2e29de2968e8)\n\n你是不是和我一样，对Node.js中的**Buffer, Stream,** 和 **二进制数据**一直都是很模糊的印象? 或者有的时候觉得，哎，我会用就行了，这些原理、底层的东西，应该交给Node.js的工程师们去理解。\n\n的确，这些名词可能会比较初学者感到恐惧和陌生，特别是那些刚从前端转全栈，做Node.js，却没有计算机基础的同学来说。\n\n但是很遗憾，很多教程或者书籍都会直接跳过这些原理和解释的部分，直接教你怎么使用Node.js的一些库、工具或者API，但是对于核心的部分、为什么这样处理和使用，却只字未提。甚至有些直接告诉你：“你根本不需要理解这些，因为你在工作中可能**永远不会**直接使用它”\n\n是的，如果你想一辈子做一个平庸的程序员，的确可以在工作中不直接使用。\n\n然而，如果那些迷惑和模糊的概念，能引起你的好奇，并不断保持这种好奇心去学习和探索，那么你对Node.js的理解就会更上一层楼，然后你就会更愿意去学习和了解Node.js一些核心的、原理性的东西，比如**Buffer, Stream**。 这也就是我写这篇文章的原因--去帮助你更好的、更深入的去理解Node.js。\n\n当说到**Buffer**，官方是这么说的：\n\n>...JavaScript 语言没有读取或操作二进制数据流的机制。 `Buffer` 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流或文件系统操作等场景中处理二进制数据流。\n\n嗯..尴尬，除非你已经有一些计算机基础，否则上面这句话说了只能让你脑袋更大。我们尝试简化一下，把主要含义提炼一下，可以这么说：\n\n`Buffer`类被引入到Node.js的API中，让其与二进制数据流的操作和交互成为可能\n\n这样是不是简单的多了？ 但是...Buffer，streams和二进制数据又是什么东西呢？我们从后向前，一个一个解释下。\n\n### 二进制数据是什么鬼？\n\n你应该已经知道，计算机存储和表示数据使用二进制的。比如，下面这些是5个二进制数，5个不同的1和0序列：\n\n`10`, `01`, `001`, `1110`, `00101011`\n\n二进制中的每个数字，0或1叫做位(bit)，也就是**Binary digIT**的缩写。\n\n为了能够存储和表示这些数据，计算机需要将数据转换为二进制形式。比如，要存储数字12，计算机需要将12转化为二进制`1100`\n\n计算机怎么知道要如何去转换？这就完全是一个数学问题了。计算机是知道怎么去处理的，有兴趣的可以自己查阅。\n\n但是，我们日常工作的数据类型不仅仅是数字。我们还有字符、图片甚至视频。计算机是知道如何将这些表示为二进制的。就拿字符来说，比如计算机如何用二进制来表示”L“这个字母。为了将数据存储为二进制形式，无论任何类型的数据都会先被转换为数字，然后将数字转为二进制形式。所以为了表示”L“，计算机首先将**L**转换为数字表示，我们看下怎么做到这一点。\n\n打开你的浏览器控制台，然后粘贴下面的代码：`\"L\".charCodeAt(0)`。你看到了什么？数字76？这就是字母**L**的数字编码。但是计算机怎么知道具体哪个数字代表那个字母呢？\n\n#### **字符集**\n\n字符集就是定义数字所代表的字符的一个规则表，同样定义了怎样用二进制存储和表示。那么，用**多少位**来表示一个数字，这个就叫**字符编码(Character Encoding)**\n\n有一种字符编码叫做**UTF-8**。它规定了，字符应该以字节为单位来表示。一个字节是8位(bit)。所以8个1和0组成的序列，应该用二进制来存储和表示任意一个字符。\n\n为了更好的理解，举个例子： 比如之前提到的12的二进制表示是`1100`。 所以，使用UTF-8的格式来表示，应该使用一个字节，也就是8位来完整表示，也即`00001100`， 没有错吧？\n\n因此，76在计算机中的存储形式应该是`01001100`。\n\n这就是计算机将字符存储成二进制的方式。当然，计算机也有一些特殊规则，将图片、视频等存储为二进制的，总之，计算机会将无论图片、视频或其他数据都转换为二进制并存储，这就是我们说的**二进制数据**。\n\n如果你对字符编码非常感兴趣，那你可以[参考一下这篇文章](https://www.w3.org/International/questions/qa-what-is-encoding)\n\n现在我们了解了什么是二进制数据，但是我们介绍buffer的时候，说的**二进制数据流(streams of binary data)**又是什么呢？\n\n### Stream\n\n在Node.js中，流(stream)就是一系列从A点到B点移动的数据。完整点的说，就是当你有一个很大的数据需要传输、搬运时，你不需要等待所有数据都传输完成才开始下一步工作。\n\n实际上，巨型数据会被分割成小块(chunks)进行传输。所以，buffer的原始定义中所说的(“streams of binary data… in the context of… file system”)意思就是说二进制数据在文件系统中的传输。比如，将file1.txt的文字存储到file2.txt中。\n\n但是，buffer到底在流(stream)中，是如何操作二进制数据的？buffer到底是个什么呢？\n\n### Buffer\n\n我们已经知道数据流(stream of data)是从一个地方向另一个地方传输数据的过程，但是这个具体是怎么样的一个过程？\n\n通常情况下，我们传输数据往往是为了处理它，或者读它，或者基于这些数据做处理等。但是，在每次传输过程中，有一个数据量的问题。因此当数据到达的时间比数据理出的时间快的时候，这个时候我们处理数据就需要等待了。\n\n领域覅那个面，如果处理数据的时间比到达的时间快，这一时刻仅仅到达了一小部分数据，那这小部分数据需要等待剩下的数据填满，然后再送过去统一处理。\n\n这个\"等待区域\"就是buffer! 它是你电脑上的一个很小的物理地址，一般在RAM中，在这里数据暂时的存储、等待，最后在流(stream)中，发送过去并处理。\n\n我们可以把整个流(stream)和buffer的配合过程看作公交站。在一些公交站，公车在没有装满乘客前是不会发车的，或者在特定的时刻才会发车。当然，乘客也可能在不同的时间，人流量大小也会有所不同，有人多的时候，有人少的时候，乘客或公交站都无法控制人流量。\n\n不论何时，早到的乘客都必须等待，直到公车接到指令可以发车。当乘客到站，发现公车已经装满，或者已经开走，他就必须等待下一班车次。\n\n总之，这里总会有一个等待的地方，这个等待的区域就是Node.js中的**Buffer** Node.js不能控制数据什么时候传输过来，传输速度，就好像公交车站无法控制人流量一样。他只能决定什么时候发送数据。如果时间还不到，那么Node.js就会把数据放入buffer--\"等待区域\"中，一个在RAM中的地址，直到把他们发送出去进行处理。\n\n一个关于buffer很典型的例子，就是你在线看视频的时候。如果你的网络足够快，数据流(stream)就可以足够快，可以让buffer迅速填满然后发送和处理，然后处理另一个，再发送，再另一个，再发送，然后整个stream完成。\n\n但是当你网络连接很慢，当处理完当前的数据后，你的播放器就会暂停，或出现\"缓冲\"(buffer)字样，意思是正在收集更多的数据，或者等待更多的数据到来，才能下一步处理。当buffer装满并处理好，播放器就会显示数据，也就是播放视频了。在播放当前内容的时候，更多的数据也会源源不断的传输、到达和在buffer等待。\n\n如果播放器已经处理完或播放完前一个数据，buffer仍然没有填满，\"buffering\"(缓冲)字符就会再次出现，等待和收集更多的数据。\n\n这就是**Buffer！**\n\n从原始的定义，我们知道，buffer可以在stream中与二进制数据进行交互和操作。那么到底可以进行什么样的操作呢？在Node.js中又应该如何进行刚才所描述的一些东西呢？我们来瞧一瞧。\n\n#### 与Buffer共舞\n\n你甚至可以做你自己的buffer！ 在stream中，Node.js会自动帮你创建buffer之外，你可以创建自己的buffer并操作它，是不是很有趣？ 我们来搞一个！\n\n根据你的需求，这里有不同的创建方式，我们一起看一下吧：\n\n```javascript\n// 创建一个大小为10的空buffer\n// 这个buffer只能承载10个字节的内容\n\nconst buf1 = Buffer.alloc(10);\n\n// 根据内容直接创建buffer\n\nconst buf2 = Buffer.from(\"hello buffer\");\n```\n\n创建了之后，你就可以操作buffer了\n\n```javascript\n// 检查下buffer的结构\n\nbuf1.toJSON()\n// { type: 'Buffer', data: [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] }\n// 一个空的buffer\n\nbuf2.toJSON()\n// { type: 'Buffer',data: [ 104, 101, 108, 108, 111, 32, 98, 117, 102, 102, 101, 114 ] }\n// the toJSON() 方法可以将数据进行Unicode编码并展示\n   \n// 检查buffer的大小\n\nbuf1.length // 10\n\nbuf2.length //12 根据数据自动盛满并创建\n\n//写入数据到buffer\nbuf1.write(\"Buffer really rocks!\")\n\n//解码buffer\n\nbuf1.toString() // 'Buffer rea'\n\n//哦豁，因为buf1只能承载10个字节的内容，所有多处的东西会被截断\n\n//比较两个buffers\n```\n\n当然，在Node.js中，还有更多更丰富的方法来操作buffer，你可以[参考这里](https://nodejs.org/dist/latest-v8.x/docs/api/buffer.html)，然后去尝试更多的方法。\n\n最后，我想给你一个小小的挑战：去阅读[zlib.js的源码](https://github.com/nodejs/node/blob/master/lib/zlib.js)，一个Node.js的核心库，去看一下它是如何利用buffer这个神器去操作二进制数据流的。处理后，最后变成gziped文件。 当你在阅读的时候，记录下你的学习经历并在评论中分享下来吧。\n\n我希望这个介绍可以帮你更好的理解Node.js中的Buffer。\n\n如果你觉得我这篇文章还不错，为了能让更多人看到，请点个赞吧，可以让这篇文章更好的传播，让更多人看到。\n\n如果你有任何问题，或者有不同的理解，请尽情的评论提出或者通过[twitter](https://twitter.com/Daajust)找我哦。\n\n","slug":"2018-10-09-Better-understand-Buffer-in-Node-js","published":1,"updated":"2022-08-17T07:53:21.232Z","comments":1,"photos":[],"link":"","_id":"cl6xbhzk5000rzk08jodb0vr1","content":"<p><a href=\"https://medium.freecodecamp.org/do-you-want-a-better-understanding-of-buffer-in-node-js-check-this-out-2e29de2968e8\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<p>你是不是和我一样，对Node.js中的<strong>Buffer, Stream,</strong> 和 <strong>二进制数据</strong>一直都是很模糊的印象? 或者有的时候觉得，哎，我会用就行了，这些原理、底层的东西，应该交给Node.js的工程师们去理解。</p>\n<p>的确，这些名词可能会比较初学者感到恐惧和陌生，特别是那些刚从前端转全栈，做Node.js，却没有计算机基础的同学来说。</p>\n<p>但是很遗憾，很多教程或者书籍都会直接跳过这些原理和解释的部分，直接教你怎么使用Node.js的一些库、工具或者API，但是对于核心的部分、为什么这样处理和使用，却只字未提。甚至有些直接告诉你：“你根本不需要理解这些，因为你在工作中可能<strong>永远不会</strong>直接使用它”</p>\n<p>是的，如果你想一辈子做一个平庸的程序员，的确可以在工作中不直接使用。</p>\n<p>然而，如果那些迷惑和模糊的概念，能引起你的好奇，并不断保持这种好奇心去学习和探索，那么你对Node.js的理解就会更上一层楼，然后你就会更愿意去学习和了解Node.js一些核心的、原理性的东西，比如<strong>Buffer, Stream</strong>。 这也就是我写这篇文章的原因–去帮助你更好的、更深入的去理解Node.js。</p>\n<p>当说到<strong>Buffer</strong>，官方是这么说的：</p>\n<blockquote>\n<p>…JavaScript 语言没有读取或操作二进制数据流的机制。 <code>Buffer</code> 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流或文件系统操作等场景中处理二进制数据流。</p>\n</blockquote>\n<p>嗯..尴尬，除非你已经有一些计算机基础，否则上面这句话说了只能让你脑袋更大。我们尝试简化一下，把主要含义提炼一下，可以这么说：</p>\n<p><code>Buffer</code>类被引入到Node.js的API中，让其与二进制数据流的操作和交互成为可能</p>\n<p>这样是不是简单的多了？ 但是…Buffer，streams和二进制数据又是什么东西呢？我们从后向前，一个一个解释下。</p>\n<h3 id=\"二进制数据是什么鬼？\"><a href=\"#二进制数据是什么鬼？\" class=\"headerlink\" title=\"二进制数据是什么鬼？\"></a>二进制数据是什么鬼？</h3><p>你应该已经知道，计算机存储和表示数据使用二进制的。比如，下面这些是5个二进制数，5个不同的1和0序列：</p>\n<p><code>10</code>, <code>01</code>, <code>001</code>, <code>1110</code>, <code>00101011</code></p>\n<p>二进制中的每个数字，0或1叫做位(bit)，也就是<strong>Binary digIT</strong>的缩写。</p>\n<p>为了能够存储和表示这些数据，计算机需要将数据转换为二进制形式。比如，要存储数字12，计算机需要将12转化为二进制<code>1100</code></p>\n<p>计算机怎么知道要如何去转换？这就完全是一个数学问题了。计算机是知道怎么去处理的，有兴趣的可以自己查阅。</p>\n<p>但是，我们日常工作的数据类型不仅仅是数字。我们还有字符、图片甚至视频。计算机是知道如何将这些表示为二进制的。就拿字符来说，比如计算机如何用二进制来表示”L“这个字母。为了将数据存储为二进制形式，无论任何类型的数据都会先被转换为数字，然后将数字转为二进制形式。所以为了表示”L“，计算机首先将<strong>L</strong>转换为数字表示，我们看下怎么做到这一点。</p>\n<p>打开你的浏览器控制台，然后粘贴下面的代码：<code>&quot;L&quot;.charCodeAt(0)</code>。你看到了什么？数字76？这就是字母<strong>L</strong>的数字编码。但是计算机怎么知道具体哪个数字代表那个字母呢？</p>\n<h4 id=\"字符集\"><a href=\"#字符集\" class=\"headerlink\" title=\"字符集\"></a><strong>字符集</strong></h4><p>字符集就是定义数字所代表的字符的一个规则表，同样定义了怎样用二进制存储和表示。那么，用<strong>多少位</strong>来表示一个数字，这个就叫<strong>字符编码(Character Encoding)</strong></p>\n<p>有一种字符编码叫做<strong>UTF-8</strong>。它规定了，字符应该以字节为单位来表示。一个字节是8位(bit)。所以8个1和0组成的序列，应该用二进制来存储和表示任意一个字符。</p>\n<p>为了更好的理解，举个例子： 比如之前提到的12的二进制表示是<code>1100</code>。 所以，使用UTF-8的格式来表示，应该使用一个字节，也就是8位来完整表示，也即<code>00001100</code>， 没有错吧？</p>\n<p>因此，76在计算机中的存储形式应该是<code>01001100</code>。</p>\n<p>这就是计算机将字符存储成二进制的方式。当然，计算机也有一些特殊规则，将图片、视频等存储为二进制的，总之，计算机会将无论图片、视频或其他数据都转换为二进制并存储，这就是我们说的<strong>二进制数据</strong>。</p>\n<p>如果你对字符编码非常感兴趣，那你可以<a href=\"https://www.w3.org/International/questions/qa-what-is-encoding\" target=\"_blank\" rel=\"noopener\">参考一下这篇文章</a></p>\n<p>现在我们了解了什么是二进制数据，但是我们介绍buffer的时候，说的<strong>二进制数据流(streams of binary data)</strong>又是什么呢？</p>\n<h3 id=\"Stream\"><a href=\"#Stream\" class=\"headerlink\" title=\"Stream\"></a>Stream</h3><p>在Node.js中，流(stream)就是一系列从A点到B点移动的数据。完整点的说，就是当你有一个很大的数据需要传输、搬运时，你不需要等待所有数据都传输完成才开始下一步工作。</p>\n<p>实际上，巨型数据会被分割成小块(chunks)进行传输。所以，buffer的原始定义中所说的(“streams of binary data… in the context of… file system”)意思就是说二进制数据在文件系统中的传输。比如，将file1.txt的文字存储到file2.txt中。</p>\n<p>但是，buffer到底在流(stream)中，是如何操作二进制数据的？buffer到底是个什么呢？</p>\n<h3 id=\"Buffer\"><a href=\"#Buffer\" class=\"headerlink\" title=\"Buffer\"></a>Buffer</h3><p>我们已经知道数据流(stream of data)是从一个地方向另一个地方传输数据的过程，但是这个具体是怎么样的一个过程？</p>\n<p>通常情况下，我们传输数据往往是为了处理它，或者读它，或者基于这些数据做处理等。但是，在每次传输过程中，有一个数据量的问题。因此当数据到达的时间比数据理出的时间快的时候，这个时候我们处理数据就需要等待了。</p>\n<p>领域覅那个面，如果处理数据的时间比到达的时间快，这一时刻仅仅到达了一小部分数据，那这小部分数据需要等待剩下的数据填满，然后再送过去统一处理。</p>\n<p>这个”等待区域”就是buffer! 它是你电脑上的一个很小的物理地址，一般在RAM中，在这里数据暂时的存储、等待，最后在流(stream)中，发送过去并处理。</p>\n<p>我们可以把整个流(stream)和buffer的配合过程看作公交站。在一些公交站，公车在没有装满乘客前是不会发车的，或者在特定的时刻才会发车。当然，乘客也可能在不同的时间，人流量大小也会有所不同，有人多的时候，有人少的时候，乘客或公交站都无法控制人流量。</p>\n<p>不论何时，早到的乘客都必须等待，直到公车接到指令可以发车。当乘客到站，发现公车已经装满，或者已经开走，他就必须等待下一班车次。</p>\n<p>总之，这里总会有一个等待的地方，这个等待的区域就是Node.js中的<strong>Buffer</strong> Node.js不能控制数据什么时候传输过来，传输速度，就好像公交车站无法控制人流量一样。他只能决定什么时候发送数据。如果时间还不到，那么Node.js就会把数据放入buffer–”等待区域”中，一个在RAM中的地址，直到把他们发送出去进行处理。</p>\n<p>一个关于buffer很典型的例子，就是你在线看视频的时候。如果你的网络足够快，数据流(stream)就可以足够快，可以让buffer迅速填满然后发送和处理，然后处理另一个，再发送，再另一个，再发送，然后整个stream完成。</p>\n<p>但是当你网络连接很慢，当处理完当前的数据后，你的播放器就会暂停，或出现”缓冲”(buffer)字样，意思是正在收集更多的数据，或者等待更多的数据到来，才能下一步处理。当buffer装满并处理好，播放器就会显示数据，也就是播放视频了。在播放当前内容的时候，更多的数据也会源源不断的传输、到达和在buffer等待。</p>\n<p>如果播放器已经处理完或播放完前一个数据，buffer仍然没有填满，”buffering”(缓冲)字符就会再次出现，等待和收集更多的数据。</p>\n<p>这就是<strong>Buffer！</strong></p>\n<p>从原始的定义，我们知道，buffer可以在stream中与二进制数据进行交互和操作。那么到底可以进行什么样的操作呢？在Node.js中又应该如何进行刚才所描述的一些东西呢？我们来瞧一瞧。</p>\n<h4 id=\"与Buffer共舞\"><a href=\"#与Buffer共舞\" class=\"headerlink\" title=\"与Buffer共舞\"></a>与Buffer共舞</h4><p>你甚至可以做你自己的buffer！ 在stream中，Node.js会自动帮你创建buffer之外，你可以创建自己的buffer并操作它，是不是很有趣？ 我们来搞一个！</p>\n<p>根据你的需求，这里有不同的创建方式，我们一起看一下吧：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个大小为10的空buffer</span></span><br><span class=\"line\"><span class=\"comment\">// 这个buffer只能承载10个字节的内容</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> buf1 = Buffer.alloc(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据内容直接创建buffer</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> buf2 = Buffer.from(<span class=\"string\">\"hello buffer\"</span>);</span><br></pre></td></tr></table></figure>\n<p>创建了之后，你就可以操作buffer了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 检查下buffer的结构</span></span><br><span class=\"line\"></span><br><span class=\"line\">buf1.toJSON()</span><br><span class=\"line\"><span class=\"comment\">// &#123; type: 'Buffer', data: [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 一个空的buffer</span></span><br><span class=\"line\"></span><br><span class=\"line\">buf2.toJSON()</span><br><span class=\"line\"><span class=\"comment\">// &#123; type: 'Buffer',data: [ 104, 101, 108, 108, 111, 32, 98, 117, 102, 102, 101, 114 ] &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// the toJSON() 方法可以将数据进行Unicode编码并展示</span></span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"comment\">// 检查buffer的大小</span></span><br><span class=\"line\"></span><br><span class=\"line\">buf1.length <span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\">buf2.length <span class=\"comment\">//12 根据数据自动盛满并创建</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//写入数据到buffer</span></span><br><span class=\"line\">buf1.write(<span class=\"string\">\"Buffer really rocks!\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//解码buffer</span></span><br><span class=\"line\"></span><br><span class=\"line\">buf1.toString() <span class=\"comment\">// 'Buffer rea'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//哦豁，因为buf1只能承载10个字节的内容，所有多处的东西会被截断</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//比较两个buffers</span></span><br></pre></td></tr></table></figure>\n<p>当然，在Node.js中，还有更多更丰富的方法来操作buffer，你可以<a href=\"https://nodejs.org/dist/latest-v8.x/docs/api/buffer.html\" target=\"_blank\" rel=\"noopener\">参考这里</a>，然后去尝试更多的方法。</p>\n<p>最后，我想给你一个小小的挑战：去阅读<a href=\"https://github.com/nodejs/node/blob/master/lib/zlib.js\" target=\"_blank\" rel=\"noopener\">zlib.js的源码</a>，一个Node.js的核心库，去看一下它是如何利用buffer这个神器去操作二进制数据流的。处理后，最后变成gziped文件。 当你在阅读的时候，记录下你的学习经历并在评论中分享下来吧。</p>\n<p>我希望这个介绍可以帮你更好的理解Node.js中的Buffer。</p>\n<p>如果你觉得我这篇文章还不错，为了能让更多人看到，请点个赞吧，可以让这篇文章更好的传播，让更多人看到。</p>\n<p>如果你有任何问题，或者有不同的理解，请尽情的评论提出或者通过<a href=\"https://twitter.com/Daajust\" target=\"_blank\" rel=\"noopener\">twitter</a>找我哦。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://medium.freecodecamp.org/do-you-want-a-better-understanding-of-buffer-in-node-js-check-this-out-2e29de2968e8\" target=\"_blank\" rel=\"noopener\">原文链接</a></p>\n<p>你是不是和我一样，对Node.js中的<strong>Buffer, Stream,</strong> 和 <strong>二进制数据</strong>一直都是很模糊的印象? 或者有的时候觉得，哎，我会用就行了，这些原理、底层的东西，应该交给Node.js的工程师们去理解。</p>\n<p>的确，这些名词可能会比较初学者感到恐惧和陌生，特别是那些刚从前端转全栈，做Node.js，却没有计算机基础的同学来说。</p>\n<p>但是很遗憾，很多教程或者书籍都会直接跳过这些原理和解释的部分，直接教你怎么使用Node.js的一些库、工具或者API，但是对于核心的部分、为什么这样处理和使用，却只字未提。甚至有些直接告诉你：“你根本不需要理解这些，因为你在工作中可能<strong>永远不会</strong>直接使用它”</p>\n<p>是的，如果你想一辈子做一个平庸的程序员，的确可以在工作中不直接使用。</p>\n<p>然而，如果那些迷惑和模糊的概念，能引起你的好奇，并不断保持这种好奇心去学习和探索，那么你对Node.js的理解就会更上一层楼，然后你就会更愿意去学习和了解Node.js一些核心的、原理性的东西，比如<strong>Buffer, Stream</strong>。 这也就是我写这篇文章的原因–去帮助你更好的、更深入的去理解Node.js。</p>\n<p>当说到<strong>Buffer</strong>，官方是这么说的：</p>\n<blockquote>\n<p>…JavaScript 语言没有读取或操作二进制数据流的机制。 <code>Buffer</code> 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流或文件系统操作等场景中处理二进制数据流。</p>\n</blockquote>\n<p>嗯..尴尬，除非你已经有一些计算机基础，否则上面这句话说了只能让你脑袋更大。我们尝试简化一下，把主要含义提炼一下，可以这么说：</p>\n<p><code>Buffer</code>类被引入到Node.js的API中，让其与二进制数据流的操作和交互成为可能</p>\n<p>这样是不是简单的多了？ 但是…Buffer，streams和二进制数据又是什么东西呢？我们从后向前，一个一个解释下。</p>\n<h3 id=\"二进制数据是什么鬼？\"><a href=\"#二进制数据是什么鬼？\" class=\"headerlink\" title=\"二进制数据是什么鬼？\"></a>二进制数据是什么鬼？</h3><p>你应该已经知道，计算机存储和表示数据使用二进制的。比如，下面这些是5个二进制数，5个不同的1和0序列：</p>\n<p><code>10</code>, <code>01</code>, <code>001</code>, <code>1110</code>, <code>00101011</code></p>\n<p>二进制中的每个数字，0或1叫做位(bit)，也就是<strong>Binary digIT</strong>的缩写。</p>\n<p>为了能够存储和表示这些数据，计算机需要将数据转换为二进制形式。比如，要存储数字12，计算机需要将12转化为二进制<code>1100</code></p>\n<p>计算机怎么知道要如何去转换？这就完全是一个数学问题了。计算机是知道怎么去处理的，有兴趣的可以自己查阅。</p>\n<p>但是，我们日常工作的数据类型不仅仅是数字。我们还有字符、图片甚至视频。计算机是知道如何将这些表示为二进制的。就拿字符来说，比如计算机如何用二进制来表示”L“这个字母。为了将数据存储为二进制形式，无论任何类型的数据都会先被转换为数字，然后将数字转为二进制形式。所以为了表示”L“，计算机首先将<strong>L</strong>转换为数字表示，我们看下怎么做到这一点。</p>\n<p>打开你的浏览器控制台，然后粘贴下面的代码：<code>&quot;L&quot;.charCodeAt(0)</code>。你看到了什么？数字76？这就是字母<strong>L</strong>的数字编码。但是计算机怎么知道具体哪个数字代表那个字母呢？</p>\n<h4 id=\"字符集\"><a href=\"#字符集\" class=\"headerlink\" title=\"字符集\"></a><strong>字符集</strong></h4><p>字符集就是定义数字所代表的字符的一个规则表，同样定义了怎样用二进制存储和表示。那么，用<strong>多少位</strong>来表示一个数字，这个就叫<strong>字符编码(Character Encoding)</strong></p>\n<p>有一种字符编码叫做<strong>UTF-8</strong>。它规定了，字符应该以字节为单位来表示。一个字节是8位(bit)。所以8个1和0组成的序列，应该用二进制来存储和表示任意一个字符。</p>\n<p>为了更好的理解，举个例子： 比如之前提到的12的二进制表示是<code>1100</code>。 所以，使用UTF-8的格式来表示，应该使用一个字节，也就是8位来完整表示，也即<code>00001100</code>， 没有错吧？</p>\n<p>因此，76在计算机中的存储形式应该是<code>01001100</code>。</p>\n<p>这就是计算机将字符存储成二进制的方式。当然，计算机也有一些特殊规则，将图片、视频等存储为二进制的，总之，计算机会将无论图片、视频或其他数据都转换为二进制并存储，这就是我们说的<strong>二进制数据</strong>。</p>\n<p>如果你对字符编码非常感兴趣，那你可以<a href=\"https://www.w3.org/International/questions/qa-what-is-encoding\" target=\"_blank\" rel=\"noopener\">参考一下这篇文章</a></p>\n<p>现在我们了解了什么是二进制数据，但是我们介绍buffer的时候，说的<strong>二进制数据流(streams of binary data)</strong>又是什么呢？</p>\n<h3 id=\"Stream\"><a href=\"#Stream\" class=\"headerlink\" title=\"Stream\"></a>Stream</h3><p>在Node.js中，流(stream)就是一系列从A点到B点移动的数据。完整点的说，就是当你有一个很大的数据需要传输、搬运时，你不需要等待所有数据都传输完成才开始下一步工作。</p>\n<p>实际上，巨型数据会被分割成小块(chunks)进行传输。所以，buffer的原始定义中所说的(“streams of binary data… in the context of… file system”)意思就是说二进制数据在文件系统中的传输。比如，将file1.txt的文字存储到file2.txt中。</p>\n<p>但是，buffer到底在流(stream)中，是如何操作二进制数据的？buffer到底是个什么呢？</p>\n<h3 id=\"Buffer\"><a href=\"#Buffer\" class=\"headerlink\" title=\"Buffer\"></a>Buffer</h3><p>我们已经知道数据流(stream of data)是从一个地方向另一个地方传输数据的过程，但是这个具体是怎么样的一个过程？</p>\n<p>通常情况下，我们传输数据往往是为了处理它，或者读它，或者基于这些数据做处理等。但是，在每次传输过程中，有一个数据量的问题。因此当数据到达的时间比数据理出的时间快的时候，这个时候我们处理数据就需要等待了。</p>\n<p>领域覅那个面，如果处理数据的时间比到达的时间快，这一时刻仅仅到达了一小部分数据，那这小部分数据需要等待剩下的数据填满，然后再送过去统一处理。</p>\n<p>这个”等待区域”就是buffer! 它是你电脑上的一个很小的物理地址，一般在RAM中，在这里数据暂时的存储、等待，最后在流(stream)中，发送过去并处理。</p>\n<p>我们可以把整个流(stream)和buffer的配合过程看作公交站。在一些公交站，公车在没有装满乘客前是不会发车的，或者在特定的时刻才会发车。当然，乘客也可能在不同的时间，人流量大小也会有所不同，有人多的时候，有人少的时候，乘客或公交站都无法控制人流量。</p>\n<p>不论何时，早到的乘客都必须等待，直到公车接到指令可以发车。当乘客到站，发现公车已经装满，或者已经开走，他就必须等待下一班车次。</p>\n<p>总之，这里总会有一个等待的地方，这个等待的区域就是Node.js中的<strong>Buffer</strong> Node.js不能控制数据什么时候传输过来，传输速度，就好像公交车站无法控制人流量一样。他只能决定什么时候发送数据。如果时间还不到，那么Node.js就会把数据放入buffer–”等待区域”中，一个在RAM中的地址，直到把他们发送出去进行处理。</p>\n<p>一个关于buffer很典型的例子，就是你在线看视频的时候。如果你的网络足够快，数据流(stream)就可以足够快，可以让buffer迅速填满然后发送和处理，然后处理另一个，再发送，再另一个，再发送，然后整个stream完成。</p>\n<p>但是当你网络连接很慢，当处理完当前的数据后，你的播放器就会暂停，或出现”缓冲”(buffer)字样，意思是正在收集更多的数据，或者等待更多的数据到来，才能下一步处理。当buffer装满并处理好，播放器就会显示数据，也就是播放视频了。在播放当前内容的时候，更多的数据也会源源不断的传输、到达和在buffer等待。</p>\n<p>如果播放器已经处理完或播放完前一个数据，buffer仍然没有填满，”buffering”(缓冲)字符就会再次出现，等待和收集更多的数据。</p>\n<p>这就是<strong>Buffer！</strong></p>\n<p>从原始的定义，我们知道，buffer可以在stream中与二进制数据进行交互和操作。那么到底可以进行什么样的操作呢？在Node.js中又应该如何进行刚才所描述的一些东西呢？我们来瞧一瞧。</p>\n<h4 id=\"与Buffer共舞\"><a href=\"#与Buffer共舞\" class=\"headerlink\" title=\"与Buffer共舞\"></a>与Buffer共舞</h4><p>你甚至可以做你自己的buffer！ 在stream中，Node.js会自动帮你创建buffer之外，你可以创建自己的buffer并操作它，是不是很有趣？ 我们来搞一个！</p>\n<p>根据你的需求，这里有不同的创建方式，我们一起看一下吧：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个大小为10的空buffer</span></span><br><span class=\"line\"><span class=\"comment\">// 这个buffer只能承载10个字节的内容</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> buf1 = Buffer.alloc(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 根据内容直接创建buffer</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> buf2 = Buffer.from(<span class=\"string\">\"hello buffer\"</span>);</span><br></pre></td></tr></table></figure>\n<p>创建了之后，你就可以操作buffer了</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 检查下buffer的结构</span></span><br><span class=\"line\"></span><br><span class=\"line\">buf1.toJSON()</span><br><span class=\"line\"><span class=\"comment\">// &#123; type: 'Buffer', data: [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 一个空的buffer</span></span><br><span class=\"line\"></span><br><span class=\"line\">buf2.toJSON()</span><br><span class=\"line\"><span class=\"comment\">// &#123; type: 'Buffer',data: [ 104, 101, 108, 108, 111, 32, 98, 117, 102, 102, 101, 114 ] &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// the toJSON() 方法可以将数据进行Unicode编码并展示</span></span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"comment\">// 检查buffer的大小</span></span><br><span class=\"line\"></span><br><span class=\"line\">buf1.length <span class=\"comment\">// 10</span></span><br><span class=\"line\"></span><br><span class=\"line\">buf2.length <span class=\"comment\">//12 根据数据自动盛满并创建</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//写入数据到buffer</span></span><br><span class=\"line\">buf1.write(<span class=\"string\">\"Buffer really rocks!\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//解码buffer</span></span><br><span class=\"line\"></span><br><span class=\"line\">buf1.toString() <span class=\"comment\">// 'Buffer rea'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//哦豁，因为buf1只能承载10个字节的内容，所有多处的东西会被截断</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//比较两个buffers</span></span><br></pre></td></tr></table></figure>\n<p>当然，在Node.js中，还有更多更丰富的方法来操作buffer，你可以<a href=\"https://nodejs.org/dist/latest-v8.x/docs/api/buffer.html\" target=\"_blank\" rel=\"noopener\">参考这里</a>，然后去尝试更多的方法。</p>\n<p>最后，我想给你一个小小的挑战：去阅读<a href=\"https://github.com/nodejs/node/blob/master/lib/zlib.js\" target=\"_blank\" rel=\"noopener\">zlib.js的源码</a>，一个Node.js的核心库，去看一下它是如何利用buffer这个神器去操作二进制数据流的。处理后，最后变成gziped文件。 当你在阅读的时候，记录下你的学习经历并在评论中分享下来吧。</p>\n<p>我希望这个介绍可以帮你更好的理解Node.js中的Buffer。</p>\n<p>如果你觉得我这篇文章还不错，为了能让更多人看到，请点个赞吧，可以让这篇文章更好的传播，让更多人看到。</p>\n<p>如果你有任何问题，或者有不同的理解，请尽情的评论提出或者通过<a href=\"https://twitter.com/Daajust\" target=\"_blank\" rel=\"noopener\">twitter</a>找我哦。</p>\n"},{"title":"Juypter Notebook 前端二次开发","date":"2019-12-09T12:15:24.000Z","author":"Vinecnt Ko","_content":"# Jupiter Notebook 前端二次开发与记录\n\n## 一、 环境准备\n\n1. 使用Anaconda进行版本控制、包管理，其管理工具`conda` 与`npm`一样方便的存在\n\n```bash\nbrew cask install Anaconda\n```\n\n2. 安装Node.js与npm\n3. 创建虚拟环境\n\n```bash\nconda create -n envName # envName 是环境名\n```\n\n这里顺便提供环境管理的几个常用命令\n\n- 激活环境\n\n```bash\nactivate envName\n```\n\n- 推出环境\n\n```bash\ndeactivate envName\n```\n\n- 删除环境\n\n```bash\nconda remove -n flowers --all\n```\n\n- 查看所有环境\n\n```bash\nconda info --envs\n```\n\n\n\n## 二、 Jupyter Notebook使用\n\n使用Anaconda安装python后，就已经集成Jupyter nodebook了，如果notebook与conda的环境和包没有关联，可以执行以下命令进行关联\n\n### 1. 安装\n\n```\nconda install nb_conda\n```\n\n### 2.使用\n\n- 可以在Conda类目下对conda环境和包进行一系列操作。\n- 可以在笔记本内的“Kernel”类目里的“Change\n  kernel”切换内核。\n\n详细参考，见:\n\n[1. Jupyter Notebook介绍、安装及使用教程](https://zhuanlan.zhihu.com/p/33105153)\n\n[2. 给初学者的 Jupyter Notebook 教程](https://juejin.im/post/5af8d3776fb9a07ab7744dd0#heading-10)\n\n\n\n## 三、二次开发\n\nJupyter Notebook的[项目地址](https://github.com/jupyter/notebook)\n\n在创建的虚拟环境中，运行一下操作\n\n```bash\ngit clone https://github.com/jupyter/notebook # clone project\ncd notebook\npip install -e . # install packages under the workspace\n```\n\nNotebook后端使用tornado框架，分为多个模块。对应的于templates不同的页面。\n\n### 配置文件\n\n执行`jupyter notebook --generate-config`  \n\n在用户目录生成配置文件，mac中，进入finder， 选择`~/.jupyter/jupyter_notebook_config.py` 进行配置\n常用配置如下：\n\n```bash\n# 解决跨域问题\nc.NotebookApp.tornado_settings = {\n      'headers': {\n            'Content-Security-Policy': \"frame-ancestors self *; report-uri /api/security/csp-report\",\n      }\n}\n# 可访问的IP地址\nc.NotebookApp.ip = '*'\n# 端口\nc.NotebookApp.port = 9123\n# 启动服务端时是否打开浏览器\nc.NotebookApp.open_browser = False\n# 去掉密码验证\nc.NotebookApp.token = \"\"\n# 是否开启新建终端\nc.NotebookApp.terminals_enabled = False\n# 是否可以通过前端修改密码\nc.NotebookApp.allow_password_change = False\n# 前端是否展示退出按钮\nc.NotebookApp.quit_button = False\n# 默认打开的目录路径\nc.NotebookApp.notebook_dir = \"workspace\"\n```\n\n### 前端二次开发\n\n项目采用Tornado的自带系统模版，该模板本身是HTML文件，包含有python的反控制结构和表达式。所以，对于前端页面的二次开发，主要包含两个部分： \n\n- 模板文件及CSS样式的修改\n- 控制模块修改（python和js）\n\n\n\n其中，jupyter的核心，cell及在线编辑的功能是基于`Code Mirror`, 该项目是网页实现的代码编辑器，支持语法高亮、自动缩紧等，因此，对于一些cell相关的二次开发，需要对`Code Mirror` 熟悉。\n\n`Code Mirror` 的简介如下： \n\n[1. 在线代码编辑器CodeMirror](https://zhuanlan.zhihu.com/p/22163474)\n\n[2.官方文档](https://codemirror.net/doc/manual.html#usage)\n\n#### 目录结构\n\n项目按照模块划分，包括`notebook`、`edit`、`nbconvert`等，前端比较关注的是\n\n- `notebook->static->templates` 各页面的模板文件\n- `notebook->static->static` 各页面的样式文件CSS和渲染控制文件JS\n\n项目的其他文件和目录暂不做分析，先从简单的修改开始\n\n#### 本地启动\n\n经过以上配置，进入项目文件夹，执行以下代码: \n\n```bash\njupyter notebook\n```\n\n这里需要注意的是，因为这里关注前端的二次开发，因此可以运行`npm run build:watch`用来监听js的修改和构建。\n\n#### toolbar的修改\n\n工具栏在notebook的主页面中，打开`templates->notebook.html` 查看其模板结构，可以看到其工具栏的模板代码非常简单\n\n```html\n<div id=\"maintoolbar\" class=\"navbar\">\n  <div class=\"toolbar-inner navbar-inner navbar-nobg\">\n    <div id=\"maintoolbar-container\" class=\"container\"></div>\n  </div>\n</div>\n```\n\n即完全是静态页面，也就说，工具栏的按钮和标签是通过脚本动态添加的。\n\n同样在`static`目录下，可以看到名为`maintoolbar.js`，这里定了`maintoolbar`对象，在该对象的原型上绑定了一些方法，比如： \n\n```js\nMainToolBar.prototype._pseudo_actions.add_celltype_list = function () {\n        var that = this;\n        var multiselect = $('<option/>').attr('value','multiselect').attr('disabled','').text('-');\n        var sel = $('<select/>')\n            .attr('id','cell_type')\n            .attr('aria-label', i18n.msg._('combobox, select cell type'))\n            .attr('role', 'combobox')\n            .addClass('form-control select-xs')\n            .append($('<option/>').attr('value','code').text(i18n.msg._('Code')))\n            .append($('<option/>').attr('value','markdown').text(i18n.msg._('Markdown')))\n            .append($('<option/>').attr('value','raw').text(i18n.msg._('Raw NBConvert')))\n            .append($('<option/>').attr('value','heading').text(i18n.msg._('Heading')))\n            .append(multiselect);\n        this.notebook.keyboard_manager.register_events(sel);\n      \n      ...\n```\n\n这里即动态添加工具栏内容的代码，也就可以从这里入手，根据自己的实际需求，修改相应的前端展示内容。\n\n##### 下拉选项修改\n\n![image-20191209171941402](/images/jupyter-toolbar.png)\n\n\n\n比如一个简单需求：修改工具栏下拉的内容，并能通过与父级通讯，实现在下拉切换时，调用外部的方法。\n\n- 修改下拉的内容\n\n直接修改动态加载页面的js文件，去除不需要的下拉内容，这里不过多说明\n\n- 与父组件进行\n\nnotebook在项目中会作为iframe嵌在页面中，可考虑iframe父子通讯的方法。在本系统中，因为页面存在跨域问题，因此无法直接使用`window.parent.fn();` 或者 `window.top.fn()` 。 \n\n这里使用`window.postMessage`方法，实现跨域的通讯，在下拉的change事件中，添加如下代码\n\n```js\n/**\n* 与父级通讯，调用外部方法\n*/\nwindow.top.postMessage({\n  selected: data.cell_type,\n  eventType: 'languageChanged'\n}, '*')\n```\n\n这样，在父级页面，只需要添加监听，即可实现通讯，具体如下:\n\n```js\nwindow.addEventListener('message', event => {\n  if (event.data.eventType === 'languageChanged') {\n    console.log(event.data.selected) // 修改为具体的需要执行的函数即可\n  }\n})\n```\n\n对iframe跨域同学的两种方案: \n\n[1. postMessage方法]([https://gjincai.github.io/2017/05/22/%E5%AD%90%E9%A1%B5%E9%9D%A2iframe%E8%B7%A8%E5%9F%9F%E6%89%A7%E8%A1%8C%E7%88%B6%E9%A1%B5%E9%9D%A2%E5%AE%9A%E4%B9%89%E7%9A%84JS%E6%96%B9%E6%B3%95/](https://gjincai.github.io/2017/05/22/子页面iframe跨域执行父页面定义的JS方法/))\n\n[2. iframe代理方法](https://www.jianshu.com/p/9d90d3333215)\n\n#### notebook功能模块\n\n核心功能模块的目录为\n  - 编辑器相关功能 `/notebook/notebook/static/edit/js`\n  - notebook功能模块 `/notebook/notebook/static/notebook/js`\n\n其中编辑器包含了导航栏、编辑器功能板的动态页面生成以及相关action的调用； \nnotebook的功能模块，则囊括了整个jupyter-notebook的各项基础功能，包括自动保存、自动保存配置、编辑器状态、事件注册等。\n\n##### notebook.js\n\n在notebook目录下，`notebook.js`定义了Notebook的类，可以将其看作项目的容器，将各基础模块和功能集成并接入进来，这里举一个简单的例子。\n\n比如编辑器的自动保存功能，notebook的属性上有\n  - `autosave_interval`\n\n可以配置自动保存的事件间隔，默认为2分钟。\n\n---\n**实例解释**\n\n又比如在iframe嵌套jupyter-notebook中，外层想要获取编辑器状态，避免在为保存状态下刷新。\n\n编辑器的未保存状态刷新，其本身是有保护机制的，在源码中，使用一下子方法做了处理\n```js\nwindow.onbeforeunload = function() {\n  ...\n}\n\n```\n但是，该方法是在外部刷新iframe时才会触发，现在想要外部去调用内部刷新前，就先判断是否可刷新，并给出更友好的提示。\n\n这样开发思路可以为： \n  1. 外部通过`postMessage`查询iframe(notebook)的状态，询问是否可刷新\n  2. 内部监听`message`，并根据编辑状态返回信息\n  3. 外部拿到编辑器状态，决定是否刷新，并提示用户。\n\n这样，问题就简化成了，获取编辑器状态即可，编辑器状态在`Notebook`的`dirty`属性上,当该属性为 `true`时，表示当前编辑器未保存。\n\n因此，在Notebook.js中可以加入以下代码： \n```js\n  //...\n  window.addEventListener('message', event => {\n    if (event.data.eventType === 'getEditStatus') {\n      window.top.postMessage({\n        status: that.dirty,\n        eventType: 'editStatus'\n      }, '*')\n    }\n  })\n\n```\n\n同理，父级也只需要通过`postMessage`实现通讯，即可根据状态信息，完成二次开发，给出更友好的提示。\n\n其他的模块、内容类似，等之后深入研究后，继续补充前端二次开发的踩坑经历。\n\n\n\n## 参考资料\n\n[SQL Interface within JupyterLab](https://www.datacamp.com/community/tutorials/sql-interface-within-jupyterlab)\n\n[Jupyter Notebook Tutorial: The Definitive Guide](https://www.datacamp.com/community/tutorials/tutorial-jupyter-notebook)\n\n[jupyter notebook 中文文档](https://www.osgeo.cn/jupyter/extending/frontend_extensions.html)\n\n[jupyter notebook document](https://jupyter-notebook.readthedocs.io/en/latest/extending/frontend_extensions.html#installing-and-enabling-extensions)\n\n[tornado web 服务器框架](http://www.ttlsa.com/docs/tornado/)\n\n[jupyter notebook 二次开发经验](https://blog.csdn.net/weixin_39198406/article/details/90812334)\n\n\n\n","source":"_posts/Jupyter Notebook 前端二次开发初探.md","raw":"---\ntitle: Juypter Notebook 前端二次开发\ndate: 2019-12-09 20:15:24\nauthor:  \"Vinecnt Ko\"\ntags:\n    - jupyter notebook\n    - 前端\n    - 二次开发\n---\n# Jupiter Notebook 前端二次开发与记录\n\n## 一、 环境准备\n\n1. 使用Anaconda进行版本控制、包管理，其管理工具`conda` 与`npm`一样方便的存在\n\n```bash\nbrew cask install Anaconda\n```\n\n2. 安装Node.js与npm\n3. 创建虚拟环境\n\n```bash\nconda create -n envName # envName 是环境名\n```\n\n这里顺便提供环境管理的几个常用命令\n\n- 激活环境\n\n```bash\nactivate envName\n```\n\n- 推出环境\n\n```bash\ndeactivate envName\n```\n\n- 删除环境\n\n```bash\nconda remove -n flowers --all\n```\n\n- 查看所有环境\n\n```bash\nconda info --envs\n```\n\n\n\n## 二、 Jupyter Notebook使用\n\n使用Anaconda安装python后，就已经集成Jupyter nodebook了，如果notebook与conda的环境和包没有关联，可以执行以下命令进行关联\n\n### 1. 安装\n\n```\nconda install nb_conda\n```\n\n### 2.使用\n\n- 可以在Conda类目下对conda环境和包进行一系列操作。\n- 可以在笔记本内的“Kernel”类目里的“Change\n  kernel”切换内核。\n\n详细参考，见:\n\n[1. Jupyter Notebook介绍、安装及使用教程](https://zhuanlan.zhihu.com/p/33105153)\n\n[2. 给初学者的 Jupyter Notebook 教程](https://juejin.im/post/5af8d3776fb9a07ab7744dd0#heading-10)\n\n\n\n## 三、二次开发\n\nJupyter Notebook的[项目地址](https://github.com/jupyter/notebook)\n\n在创建的虚拟环境中，运行一下操作\n\n```bash\ngit clone https://github.com/jupyter/notebook # clone project\ncd notebook\npip install -e . # install packages under the workspace\n```\n\nNotebook后端使用tornado框架，分为多个模块。对应的于templates不同的页面。\n\n### 配置文件\n\n执行`jupyter notebook --generate-config`  \n\n在用户目录生成配置文件，mac中，进入finder， 选择`~/.jupyter/jupyter_notebook_config.py` 进行配置\n常用配置如下：\n\n```bash\n# 解决跨域问题\nc.NotebookApp.tornado_settings = {\n      'headers': {\n            'Content-Security-Policy': \"frame-ancestors self *; report-uri /api/security/csp-report\",\n      }\n}\n# 可访问的IP地址\nc.NotebookApp.ip = '*'\n# 端口\nc.NotebookApp.port = 9123\n# 启动服务端时是否打开浏览器\nc.NotebookApp.open_browser = False\n# 去掉密码验证\nc.NotebookApp.token = \"\"\n# 是否开启新建终端\nc.NotebookApp.terminals_enabled = False\n# 是否可以通过前端修改密码\nc.NotebookApp.allow_password_change = False\n# 前端是否展示退出按钮\nc.NotebookApp.quit_button = False\n# 默认打开的目录路径\nc.NotebookApp.notebook_dir = \"workspace\"\n```\n\n### 前端二次开发\n\n项目采用Tornado的自带系统模版，该模板本身是HTML文件，包含有python的反控制结构和表达式。所以，对于前端页面的二次开发，主要包含两个部分： \n\n- 模板文件及CSS样式的修改\n- 控制模块修改（python和js）\n\n\n\n其中，jupyter的核心，cell及在线编辑的功能是基于`Code Mirror`, 该项目是网页实现的代码编辑器，支持语法高亮、自动缩紧等，因此，对于一些cell相关的二次开发，需要对`Code Mirror` 熟悉。\n\n`Code Mirror` 的简介如下： \n\n[1. 在线代码编辑器CodeMirror](https://zhuanlan.zhihu.com/p/22163474)\n\n[2.官方文档](https://codemirror.net/doc/manual.html#usage)\n\n#### 目录结构\n\n项目按照模块划分，包括`notebook`、`edit`、`nbconvert`等，前端比较关注的是\n\n- `notebook->static->templates` 各页面的模板文件\n- `notebook->static->static` 各页面的样式文件CSS和渲染控制文件JS\n\n项目的其他文件和目录暂不做分析，先从简单的修改开始\n\n#### 本地启动\n\n经过以上配置，进入项目文件夹，执行以下代码: \n\n```bash\njupyter notebook\n```\n\n这里需要注意的是，因为这里关注前端的二次开发，因此可以运行`npm run build:watch`用来监听js的修改和构建。\n\n#### toolbar的修改\n\n工具栏在notebook的主页面中，打开`templates->notebook.html` 查看其模板结构，可以看到其工具栏的模板代码非常简单\n\n```html\n<div id=\"maintoolbar\" class=\"navbar\">\n  <div class=\"toolbar-inner navbar-inner navbar-nobg\">\n    <div id=\"maintoolbar-container\" class=\"container\"></div>\n  </div>\n</div>\n```\n\n即完全是静态页面，也就说，工具栏的按钮和标签是通过脚本动态添加的。\n\n同样在`static`目录下，可以看到名为`maintoolbar.js`，这里定了`maintoolbar`对象，在该对象的原型上绑定了一些方法，比如： \n\n```js\nMainToolBar.prototype._pseudo_actions.add_celltype_list = function () {\n        var that = this;\n        var multiselect = $('<option/>').attr('value','multiselect').attr('disabled','').text('-');\n        var sel = $('<select/>')\n            .attr('id','cell_type')\n            .attr('aria-label', i18n.msg._('combobox, select cell type'))\n            .attr('role', 'combobox')\n            .addClass('form-control select-xs')\n            .append($('<option/>').attr('value','code').text(i18n.msg._('Code')))\n            .append($('<option/>').attr('value','markdown').text(i18n.msg._('Markdown')))\n            .append($('<option/>').attr('value','raw').text(i18n.msg._('Raw NBConvert')))\n            .append($('<option/>').attr('value','heading').text(i18n.msg._('Heading')))\n            .append(multiselect);\n        this.notebook.keyboard_manager.register_events(sel);\n      \n      ...\n```\n\n这里即动态添加工具栏内容的代码，也就可以从这里入手，根据自己的实际需求，修改相应的前端展示内容。\n\n##### 下拉选项修改\n\n![image-20191209171941402](/images/jupyter-toolbar.png)\n\n\n\n比如一个简单需求：修改工具栏下拉的内容，并能通过与父级通讯，实现在下拉切换时，调用外部的方法。\n\n- 修改下拉的内容\n\n直接修改动态加载页面的js文件，去除不需要的下拉内容，这里不过多说明\n\n- 与父组件进行\n\nnotebook在项目中会作为iframe嵌在页面中，可考虑iframe父子通讯的方法。在本系统中，因为页面存在跨域问题，因此无法直接使用`window.parent.fn();` 或者 `window.top.fn()` 。 \n\n这里使用`window.postMessage`方法，实现跨域的通讯，在下拉的change事件中，添加如下代码\n\n```js\n/**\n* 与父级通讯，调用外部方法\n*/\nwindow.top.postMessage({\n  selected: data.cell_type,\n  eventType: 'languageChanged'\n}, '*')\n```\n\n这样，在父级页面，只需要添加监听，即可实现通讯，具体如下:\n\n```js\nwindow.addEventListener('message', event => {\n  if (event.data.eventType === 'languageChanged') {\n    console.log(event.data.selected) // 修改为具体的需要执行的函数即可\n  }\n})\n```\n\n对iframe跨域同学的两种方案: \n\n[1. postMessage方法]([https://gjincai.github.io/2017/05/22/%E5%AD%90%E9%A1%B5%E9%9D%A2iframe%E8%B7%A8%E5%9F%9F%E6%89%A7%E8%A1%8C%E7%88%B6%E9%A1%B5%E9%9D%A2%E5%AE%9A%E4%B9%89%E7%9A%84JS%E6%96%B9%E6%B3%95/](https://gjincai.github.io/2017/05/22/子页面iframe跨域执行父页面定义的JS方法/))\n\n[2. iframe代理方法](https://www.jianshu.com/p/9d90d3333215)\n\n#### notebook功能模块\n\n核心功能模块的目录为\n  - 编辑器相关功能 `/notebook/notebook/static/edit/js`\n  - notebook功能模块 `/notebook/notebook/static/notebook/js`\n\n其中编辑器包含了导航栏、编辑器功能板的动态页面生成以及相关action的调用； \nnotebook的功能模块，则囊括了整个jupyter-notebook的各项基础功能，包括自动保存、自动保存配置、编辑器状态、事件注册等。\n\n##### notebook.js\n\n在notebook目录下，`notebook.js`定义了Notebook的类，可以将其看作项目的容器，将各基础模块和功能集成并接入进来，这里举一个简单的例子。\n\n比如编辑器的自动保存功能，notebook的属性上有\n  - `autosave_interval`\n\n可以配置自动保存的事件间隔，默认为2分钟。\n\n---\n**实例解释**\n\n又比如在iframe嵌套jupyter-notebook中，外层想要获取编辑器状态，避免在为保存状态下刷新。\n\n编辑器的未保存状态刷新，其本身是有保护机制的，在源码中，使用一下子方法做了处理\n```js\nwindow.onbeforeunload = function() {\n  ...\n}\n\n```\n但是，该方法是在外部刷新iframe时才会触发，现在想要外部去调用内部刷新前，就先判断是否可刷新，并给出更友好的提示。\n\n这样开发思路可以为： \n  1. 外部通过`postMessage`查询iframe(notebook)的状态，询问是否可刷新\n  2. 内部监听`message`，并根据编辑状态返回信息\n  3. 外部拿到编辑器状态，决定是否刷新，并提示用户。\n\n这样，问题就简化成了，获取编辑器状态即可，编辑器状态在`Notebook`的`dirty`属性上,当该属性为 `true`时，表示当前编辑器未保存。\n\n因此，在Notebook.js中可以加入以下代码： \n```js\n  //...\n  window.addEventListener('message', event => {\n    if (event.data.eventType === 'getEditStatus') {\n      window.top.postMessage({\n        status: that.dirty,\n        eventType: 'editStatus'\n      }, '*')\n    }\n  })\n\n```\n\n同理，父级也只需要通过`postMessage`实现通讯，即可根据状态信息，完成二次开发，给出更友好的提示。\n\n其他的模块、内容类似，等之后深入研究后，继续补充前端二次开发的踩坑经历。\n\n\n\n## 参考资料\n\n[SQL Interface within JupyterLab](https://www.datacamp.com/community/tutorials/sql-interface-within-jupyterlab)\n\n[Jupyter Notebook Tutorial: The Definitive Guide](https://www.datacamp.com/community/tutorials/tutorial-jupyter-notebook)\n\n[jupyter notebook 中文文档](https://www.osgeo.cn/jupyter/extending/frontend_extensions.html)\n\n[jupyter notebook document](https://jupyter-notebook.readthedocs.io/en/latest/extending/frontend_extensions.html#installing-and-enabling-extensions)\n\n[tornado web 服务器框架](http://www.ttlsa.com/docs/tornado/)\n\n[jupyter notebook 二次开发经验](https://blog.csdn.net/weixin_39198406/article/details/90812334)\n\n\n\n","slug":"Jupyter-Notebook-前端二次开发初探","published":1,"updated":"2022-08-17T07:53:21.232Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6xbhzk6000tzk085nypm9rd","content":"<h1 id=\"Jupiter-Notebook-前端二次开发与记录\"><a href=\"#Jupiter-Notebook-前端二次开发与记录\" class=\"headerlink\" title=\"Jupiter Notebook 前端二次开发与记录\"></a>Jupiter Notebook 前端二次开发与记录</h1><h2 id=\"一、-环境准备\"><a href=\"#一、-环境准备\" class=\"headerlink\" title=\"一、 环境准备\"></a>一、 环境准备</h2><ol>\n<li>使用Anaconda进行版本控制、包管理，其管理工具<code>conda</code> 与<code>npm</code>一样方便的存在</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew cask install Anaconda</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>安装Node.js与npm</li>\n<li>创建虚拟环境</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda create -n envName <span class=\"comment\"># envName 是环境名</span></span><br></pre></td></tr></table></figure>\n<p>这里顺便提供环境管理的几个常用命令</p>\n<ul>\n<li>激活环境</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">activate envName</span><br></pre></td></tr></table></figure>\n<ul>\n<li>推出环境</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deactivate envName</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除环境</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda remove -n flowers --all</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查看所有环境</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda info --envs</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、-Jupyter-Notebook使用\"><a href=\"#二、-Jupyter-Notebook使用\" class=\"headerlink\" title=\"二、 Jupyter Notebook使用\"></a>二、 Jupyter Notebook使用</h2><p>使用Anaconda安装python后，就已经集成Jupyter nodebook了，如果notebook与conda的环境和包没有关联，可以执行以下命令进行关联</p>\n<h3 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda install nb_conda</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2.使用\"></a>2.使用</h3><ul>\n<li>可以在Conda类目下对conda环境和包进行一系列操作。</li>\n<li>可以在笔记本内的“Kernel”类目里的“Change<br>kernel”切换内核。</li>\n</ul>\n<p>详细参考，见:</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/33105153\" target=\"_blank\" rel=\"noopener\">1. Jupyter Notebook介绍、安装及使用教程</a></p>\n<p><a href=\"https://juejin.im/post/5af8d3776fb9a07ab7744dd0#heading-10\" target=\"_blank\" rel=\"noopener\">2. 给初学者的 Jupyter Notebook 教程</a></p>\n<h2 id=\"三、二次开发\"><a href=\"#三、二次开发\" class=\"headerlink\" title=\"三、二次开发\"></a>三、二次开发</h2><p>Jupyter Notebook的<a href=\"https://github.com/jupyter/notebook\" target=\"_blank\" rel=\"noopener\">项目地址</a></p>\n<p>在创建的虚拟环境中，运行一下操作</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/jupyter/notebook <span class=\"comment\"># clone project</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> notebook</span><br><span class=\"line\">pip install -e . <span class=\"comment\"># install packages under the workspace</span></span><br></pre></td></tr></table></figure>\n<p>Notebook后端使用tornado框架，分为多个模块。对应的于templates不同的页面。</p>\n<h3 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h3><p>执行<code>jupyter notebook --generate-config</code>  </p>\n<p>在用户目录生成配置文件，mac中，进入finder， 选择<code>~/.jupyter/jupyter_notebook_config.py</code> 进行配置<br>常用配置如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 解决跨域问题</span></span><br><span class=\"line\">c.NotebookApp.tornado_settings = &#123;</span><br><span class=\"line\">      <span class=\"string\">'headers'</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">'Content-Security-Policy'</span>: <span class=\"string\">\"frame-ancestors self *; report-uri /api/security/csp-report\"</span>,</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\"># 可访问的IP地址</span></span><br><span class=\"line\">c.NotebookApp.ip = <span class=\"string\">'*'</span></span><br><span class=\"line\"><span class=\"comment\"># 端口</span></span><br><span class=\"line\">c.NotebookApp.port = 9123</span><br><span class=\"line\"><span class=\"comment\"># 启动服务端时是否打开浏览器</span></span><br><span class=\"line\">c.NotebookApp.open_browser = False</span><br><span class=\"line\"><span class=\"comment\"># 去掉密码验证</span></span><br><span class=\"line\">c.NotebookApp.token = <span class=\"string\">\"\"</span></span><br><span class=\"line\"><span class=\"comment\"># 是否开启新建终端</span></span><br><span class=\"line\">c.NotebookApp.terminals_enabled = False</span><br><span class=\"line\"><span class=\"comment\"># 是否可以通过前端修改密码</span></span><br><span class=\"line\">c.NotebookApp.allow_password_change = False</span><br><span class=\"line\"><span class=\"comment\"># 前端是否展示退出按钮</span></span><br><span class=\"line\">c.NotebookApp.quit_button = False</span><br><span class=\"line\"><span class=\"comment\"># 默认打开的目录路径</span></span><br><span class=\"line\">c.NotebookApp.notebook_dir = <span class=\"string\">\"workspace\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"前端二次开发\"><a href=\"#前端二次开发\" class=\"headerlink\" title=\"前端二次开发\"></a>前端二次开发</h3><p>项目采用Tornado的自带系统模版，该模板本身是HTML文件，包含有python的反控制结构和表达式。所以，对于前端页面的二次开发，主要包含两个部分： </p>\n<ul>\n<li>模板文件及CSS样式的修改</li>\n<li>控制模块修改（python和js）</li>\n</ul>\n<p>其中，jupyter的核心，cell及在线编辑的功能是基于<code>Code Mirror</code>, 该项目是网页实现的代码编辑器，支持语法高亮、自动缩紧等，因此，对于一些cell相关的二次开发，需要对<code>Code Mirror</code> 熟悉。</p>\n<p><code>Code Mirror</code> 的简介如下： </p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/22163474\" target=\"_blank\" rel=\"noopener\">1. 在线代码编辑器CodeMirror</a></p>\n<p><a href=\"https://codemirror.net/doc/manual.html#usage\" target=\"_blank\" rel=\"noopener\">2.官方文档</a></p>\n<h4 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h4><p>项目按照模块划分，包括<code>notebook</code>、<code>edit</code>、<code>nbconvert</code>等，前端比较关注的是</p>\n<ul>\n<li><code>notebook-&gt;static-&gt;templates</code> 各页面的模板文件</li>\n<li><code>notebook-&gt;static-&gt;static</code> 各页面的样式文件CSS和渲染控制文件JS</li>\n</ul>\n<p>项目的其他文件和目录暂不做分析，先从简单的修改开始</p>\n<h4 id=\"本地启动\"><a href=\"#本地启动\" class=\"headerlink\" title=\"本地启动\"></a>本地启动</h4><p>经过以上配置，进入项目文件夹，执行以下代码: </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jupyter notebook</span><br></pre></td></tr></table></figure>\n<p>这里需要注意的是，因为这里关注前端的二次开发，因此可以运行<code>npm run build:watch</code>用来监听js的修改和构建。</p>\n<h4 id=\"toolbar的修改\"><a href=\"#toolbar的修改\" class=\"headerlink\" title=\"toolbar的修改\"></a>toolbar的修改</h4><p>工具栏在notebook的主页面中，打开<code>templates-&gt;notebook.html</code> 查看其模板结构，可以看到其工具栏的模板代码非常简单</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"maintoolbar\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"navbar\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"toolbar-inner navbar-inner navbar-nobg\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"maintoolbar-container\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>即完全是静态页面，也就说，工具栏的按钮和标签是通过脚本动态添加的。</p>\n<p>同样在<code>static</code>目录下，可以看到名为<code>maintoolbar.js</code>，这里定了<code>maintoolbar</code>对象，在该对象的原型上绑定了一些方法，比如： </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MainToolBar.prototype._pseudo_actions.add_celltype_list = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> multiselect = $(<span class=\"string\">'&lt;option/&gt;'</span>).attr(<span class=\"string\">'value'</span>,<span class=\"string\">'multiselect'</span>).attr(<span class=\"string\">'disabled'</span>,<span class=\"string\">''</span>).text(<span class=\"string\">'-'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> sel = $(<span class=\"string\">'&lt;select/&gt;'</span>)</span><br><span class=\"line\">            .attr(<span class=\"string\">'id'</span>,<span class=\"string\">'cell_type'</span>)</span><br><span class=\"line\">            .attr(<span class=\"string\">'aria-label'</span>, i18n.msg._(<span class=\"string\">'combobox, select cell type'</span>))</span><br><span class=\"line\">            .attr(<span class=\"string\">'role'</span>, <span class=\"string\">'combobox'</span>)</span><br><span class=\"line\">            .addClass(<span class=\"string\">'form-control select-xs'</span>)</span><br><span class=\"line\">            .append($(<span class=\"string\">'&lt;option/&gt;'</span>).attr(<span class=\"string\">'value'</span>,<span class=\"string\">'code'</span>).text(i18n.msg._(<span class=\"string\">'Code'</span>)))</span><br><span class=\"line\">            .append($(<span class=\"string\">'&lt;option/&gt;'</span>).attr(<span class=\"string\">'value'</span>,<span class=\"string\">'markdown'</span>).text(i18n.msg._(<span class=\"string\">'Markdown'</span>)))</span><br><span class=\"line\">            .append($(<span class=\"string\">'&lt;option/&gt;'</span>).attr(<span class=\"string\">'value'</span>,<span class=\"string\">'raw'</span>).text(i18n.msg._(<span class=\"string\">'Raw NBConvert'</span>)))</span><br><span class=\"line\">            .append($(<span class=\"string\">'&lt;option/&gt;'</span>).attr(<span class=\"string\">'value'</span>,<span class=\"string\">'heading'</span>).text(i18n.msg._(<span class=\"string\">'Heading'</span>)))</span><br><span class=\"line\">            .append(multiselect);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.notebook.keyboard_manager.register_events(sel);</span><br><span class=\"line\">      </span><br><span class=\"line\">      ...</span><br></pre></td></tr></table></figure>\n<p>这里即动态添加工具栏内容的代码，也就可以从这里入手，根据自己的实际需求，修改相应的前端展示内容。</p>\n<h5 id=\"下拉选项修改\"><a href=\"#下拉选项修改\" class=\"headerlink\" title=\"下拉选项修改\"></a>下拉选项修改</h5><p><img src=\"/images/jupyter-toolbar.png\" alt=\"image-20191209171941402\"></p>\n<p>比如一个简单需求：修改工具栏下拉的内容，并能通过与父级通讯，实现在下拉切换时，调用外部的方法。</p>\n<ul>\n<li>修改下拉的内容</li>\n</ul>\n<p>直接修改动态加载页面的js文件，去除不需要的下拉内容，这里不过多说明</p>\n<ul>\n<li>与父组件进行</li>\n</ul>\n<p>notebook在项目中会作为iframe嵌在页面中，可考虑iframe父子通讯的方法。在本系统中，因为页面存在跨域问题，因此无法直接使用<code>window.parent.fn();</code> 或者 <code>window.top.fn()</code> 。 </p>\n<p>这里使用<code>window.postMessage</code>方法，实现跨域的通讯，在下拉的change事件中，添加如下代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 与父级通讯，调用外部方法</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.top.postMessage(&#123;</span><br><span class=\"line\">  selected: data.cell_type,</span><br><span class=\"line\">  eventType: <span class=\"string\">'languageChanged'</span></span><br><span class=\"line\">&#125;, <span class=\"string\">'*'</span>)</span><br></pre></td></tr></table></figure>\n<p>这样，在父级页面，只需要添加监听，即可实现通讯，具体如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'message'</span>, event =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (event.data.eventType === <span class=\"string\">'languageChanged'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(event.data.selected) <span class=\"comment\">// 修改为具体的需要执行的函数即可</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>对iframe跨域同学的两种方案: </p>\n<p><a href=\"[https://gjincai.github.io/2017/05/22/%E5%AD%90%E9%A1%B5%E9%9D%A2iframe%E8%B7%A8%E5%9F%9F%E6%89%A7%E8%A1%8C%E7%88%B6%E9%A1%B5%E9%9D%A2%E5%AE%9A%E4%B9%89%E7%9A%84JS%E6%96%B9%E6%B3%95/](https://gjincai.github.io/2017/05/22/子页面iframe跨域执行父页面定义的JS方法/\">1. postMessage方法</a>)</p>\n<p><a href=\"https://www.jianshu.com/p/9d90d3333215\" target=\"_blank\" rel=\"noopener\">2. iframe代理方法</a></p>\n<h4 id=\"notebook功能模块\"><a href=\"#notebook功能模块\" class=\"headerlink\" title=\"notebook功能模块\"></a>notebook功能模块</h4><p>核心功能模块的目录为</p>\n<ul>\n<li>编辑器相关功能 <code>/notebook/notebook/static/edit/js</code></li>\n<li>notebook功能模块 <code>/notebook/notebook/static/notebook/js</code></li>\n</ul>\n<p>其中编辑器包含了导航栏、编辑器功能板的动态页面生成以及相关action的调用；<br>notebook的功能模块，则囊括了整个jupyter-notebook的各项基础功能，包括自动保存、自动保存配置、编辑器状态、事件注册等。</p>\n<h5 id=\"notebook-js\"><a href=\"#notebook-js\" class=\"headerlink\" title=\"notebook.js\"></a>notebook.js</h5><p>在notebook目录下，<code>notebook.js</code>定义了Notebook的类，可以将其看作项目的容器，将各基础模块和功能集成并接入进来，这里举一个简单的例子。</p>\n<p>比如编辑器的自动保存功能，notebook的属性上有</p>\n<ul>\n<li><code>autosave_interval</code></li>\n</ul>\n<p>可以配置自动保存的事件间隔，默认为2分钟。</p>\n<hr>\n<p><strong>实例解释</strong></p>\n<p>又比如在iframe嵌套jupyter-notebook中，外层想要获取编辑器状态，避免在为保存状态下刷新。</p>\n<p>编辑器的未保存状态刷新，其本身是有保护机制的，在源码中，使用一下子方法做了处理<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onbeforeunload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但是，该方法是在外部刷新iframe时才会触发，现在想要外部去调用内部刷新前，就先判断是否可刷新，并给出更友好的提示。</p>\n<p>这样开发思路可以为： </p>\n<ol>\n<li>外部通过<code>postMessage</code>查询iframe(notebook)的状态，询问是否可刷新</li>\n<li>内部监听<code>message</code>，并根据编辑状态返回信息</li>\n<li>外部拿到编辑器状态，决定是否刷新，并提示用户。</li>\n</ol>\n<p>这样，问题就简化成了，获取编辑器状态即可，编辑器状态在<code>Notebook</code>的<code>dirty</code>属性上,当该属性为 <code>true</code>时，表示当前编辑器未保存。</p>\n<p>因此，在Notebook.js中可以加入以下代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'message'</span>, event =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (event.data.eventType === <span class=\"string\">'getEditStatus'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.top.postMessage(&#123;</span><br><span class=\"line\">      status: that.dirty,</span><br><span class=\"line\">      eventType: <span class=\"string\">'editStatus'</span></span><br><span class=\"line\">    &#125;, <span class=\"string\">'*'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>同理，父级也只需要通过<code>postMessage</code>实现通讯，即可根据状态信息，完成二次开发，给出更友好的提示。</p>\n<p>其他的模块、内容类似，等之后深入研究后，继续补充前端二次开发的踩坑经历。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://www.datacamp.com/community/tutorials/sql-interface-within-jupyterlab\" target=\"_blank\" rel=\"noopener\">SQL Interface within JupyterLab</a></p>\n<p><a href=\"https://www.datacamp.com/community/tutorials/tutorial-jupyter-notebook\" target=\"_blank\" rel=\"noopener\">Jupyter Notebook Tutorial: The Definitive Guide</a></p>\n<p><a href=\"https://www.osgeo.cn/jupyter/extending/frontend_extensions.html\" target=\"_blank\" rel=\"noopener\">jupyter notebook 中文文档</a></p>\n<p><a href=\"https://jupyter-notebook.readthedocs.io/en/latest/extending/frontend_extensions.html#installing-and-enabling-extensions\" target=\"_blank\" rel=\"noopener\">jupyter notebook document</a></p>\n<p><a href=\"http://www.ttlsa.com/docs/tornado/\" target=\"_blank\" rel=\"noopener\">tornado web 服务器框架</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_39198406/article/details/90812334\" target=\"_blank\" rel=\"noopener\">jupyter notebook 二次开发经验</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Jupiter-Notebook-前端二次开发与记录\"><a href=\"#Jupiter-Notebook-前端二次开发与记录\" class=\"headerlink\" title=\"Jupiter Notebook 前端二次开发与记录\"></a>Jupiter Notebook 前端二次开发与记录</h1><h2 id=\"一、-环境准备\"><a href=\"#一、-环境准备\" class=\"headerlink\" title=\"一、 环境准备\"></a>一、 环境准备</h2><ol>\n<li>使用Anaconda进行版本控制、包管理，其管理工具<code>conda</code> 与<code>npm</code>一样方便的存在</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew cask install Anaconda</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>安装Node.js与npm</li>\n<li>创建虚拟环境</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda create -n envName <span class=\"comment\"># envName 是环境名</span></span><br></pre></td></tr></table></figure>\n<p>这里顺便提供环境管理的几个常用命令</p>\n<ul>\n<li>激活环境</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">activate envName</span><br></pre></td></tr></table></figure>\n<ul>\n<li>推出环境</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deactivate envName</span><br></pre></td></tr></table></figure>\n<ul>\n<li>删除环境</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda remove -n flowers --all</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查看所有环境</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda info --envs</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、-Jupyter-Notebook使用\"><a href=\"#二、-Jupyter-Notebook使用\" class=\"headerlink\" title=\"二、 Jupyter Notebook使用\"></a>二、 Jupyter Notebook使用</h2><p>使用Anaconda安装python后，就已经集成Jupyter nodebook了，如果notebook与conda的环境和包没有关联，可以执行以下命令进行关联</p>\n<h3 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda install nb_conda</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-使用\"><a href=\"#2-使用\" class=\"headerlink\" title=\"2.使用\"></a>2.使用</h3><ul>\n<li>可以在Conda类目下对conda环境和包进行一系列操作。</li>\n<li>可以在笔记本内的“Kernel”类目里的“Change<br>kernel”切换内核。</li>\n</ul>\n<p>详细参考，见:</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/33105153\" target=\"_blank\" rel=\"noopener\">1. Jupyter Notebook介绍、安装及使用教程</a></p>\n<p><a href=\"https://juejin.im/post/5af8d3776fb9a07ab7744dd0#heading-10\" target=\"_blank\" rel=\"noopener\">2. 给初学者的 Jupyter Notebook 教程</a></p>\n<h2 id=\"三、二次开发\"><a href=\"#三、二次开发\" class=\"headerlink\" title=\"三、二次开发\"></a>三、二次开发</h2><p>Jupyter Notebook的<a href=\"https://github.com/jupyter/notebook\" target=\"_blank\" rel=\"noopener\">项目地址</a></p>\n<p>在创建的虚拟环境中，运行一下操作</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/jupyter/notebook <span class=\"comment\"># clone project</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> notebook</span><br><span class=\"line\">pip install -e . <span class=\"comment\"># install packages under the workspace</span></span><br></pre></td></tr></table></figure>\n<p>Notebook后端使用tornado框架，分为多个模块。对应的于templates不同的页面。</p>\n<h3 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h3><p>执行<code>jupyter notebook --generate-config</code>  </p>\n<p>在用户目录生成配置文件，mac中，进入finder， 选择<code>~/.jupyter/jupyter_notebook_config.py</code> 进行配置<br>常用配置如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 解决跨域问题</span></span><br><span class=\"line\">c.NotebookApp.tornado_settings = &#123;</span><br><span class=\"line\">      <span class=\"string\">'headers'</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">'Content-Security-Policy'</span>: <span class=\"string\">\"frame-ancestors self *; report-uri /api/security/csp-report\"</span>,</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\"># 可访问的IP地址</span></span><br><span class=\"line\">c.NotebookApp.ip = <span class=\"string\">'*'</span></span><br><span class=\"line\"><span class=\"comment\"># 端口</span></span><br><span class=\"line\">c.NotebookApp.port = 9123</span><br><span class=\"line\"><span class=\"comment\"># 启动服务端时是否打开浏览器</span></span><br><span class=\"line\">c.NotebookApp.open_browser = False</span><br><span class=\"line\"><span class=\"comment\"># 去掉密码验证</span></span><br><span class=\"line\">c.NotebookApp.token = <span class=\"string\">\"\"</span></span><br><span class=\"line\"><span class=\"comment\"># 是否开启新建终端</span></span><br><span class=\"line\">c.NotebookApp.terminals_enabled = False</span><br><span class=\"line\"><span class=\"comment\"># 是否可以通过前端修改密码</span></span><br><span class=\"line\">c.NotebookApp.allow_password_change = False</span><br><span class=\"line\"><span class=\"comment\"># 前端是否展示退出按钮</span></span><br><span class=\"line\">c.NotebookApp.quit_button = False</span><br><span class=\"line\"><span class=\"comment\"># 默认打开的目录路径</span></span><br><span class=\"line\">c.NotebookApp.notebook_dir = <span class=\"string\">\"workspace\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"前端二次开发\"><a href=\"#前端二次开发\" class=\"headerlink\" title=\"前端二次开发\"></a>前端二次开发</h3><p>项目采用Tornado的自带系统模版，该模板本身是HTML文件，包含有python的反控制结构和表达式。所以，对于前端页面的二次开发，主要包含两个部分： </p>\n<ul>\n<li>模板文件及CSS样式的修改</li>\n<li>控制模块修改（python和js）</li>\n</ul>\n<p>其中，jupyter的核心，cell及在线编辑的功能是基于<code>Code Mirror</code>, 该项目是网页实现的代码编辑器，支持语法高亮、自动缩紧等，因此，对于一些cell相关的二次开发，需要对<code>Code Mirror</code> 熟悉。</p>\n<p><code>Code Mirror</code> 的简介如下： </p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/22163474\" target=\"_blank\" rel=\"noopener\">1. 在线代码编辑器CodeMirror</a></p>\n<p><a href=\"https://codemirror.net/doc/manual.html#usage\" target=\"_blank\" rel=\"noopener\">2.官方文档</a></p>\n<h4 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h4><p>项目按照模块划分，包括<code>notebook</code>、<code>edit</code>、<code>nbconvert</code>等，前端比较关注的是</p>\n<ul>\n<li><code>notebook-&gt;static-&gt;templates</code> 各页面的模板文件</li>\n<li><code>notebook-&gt;static-&gt;static</code> 各页面的样式文件CSS和渲染控制文件JS</li>\n</ul>\n<p>项目的其他文件和目录暂不做分析，先从简单的修改开始</p>\n<h4 id=\"本地启动\"><a href=\"#本地启动\" class=\"headerlink\" title=\"本地启动\"></a>本地启动</h4><p>经过以上配置，进入项目文件夹，执行以下代码: </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jupyter notebook</span><br></pre></td></tr></table></figure>\n<p>这里需要注意的是，因为这里关注前端的二次开发，因此可以运行<code>npm run build:watch</code>用来监听js的修改和构建。</p>\n<h4 id=\"toolbar的修改\"><a href=\"#toolbar的修改\" class=\"headerlink\" title=\"toolbar的修改\"></a>toolbar的修改</h4><p>工具栏在notebook的主页面中，打开<code>templates-&gt;notebook.html</code> 查看其模板结构，可以看到其工具栏的模板代码非常简单</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"maintoolbar\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"navbar\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"toolbar-inner navbar-inner navbar-nobg\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"maintoolbar-container\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>即完全是静态页面，也就说，工具栏的按钮和标签是通过脚本动态添加的。</p>\n<p>同样在<code>static</code>目录下，可以看到名为<code>maintoolbar.js</code>，这里定了<code>maintoolbar</code>对象，在该对象的原型上绑定了一些方法，比如： </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MainToolBar.prototype._pseudo_actions.add_celltype_list = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> multiselect = $(<span class=\"string\">'&lt;option/&gt;'</span>).attr(<span class=\"string\">'value'</span>,<span class=\"string\">'multiselect'</span>).attr(<span class=\"string\">'disabled'</span>,<span class=\"string\">''</span>).text(<span class=\"string\">'-'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> sel = $(<span class=\"string\">'&lt;select/&gt;'</span>)</span><br><span class=\"line\">            .attr(<span class=\"string\">'id'</span>,<span class=\"string\">'cell_type'</span>)</span><br><span class=\"line\">            .attr(<span class=\"string\">'aria-label'</span>, i18n.msg._(<span class=\"string\">'combobox, select cell type'</span>))</span><br><span class=\"line\">            .attr(<span class=\"string\">'role'</span>, <span class=\"string\">'combobox'</span>)</span><br><span class=\"line\">            .addClass(<span class=\"string\">'form-control select-xs'</span>)</span><br><span class=\"line\">            .append($(<span class=\"string\">'&lt;option/&gt;'</span>).attr(<span class=\"string\">'value'</span>,<span class=\"string\">'code'</span>).text(i18n.msg._(<span class=\"string\">'Code'</span>)))</span><br><span class=\"line\">            .append($(<span class=\"string\">'&lt;option/&gt;'</span>).attr(<span class=\"string\">'value'</span>,<span class=\"string\">'markdown'</span>).text(i18n.msg._(<span class=\"string\">'Markdown'</span>)))</span><br><span class=\"line\">            .append($(<span class=\"string\">'&lt;option/&gt;'</span>).attr(<span class=\"string\">'value'</span>,<span class=\"string\">'raw'</span>).text(i18n.msg._(<span class=\"string\">'Raw NBConvert'</span>)))</span><br><span class=\"line\">            .append($(<span class=\"string\">'&lt;option/&gt;'</span>).attr(<span class=\"string\">'value'</span>,<span class=\"string\">'heading'</span>).text(i18n.msg._(<span class=\"string\">'Heading'</span>)))</span><br><span class=\"line\">            .append(multiselect);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.notebook.keyboard_manager.register_events(sel);</span><br><span class=\"line\">      </span><br><span class=\"line\">      ...</span><br></pre></td></tr></table></figure>\n<p>这里即动态添加工具栏内容的代码，也就可以从这里入手，根据自己的实际需求，修改相应的前端展示内容。</p>\n<h5 id=\"下拉选项修改\"><a href=\"#下拉选项修改\" class=\"headerlink\" title=\"下拉选项修改\"></a>下拉选项修改</h5><p><img src=\"/images/jupyter-toolbar.png\" alt=\"image-20191209171941402\"></p>\n<p>比如一个简单需求：修改工具栏下拉的内容，并能通过与父级通讯，实现在下拉切换时，调用外部的方法。</p>\n<ul>\n<li>修改下拉的内容</li>\n</ul>\n<p>直接修改动态加载页面的js文件，去除不需要的下拉内容，这里不过多说明</p>\n<ul>\n<li>与父组件进行</li>\n</ul>\n<p>notebook在项目中会作为iframe嵌在页面中，可考虑iframe父子通讯的方法。在本系统中，因为页面存在跨域问题，因此无法直接使用<code>window.parent.fn();</code> 或者 <code>window.top.fn()</code> 。 </p>\n<p>这里使用<code>window.postMessage</code>方法，实现跨域的通讯，在下拉的change事件中，添加如下代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 与父级通讯，调用外部方法</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.top.postMessage(&#123;</span><br><span class=\"line\">  selected: data.cell_type,</span><br><span class=\"line\">  eventType: <span class=\"string\">'languageChanged'</span></span><br><span class=\"line\">&#125;, <span class=\"string\">'*'</span>)</span><br></pre></td></tr></table></figure>\n<p>这样，在父级页面，只需要添加监听，即可实现通讯，具体如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'message'</span>, event =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (event.data.eventType === <span class=\"string\">'languageChanged'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(event.data.selected) <span class=\"comment\">// 修改为具体的需要执行的函数即可</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>对iframe跨域同学的两种方案: </p>\n<p><a href=\"[https://gjincai.github.io/2017/05/22/%E5%AD%90%E9%A1%B5%E9%9D%A2iframe%E8%B7%A8%E5%9F%9F%E6%89%A7%E8%A1%8C%E7%88%B6%E9%A1%B5%E9%9D%A2%E5%AE%9A%E4%B9%89%E7%9A%84JS%E6%96%B9%E6%B3%95/](https://gjincai.github.io/2017/05/22/子页面iframe跨域执行父页面定义的JS方法/\">1. postMessage方法</a>)</p>\n<p><a href=\"https://www.jianshu.com/p/9d90d3333215\" target=\"_blank\" rel=\"noopener\">2. iframe代理方法</a></p>\n<h4 id=\"notebook功能模块\"><a href=\"#notebook功能模块\" class=\"headerlink\" title=\"notebook功能模块\"></a>notebook功能模块</h4><p>核心功能模块的目录为</p>\n<ul>\n<li>编辑器相关功能 <code>/notebook/notebook/static/edit/js</code></li>\n<li>notebook功能模块 <code>/notebook/notebook/static/notebook/js</code></li>\n</ul>\n<p>其中编辑器包含了导航栏、编辑器功能板的动态页面生成以及相关action的调用；<br>notebook的功能模块，则囊括了整个jupyter-notebook的各项基础功能，包括自动保存、自动保存配置、编辑器状态、事件注册等。</p>\n<h5 id=\"notebook-js\"><a href=\"#notebook-js\" class=\"headerlink\" title=\"notebook.js\"></a>notebook.js</h5><p>在notebook目录下，<code>notebook.js</code>定义了Notebook的类，可以将其看作项目的容器，将各基础模块和功能集成并接入进来，这里举一个简单的例子。</p>\n<p>比如编辑器的自动保存功能，notebook的属性上有</p>\n<ul>\n<li><code>autosave_interval</code></li>\n</ul>\n<p>可以配置自动保存的事件间隔，默认为2分钟。</p>\n<hr>\n<p><strong>实例解释</strong></p>\n<p>又比如在iframe嵌套jupyter-notebook中，外层想要获取编辑器状态，避免在为保存状态下刷新。</p>\n<p>编辑器的未保存状态刷新，其本身是有保护机制的，在源码中，使用一下子方法做了处理<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onbeforeunload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但是，该方法是在外部刷新iframe时才会触发，现在想要外部去调用内部刷新前，就先判断是否可刷新，并给出更友好的提示。</p>\n<p>这样开发思路可以为： </p>\n<ol>\n<li>外部通过<code>postMessage</code>查询iframe(notebook)的状态，询问是否可刷新</li>\n<li>内部监听<code>message</code>，并根据编辑状态返回信息</li>\n<li>外部拿到编辑器状态，决定是否刷新，并提示用户。</li>\n</ol>\n<p>这样，问题就简化成了，获取编辑器状态即可，编辑器状态在<code>Notebook</code>的<code>dirty</code>属性上,当该属性为 <code>true</code>时，表示当前编辑器未保存。</p>\n<p>因此，在Notebook.js中可以加入以下代码：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//...</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'message'</span>, event =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (event.data.eventType === <span class=\"string\">'getEditStatus'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.top.postMessage(&#123;</span><br><span class=\"line\">      status: that.dirty,</span><br><span class=\"line\">      eventType: <span class=\"string\">'editStatus'</span></span><br><span class=\"line\">    &#125;, <span class=\"string\">'*'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>同理，父级也只需要通过<code>postMessage</code>实现通讯，即可根据状态信息，完成二次开发，给出更友好的提示。</p>\n<p>其他的模块、内容类似，等之后深入研究后，继续补充前端二次开发的踩坑经历。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://www.datacamp.com/community/tutorials/sql-interface-within-jupyterlab\" target=\"_blank\" rel=\"noopener\">SQL Interface within JupyterLab</a></p>\n<p><a href=\"https://www.datacamp.com/community/tutorials/tutorial-jupyter-notebook\" target=\"_blank\" rel=\"noopener\">Jupyter Notebook Tutorial: The Definitive Guide</a></p>\n<p><a href=\"https://www.osgeo.cn/jupyter/extending/frontend_extensions.html\" target=\"_blank\" rel=\"noopener\">jupyter notebook 中文文档</a></p>\n<p><a href=\"https://jupyter-notebook.readthedocs.io/en/latest/extending/frontend_extensions.html#installing-and-enabling-extensions\" target=\"_blank\" rel=\"noopener\">jupyter notebook document</a></p>\n<p><a href=\"http://www.ttlsa.com/docs/tornado/\" target=\"_blank\" rel=\"noopener\">tornado web 服务器框架</a></p>\n<p><a href=\"https://blog.csdn.net/weixin_39198406/article/details/90812334\" target=\"_blank\" rel=\"noopener\">jupyter notebook 二次开发经验</a></p>\n"},{"title":"折腾路由--Padavan私有云","date":"2019-01-14T07:07:50.000Z","_content":"\n经历了网盘的各种关闭、数据迁移和限速，国内基本只有百度网盘一家独大了。然而百度网盘推出会员、进而超级会员一波骚操作后，实在让人累觉不爱。\n\n最近正好在折腾路由器，上一篇已经把刚买的小米路由器刷成了Padavan固件，就其本身而言，已经很具可玩性了。这次把搭建私有云的过程写下来，也只是防止日后忘记而已，并没有太多的技术含量。\n\n在实验室、家庭中，有一个内网范围的共享平台是非常方便的，这也是觉得比较使用，有必要记录和分享的原因吧，下面进入正题。\n\n## 准备阶段\n\n1. 已刷Padavan固件的路由器，这个已经在上一篇记录，有需要的可以参考[小米路由器刷机指南](https://forrany.github.io/2018/12/20/%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A8R3G%E5%88%B7%E6%9C%BA%E6%8C%87%E5%8D%97/)\n2. 移动硬盘\n\n## KodExplorer可道云\n\nKodExplorer可道云和智能路由器真的是绝配，刷Padavan是因为固件本身已经继承了KodExplorer，以及很多其他工具。\n\n这里是KodExplorer的一个在线Demo，有桌面和文件夹两种管理模式，非常Nice。\n[可道云在线Demo](http://demo.kodcloud.com/)\n\n## 配置可道云\n\n登陆路由器管理页面，默认地址:192.168.123.1,账号密码:admin\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fz650q87odj20gf0dtjtu.jpg)\n\n固件中已经集成可道云，点击左侧搭建Web环境\n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fz651mknbuj208b0jqt98.jpg)\n\n点入以后，按照以下显示操作。按如下操作就可以打开WEB服务器功能和可道云，因为可道云不使用数据库，所以还是很方便的，这个时候就可以直接通过IP+端口的方式访问可道云了，因为集成的是早些版本的可道云，所以建议在升级以后使用。\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fz6521tm3dj20ds0csjua.jpg)\n\n通过以上的步骤，已经可以实现内网的可道云了，只需要IP地址加端口号即可访问。\n\n当然，如果想要外网访问，还需要做一下其他工作,主要有4中方法：\n\n1、方法一：跟电信商要一个公网的IP在路由器中开启端口映射功能\n2、方法二：注册花生壳免费账号，通过绑定花生壳来做访问\n3、方法三：ngrok内网转发等方式来实现访问\n4、更多方法：百度搜索“内网穿透”\n\n这里就在暂时不讨论了。\n\n最后，简单上一下效果吧：\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fz6541js5uj20yo0khasc.jpg)\n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fz654abilwj20yu0f742d.jpg)\n\n## opt挂载空间占用100%问题\n\n在使用kod云进行大文件传输的时候，会遇到资源空间用完的问题，这是非常坑的，提示如下\n```bash  \n【LNMP】: /opt 已用节点空间100%/100%\n```\n为了解决这个问题，需要将opt挂载到U盘。\n\n这里主要涉及两个点：\n1. ext4格式U盘\n2. 挂载opt\n\n一般U盘不是ext4格式的，Windows格式化ext4需要一些软件，其实可以在Linux进行格式化，这里介绍对方法进行总结。\n\n### 如何在路由器上格式化 U 盘为 ext4\n\n**一、安装fdisk**\n一般梅林固件都会自带的，不用安装\n```bash\n$ opkg update\n$ opkg install fdisk\n# 输出Configuring fdisk. 并且没有错误\n# fdisk就安装好了\n```\n\n**二、查看设备**\n```bash\n$ fdisk -l \n# 这里先输出系统分区之类的不用管，外置设备一般在最后\nDisk /dev/sda: 30.7 GB, 30752000000 bytes\n64 heads, 32 sectors/track, 29327 cylinders\nUnits = cylinders of 2048 * 512 = 1048576 bytes\nDevice Boot      Start         End      Blocks  Id System\n/dev/sda1               2       29327    30029824  83 Linux\n```\n上面的信息注意看到和你的存储大小一样的设备，我的是/dev/sda，在它里面有个/dev/sda1的分区\n\n**三、删除分区、新建分区**\n```bash\n$ fdisk /dev/sda # 这是你的设备別打成分区\n\nWelcome to fdisk (util-linux 2.29.2).\nChanges will remain in memory only, until you decide to write them.\nBe careful before using the write command.\n\nCommand (m for help): d # 输入d回车，我只有一个分区，它自动选择了，如果你有多个分区，可以多次使用d\nSelected partition 1\nPartition 1 has been deleted.\n\nCommand (m for help): n # 输入n会车，创建分区\nPartition type\np   primary (0 primary, 0 extended, 4 free)\ne   extended (container for logical partitions)\n\nSelect (default p): p # 选择p\nPartition number (1-4, default 1): # 回车\nFirst sector (2048-2065023, default 2048): #回车\nLast sector, +sectors or +size{K,M,G,T,P} (2048-2065023, default 2065023): # 回车\nCreated a new partition 1 of type 'Linux' and of size 1007.3 MiB.\n\nCommand (m for help): w # 输入w回车，保存并退出\nThe partition table has been altered.\nCalling ioctl() to re-read partition table.\nSyncing disks.\n```\n经过以上的操作，你可以用fdisk -l命令查看U盘上是否只有一个Linux分区\n\n```bash\n$ fdisk -l \n# 找到你的设备 可以看到ID为83就对了\nDisk /dev/sda: 30.7 GB, 30752000000 bytes\n64 heads, 32 sectors/track, 29327 cylinders\nUnits = cylinders of 2048 * 512 = 1048576 bytes\nDevice Boot      Start         End      Blocks  Id System\n/dev/sda1               2       29327    30029824  83 Linux\n```\n\n**四、格式化分区**\n分区已经有了，现在开始格式化，其实现在的分区已经是ext4格式的了，不过我们还是对它进行一下格式化，算是熟悉一下命令，以后直接这样格式化吧\n```bash\n\n$ mkfs.ext4 /dev/sda1 \n# 如果你的硬盘比较大，256G以上的话，是这个命令：mkfs.ext4 -T largefile /dev/sda1\nmke2fs 1.43.3 (04-Sep-2016)\n/dev/sda1 contains a ext4 file system labelled 'ONMP'\nlast mounted on Sun Nov 12 09:21:22 2017\nProceed anyway? (y,n) y # 输入y回车\n\n$ umount /dev/sda1 # 如果出错，可能是因为已经被挂载了，先执行这个卸载\n```\n这样，U盘就被格式化完了\n\n### 修改opt挂载\n\n当出现opt资源空间不足问题时，服务是无法正常启动的。\n\n我们先查看下空间使用情况，两个指令，分别是:\n```bash\ndf -h  #查看空间\ndf -i  #这个命令的节点空间查看\n``` \n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fz8uovlawtj20k907pq33.jpg)\n\n原来的是100%，是在内存卡上的\n\nada1 这个是我的u盘\n\n我吧这个opt文件挂载到u盘上\n\nmount /dev/sda1 /opt\n\n然后重启，就可以了\n\n现在你继续用LNMP就 可以了\n\n## opt下载失败/解压失败\n\n曾经遇到这个问题，当出现时，可以手动下载来解决，过程如下。\n\n1、首先在U盘或者SD卡的分区一上建立一个opt 目录：\n例如 \n```bash\nmkdir /media/AiCard_01/opt -p\n```\n这里的目录可能和你的存储设备不同。\n\n2、重启路由，确定你的opt目录已经正确mount了。\n输入 mount ，看到有如下字样\n```bash\n/dev/mmcblk0p1 on /opt type ext4 (rw,noatime,data=ordered)\n```\n说明成功了。\n\n3、然后手动下载 opt.tgz 文件，目前有两个下载地址：\n```bash\ncd /opt\nwget https://bitbucket.org/hiboyhiboy ... aster/optupang7.tgz -O opt.tgz\n```\n或者\n```bash\n\nwget https://raw.githubusercontent.co ... aster/optupang7.tgz -O opt.tgz\n```\n\n\n也可以使用 curl\n```bash\ncurl https://bitbucket.org/hiboyhiboy ... aster/optupang7.tgz -o opt.tgz -k\n```\n或者\n```bash\ncurl https://raw.githubusercontent.co ... aster/optupang7.tgz -o opt.tgz -k\n```\n这个时候可以看到下载进度条开始慢慢跑了，是的，两个都很慢。\n\n当下载进度条到了100%以后，再把opt 功能打开，\n\n\n## 参考资料\n[1.如何在路由器上格式化 U 盘为 ext4](https://github.com/xzhih/ONMP/wiki/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96-U-%E7%9B%98%E4%B8%BA-ext4)\n[2.【LNMP】: /opt 已用节点空间100%/100%](https://www.cnblogs.com/dbfedbf/p/7644989.html)\n","source":"_posts/year-01-14-折腾路由-Padavan私有云.md","raw":"---\ntitle: 折腾路由--Padavan私有云\ndate: 2019-01-14 15:07:50\ntags:\n     - 路由器 \n---\n\n经历了网盘的各种关闭、数据迁移和限速，国内基本只有百度网盘一家独大了。然而百度网盘推出会员、进而超级会员一波骚操作后，实在让人累觉不爱。\n\n最近正好在折腾路由器，上一篇已经把刚买的小米路由器刷成了Padavan固件，就其本身而言，已经很具可玩性了。这次把搭建私有云的过程写下来，也只是防止日后忘记而已，并没有太多的技术含量。\n\n在实验室、家庭中，有一个内网范围的共享平台是非常方便的，这也是觉得比较使用，有必要记录和分享的原因吧，下面进入正题。\n\n## 准备阶段\n\n1. 已刷Padavan固件的路由器，这个已经在上一篇记录，有需要的可以参考[小米路由器刷机指南](https://forrany.github.io/2018/12/20/%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A8R3G%E5%88%B7%E6%9C%BA%E6%8C%87%E5%8D%97/)\n2. 移动硬盘\n\n## KodExplorer可道云\n\nKodExplorer可道云和智能路由器真的是绝配，刷Padavan是因为固件本身已经继承了KodExplorer，以及很多其他工具。\n\n这里是KodExplorer的一个在线Demo，有桌面和文件夹两种管理模式，非常Nice。\n[可道云在线Demo](http://demo.kodcloud.com/)\n\n## 配置可道云\n\n登陆路由器管理页面，默认地址:192.168.123.1,账号密码:admin\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fz650q87odj20gf0dtjtu.jpg)\n\n固件中已经集成可道云，点击左侧搭建Web环境\n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fz651mknbuj208b0jqt98.jpg)\n\n点入以后，按照以下显示操作。按如下操作就可以打开WEB服务器功能和可道云，因为可道云不使用数据库，所以还是很方便的，这个时候就可以直接通过IP+端口的方式访问可道云了，因为集成的是早些版本的可道云，所以建议在升级以后使用。\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fz6521tm3dj20ds0csjua.jpg)\n\n通过以上的步骤，已经可以实现内网的可道云了，只需要IP地址加端口号即可访问。\n\n当然，如果想要外网访问，还需要做一下其他工作,主要有4中方法：\n\n1、方法一：跟电信商要一个公网的IP在路由器中开启端口映射功能\n2、方法二：注册花生壳免费账号，通过绑定花生壳来做访问\n3、方法三：ngrok内网转发等方式来实现访问\n4、更多方法：百度搜索“内网穿透”\n\n这里就在暂时不讨论了。\n\n最后，简单上一下效果吧：\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fz6541js5uj20yo0khasc.jpg)\n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fz654abilwj20yu0f742d.jpg)\n\n## opt挂载空间占用100%问题\n\n在使用kod云进行大文件传输的时候，会遇到资源空间用完的问题，这是非常坑的，提示如下\n```bash  \n【LNMP】: /opt 已用节点空间100%/100%\n```\n为了解决这个问题，需要将opt挂载到U盘。\n\n这里主要涉及两个点：\n1. ext4格式U盘\n2. 挂载opt\n\n一般U盘不是ext4格式的，Windows格式化ext4需要一些软件，其实可以在Linux进行格式化，这里介绍对方法进行总结。\n\n### 如何在路由器上格式化 U 盘为 ext4\n\n**一、安装fdisk**\n一般梅林固件都会自带的，不用安装\n```bash\n$ opkg update\n$ opkg install fdisk\n# 输出Configuring fdisk. 并且没有错误\n# fdisk就安装好了\n```\n\n**二、查看设备**\n```bash\n$ fdisk -l \n# 这里先输出系统分区之类的不用管，外置设备一般在最后\nDisk /dev/sda: 30.7 GB, 30752000000 bytes\n64 heads, 32 sectors/track, 29327 cylinders\nUnits = cylinders of 2048 * 512 = 1048576 bytes\nDevice Boot      Start         End      Blocks  Id System\n/dev/sda1               2       29327    30029824  83 Linux\n```\n上面的信息注意看到和你的存储大小一样的设备，我的是/dev/sda，在它里面有个/dev/sda1的分区\n\n**三、删除分区、新建分区**\n```bash\n$ fdisk /dev/sda # 这是你的设备別打成分区\n\nWelcome to fdisk (util-linux 2.29.2).\nChanges will remain in memory only, until you decide to write them.\nBe careful before using the write command.\n\nCommand (m for help): d # 输入d回车，我只有一个分区，它自动选择了，如果你有多个分区，可以多次使用d\nSelected partition 1\nPartition 1 has been deleted.\n\nCommand (m for help): n # 输入n会车，创建分区\nPartition type\np   primary (0 primary, 0 extended, 4 free)\ne   extended (container for logical partitions)\n\nSelect (default p): p # 选择p\nPartition number (1-4, default 1): # 回车\nFirst sector (2048-2065023, default 2048): #回车\nLast sector, +sectors or +size{K,M,G,T,P} (2048-2065023, default 2065023): # 回车\nCreated a new partition 1 of type 'Linux' and of size 1007.3 MiB.\n\nCommand (m for help): w # 输入w回车，保存并退出\nThe partition table has been altered.\nCalling ioctl() to re-read partition table.\nSyncing disks.\n```\n经过以上的操作，你可以用fdisk -l命令查看U盘上是否只有一个Linux分区\n\n```bash\n$ fdisk -l \n# 找到你的设备 可以看到ID为83就对了\nDisk /dev/sda: 30.7 GB, 30752000000 bytes\n64 heads, 32 sectors/track, 29327 cylinders\nUnits = cylinders of 2048 * 512 = 1048576 bytes\nDevice Boot      Start         End      Blocks  Id System\n/dev/sda1               2       29327    30029824  83 Linux\n```\n\n**四、格式化分区**\n分区已经有了，现在开始格式化，其实现在的分区已经是ext4格式的了，不过我们还是对它进行一下格式化，算是熟悉一下命令，以后直接这样格式化吧\n```bash\n\n$ mkfs.ext4 /dev/sda1 \n# 如果你的硬盘比较大，256G以上的话，是这个命令：mkfs.ext4 -T largefile /dev/sda1\nmke2fs 1.43.3 (04-Sep-2016)\n/dev/sda1 contains a ext4 file system labelled 'ONMP'\nlast mounted on Sun Nov 12 09:21:22 2017\nProceed anyway? (y,n) y # 输入y回车\n\n$ umount /dev/sda1 # 如果出错，可能是因为已经被挂载了，先执行这个卸载\n```\n这样，U盘就被格式化完了\n\n### 修改opt挂载\n\n当出现opt资源空间不足问题时，服务是无法正常启动的。\n\n我们先查看下空间使用情况，两个指令，分别是:\n```bash\ndf -h  #查看空间\ndf -i  #这个命令的节点空间查看\n``` \n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fz8uovlawtj20k907pq33.jpg)\n\n原来的是100%，是在内存卡上的\n\nada1 这个是我的u盘\n\n我吧这个opt文件挂载到u盘上\n\nmount /dev/sda1 /opt\n\n然后重启，就可以了\n\n现在你继续用LNMP就 可以了\n\n## opt下载失败/解压失败\n\n曾经遇到这个问题，当出现时，可以手动下载来解决，过程如下。\n\n1、首先在U盘或者SD卡的分区一上建立一个opt 目录：\n例如 \n```bash\nmkdir /media/AiCard_01/opt -p\n```\n这里的目录可能和你的存储设备不同。\n\n2、重启路由，确定你的opt目录已经正确mount了。\n输入 mount ，看到有如下字样\n```bash\n/dev/mmcblk0p1 on /opt type ext4 (rw,noatime,data=ordered)\n```\n说明成功了。\n\n3、然后手动下载 opt.tgz 文件，目前有两个下载地址：\n```bash\ncd /opt\nwget https://bitbucket.org/hiboyhiboy ... aster/optupang7.tgz -O opt.tgz\n```\n或者\n```bash\n\nwget https://raw.githubusercontent.co ... aster/optupang7.tgz -O opt.tgz\n```\n\n\n也可以使用 curl\n```bash\ncurl https://bitbucket.org/hiboyhiboy ... aster/optupang7.tgz -o opt.tgz -k\n```\n或者\n```bash\ncurl https://raw.githubusercontent.co ... aster/optupang7.tgz -o opt.tgz -k\n```\n这个时候可以看到下载进度条开始慢慢跑了，是的，两个都很慢。\n\n当下载进度条到了100%以后，再把opt 功能打开，\n\n\n## 参考资料\n[1.如何在路由器上格式化 U 盘为 ext4](https://github.com/xzhih/ONMP/wiki/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96-U-%E7%9B%98%E4%B8%BA-ext4)\n[2.【LNMP】: /opt 已用节点空间100%/100%](https://www.cnblogs.com/dbfedbf/p/7644989.html)\n","slug":"折腾路由-Padavan私有云","published":1,"updated":"2022-08-17T07:53:21.232Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6xbhzk8000wzk08dt92ewkv","content":"<p>经历了网盘的各种关闭、数据迁移和限速，国内基本只有百度网盘一家独大了。然而百度网盘推出会员、进而超级会员一波骚操作后，实在让人累觉不爱。</p>\n<p>最近正好在折腾路由器，上一篇已经把刚买的小米路由器刷成了Padavan固件，就其本身而言，已经很具可玩性了。这次把搭建私有云的过程写下来，也只是防止日后忘记而已，并没有太多的技术含量。</p>\n<p>在实验室、家庭中，有一个内网范围的共享平台是非常方便的，这也是觉得比较使用，有必要记录和分享的原因吧，下面进入正题。</p>\n<h2 id=\"准备阶段\"><a href=\"#准备阶段\" class=\"headerlink\" title=\"准备阶段\"></a>准备阶段</h2><ol>\n<li>已刷Padavan固件的路由器，这个已经在上一篇记录，有需要的可以参考<a href=\"https://forrany.github.io/2018/12/20/%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A8R3G%E5%88%B7%E6%9C%BA%E6%8C%87%E5%8D%97/\" target=\"_blank\" rel=\"noopener\">小米路由器刷机指南</a></li>\n<li>移动硬盘</li>\n</ol>\n<h2 id=\"KodExplorer可道云\"><a href=\"#KodExplorer可道云\" class=\"headerlink\" title=\"KodExplorer可道云\"></a>KodExplorer可道云</h2><p>KodExplorer可道云和智能路由器真的是绝配，刷Padavan是因为固件本身已经继承了KodExplorer，以及很多其他工具。</p>\n<p>这里是KodExplorer的一个在线Demo，有桌面和文件夹两种管理模式，非常Nice。<br><a href=\"http://demo.kodcloud.com/\" target=\"_blank\" rel=\"noopener\">可道云在线Demo</a></p>\n<h2 id=\"配置可道云\"><a href=\"#配置可道云\" class=\"headerlink\" title=\"配置可道云\"></a>配置可道云</h2><p>登陆路由器管理页面，默认地址:192.168.123.1,账号密码:admin<br><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fz650q87odj20gf0dtjtu.jpg\" alt=\"\"></p>\n<p>固件中已经集成可道云，点击左侧搭建Web环境</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fz651mknbuj208b0jqt98.jpg\" alt=\"\"></p>\n<p>点入以后，按照以下显示操作。按如下操作就可以打开WEB服务器功能和可道云，因为可道云不使用数据库，所以还是很方便的，这个时候就可以直接通过IP+端口的方式访问可道云了，因为集成的是早些版本的可道云，所以建议在升级以后使用。<br><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fz6521tm3dj20ds0csjua.jpg\" alt=\"\"></p>\n<p>通过以上的步骤，已经可以实现内网的可道云了，只需要IP地址加端口号即可访问。</p>\n<p>当然，如果想要外网访问，还需要做一下其他工作,主要有4中方法：</p>\n<p>1、方法一：跟电信商要一个公网的IP在路由器中开启端口映射功能<br>2、方法二：注册花生壳免费账号，通过绑定花生壳来做访问<br>3、方法三：ngrok内网转发等方式来实现访问<br>4、更多方法：百度搜索“内网穿透”</p>\n<p>这里就在暂时不讨论了。</p>\n<p>最后，简单上一下效果吧：<br><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fz6541js5uj20yo0khasc.jpg\" alt=\"\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fz654abilwj20yu0f742d.jpg\" alt=\"\"></p>\n<h2 id=\"opt挂载空间占用100-问题\"><a href=\"#opt挂载空间占用100-问题\" class=\"headerlink\" title=\"opt挂载空间占用100%问题\"></a>opt挂载空间占用100%问题</h2><p>在使用kod云进行大文件传输的时候，会遇到资源空间用完的问题，这是非常坑的，提示如下<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">【LNMP】: /opt 已用节点空间100%/100%</span><br></pre></td></tr></table></figure></p>\n<p>为了解决这个问题，需要将opt挂载到U盘。</p>\n<p>这里主要涉及两个点：</p>\n<ol>\n<li>ext4格式U盘</li>\n<li>挂载opt</li>\n</ol>\n<p>一般U盘不是ext4格式的，Windows格式化ext4需要一些软件，其实可以在Linux进行格式化，这里介绍对方法进行总结。</p>\n<h3 id=\"如何在路由器上格式化-U-盘为-ext4\"><a href=\"#如何在路由器上格式化-U-盘为-ext4\" class=\"headerlink\" title=\"如何在路由器上格式化 U 盘为 ext4\"></a>如何在路由器上格式化 U 盘为 ext4</h3><p><strong>一、安装fdisk</strong><br>一般梅林固件都会自带的，不用安装<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ opkg update</span><br><span class=\"line\">$ opkg install fdisk</span><br><span class=\"line\"><span class=\"comment\"># 输出Configuring fdisk. 并且没有错误</span></span><br><span class=\"line\"><span class=\"comment\"># fdisk就安装好了</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>二、查看设备</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ fdisk -l </span><br><span class=\"line\"><span class=\"comment\"># 这里先输出系统分区之类的不用管，外置设备一般在最后</span></span><br><span class=\"line\">Disk /dev/sda: 30.7 GB, 30752000000 bytes</span><br><span class=\"line\">64 heads, 32 sectors/track, 29327 cylinders</span><br><span class=\"line\">Units = cylinders of 2048 * 512 = 1048576 bytes</span><br><span class=\"line\">Device Boot      Start         End      Blocks  Id System</span><br><span class=\"line\">/dev/sda1               2       29327    30029824  83 Linux</span><br></pre></td></tr></table></figure></p>\n<p>上面的信息注意看到和你的存储大小一样的设备，我的是/dev/sda，在它里面有个/dev/sda1的分区</p>\n<p><strong>三、删除分区、新建分区</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ fdisk /dev/sda <span class=\"comment\"># 这是你的设备別打成分区</span></span><br><span class=\"line\"></span><br><span class=\"line\">Welcome to fdisk (util-linux 2.29.2).</span><br><span class=\"line\">Changes will remain <span class=\"keyword\">in</span> memory only, until you decide to write them.</span><br><span class=\"line\">Be careful before using the write <span class=\"built_in\">command</span>.</span><br><span class=\"line\"></span><br><span class=\"line\">Command (m <span class=\"keyword\">for</span> <span class=\"built_in\">help</span>): d <span class=\"comment\"># 输入d回车，我只有一个分区，它自动选择了，如果你有多个分区，可以多次使用d</span></span><br><span class=\"line\">Selected partition 1</span><br><span class=\"line\">Partition 1 has been deleted.</span><br><span class=\"line\"></span><br><span class=\"line\">Command (m <span class=\"keyword\">for</span> <span class=\"built_in\">help</span>): n <span class=\"comment\"># 输入n会车，创建分区</span></span><br><span class=\"line\">Partition <span class=\"built_in\">type</span></span><br><span class=\"line\">p   primary (0 primary, 0 extended, 4 free)</span><br><span class=\"line\">e   extended (container <span class=\"keyword\">for</span> logical partitions)</span><br><span class=\"line\"></span><br><span class=\"line\">Select (default p): p <span class=\"comment\"># 选择p</span></span><br><span class=\"line\">Partition number (1-4, default 1): <span class=\"comment\"># 回车</span></span><br><span class=\"line\">First sector (2048-2065023, default 2048): <span class=\"comment\">#回车</span></span><br><span class=\"line\">Last sector, +sectors or +size&#123;K,M,G,T,P&#125; (2048-2065023, default 2065023): <span class=\"comment\"># 回车</span></span><br><span class=\"line\">Created a new partition 1 of <span class=\"built_in\">type</span> <span class=\"string\">'Linux'</span> and of size 1007.3 MiB.</span><br><span class=\"line\"></span><br><span class=\"line\">Command (m <span class=\"keyword\">for</span> <span class=\"built_in\">help</span>): w <span class=\"comment\"># 输入w回车，保存并退出</span></span><br><span class=\"line\">The partition table has been altered.</span><br><span class=\"line\">Calling ioctl() to re-read partition table.</span><br><span class=\"line\">Syncing disks.</span><br></pre></td></tr></table></figure></p>\n<p>经过以上的操作，你可以用fdisk -l命令查看U盘上是否只有一个Linux分区</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ fdisk -l </span><br><span class=\"line\"><span class=\"comment\"># 找到你的设备 可以看到ID为83就对了</span></span><br><span class=\"line\">Disk /dev/sda: 30.7 GB, 30752000000 bytes</span><br><span class=\"line\">64 heads, 32 sectors/track, 29327 cylinders</span><br><span class=\"line\">Units = cylinders of 2048 * 512 = 1048576 bytes</span><br><span class=\"line\">Device Boot      Start         End      Blocks  Id System</span><br><span class=\"line\">/dev/sda1               2       29327    30029824  83 Linux</span><br></pre></td></tr></table></figure>\n<p><strong>四、格式化分区</strong><br>分区已经有了，现在开始格式化，其实现在的分区已经是ext4格式的了，不过我们还是对它进行一下格式化，算是熟悉一下命令，以后直接这样格式化吧<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$ mkfs.ext4 /dev/sda1 </span><br><span class=\"line\"><span class=\"comment\"># 如果你的硬盘比较大，256G以上的话，是这个命令：mkfs.ext4 -T largefile /dev/sda1</span></span><br><span class=\"line\">mke2fs 1.43.3 (04-Sep-2016)</span><br><span class=\"line\">/dev/sda1 contains a ext4 file system labelled <span class=\"string\">'ONMP'</span></span><br><span class=\"line\">last mounted on Sun Nov 12 09:21:22 2017</span><br><span class=\"line\">Proceed anyway? (y,n) y <span class=\"comment\"># 输入y回车</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ umount /dev/sda1 <span class=\"comment\"># 如果出错，可能是因为已经被挂载了，先执行这个卸载</span></span><br></pre></td></tr></table></figure></p>\n<p>这样，U盘就被格式化完了</p>\n<h3 id=\"修改opt挂载\"><a href=\"#修改opt挂载\" class=\"headerlink\" title=\"修改opt挂载\"></a>修改opt挂载</h3><p>当出现opt资源空间不足问题时，服务是无法正常启动的。</p>\n<p>我们先查看下空间使用情况，两个指令，分别是:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df -h  <span class=\"comment\">#查看空间</span></span><br><span class=\"line\">df -i  <span class=\"comment\">#这个命令的节点空间查看</span></span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">![](http://ww1.sinaimg.cn/large/6f9f3683ly1fz8uovlawtj20k907pq33.jpg)</span><br><span class=\"line\"></span><br><span class=\"line\">原来的是100%，是在内存卡上的</span><br><span class=\"line\"></span><br><span class=\"line\">ada1 这个是我的u盘</span><br><span class=\"line\"></span><br><span class=\"line\">我吧这个opt文件挂载到u盘上</span><br><span class=\"line\"></span><br><span class=\"line\">mount /dev/sda1 /opt</span><br><span class=\"line\"></span><br><span class=\"line\">然后重启，就可以了</span><br><span class=\"line\"></span><br><span class=\"line\">现在你继续用LNMP就 可以了</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## opt下载失败/解压失败</span></span><br><span class=\"line\"></span><br><span class=\"line\">曾经遇到这个问题，当出现时，可以手动下载来解决，过程如下。</span><br><span class=\"line\"></span><br><span class=\"line\">1、首先在U盘或者SD卡的分区一上建立一个opt 目录：</span><br><span class=\"line\">例如 </span><br><span class=\"line\">```bash</span><br><span class=\"line\">mkdir /media/AiCard_01/opt -p</span><br></pre></td></tr></table></figure></p>\n<p>这里的目录可能和你的存储设备不同。</p>\n<p>2、重启路由，确定你的opt目录已经正确mount了。<br>输入 mount ，看到有如下字样<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/dev/mmcblk0p1 on /opt <span class=\"built_in\">type</span> ext4 (rw,noatime,data=ordered)</span><br></pre></td></tr></table></figure></p>\n<p>说明成功了。</p>\n<p>3、然后手动下载 opt.tgz 文件，目前有两个下载地址：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /opt</span><br><span class=\"line\">wget https://bitbucket.org/hiboyhiboy ... aster/optupang7.tgz -O opt.tgz</span><br></pre></td></tr></table></figure></p>\n<p>或者<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">wget https://raw.githubusercontent.co ... aster/optupang7.tgz -O opt.tgz</span><br></pre></td></tr></table></figure></p>\n<p>也可以使用 curl<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://bitbucket.org/hiboyhiboy ... aster/optupang7.tgz -o opt.tgz -k</span><br></pre></td></tr></table></figure></p>\n<p>或者<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://raw.githubusercontent.co ... aster/optupang7.tgz -o opt.tgz -k</span><br></pre></td></tr></table></figure></p>\n<p>这个时候可以看到下载进度条开始慢慢跑了，是的，两个都很慢。</p>\n<p>当下载进度条到了100%以后，再把opt 功能打开，</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://github.com/xzhih/ONMP/wiki/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96-U-%E7%9B%98%E4%B8%BA-ext4\" target=\"_blank\" rel=\"noopener\">1.如何在路由器上格式化 U 盘为 ext4</a><br><a href=\"https://www.cnblogs.com/dbfedbf/p/7644989.html\" target=\"_blank\" rel=\"noopener\">2.【LNMP】: /opt 已用节点空间100%/100%</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>经历了网盘的各种关闭、数据迁移和限速，国内基本只有百度网盘一家独大了。然而百度网盘推出会员、进而超级会员一波骚操作后，实在让人累觉不爱。</p>\n<p>最近正好在折腾路由器，上一篇已经把刚买的小米路由器刷成了Padavan固件，就其本身而言，已经很具可玩性了。这次把搭建私有云的过程写下来，也只是防止日后忘记而已，并没有太多的技术含量。</p>\n<p>在实验室、家庭中，有一个内网范围的共享平台是非常方便的，这也是觉得比较使用，有必要记录和分享的原因吧，下面进入正题。</p>\n<h2 id=\"准备阶段\"><a href=\"#准备阶段\" class=\"headerlink\" title=\"准备阶段\"></a>准备阶段</h2><ol>\n<li>已刷Padavan固件的路由器，这个已经在上一篇记录，有需要的可以参考<a href=\"https://forrany.github.io/2018/12/20/%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A8R3G%E5%88%B7%E6%9C%BA%E6%8C%87%E5%8D%97/\" target=\"_blank\" rel=\"noopener\">小米路由器刷机指南</a></li>\n<li>移动硬盘</li>\n</ol>\n<h2 id=\"KodExplorer可道云\"><a href=\"#KodExplorer可道云\" class=\"headerlink\" title=\"KodExplorer可道云\"></a>KodExplorer可道云</h2><p>KodExplorer可道云和智能路由器真的是绝配，刷Padavan是因为固件本身已经继承了KodExplorer，以及很多其他工具。</p>\n<p>这里是KodExplorer的一个在线Demo，有桌面和文件夹两种管理模式，非常Nice。<br><a href=\"http://demo.kodcloud.com/\" target=\"_blank\" rel=\"noopener\">可道云在线Demo</a></p>\n<h2 id=\"配置可道云\"><a href=\"#配置可道云\" class=\"headerlink\" title=\"配置可道云\"></a>配置可道云</h2><p>登陆路由器管理页面，默认地址:192.168.123.1,账号密码:admin<br><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fz650q87odj20gf0dtjtu.jpg\" alt=\"\"></p>\n<p>固件中已经集成可道云，点击左侧搭建Web环境</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fz651mknbuj208b0jqt98.jpg\" alt=\"\"></p>\n<p>点入以后，按照以下显示操作。按如下操作就可以打开WEB服务器功能和可道云，因为可道云不使用数据库，所以还是很方便的，这个时候就可以直接通过IP+端口的方式访问可道云了，因为集成的是早些版本的可道云，所以建议在升级以后使用。<br><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fz6521tm3dj20ds0csjua.jpg\" alt=\"\"></p>\n<p>通过以上的步骤，已经可以实现内网的可道云了，只需要IP地址加端口号即可访问。</p>\n<p>当然，如果想要外网访问，还需要做一下其他工作,主要有4中方法：</p>\n<p>1、方法一：跟电信商要一个公网的IP在路由器中开启端口映射功能<br>2、方法二：注册花生壳免费账号，通过绑定花生壳来做访问<br>3、方法三：ngrok内网转发等方式来实现访问<br>4、更多方法：百度搜索“内网穿透”</p>\n<p>这里就在暂时不讨论了。</p>\n<p>最后，简单上一下效果吧：<br><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fz6541js5uj20yo0khasc.jpg\" alt=\"\"></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fz654abilwj20yu0f742d.jpg\" alt=\"\"></p>\n<h2 id=\"opt挂载空间占用100-问题\"><a href=\"#opt挂载空间占用100-问题\" class=\"headerlink\" title=\"opt挂载空间占用100%问题\"></a>opt挂载空间占用100%问题</h2><p>在使用kod云进行大文件传输的时候，会遇到资源空间用完的问题，这是非常坑的，提示如下<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">【LNMP】: /opt 已用节点空间100%/100%</span><br></pre></td></tr></table></figure></p>\n<p>为了解决这个问题，需要将opt挂载到U盘。</p>\n<p>这里主要涉及两个点：</p>\n<ol>\n<li>ext4格式U盘</li>\n<li>挂载opt</li>\n</ol>\n<p>一般U盘不是ext4格式的，Windows格式化ext4需要一些软件，其实可以在Linux进行格式化，这里介绍对方法进行总结。</p>\n<h3 id=\"如何在路由器上格式化-U-盘为-ext4\"><a href=\"#如何在路由器上格式化-U-盘为-ext4\" class=\"headerlink\" title=\"如何在路由器上格式化 U 盘为 ext4\"></a>如何在路由器上格式化 U 盘为 ext4</h3><p><strong>一、安装fdisk</strong><br>一般梅林固件都会自带的，不用安装<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ opkg update</span><br><span class=\"line\">$ opkg install fdisk</span><br><span class=\"line\"><span class=\"comment\"># 输出Configuring fdisk. 并且没有错误</span></span><br><span class=\"line\"><span class=\"comment\"># fdisk就安装好了</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>二、查看设备</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ fdisk -l </span><br><span class=\"line\"><span class=\"comment\"># 这里先输出系统分区之类的不用管，外置设备一般在最后</span></span><br><span class=\"line\">Disk /dev/sda: 30.7 GB, 30752000000 bytes</span><br><span class=\"line\">64 heads, 32 sectors/track, 29327 cylinders</span><br><span class=\"line\">Units = cylinders of 2048 * 512 = 1048576 bytes</span><br><span class=\"line\">Device Boot      Start         End      Blocks  Id System</span><br><span class=\"line\">/dev/sda1               2       29327    30029824  83 Linux</span><br></pre></td></tr></table></figure></p>\n<p>上面的信息注意看到和你的存储大小一样的设备，我的是/dev/sda，在它里面有个/dev/sda1的分区</p>\n<p><strong>三、删除分区、新建分区</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ fdisk /dev/sda <span class=\"comment\"># 这是你的设备別打成分区</span></span><br><span class=\"line\"></span><br><span class=\"line\">Welcome to fdisk (util-linux 2.29.2).</span><br><span class=\"line\">Changes will remain <span class=\"keyword\">in</span> memory only, until you decide to write them.</span><br><span class=\"line\">Be careful before using the write <span class=\"built_in\">command</span>.</span><br><span class=\"line\"></span><br><span class=\"line\">Command (m <span class=\"keyword\">for</span> <span class=\"built_in\">help</span>): d <span class=\"comment\"># 输入d回车，我只有一个分区，它自动选择了，如果你有多个分区，可以多次使用d</span></span><br><span class=\"line\">Selected partition 1</span><br><span class=\"line\">Partition 1 has been deleted.</span><br><span class=\"line\"></span><br><span class=\"line\">Command (m <span class=\"keyword\">for</span> <span class=\"built_in\">help</span>): n <span class=\"comment\"># 输入n会车，创建分区</span></span><br><span class=\"line\">Partition <span class=\"built_in\">type</span></span><br><span class=\"line\">p   primary (0 primary, 0 extended, 4 free)</span><br><span class=\"line\">e   extended (container <span class=\"keyword\">for</span> logical partitions)</span><br><span class=\"line\"></span><br><span class=\"line\">Select (default p): p <span class=\"comment\"># 选择p</span></span><br><span class=\"line\">Partition number (1-4, default 1): <span class=\"comment\"># 回车</span></span><br><span class=\"line\">First sector (2048-2065023, default 2048): <span class=\"comment\">#回车</span></span><br><span class=\"line\">Last sector, +sectors or +size&#123;K,M,G,T,P&#125; (2048-2065023, default 2065023): <span class=\"comment\"># 回车</span></span><br><span class=\"line\">Created a new partition 1 of <span class=\"built_in\">type</span> <span class=\"string\">'Linux'</span> and of size 1007.3 MiB.</span><br><span class=\"line\"></span><br><span class=\"line\">Command (m <span class=\"keyword\">for</span> <span class=\"built_in\">help</span>): w <span class=\"comment\"># 输入w回车，保存并退出</span></span><br><span class=\"line\">The partition table has been altered.</span><br><span class=\"line\">Calling ioctl() to re-read partition table.</span><br><span class=\"line\">Syncing disks.</span><br></pre></td></tr></table></figure></p>\n<p>经过以上的操作，你可以用fdisk -l命令查看U盘上是否只有一个Linux分区</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ fdisk -l </span><br><span class=\"line\"><span class=\"comment\"># 找到你的设备 可以看到ID为83就对了</span></span><br><span class=\"line\">Disk /dev/sda: 30.7 GB, 30752000000 bytes</span><br><span class=\"line\">64 heads, 32 sectors/track, 29327 cylinders</span><br><span class=\"line\">Units = cylinders of 2048 * 512 = 1048576 bytes</span><br><span class=\"line\">Device Boot      Start         End      Blocks  Id System</span><br><span class=\"line\">/dev/sda1               2       29327    30029824  83 Linux</span><br></pre></td></tr></table></figure>\n<p><strong>四、格式化分区</strong><br>分区已经有了，现在开始格式化，其实现在的分区已经是ext4格式的了，不过我们还是对它进行一下格式化，算是熟悉一下命令，以后直接这样格式化吧<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$ mkfs.ext4 /dev/sda1 </span><br><span class=\"line\"><span class=\"comment\"># 如果你的硬盘比较大，256G以上的话，是这个命令：mkfs.ext4 -T largefile /dev/sda1</span></span><br><span class=\"line\">mke2fs 1.43.3 (04-Sep-2016)</span><br><span class=\"line\">/dev/sda1 contains a ext4 file system labelled <span class=\"string\">'ONMP'</span></span><br><span class=\"line\">last mounted on Sun Nov 12 09:21:22 2017</span><br><span class=\"line\">Proceed anyway? (y,n) y <span class=\"comment\"># 输入y回车</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ umount /dev/sda1 <span class=\"comment\"># 如果出错，可能是因为已经被挂载了，先执行这个卸载</span></span><br></pre></td></tr></table></figure></p>\n<p>这样，U盘就被格式化完了</p>\n<h3 id=\"修改opt挂载\"><a href=\"#修改opt挂载\" class=\"headerlink\" title=\"修改opt挂载\"></a>修改opt挂载</h3><p>当出现opt资源空间不足问题时，服务是无法正常启动的。</p>\n<p>我们先查看下空间使用情况，两个指令，分别是:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">df -h  <span class=\"comment\">#查看空间</span></span><br><span class=\"line\">df -i  <span class=\"comment\">#这个命令的节点空间查看</span></span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">![](http://ww1.sinaimg.cn/large/6f9f3683ly1fz8uovlawtj20k907pq33.jpg)</span><br><span class=\"line\"></span><br><span class=\"line\">原来的是100%，是在内存卡上的</span><br><span class=\"line\"></span><br><span class=\"line\">ada1 这个是我的u盘</span><br><span class=\"line\"></span><br><span class=\"line\">我吧这个opt文件挂载到u盘上</span><br><span class=\"line\"></span><br><span class=\"line\">mount /dev/sda1 /opt</span><br><span class=\"line\"></span><br><span class=\"line\">然后重启，就可以了</span><br><span class=\"line\"></span><br><span class=\"line\">现在你继续用LNMP就 可以了</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## opt下载失败/解压失败</span></span><br><span class=\"line\"></span><br><span class=\"line\">曾经遇到这个问题，当出现时，可以手动下载来解决，过程如下。</span><br><span class=\"line\"></span><br><span class=\"line\">1、首先在U盘或者SD卡的分区一上建立一个opt 目录：</span><br><span class=\"line\">例如 </span><br><span class=\"line\">```bash</span><br><span class=\"line\">mkdir /media/AiCard_01/opt -p</span><br></pre></td></tr></table></figure></p>\n<p>这里的目录可能和你的存储设备不同。</p>\n<p>2、重启路由，确定你的opt目录已经正确mount了。<br>输入 mount ，看到有如下字样<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/dev/mmcblk0p1 on /opt <span class=\"built_in\">type</span> ext4 (rw,noatime,data=ordered)</span><br></pre></td></tr></table></figure></p>\n<p>说明成功了。</p>\n<p>3、然后手动下载 opt.tgz 文件，目前有两个下载地址：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /opt</span><br><span class=\"line\">wget https://bitbucket.org/hiboyhiboy ... aster/optupang7.tgz -O opt.tgz</span><br></pre></td></tr></table></figure></p>\n<p>或者<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">wget https://raw.githubusercontent.co ... aster/optupang7.tgz -O opt.tgz</span><br></pre></td></tr></table></figure></p>\n<p>也可以使用 curl<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://bitbucket.org/hiboyhiboy ... aster/optupang7.tgz -o opt.tgz -k</span><br></pre></td></tr></table></figure></p>\n<p>或者<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://raw.githubusercontent.co ... aster/optupang7.tgz -o opt.tgz -k</span><br></pre></td></tr></table></figure></p>\n<p>这个时候可以看到下载进度条开始慢慢跑了，是的，两个都很慢。</p>\n<p>当下载进度条到了100%以后，再把opt 功能打开，</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://github.com/xzhih/ONMP/wiki/%E5%A6%82%E4%BD%95%E5%9C%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96-U-%E7%9B%98%E4%B8%BA-ext4\" target=\"_blank\" rel=\"noopener\">1.如何在路由器上格式化 U 盘为 ext4</a><br><a href=\"https://www.cnblogs.com/dbfedbf/p/7644989.html\" target=\"_blank\" rel=\"noopener\">2.【LNMP】: /opt 已用节点空间100%/100%</a></p>\n"},{"title":"D3可视化：（1）初次见面，SVG与D3的魅力","date":"2019-02-16T12:15:24.000Z","author":"Vinecnt Ko","_content":"\nD3.js是一个基于HTML/SVG/CSS的数据可视化库，是领域内非常强大的存在了。\n\n今后会在工作使用，也因此开始了自学之旅。学习过程中，我主要通过[Curran Kelleher](https://curran.github.io/dataviz-course-2018/)老师的系列教程进行学习，这个笔记用于学习、整理和分享，陆续学习、更新和记录中....\n\n---\n**学习目的：**\n* 熟悉和认识D3.js\n* 练习使用SVG画图，熟悉操作\n* 练习D3.js的基本函数和操作\n\n**完成效果图：**\n[在线demo](https://forrany.github.io/Web-Project/D3js%E5%8F%AF%E8%A7%86%E5%8C%96/1.Smile%20face%20with%20D3js/)\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1g08p6oabibg205r05nmx4.gif)\n## D3初印象\n\n### 选择集\n\nD3是实现数据可视化，仍然离不开传统DOM的选择和操作，也因此，D3提供了类似Jquery的DOM操作指令：\n* `d3.select`：选择第一个指定元素\n* `d3.selectAll` ： 选择所有的元素\n\n```javascript\nconst svg = d3.select('svg') //选择svg\nconst p = svg.selectAll('p') //选择svg下所有的p标签\n\n```\n当然，可以使用`#id` 以及 `.class` 对id和类进行选择\n\n#### 查看状态\n`d3.select`和`d3.selectAll`返回的都是选择集，添加、删除以及修改都需要用到选择集，查看状态有三个函数可以使用：\n\n* `selection.empty()`  选择集为空，返回true，否则返回false\n* `selection.node()` 返回第一个非空元素，如果选择集为空，返回null\n* `selection.size()` 返回选择集中的元素个数\n\n#### 设定和获取属性\n\n使用`select`或`selectAll`选择后，可以通过`attr`获取和设定属性，可以使用`append`方法添加元素\n```javascript\nconst svg = select('svg');\nsvg.append('circle')\n    .attr('r','30')\n\n```\n\n## 使用D3和SVG画图\nhtml文件\n```html\n<html lang=\"en\">\n<head>\n    <title>Smile face with d3</title>\n</head>\n<body>\n    <svg width=\"960\" height=\"500\"></svg>\n    <script src=\"https://d3js.org/d3.v5.min.js\"></script>\n    <script src=\"index.js\"></script>\n</body>\n</html>\n```\n\n主要内容通过index.js实现:\n### 第一步：通过d3选择SVG，使用`circle`构建轮廓\n![](http://ww1.sinaimg.cn/mw690/6f9f3683ly1g08ldlcwb6j20fm0e5q3a.jpg)\n\n```javascript\nconst svg = d3.select('svg');\nconst height = +svg.attr('height');\nconst width = +svg.attr('width');\nsvg.append('circle')\n    .attr('r',height / 2)\n    .attr('cx', width / 2)\n    .attr('cy', height / 2)\n    .attr('fill', 'yellow')\n    .attr('stroke','black')\n\nconst leftEye = svg.append('circle')\n    .attr('r', 30)\n    .attr('cx', width / 2 - 100)\n    .attr('cy', height / 2 - 80)\n    .attr('fill', 'black')\n\nconst rightEye = svg.append('circle')\n    .attr('r', 30)\n    .attr('cx', width / 2 + 100)\n    .attr('cy', height / 2 - 80)\n    .attr('fill', 'black')\n```\n\n要点：\n* 通过`attr`获取的属性是`string`类型的，通过`parseFloat`或者`+`转换为`number`类型\n* 对圆形`circle`的属性`cx` `cy`等，使用变量作为其大小设置的值，而不用一个数字，方便日后的维护\n* leftEye和RightEye用类似的方法，创造出来，并将眼睛放置在合适的位置。\n\n#### 代码优化\n\n1）可以发现，对三个圆圆心的操作`cx`和`cy`出现了多次，而作用也仅仅是为了将圆放在中心。因此，可以通过SVG中的`<g>`来分组来实现一次性操作。\n\n```javascript\nconst g = svg.append('g')\n    .attr('transform',`translate(${ width / 2}, ${ height / 2})`)\n\n//这样，在画圆的时候，就可以去掉对其圆心的操作，因为默认的位置就在中心了\nconst circle = g.append('circle')\n    .attr('r',height / 2)\n    .attr('fill', 'yellow')\n    .attr('stroke','black')\n```\n\n2）同样的，对于眼睛的操作，也有点繁琐，可以通过变量和分组，提高代码的可维护性能。\n```javascript\nconst eyeSpacing = 100;\nconst eyeYoffset = -80\nconst eyeRadius = 30;\n\nconst eyesG = g.append('g')\n    .attr('transform', `translate(0, ${eyeYoffset})`);\n\nconst leftEye = eyesG.append('circle')\n    .attr('r', eyeRadius)\n    .attr('cx', - eyeSpacing)\n\nconst rightEye = eyesG.append('circle')\n    .attr('r', eyeRadius)\n    .attr('cx', + eyeSpacing)\n```\n### 第二步 嘴巴\n\n![](http://ww1.sinaimg.cn/mw690/6f9f3683ly1g08oa97tj2j20e00e8dgb.jpg)\n\n嘴巴实际上是一个弧线，使用SVG中的`path`进行绘制。熟悉`path`的，当然可以直接给参数进行绘制，但是d3对圆弧有更好的支持，可以使用`d3.arc`函数，方便的绘制圆弧。\n\n#### arc函数\n根据官方的API手册，函数的使用方法如下：\n```javascript\nvar arc = d3.arc();\n\narc({\n  innerRadius: 0,\n  outerRadius: 100,\n  startAngle: 0,\n  endAngle: Math.PI / 2\n}); // \"M0,-100A100,100,0,0,1,100,0L0,0Z\"\n```\n其中，innerRadius是内圆半径，outerRadius是外圆半径，startAngle和endAngle分别是开始和结束的弧度（完整的圆是0~2PI）\n\n#### 笑脸的实现\n根据以上内容，代码如下：\n```javascript\nconst mouth = g.append('path')\n    .attr('d',d3.arc()({\n        innerRadius: 150,\n        outerRadius: 170,\n        startAngle: Math.PI /2,\n        endAngle: Math.PI * 3 / 2\n    }))\n```\n\n### 眉毛\n\n眉毛用简单的长方形来代替，也就是svg中的`<rect>`，使用前文的编程风格，将眉毛归为一个group，并将位置设定。\n```javascript\nconst eyebrowWidth = 50;\nconst eyebrowHeight = 10;\nconst eyebrowYoffset = -150;\nconst BrowG = g.append('g')\n    .attr('transform',`translate(${-eyebrowWidth / 2},${eyebrowYoffset})`);\n\nconst leftEyebrow = BrowG.append('rect')\n    .attr('width',eyebrowWidth)\n    .attr('height',eyebrowHeight)\n    .attr('x',-eyeSpacing)\n\nconst rightEyebrow = BrowG.append('rect')\n    .attr('width', eyebrowWidth)\n    .attr('height', eyebrowHeight)\n    .attr('x', eyeSpacing)\n```\n\n#### 加入动画\n使用`transition`函数设置眉毛的动画，让笑脸动起来\n```javascript\nconst BrowG = g.append('g')\n    .attr('transform',`translate(${-eyebrowWidth / 2},${eyebrowYoffset})`);\nBrowG.transition().duration(2000)\n    .attr('transform', `translate(${-eyebrowWidth / 2},${eyebrowYoffset - 50})`)\n    .transition().duration(2000)\n    .attr('transform', `translate(${-eyebrowWidth / 2},${eyebrowYoffset})`).duration(2000)\n\n```\n**注意点：**\n* `transition`函数要对号入座，即如果加在了`<g>`上，对应的增加的属性动画应该在`transform`上； 如果动画在`<rect>`上，动画应该在`y`属性上。\n* 添加动画不能在`append`函数之后连接，比如`BrowG.append('g').attr(...).transition()`是不行的。因为过度动画无法绑定在`append`的元素上，需要分别操作。\n\n## 完整代码\n\n[code downlaod here](https://github.com/forrany/Web-Project/blob/master/D3js%E5%8F%AF%E8%A7%86%E5%8C%96/1.Smile%20face%20with%20D3js/index.js)\n\n```javascript\nconst svg = d3.select('svg');\nconst height = +svg.attr('height');\nconst width = +svg.attr('width');\nconst g = svg.append('g')\n    .attr('transform',`translate(${ width / 2}, ${ height / 2})`)\n\nconst circle = g.append('circle')\n    .attr('r',height / 2)\n    .attr('fill', 'yellow')\n    .attr('stroke','black')\n\nconst eyeSpacing = 100;\nconst eyeYoffset = -80\nconst eyeRadius = 30;\nconst eyebrowWidth = 50;\nconst eyebrowHeight = 10;\nconst eyebrowYoffset = -150;\n\nconst eyesG = g.append('g')\n    .attr('transform', `translate(0, ${eyeYoffset})`);\n\nconst leftEye = eyesG.append('circle')\n    .attr('r', eyeRadius)\n    .attr('cx', - eyeSpacing)\n\nconst rightEye = eyesG.append('circle')\n    .attr('r', eyeRadius)\n    .attr('cx', + eyeSpacing)\n\nconst mouth = g.append('path')\n    .attr('d',d3.arc()({\n        innerRadius: 150,\n        outerRadius: 170,\n        startAngle: Math.PI /2,\n        endAngle: Math.PI * 3 / 2\n    }))\n\nconst BrowG = g.append('g')\n    .attr('transform',`translate(${-eyebrowWidth / 2},${eyebrowYoffset})`);\nBrowG.transition().duration(2000)\n    .attr('transform', `translate(${-eyebrowWidth / 2},${eyebrowYoffset - 50})`)\n    .transition().duration(2000)\n    .attr('transform', `translate(${-eyebrowWidth / 2},${eyebrowYoffset})`).duration(2000)\n\nconst leftEyebrow = BrowG.append('rect')\n    .attr('width',eyebrowWidth)\n    .attr('height',eyebrowHeight)\n    .attr('x',-eyeSpacing)\n\nconst rightEyebrow = BrowG.append('rect')\n    .attr('width', eyebrowWidth)\n    .attr('height', eyebrowHeight)\n    .attr('x', eyeSpacing)\n\n\n```","source":"_posts/year-02-16-D3可视化之初印象.md","raw":"---\ntitle: D3可视化：（1）初次见面，SVG与D3的魅力\ndate: 2019-02-16 20:15:24\nauthor:  \"Vinecnt Ko\"\ntags:\n    - d3.js\n    - 可视化\n    - SVG\n---\n\nD3.js是一个基于HTML/SVG/CSS的数据可视化库，是领域内非常强大的存在了。\n\n今后会在工作使用，也因此开始了自学之旅。学习过程中，我主要通过[Curran Kelleher](https://curran.github.io/dataviz-course-2018/)老师的系列教程进行学习，这个笔记用于学习、整理和分享，陆续学习、更新和记录中....\n\n---\n**学习目的：**\n* 熟悉和认识D3.js\n* 练习使用SVG画图，熟悉操作\n* 练习D3.js的基本函数和操作\n\n**完成效果图：**\n[在线demo](https://forrany.github.io/Web-Project/D3js%E5%8F%AF%E8%A7%86%E5%8C%96/1.Smile%20face%20with%20D3js/)\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1g08p6oabibg205r05nmx4.gif)\n## D3初印象\n\n### 选择集\n\nD3是实现数据可视化，仍然离不开传统DOM的选择和操作，也因此，D3提供了类似Jquery的DOM操作指令：\n* `d3.select`：选择第一个指定元素\n* `d3.selectAll` ： 选择所有的元素\n\n```javascript\nconst svg = d3.select('svg') //选择svg\nconst p = svg.selectAll('p') //选择svg下所有的p标签\n\n```\n当然，可以使用`#id` 以及 `.class` 对id和类进行选择\n\n#### 查看状态\n`d3.select`和`d3.selectAll`返回的都是选择集，添加、删除以及修改都需要用到选择集，查看状态有三个函数可以使用：\n\n* `selection.empty()`  选择集为空，返回true，否则返回false\n* `selection.node()` 返回第一个非空元素，如果选择集为空，返回null\n* `selection.size()` 返回选择集中的元素个数\n\n#### 设定和获取属性\n\n使用`select`或`selectAll`选择后，可以通过`attr`获取和设定属性，可以使用`append`方法添加元素\n```javascript\nconst svg = select('svg');\nsvg.append('circle')\n    .attr('r','30')\n\n```\n\n## 使用D3和SVG画图\nhtml文件\n```html\n<html lang=\"en\">\n<head>\n    <title>Smile face with d3</title>\n</head>\n<body>\n    <svg width=\"960\" height=\"500\"></svg>\n    <script src=\"https://d3js.org/d3.v5.min.js\"></script>\n    <script src=\"index.js\"></script>\n</body>\n</html>\n```\n\n主要内容通过index.js实现:\n### 第一步：通过d3选择SVG，使用`circle`构建轮廓\n![](http://ww1.sinaimg.cn/mw690/6f9f3683ly1g08ldlcwb6j20fm0e5q3a.jpg)\n\n```javascript\nconst svg = d3.select('svg');\nconst height = +svg.attr('height');\nconst width = +svg.attr('width');\nsvg.append('circle')\n    .attr('r',height / 2)\n    .attr('cx', width / 2)\n    .attr('cy', height / 2)\n    .attr('fill', 'yellow')\n    .attr('stroke','black')\n\nconst leftEye = svg.append('circle')\n    .attr('r', 30)\n    .attr('cx', width / 2 - 100)\n    .attr('cy', height / 2 - 80)\n    .attr('fill', 'black')\n\nconst rightEye = svg.append('circle')\n    .attr('r', 30)\n    .attr('cx', width / 2 + 100)\n    .attr('cy', height / 2 - 80)\n    .attr('fill', 'black')\n```\n\n要点：\n* 通过`attr`获取的属性是`string`类型的，通过`parseFloat`或者`+`转换为`number`类型\n* 对圆形`circle`的属性`cx` `cy`等，使用变量作为其大小设置的值，而不用一个数字，方便日后的维护\n* leftEye和RightEye用类似的方法，创造出来，并将眼睛放置在合适的位置。\n\n#### 代码优化\n\n1）可以发现，对三个圆圆心的操作`cx`和`cy`出现了多次，而作用也仅仅是为了将圆放在中心。因此，可以通过SVG中的`<g>`来分组来实现一次性操作。\n\n```javascript\nconst g = svg.append('g')\n    .attr('transform',`translate(${ width / 2}, ${ height / 2})`)\n\n//这样，在画圆的时候，就可以去掉对其圆心的操作，因为默认的位置就在中心了\nconst circle = g.append('circle')\n    .attr('r',height / 2)\n    .attr('fill', 'yellow')\n    .attr('stroke','black')\n```\n\n2）同样的，对于眼睛的操作，也有点繁琐，可以通过变量和分组，提高代码的可维护性能。\n```javascript\nconst eyeSpacing = 100;\nconst eyeYoffset = -80\nconst eyeRadius = 30;\n\nconst eyesG = g.append('g')\n    .attr('transform', `translate(0, ${eyeYoffset})`);\n\nconst leftEye = eyesG.append('circle')\n    .attr('r', eyeRadius)\n    .attr('cx', - eyeSpacing)\n\nconst rightEye = eyesG.append('circle')\n    .attr('r', eyeRadius)\n    .attr('cx', + eyeSpacing)\n```\n### 第二步 嘴巴\n\n![](http://ww1.sinaimg.cn/mw690/6f9f3683ly1g08oa97tj2j20e00e8dgb.jpg)\n\n嘴巴实际上是一个弧线，使用SVG中的`path`进行绘制。熟悉`path`的，当然可以直接给参数进行绘制，但是d3对圆弧有更好的支持，可以使用`d3.arc`函数，方便的绘制圆弧。\n\n#### arc函数\n根据官方的API手册，函数的使用方法如下：\n```javascript\nvar arc = d3.arc();\n\narc({\n  innerRadius: 0,\n  outerRadius: 100,\n  startAngle: 0,\n  endAngle: Math.PI / 2\n}); // \"M0,-100A100,100,0,0,1,100,0L0,0Z\"\n```\n其中，innerRadius是内圆半径，outerRadius是外圆半径，startAngle和endAngle分别是开始和结束的弧度（完整的圆是0~2PI）\n\n#### 笑脸的实现\n根据以上内容，代码如下：\n```javascript\nconst mouth = g.append('path')\n    .attr('d',d3.arc()({\n        innerRadius: 150,\n        outerRadius: 170,\n        startAngle: Math.PI /2,\n        endAngle: Math.PI * 3 / 2\n    }))\n```\n\n### 眉毛\n\n眉毛用简单的长方形来代替，也就是svg中的`<rect>`，使用前文的编程风格，将眉毛归为一个group，并将位置设定。\n```javascript\nconst eyebrowWidth = 50;\nconst eyebrowHeight = 10;\nconst eyebrowYoffset = -150;\nconst BrowG = g.append('g')\n    .attr('transform',`translate(${-eyebrowWidth / 2},${eyebrowYoffset})`);\n\nconst leftEyebrow = BrowG.append('rect')\n    .attr('width',eyebrowWidth)\n    .attr('height',eyebrowHeight)\n    .attr('x',-eyeSpacing)\n\nconst rightEyebrow = BrowG.append('rect')\n    .attr('width', eyebrowWidth)\n    .attr('height', eyebrowHeight)\n    .attr('x', eyeSpacing)\n```\n\n#### 加入动画\n使用`transition`函数设置眉毛的动画，让笑脸动起来\n```javascript\nconst BrowG = g.append('g')\n    .attr('transform',`translate(${-eyebrowWidth / 2},${eyebrowYoffset})`);\nBrowG.transition().duration(2000)\n    .attr('transform', `translate(${-eyebrowWidth / 2},${eyebrowYoffset - 50})`)\n    .transition().duration(2000)\n    .attr('transform', `translate(${-eyebrowWidth / 2},${eyebrowYoffset})`).duration(2000)\n\n```\n**注意点：**\n* `transition`函数要对号入座，即如果加在了`<g>`上，对应的增加的属性动画应该在`transform`上； 如果动画在`<rect>`上，动画应该在`y`属性上。\n* 添加动画不能在`append`函数之后连接，比如`BrowG.append('g').attr(...).transition()`是不行的。因为过度动画无法绑定在`append`的元素上，需要分别操作。\n\n## 完整代码\n\n[code downlaod here](https://github.com/forrany/Web-Project/blob/master/D3js%E5%8F%AF%E8%A7%86%E5%8C%96/1.Smile%20face%20with%20D3js/index.js)\n\n```javascript\nconst svg = d3.select('svg');\nconst height = +svg.attr('height');\nconst width = +svg.attr('width');\nconst g = svg.append('g')\n    .attr('transform',`translate(${ width / 2}, ${ height / 2})`)\n\nconst circle = g.append('circle')\n    .attr('r',height / 2)\n    .attr('fill', 'yellow')\n    .attr('stroke','black')\n\nconst eyeSpacing = 100;\nconst eyeYoffset = -80\nconst eyeRadius = 30;\nconst eyebrowWidth = 50;\nconst eyebrowHeight = 10;\nconst eyebrowYoffset = -150;\n\nconst eyesG = g.append('g')\n    .attr('transform', `translate(0, ${eyeYoffset})`);\n\nconst leftEye = eyesG.append('circle')\n    .attr('r', eyeRadius)\n    .attr('cx', - eyeSpacing)\n\nconst rightEye = eyesG.append('circle')\n    .attr('r', eyeRadius)\n    .attr('cx', + eyeSpacing)\n\nconst mouth = g.append('path')\n    .attr('d',d3.arc()({\n        innerRadius: 150,\n        outerRadius: 170,\n        startAngle: Math.PI /2,\n        endAngle: Math.PI * 3 / 2\n    }))\n\nconst BrowG = g.append('g')\n    .attr('transform',`translate(${-eyebrowWidth / 2},${eyebrowYoffset})`);\nBrowG.transition().duration(2000)\n    .attr('transform', `translate(${-eyebrowWidth / 2},${eyebrowYoffset - 50})`)\n    .transition().duration(2000)\n    .attr('transform', `translate(${-eyebrowWidth / 2},${eyebrowYoffset})`).duration(2000)\n\nconst leftEyebrow = BrowG.append('rect')\n    .attr('width',eyebrowWidth)\n    .attr('height',eyebrowHeight)\n    .attr('x',-eyeSpacing)\n\nconst rightEyebrow = BrowG.append('rect')\n    .attr('width', eyebrowWidth)\n    .attr('height', eyebrowHeight)\n    .attr('x', eyeSpacing)\n\n\n```","slug":"D3可视化之初印象","published":1,"updated":"2022-08-17T07:53:21.232Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6xbhzk9000yzk08epu0ruq0","content":"<p>D3.js是一个基于HTML/SVG/CSS的数据可视化库，是领域内非常强大的存在了。</p>\n<p>今后会在工作使用，也因此开始了自学之旅。学习过程中，我主要通过<a href=\"https://curran.github.io/dataviz-course-2018/\" target=\"_blank\" rel=\"noopener\">Curran Kelleher</a>老师的系列教程进行学习，这个笔记用于学习、整理和分享，陆续学习、更新和记录中….</p>\n<hr>\n<p><strong>学习目的：</strong></p>\n<ul>\n<li>熟悉和认识D3.js</li>\n<li>练习使用SVG画图，熟悉操作</li>\n<li>练习D3.js的基本函数和操作</li>\n</ul>\n<p><strong>完成效果图：</strong><br><a href=\"https://forrany.github.io/Web-Project/D3js%E5%8F%AF%E8%A7%86%E5%8C%96/1.Smile%20face%20with%20D3js/\" target=\"_blank\" rel=\"noopener\">在线demo</a><br><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1g08p6oabibg205r05nmx4.gif\" alt=\"\"></p>\n<h2 id=\"D3初印象\"><a href=\"#D3初印象\" class=\"headerlink\" title=\"D3初印象\"></a>D3初印象</h2><h3 id=\"选择集\"><a href=\"#选择集\" class=\"headerlink\" title=\"选择集\"></a>选择集</h3><p>D3是实现数据可视化，仍然离不开传统DOM的选择和操作，也因此，D3提供了类似Jquery的DOM操作指令：</p>\n<ul>\n<li><code>d3.select</code>：选择第一个指定元素</li>\n<li><code>d3.selectAll</code> ： 选择所有的元素</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> svg = d3.select(<span class=\"string\">'svg'</span>) <span class=\"comment\">//选择svg</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> p = svg.selectAll(<span class=\"string\">'p'</span>) <span class=\"comment\">//选择svg下所有的p标签</span></span><br></pre></td></tr></table></figure>\n<p>当然，可以使用<code>#id</code> 以及 <code>.class</code> 对id和类进行选择</p>\n<h4 id=\"查看状态\"><a href=\"#查看状态\" class=\"headerlink\" title=\"查看状态\"></a>查看状态</h4><p><code>d3.select</code>和<code>d3.selectAll</code>返回的都是选择集，添加、删除以及修改都需要用到选择集，查看状态有三个函数可以使用：</p>\n<ul>\n<li><code>selection.empty()</code>  选择集为空，返回true，否则返回false</li>\n<li><code>selection.node()</code> 返回第一个非空元素，如果选择集为空，返回null</li>\n<li><code>selection.size()</code> 返回选择集中的元素个数</li>\n</ul>\n<h4 id=\"设定和获取属性\"><a href=\"#设定和获取属性\" class=\"headerlink\" title=\"设定和获取属性\"></a>设定和获取属性</h4><p>使用<code>select</code>或<code>selectAll</code>选择后，可以通过<code>attr</code>获取和设定属性，可以使用<code>append</code>方法添加元素<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> svg = select(<span class=\"string\">'svg'</span>);</span><br><span class=\"line\">svg.append(<span class=\"string\">'circle'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'r'</span>,<span class=\"string\">'30'</span>)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用D3和SVG画图\"><a href=\"#使用D3和SVG画图\" class=\"headerlink\" title=\"使用D3和SVG画图\"></a>使用D3和SVG画图</h2><p>html文件<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Smile face with d3<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">svg</span> <span class=\"attr\">width</span>=<span class=\"string\">\"960\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"500\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://d3js.org/d3.v5.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"index.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>主要内容通过index.js实现:</p>\n<h3 id=\"第一步：通过d3选择SVG，使用circle构建轮廓\"><a href=\"#第一步：通过d3选择SVG，使用circle构建轮廓\" class=\"headerlink\" title=\"第一步：通过d3选择SVG，使用circle构建轮廓\"></a>第一步：通过d3选择SVG，使用<code>circle</code>构建轮廓</h3><p><img src=\"http://ww1.sinaimg.cn/mw690/6f9f3683ly1g08ldlcwb6j20fm0e5q3a.jpg\" alt=\"\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> svg = d3.select(<span class=\"string\">'svg'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> height = +svg.attr(<span class=\"string\">'height'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> width = +svg.attr(<span class=\"string\">'width'</span>);</span><br><span class=\"line\">svg.append(<span class=\"string\">'circle'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'r'</span>,height / <span class=\"number\">2</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'cx'</span>, width / <span class=\"number\">2</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'cy'</span>, height / <span class=\"number\">2</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'fill'</span>, <span class=\"string\">'yellow'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'stroke'</span>,<span class=\"string\">'black'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> leftEye = svg.append(<span class=\"string\">'circle'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'r'</span>, <span class=\"number\">30</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'cx'</span>, width / <span class=\"number\">2</span> - <span class=\"number\">100</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'cy'</span>, height / <span class=\"number\">2</span> - <span class=\"number\">80</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'fill'</span>, <span class=\"string\">'black'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> rightEye = svg.append(<span class=\"string\">'circle'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'r'</span>, <span class=\"number\">30</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'cx'</span>, width / <span class=\"number\">2</span> + <span class=\"number\">100</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'cy'</span>, height / <span class=\"number\">2</span> - <span class=\"number\">80</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'fill'</span>, <span class=\"string\">'black'</span>)</span><br></pre></td></tr></table></figure>\n<p>要点：</p>\n<ul>\n<li>通过<code>attr</code>获取的属性是<code>string</code>类型的，通过<code>parseFloat</code>或者<code>+</code>转换为<code>number</code>类型</li>\n<li>对圆形<code>circle</code>的属性<code>cx</code> <code>cy</code>等，使用变量作为其大小设置的值，而不用一个数字，方便日后的维护</li>\n<li>leftEye和RightEye用类似的方法，创造出来，并将眼睛放置在合适的位置。</li>\n</ul>\n<h4 id=\"代码优化\"><a href=\"#代码优化\" class=\"headerlink\" title=\"代码优化\"></a>代码优化</h4><p>1）可以发现，对三个圆圆心的操作<code>cx</code>和<code>cy</code>出现了多次，而作用也仅仅是为了将圆放在中心。因此，可以通过SVG中的<code>&lt;g&gt;</code>来分组来实现一次性操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> g = svg.append(<span class=\"string\">'g'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'transform'</span>,<span class=\"string\">`translate(<span class=\"subst\">$&#123; width <span class=\"regexp\">/ 2&#125;, $&#123; height /</span> <span class=\"number\">2</span>&#125;</span>)`</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这样，在画圆的时候，就可以去掉对其圆心的操作，因为默认的位置就在中心了</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> circle = g.append(<span class=\"string\">'circle'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'r'</span>,height / <span class=\"number\">2</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'fill'</span>, <span class=\"string\">'yellow'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'stroke'</span>,<span class=\"string\">'black'</span>)</span><br></pre></td></tr></table></figure>\n<p>2）同样的，对于眼睛的操作，也有点繁琐，可以通过变量和分组，提高代码的可维护性能。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> eyeSpacing = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> eyeYoffset = <span class=\"number\">-80</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> eyeRadius = <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> eyesG = g.append(<span class=\"string\">'g'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'transform'</span>, <span class=\"string\">`translate(0, <span class=\"subst\">$&#123;eyeYoffset&#125;</span>)`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> leftEye = eyesG.append(<span class=\"string\">'circle'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'r'</span>, eyeRadius)</span><br><span class=\"line\">    .attr(<span class=\"string\">'cx'</span>, - eyeSpacing)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> rightEye = eyesG.append(<span class=\"string\">'circle'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'r'</span>, eyeRadius)</span><br><span class=\"line\">    .attr(<span class=\"string\">'cx'</span>, + eyeSpacing)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"第二步-嘴巴\"><a href=\"#第二步-嘴巴\" class=\"headerlink\" title=\"第二步 嘴巴\"></a>第二步 嘴巴</h3><p><img src=\"http://ww1.sinaimg.cn/mw690/6f9f3683ly1g08oa97tj2j20e00e8dgb.jpg\" alt=\"\"></p>\n<p>嘴巴实际上是一个弧线，使用SVG中的<code>path</code>进行绘制。熟悉<code>path</code>的，当然可以直接给参数进行绘制，但是d3对圆弧有更好的支持，可以使用<code>d3.arc</code>函数，方便的绘制圆弧。</p>\n<h4 id=\"arc函数\"><a href=\"#arc函数\" class=\"headerlink\" title=\"arc函数\"></a>arc函数</h4><p>根据官方的API手册，函数的使用方法如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arc = d3.arc();</span><br><span class=\"line\"></span><br><span class=\"line\">arc(&#123;</span><br><span class=\"line\">  innerRadius: <span class=\"number\">0</span>,</span><br><span class=\"line\">  outerRadius: <span class=\"number\">100</span>,</span><br><span class=\"line\">  startAngle: <span class=\"number\">0</span>,</span><br><span class=\"line\">  endAngle: <span class=\"built_in\">Math</span>.PI / <span class=\"number\">2</span></span><br><span class=\"line\">&#125;); <span class=\"comment\">// \"M0,-100A100,100,0,0,1,100,0L0,0Z\"</span></span><br></pre></td></tr></table></figure></p>\n<p>其中，innerRadius是内圆半径，outerRadius是外圆半径，startAngle和endAngle分别是开始和结束的弧度（完整的圆是0~2PI）</p>\n<h4 id=\"笑脸的实现\"><a href=\"#笑脸的实现\" class=\"headerlink\" title=\"笑脸的实现\"></a>笑脸的实现</h4><p>根据以上内容，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mouth = g.append(<span class=\"string\">'path'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'d'</span>,d3.arc()(&#123;</span><br><span class=\"line\">        innerRadius: <span class=\"number\">150</span>,</span><br><span class=\"line\">        outerRadius: <span class=\"number\">170</span>,</span><br><span class=\"line\">        startAngle: <span class=\"built_in\">Math</span>.PI /<span class=\"number\">2</span>,</span><br><span class=\"line\">        endAngle: <span class=\"built_in\">Math</span>.PI * <span class=\"number\">3</span> / <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;))</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"眉毛\"><a href=\"#眉毛\" class=\"headerlink\" title=\"眉毛\"></a>眉毛</h3><p>眉毛用简单的长方形来代替，也就是svg中的<code>&lt;rect&gt;</code>，使用前文的编程风格，将眉毛归为一个group，并将位置设定。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> eyebrowWidth = <span class=\"number\">50</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> eyebrowHeight = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> eyebrowYoffset = <span class=\"number\">-150</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> BrowG = g.append(<span class=\"string\">'g'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'transform'</span>,<span class=\"string\">`translate(<span class=\"subst\">$&#123;-eyebrowWidth <span class=\"regexp\">/ 2&#125;,$&#123;eyebrowYoffset&#125;)`);</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\"></span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">const leftEyebrow = BrowG.append('rect')</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">    .attr('width',eyebrowWidth)</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">    .attr('height',eyebrowHeight)</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">    .attr('x',-eyeSpacing)</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\"></span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">const rightEyebrow = BrowG.append('rect')</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">    .attr('width', eyebrowWidth)</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">    .attr('height', eyebrowHeight)</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">    .attr('x', eyeSpacing)</span></span></span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"加入动画\"><a href=\"#加入动画\" class=\"headerlink\" title=\"加入动画\"></a>加入动画</h4><p>使用<code>transition</code>函数设置眉毛的动画，让笑脸动起来<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> BrowG = g.append(<span class=\"string\">'g'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'transform'</span>,<span class=\"string\">`translate(<span class=\"subst\">$&#123;-eyebrowWidth <span class=\"regexp\">/ 2&#125;,$&#123;eyebrowYoffset&#125;)`);</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">BrowG.transition().duration(2000)</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">    .attr('transform', `translate($&#123;-eyebrowWidth /</span> <span class=\"number\">2</span>&#125;</span>,<span class=\"subst\">$&#123;eyebrowYoffset - <span class=\"number\">50</span>&#125;</span>)`</span>)</span><br><span class=\"line\">    .transition().duration(<span class=\"number\">2000</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'transform'</span>, <span class=\"string\">`translate(<span class=\"subst\">$&#123;-eyebrowWidth <span class=\"regexp\">/ 2&#125;,$&#123;eyebrowYoffset&#125;)`).duration(2000)</span></span></span></span><br></pre></td></tr></table></figure></p>\n<p><strong>注意点：</strong></p>\n<ul>\n<li><code>transition</code>函数要对号入座，即如果加在了<code>&lt;g&gt;</code>上，对应的增加的属性动画应该在<code>transform</code>上； 如果动画在<code>&lt;rect&gt;</code>上，动画应该在<code>y</code>属性上。</li>\n<li>添加动画不能在<code>append</code>函数之后连接，比如<code>BrowG.append(&#39;g&#39;).attr(...).transition()</code>是不行的。因为过度动画无法绑定在<code>append</code>的元素上，需要分别操作。</li>\n</ul>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><p><a href=\"https://github.com/forrany/Web-Project/blob/master/D3js%E5%8F%AF%E8%A7%86%E5%8C%96/1.Smile%20face%20with%20D3js/index.js\" target=\"_blank\" rel=\"noopener\">code downlaod here</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> svg = d3.select(<span class=\"string\">'svg'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> height = +svg.attr(<span class=\"string\">'height'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> width = +svg.attr(<span class=\"string\">'width'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> g = svg.append(<span class=\"string\">'g'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'transform'</span>,<span class=\"string\">`translate(<span class=\"subst\">$&#123; width <span class=\"regexp\">/ 2&#125;, $&#123; height /</span> <span class=\"number\">2</span>&#125;</span>)`</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> circle = g.append(<span class=\"string\">'circle'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'r'</span>,height / <span class=\"number\">2</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'fill'</span>, <span class=\"string\">'yellow'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'stroke'</span>,<span class=\"string\">'black'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> eyeSpacing = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> eyeYoffset = <span class=\"number\">-80</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> eyeRadius = <span class=\"number\">30</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> eyebrowWidth = <span class=\"number\">50</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> eyebrowHeight = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> eyebrowYoffset = <span class=\"number\">-150</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> eyesG = g.append(<span class=\"string\">'g'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'transform'</span>, <span class=\"string\">`translate(0, <span class=\"subst\">$&#123;eyeYoffset&#125;</span>)`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> leftEye = eyesG.append(<span class=\"string\">'circle'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'r'</span>, eyeRadius)</span><br><span class=\"line\">    .attr(<span class=\"string\">'cx'</span>, - eyeSpacing)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> rightEye = eyesG.append(<span class=\"string\">'circle'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'r'</span>, eyeRadius)</span><br><span class=\"line\">    .attr(<span class=\"string\">'cx'</span>, + eyeSpacing)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mouth = g.append(<span class=\"string\">'path'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'d'</span>,d3.arc()(&#123;</span><br><span class=\"line\">        innerRadius: <span class=\"number\">150</span>,</span><br><span class=\"line\">        outerRadius: <span class=\"number\">170</span>,</span><br><span class=\"line\">        startAngle: <span class=\"built_in\">Math</span>.PI /<span class=\"number\">2</span>,</span><br><span class=\"line\">        endAngle: <span class=\"built_in\">Math</span>.PI * <span class=\"number\">3</span> / <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> BrowG = g.append(<span class=\"string\">'g'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'transform'</span>,<span class=\"string\">`translate(<span class=\"subst\">$&#123;-eyebrowWidth <span class=\"regexp\">/ 2&#125;,$&#123;eyebrowYoffset&#125;)`);</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">BrowG.transition().duration(2000)</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">    .attr('transform', `translate($&#123;-eyebrowWidth /</span> <span class=\"number\">2</span>&#125;</span>,<span class=\"subst\">$&#123;eyebrowYoffset - <span class=\"number\">50</span>&#125;</span>)`</span>)</span><br><span class=\"line\">    .transition().duration(<span class=\"number\">2000</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'transform'</span>, <span class=\"string\">`translate(<span class=\"subst\">$&#123;-eyebrowWidth <span class=\"regexp\">/ 2&#125;,$&#123;eyebrowYoffset&#125;)`).duration(2000)</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\"></span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">const leftEyebrow = BrowG.append('rect')</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">    .attr('width',eyebrowWidth)</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">    .attr('height',eyebrowHeight)</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">    .attr('x',-eyeSpacing)</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\"></span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">const rightEyebrow = BrowG.append('rect')</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">    .attr('width', eyebrowWidth)</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">    .attr('height', eyebrowHeight)</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">    .attr('x', eyeSpacing)</span></span></span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>D3.js是一个基于HTML/SVG/CSS的数据可视化库，是领域内非常强大的存在了。</p>\n<p>今后会在工作使用，也因此开始了自学之旅。学习过程中，我主要通过<a href=\"https://curran.github.io/dataviz-course-2018/\" target=\"_blank\" rel=\"noopener\">Curran Kelleher</a>老师的系列教程进行学习，这个笔记用于学习、整理和分享，陆续学习、更新和记录中….</p>\n<hr>\n<p><strong>学习目的：</strong></p>\n<ul>\n<li>熟悉和认识D3.js</li>\n<li>练习使用SVG画图，熟悉操作</li>\n<li>练习D3.js的基本函数和操作</li>\n</ul>\n<p><strong>完成效果图：</strong><br><a href=\"https://forrany.github.io/Web-Project/D3js%E5%8F%AF%E8%A7%86%E5%8C%96/1.Smile%20face%20with%20D3js/\" target=\"_blank\" rel=\"noopener\">在线demo</a><br><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1g08p6oabibg205r05nmx4.gif\" alt=\"\"></p>\n<h2 id=\"D3初印象\"><a href=\"#D3初印象\" class=\"headerlink\" title=\"D3初印象\"></a>D3初印象</h2><h3 id=\"选择集\"><a href=\"#选择集\" class=\"headerlink\" title=\"选择集\"></a>选择集</h3><p>D3是实现数据可视化，仍然离不开传统DOM的选择和操作，也因此，D3提供了类似Jquery的DOM操作指令：</p>\n<ul>\n<li><code>d3.select</code>：选择第一个指定元素</li>\n<li><code>d3.selectAll</code> ： 选择所有的元素</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> svg = d3.select(<span class=\"string\">'svg'</span>) <span class=\"comment\">//选择svg</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> p = svg.selectAll(<span class=\"string\">'p'</span>) <span class=\"comment\">//选择svg下所有的p标签</span></span><br></pre></td></tr></table></figure>\n<p>当然，可以使用<code>#id</code> 以及 <code>.class</code> 对id和类进行选择</p>\n<h4 id=\"查看状态\"><a href=\"#查看状态\" class=\"headerlink\" title=\"查看状态\"></a>查看状态</h4><p><code>d3.select</code>和<code>d3.selectAll</code>返回的都是选择集，添加、删除以及修改都需要用到选择集，查看状态有三个函数可以使用：</p>\n<ul>\n<li><code>selection.empty()</code>  选择集为空，返回true，否则返回false</li>\n<li><code>selection.node()</code> 返回第一个非空元素，如果选择集为空，返回null</li>\n<li><code>selection.size()</code> 返回选择集中的元素个数</li>\n</ul>\n<h4 id=\"设定和获取属性\"><a href=\"#设定和获取属性\" class=\"headerlink\" title=\"设定和获取属性\"></a>设定和获取属性</h4><p>使用<code>select</code>或<code>selectAll</code>选择后，可以通过<code>attr</code>获取和设定属性，可以使用<code>append</code>方法添加元素<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> svg = select(<span class=\"string\">'svg'</span>);</span><br><span class=\"line\">svg.append(<span class=\"string\">'circle'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'r'</span>,<span class=\"string\">'30'</span>)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用D3和SVG画图\"><a href=\"#使用D3和SVG画图\" class=\"headerlink\" title=\"使用D3和SVG画图\"></a>使用D3和SVG画图</h2><p>html文件<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Smile face with d3<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">svg</span> <span class=\"attr\">width</span>=<span class=\"string\">\"960\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"500\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">svg</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"https://d3js.org/d3.v5.min.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"index.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>主要内容通过index.js实现:</p>\n<h3 id=\"第一步：通过d3选择SVG，使用circle构建轮廓\"><a href=\"#第一步：通过d3选择SVG，使用circle构建轮廓\" class=\"headerlink\" title=\"第一步：通过d3选择SVG，使用circle构建轮廓\"></a>第一步：通过d3选择SVG，使用<code>circle</code>构建轮廓</h3><p><img src=\"http://ww1.sinaimg.cn/mw690/6f9f3683ly1g08ldlcwb6j20fm0e5q3a.jpg\" alt=\"\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> svg = d3.select(<span class=\"string\">'svg'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> height = +svg.attr(<span class=\"string\">'height'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> width = +svg.attr(<span class=\"string\">'width'</span>);</span><br><span class=\"line\">svg.append(<span class=\"string\">'circle'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'r'</span>,height / <span class=\"number\">2</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'cx'</span>, width / <span class=\"number\">2</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'cy'</span>, height / <span class=\"number\">2</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'fill'</span>, <span class=\"string\">'yellow'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'stroke'</span>,<span class=\"string\">'black'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> leftEye = svg.append(<span class=\"string\">'circle'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'r'</span>, <span class=\"number\">30</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'cx'</span>, width / <span class=\"number\">2</span> - <span class=\"number\">100</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'cy'</span>, height / <span class=\"number\">2</span> - <span class=\"number\">80</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'fill'</span>, <span class=\"string\">'black'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> rightEye = svg.append(<span class=\"string\">'circle'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'r'</span>, <span class=\"number\">30</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'cx'</span>, width / <span class=\"number\">2</span> + <span class=\"number\">100</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'cy'</span>, height / <span class=\"number\">2</span> - <span class=\"number\">80</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'fill'</span>, <span class=\"string\">'black'</span>)</span><br></pre></td></tr></table></figure>\n<p>要点：</p>\n<ul>\n<li>通过<code>attr</code>获取的属性是<code>string</code>类型的，通过<code>parseFloat</code>或者<code>+</code>转换为<code>number</code>类型</li>\n<li>对圆形<code>circle</code>的属性<code>cx</code> <code>cy</code>等，使用变量作为其大小设置的值，而不用一个数字，方便日后的维护</li>\n<li>leftEye和RightEye用类似的方法，创造出来，并将眼睛放置在合适的位置。</li>\n</ul>\n<h4 id=\"代码优化\"><a href=\"#代码优化\" class=\"headerlink\" title=\"代码优化\"></a>代码优化</h4><p>1）可以发现，对三个圆圆心的操作<code>cx</code>和<code>cy</code>出现了多次，而作用也仅仅是为了将圆放在中心。因此，可以通过SVG中的<code>&lt;g&gt;</code>来分组来实现一次性操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> g = svg.append(<span class=\"string\">'g'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'transform'</span>,<span class=\"string\">`translate(<span class=\"subst\">$&#123; width <span class=\"regexp\">/ 2&#125;, $&#123; height /</span> <span class=\"number\">2</span>&#125;</span>)`</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这样，在画圆的时候，就可以去掉对其圆心的操作，因为默认的位置就在中心了</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> circle = g.append(<span class=\"string\">'circle'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'r'</span>,height / <span class=\"number\">2</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'fill'</span>, <span class=\"string\">'yellow'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'stroke'</span>,<span class=\"string\">'black'</span>)</span><br></pre></td></tr></table></figure>\n<p>2）同样的，对于眼睛的操作，也有点繁琐，可以通过变量和分组，提高代码的可维护性能。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> eyeSpacing = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> eyeYoffset = <span class=\"number\">-80</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> eyeRadius = <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> eyesG = g.append(<span class=\"string\">'g'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'transform'</span>, <span class=\"string\">`translate(0, <span class=\"subst\">$&#123;eyeYoffset&#125;</span>)`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> leftEye = eyesG.append(<span class=\"string\">'circle'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'r'</span>, eyeRadius)</span><br><span class=\"line\">    .attr(<span class=\"string\">'cx'</span>, - eyeSpacing)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> rightEye = eyesG.append(<span class=\"string\">'circle'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'r'</span>, eyeRadius)</span><br><span class=\"line\">    .attr(<span class=\"string\">'cx'</span>, + eyeSpacing)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"第二步-嘴巴\"><a href=\"#第二步-嘴巴\" class=\"headerlink\" title=\"第二步 嘴巴\"></a>第二步 嘴巴</h3><p><img src=\"http://ww1.sinaimg.cn/mw690/6f9f3683ly1g08oa97tj2j20e00e8dgb.jpg\" alt=\"\"></p>\n<p>嘴巴实际上是一个弧线，使用SVG中的<code>path</code>进行绘制。熟悉<code>path</code>的，当然可以直接给参数进行绘制，但是d3对圆弧有更好的支持，可以使用<code>d3.arc</code>函数，方便的绘制圆弧。</p>\n<h4 id=\"arc函数\"><a href=\"#arc函数\" class=\"headerlink\" title=\"arc函数\"></a>arc函数</h4><p>根据官方的API手册，函数的使用方法如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arc = d3.arc();</span><br><span class=\"line\"></span><br><span class=\"line\">arc(&#123;</span><br><span class=\"line\">  innerRadius: <span class=\"number\">0</span>,</span><br><span class=\"line\">  outerRadius: <span class=\"number\">100</span>,</span><br><span class=\"line\">  startAngle: <span class=\"number\">0</span>,</span><br><span class=\"line\">  endAngle: <span class=\"built_in\">Math</span>.PI / <span class=\"number\">2</span></span><br><span class=\"line\">&#125;); <span class=\"comment\">// \"M0,-100A100,100,0,0,1,100,0L0,0Z\"</span></span><br></pre></td></tr></table></figure></p>\n<p>其中，innerRadius是内圆半径，outerRadius是外圆半径，startAngle和endAngle分别是开始和结束的弧度（完整的圆是0~2PI）</p>\n<h4 id=\"笑脸的实现\"><a href=\"#笑脸的实现\" class=\"headerlink\" title=\"笑脸的实现\"></a>笑脸的实现</h4><p>根据以上内容，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> mouth = g.append(<span class=\"string\">'path'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'d'</span>,d3.arc()(&#123;</span><br><span class=\"line\">        innerRadius: <span class=\"number\">150</span>,</span><br><span class=\"line\">        outerRadius: <span class=\"number\">170</span>,</span><br><span class=\"line\">        startAngle: <span class=\"built_in\">Math</span>.PI /<span class=\"number\">2</span>,</span><br><span class=\"line\">        endAngle: <span class=\"built_in\">Math</span>.PI * <span class=\"number\">3</span> / <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;))</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"眉毛\"><a href=\"#眉毛\" class=\"headerlink\" title=\"眉毛\"></a>眉毛</h3><p>眉毛用简单的长方形来代替，也就是svg中的<code>&lt;rect&gt;</code>，使用前文的编程风格，将眉毛归为一个group，并将位置设定。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> eyebrowWidth = <span class=\"number\">50</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> eyebrowHeight = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> eyebrowYoffset = <span class=\"number\">-150</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> BrowG = g.append(<span class=\"string\">'g'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'transform'</span>,<span class=\"string\">`translate(<span class=\"subst\">$&#123;-eyebrowWidth <span class=\"regexp\">/ 2&#125;,$&#123;eyebrowYoffset&#125;)`);</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\"></span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">const leftEyebrow = BrowG.append('rect')</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">    .attr('width',eyebrowWidth)</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">    .attr('height',eyebrowHeight)</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">    .attr('x',-eyeSpacing)</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\"></span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">const rightEyebrow = BrowG.append('rect')</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">    .attr('width', eyebrowWidth)</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">    .attr('height', eyebrowHeight)</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">    .attr('x', eyeSpacing)</span></span></span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"加入动画\"><a href=\"#加入动画\" class=\"headerlink\" title=\"加入动画\"></a>加入动画</h4><p>使用<code>transition</code>函数设置眉毛的动画，让笑脸动起来<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> BrowG = g.append(<span class=\"string\">'g'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'transform'</span>,<span class=\"string\">`translate(<span class=\"subst\">$&#123;-eyebrowWidth <span class=\"regexp\">/ 2&#125;,$&#123;eyebrowYoffset&#125;)`);</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">BrowG.transition().duration(2000)</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">    .attr('transform', `translate($&#123;-eyebrowWidth /</span> <span class=\"number\">2</span>&#125;</span>,<span class=\"subst\">$&#123;eyebrowYoffset - <span class=\"number\">50</span>&#125;</span>)`</span>)</span><br><span class=\"line\">    .transition().duration(<span class=\"number\">2000</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'transform'</span>, <span class=\"string\">`translate(<span class=\"subst\">$&#123;-eyebrowWidth <span class=\"regexp\">/ 2&#125;,$&#123;eyebrowYoffset&#125;)`).duration(2000)</span></span></span></span><br></pre></td></tr></table></figure></p>\n<p><strong>注意点：</strong></p>\n<ul>\n<li><code>transition</code>函数要对号入座，即如果加在了<code>&lt;g&gt;</code>上，对应的增加的属性动画应该在<code>transform</code>上； 如果动画在<code>&lt;rect&gt;</code>上，动画应该在<code>y</code>属性上。</li>\n<li>添加动画不能在<code>append</code>函数之后连接，比如<code>BrowG.append(&#39;g&#39;).attr(...).transition()</code>是不行的。因为过度动画无法绑定在<code>append</code>的元素上，需要分别操作。</li>\n</ul>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><p><a href=\"https://github.com/forrany/Web-Project/blob/master/D3js%E5%8F%AF%E8%A7%86%E5%8C%96/1.Smile%20face%20with%20D3js/index.js\" target=\"_blank\" rel=\"noopener\">code downlaod here</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> svg = d3.select(<span class=\"string\">'svg'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> height = +svg.attr(<span class=\"string\">'height'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> width = +svg.attr(<span class=\"string\">'width'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> g = svg.append(<span class=\"string\">'g'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'transform'</span>,<span class=\"string\">`translate(<span class=\"subst\">$&#123; width <span class=\"regexp\">/ 2&#125;, $&#123; height /</span> <span class=\"number\">2</span>&#125;</span>)`</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> circle = g.append(<span class=\"string\">'circle'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'r'</span>,height / <span class=\"number\">2</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'fill'</span>, <span class=\"string\">'yellow'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'stroke'</span>,<span class=\"string\">'black'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> eyeSpacing = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> eyeYoffset = <span class=\"number\">-80</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> eyeRadius = <span class=\"number\">30</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> eyebrowWidth = <span class=\"number\">50</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> eyebrowHeight = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> eyebrowYoffset = <span class=\"number\">-150</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> eyesG = g.append(<span class=\"string\">'g'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'transform'</span>, <span class=\"string\">`translate(0, <span class=\"subst\">$&#123;eyeYoffset&#125;</span>)`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> leftEye = eyesG.append(<span class=\"string\">'circle'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'r'</span>, eyeRadius)</span><br><span class=\"line\">    .attr(<span class=\"string\">'cx'</span>, - eyeSpacing)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> rightEye = eyesG.append(<span class=\"string\">'circle'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'r'</span>, eyeRadius)</span><br><span class=\"line\">    .attr(<span class=\"string\">'cx'</span>, + eyeSpacing)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mouth = g.append(<span class=\"string\">'path'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'d'</span>,d3.arc()(&#123;</span><br><span class=\"line\">        innerRadius: <span class=\"number\">150</span>,</span><br><span class=\"line\">        outerRadius: <span class=\"number\">170</span>,</span><br><span class=\"line\">        startAngle: <span class=\"built_in\">Math</span>.PI /<span class=\"number\">2</span>,</span><br><span class=\"line\">        endAngle: <span class=\"built_in\">Math</span>.PI * <span class=\"number\">3</span> / <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> BrowG = g.append(<span class=\"string\">'g'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'transform'</span>,<span class=\"string\">`translate(<span class=\"subst\">$&#123;-eyebrowWidth <span class=\"regexp\">/ 2&#125;,$&#123;eyebrowYoffset&#125;)`);</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">BrowG.transition().duration(2000)</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">    .attr('transform', `translate($&#123;-eyebrowWidth /</span> <span class=\"number\">2</span>&#125;</span>,<span class=\"subst\">$&#123;eyebrowYoffset - <span class=\"number\">50</span>&#125;</span>)`</span>)</span><br><span class=\"line\">    .transition().duration(<span class=\"number\">2000</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'transform'</span>, <span class=\"string\">`translate(<span class=\"subst\">$&#123;-eyebrowWidth <span class=\"regexp\">/ 2&#125;,$&#123;eyebrowYoffset&#125;)`).duration(2000)</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\"></span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">const leftEyebrow = BrowG.append('rect')</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">    .attr('width',eyebrowWidth)</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">    .attr('height',eyebrowHeight)</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">    .attr('x',-eyeSpacing)</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\"></span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">const rightEyebrow = BrowG.append('rect')</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">    .attr('width', eyebrowWidth)</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">    .attr('height', eyebrowHeight)</span></span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"subst\"><span class=\"regexp\">    .attr('x', eyeSpacing)</span></span></span></span><br></pre></td></tr></table></figure>"},{"title":"PipeRobot 串口传输协议说明","date":"2019-03-23T07:42:38.000Z","_content":"\n树莓派作为服务器，接收手机/PC端发送的控制指令后，通过UART串口将控制指令进行转发，这里对指令协议进行说明\n\n## 通讯协议\n\n| 数据编号 | 数据内容 | 含义     |\n| :------- | -------: | :------: |\n| 0        | 0x55     | 包头     |\n| 1        | command  | 控制指令 |\n| 2        | speed    | 速度     |\n\n每帧数据都包含了3个字节的数据，分别为包头、控制指令和速度，其中包头均以`0x55`开头，可以在接收数据时做简单的校验。\n\n### 控制指令\n\n第二个字节控制指令主要包括了：\n* 前进 `0x01`\n* 后退 `0x02`\n* 伸张 `0x03`\n* 收缩 `0x04`\n* 停止 `0x05`\n\n下位机在接受数据时，根据第二字节数据判断指令内容\n\n### 速度\n\n第三个字节是速度，范围是`[0x00,0x64]`(即十进制的0~100)。\n\n下位机在接收到数据时，可以根据速度对电机的转速进行相应的控制\n\n## 下位机程序参考\n\n下位机使用ARM系列芯片，实现对机器人的控制，这里主要对串口协议部分给出程序参考\n\n### 中断部分\n\n```C\nunsigned char Re_buf[11],counter=0;\nunsigned char sign;\nvoid USART2_IRQHandler(void)\t\t   //串口2全局中断服务函数\n{\n\tif(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)  //接收中断有效,若接收数据寄存器满\n  \t{\n\t\tRe_buf[counter] = USART_ReceiveData(USART2);\t//接收数据\n\t\tif(counter == 0 && Re_buf[0] != 0x55) return;      //第 0 号数据不是帧头，跳过\n\t\tcounter++; \n\t\tif(counter==3) //接收到 11 个数据\n\t\t{ \n\t\t\tcounter=0; //重新赋值，准备下一帧数据的接收\n\t\t\tsign=1;  //sign作为标志，表示收到数据，可以在主程序中检测该状态，以进行相应的内容\n\t\t}\n\t}\n}\n\n```\n\n### 主程序\n\n在主程序中，根据指令的内容，进行不同的控制\n```C\nu16 speed;\nextern unsigned char Re_buf[11],counter;\nextern unsigned char sign;\n while (1)\n   {\n      if(sign)\n      {  \n        sign = 0;\n        if(Re_buf[0]==0x55)       //检查帧头\n        {  \n           speed = speedMap(Re_buf[2]); //写一个函数，将0~100映射到0~999\n           switch(Re_buf[1])\n           {\n              case 0x01: //标识前进\n                Motor1_control(0,speed) //前进\n                break;\n              case 0x02: //标识后退\n                Motor1_control(speed,0) //前进\n                break;\n              case 0x53: //标识伸长\n                Motor2_control(900,0); //直接900的速度伸长，忽略速度\n                break;\n              case 0x54: //标识收缩\n                Motor2_control(0,900);直接900的速度收缩，忽略速度\n                break;\n              case 0x55: //标识停止\n                GPIO_ResetBits(GPIOC,GPIO_Pin_7); //拉低使能端\n                break;\n              default:  break;\n           }\t\t\t\n        }   \n      }\n```\n\n#### 注意点\n\n收缩和伸展均以较高的速度进行，原因在于原程序中使用了编码器检测速度变化的方式，来自动停止伸缩和伸长。\n\n当速度较低的时，会影响其正常工作，且一般伸长、收缩需要尽快完成。","source":"_posts/year-03-23-PipeRobot-串口传输协议说明.md","raw":"---\ntitle: PipeRobot 串口传输协议说明\ndate: 2019-03-23 15:42:38\ntags: \n    - 串口协议说明\n---\n\n树莓派作为服务器，接收手机/PC端发送的控制指令后，通过UART串口将控制指令进行转发，这里对指令协议进行说明\n\n## 通讯协议\n\n| 数据编号 | 数据内容 | 含义     |\n| :------- | -------: | :------: |\n| 0        | 0x55     | 包头     |\n| 1        | command  | 控制指令 |\n| 2        | speed    | 速度     |\n\n每帧数据都包含了3个字节的数据，分别为包头、控制指令和速度，其中包头均以`0x55`开头，可以在接收数据时做简单的校验。\n\n### 控制指令\n\n第二个字节控制指令主要包括了：\n* 前进 `0x01`\n* 后退 `0x02`\n* 伸张 `0x03`\n* 收缩 `0x04`\n* 停止 `0x05`\n\n下位机在接受数据时，根据第二字节数据判断指令内容\n\n### 速度\n\n第三个字节是速度，范围是`[0x00,0x64]`(即十进制的0~100)。\n\n下位机在接收到数据时，可以根据速度对电机的转速进行相应的控制\n\n## 下位机程序参考\n\n下位机使用ARM系列芯片，实现对机器人的控制，这里主要对串口协议部分给出程序参考\n\n### 中断部分\n\n```C\nunsigned char Re_buf[11],counter=0;\nunsigned char sign;\nvoid USART2_IRQHandler(void)\t\t   //串口2全局中断服务函数\n{\n\tif(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)  //接收中断有效,若接收数据寄存器满\n  \t{\n\t\tRe_buf[counter] = USART_ReceiveData(USART2);\t//接收数据\n\t\tif(counter == 0 && Re_buf[0] != 0x55) return;      //第 0 号数据不是帧头，跳过\n\t\tcounter++; \n\t\tif(counter==3) //接收到 11 个数据\n\t\t{ \n\t\t\tcounter=0; //重新赋值，准备下一帧数据的接收\n\t\t\tsign=1;  //sign作为标志，表示收到数据，可以在主程序中检测该状态，以进行相应的内容\n\t\t}\n\t}\n}\n\n```\n\n### 主程序\n\n在主程序中，根据指令的内容，进行不同的控制\n```C\nu16 speed;\nextern unsigned char Re_buf[11],counter;\nextern unsigned char sign;\n while (1)\n   {\n      if(sign)\n      {  \n        sign = 0;\n        if(Re_buf[0]==0x55)       //检查帧头\n        {  \n           speed = speedMap(Re_buf[2]); //写一个函数，将0~100映射到0~999\n           switch(Re_buf[1])\n           {\n              case 0x01: //标识前进\n                Motor1_control(0,speed) //前进\n                break;\n              case 0x02: //标识后退\n                Motor1_control(speed,0) //前进\n                break;\n              case 0x53: //标识伸长\n                Motor2_control(900,0); //直接900的速度伸长，忽略速度\n                break;\n              case 0x54: //标识收缩\n                Motor2_control(0,900);直接900的速度收缩，忽略速度\n                break;\n              case 0x55: //标识停止\n                GPIO_ResetBits(GPIOC,GPIO_Pin_7); //拉低使能端\n                break;\n              default:  break;\n           }\t\t\t\n        }   \n      }\n```\n\n#### 注意点\n\n收缩和伸展均以较高的速度进行，原因在于原程序中使用了编码器检测速度变化的方式，来自动停止伸缩和伸长。\n\n当速度较低的时，会影响其正常工作，且一般伸长、收缩需要尽快完成。","slug":"PipeRobot-串口传输协议说明","published":1,"updated":"2022-08-17T07:53:21.232Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6xbhzka0011zk08ei5iidhu","content":"<p>树莓派作为服务器，接收手机/PC端发送的控制指令后，通过UART串口将控制指令进行转发，这里对指令协议进行说明</p>\n<h2 id=\"通讯协议\"><a href=\"#通讯协议\" class=\"headerlink\" title=\"通讯协议\"></a>通讯协议</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">数据编号</th>\n<th style=\"text-align:right\">数据内容</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:right\">0x55</td>\n<td style=\"text-align:center\">包头</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:right\">command</td>\n<td style=\"text-align:center\">控制指令</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:right\">speed</td>\n<td style=\"text-align:center\">速度</td>\n</tr>\n</tbody>\n</table>\n<p>每帧数据都包含了3个字节的数据，分别为包头、控制指令和速度，其中包头均以<code>0x55</code>开头，可以在接收数据时做简单的校验。</p>\n<h3 id=\"控制指令\"><a href=\"#控制指令\" class=\"headerlink\" title=\"控制指令\"></a>控制指令</h3><p>第二个字节控制指令主要包括了：</p>\n<ul>\n<li>前进 <code>0x01</code></li>\n<li>后退 <code>0x02</code></li>\n<li>伸张 <code>0x03</code></li>\n<li>收缩 <code>0x04</code></li>\n<li>停止 <code>0x05</code></li>\n</ul>\n<p>下位机在接受数据时，根据第二字节数据判断指令内容</p>\n<h3 id=\"速度\"><a href=\"#速度\" class=\"headerlink\" title=\"速度\"></a>速度</h3><p>第三个字节是速度，范围是<code>[0x00,0x64]</code>(即十进制的0~100)。</p>\n<p>下位机在接收到数据时，可以根据速度对电机的转速进行相应的控制</p>\n<h2 id=\"下位机程序参考\"><a href=\"#下位机程序参考\" class=\"headerlink\" title=\"下位机程序参考\"></a>下位机程序参考</h2><p>下位机使用ARM系列芯片，实现对机器人的控制，这里主要对串口协议部分给出程序参考</p>\n<h3 id=\"中断部分\"><a href=\"#中断部分\" class=\"headerlink\" title=\"中断部分\"></a>中断部分</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> Re_buf[<span class=\"number\">11</span>],counter=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> sign;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">USART2_IRQHandler</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span>\t\t   <span class=\"comment\">//串口2全局中断服务函数</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)  <span class=\"comment\">//接收中断有效,若接收数据寄存器满</span></span><br><span class=\"line\">  \t&#123;</span><br><span class=\"line\">\t\tRe_buf[counter] = USART_ReceiveData(USART2);\t<span class=\"comment\">//接收数据</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(counter == <span class=\"number\">0</span> &amp;&amp; Re_buf[<span class=\"number\">0</span>] != <span class=\"number\">0x55</span>) <span class=\"keyword\">return</span>;      <span class=\"comment\">//第 0 号数据不是帧头，跳过</span></span><br><span class=\"line\">\t\tcounter++; </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(counter==<span class=\"number\">3</span>) <span class=\"comment\">//接收到 11 个数据</span></span><br><span class=\"line\">\t\t&#123; </span><br><span class=\"line\">\t\t\tcounter=<span class=\"number\">0</span>; <span class=\"comment\">//重新赋值，准备下一帧数据的接收</span></span><br><span class=\"line\">\t\t\tsign=<span class=\"number\">1</span>;  <span class=\"comment\">//sign作为标志，表示收到数据，可以在主程序中检测该状态，以进行相应的内容</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"主程序\"><a href=\"#主程序\" class=\"headerlink\" title=\"主程序\"></a>主程序</h3><p>在主程序中，根据指令的内容，进行不同的控制<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">u16 speed;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> Re_buf[<span class=\"number\">11</span>],counter;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> sign;</span><br><span class=\"line\"> <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(sign)</span><br><span class=\"line\">      &#123;  </span><br><span class=\"line\">        sign = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(Re_buf[<span class=\"number\">0</span>]==<span class=\"number\">0x55</span>)       <span class=\"comment\">//检查帧头</span></span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">           speed = speedMap(Re_buf[<span class=\"number\">2</span>]); <span class=\"comment\">//写一个函数，将0~100映射到0~999</span></span><br><span class=\"line\">           <span class=\"keyword\">switch</span>(Re_buf[<span class=\"number\">1</span>])</span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">              <span class=\"keyword\">case</span> <span class=\"number\">0x01</span>: <span class=\"comment\">//标识前进</span></span><br><span class=\"line\">                Motor1_control(<span class=\"number\">0</span>,speed) <span class=\"comment\">//前进</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">              <span class=\"keyword\">case</span> <span class=\"number\">0x02</span>: <span class=\"comment\">//标识后退</span></span><br><span class=\"line\">                Motor1_control(speed,<span class=\"number\">0</span>) <span class=\"comment\">//前进</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">              <span class=\"keyword\">case</span> <span class=\"number\">0x53</span>: <span class=\"comment\">//标识伸长</span></span><br><span class=\"line\">                Motor2_control(<span class=\"number\">900</span>,<span class=\"number\">0</span>); <span class=\"comment\">//直接900的速度伸长，忽略速度</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">              <span class=\"keyword\">case</span> <span class=\"number\">0x54</span>: <span class=\"comment\">//标识收缩</span></span><br><span class=\"line\">                Motor2_control(<span class=\"number\">0</span>,<span class=\"number\">900</span>);直接<span class=\"number\">900</span>的速度收缩，忽略速度</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">              <span class=\"keyword\">case</span> <span class=\"number\">0x55</span>: <span class=\"comment\">//标识停止</span></span><br><span class=\"line\">                GPIO_ResetBits(GPIOC,GPIO_Pin_7); <span class=\"comment\">//拉低使能端</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">              <span class=\"keyword\">default</span>:  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           &#125;\t\t\t</span><br><span class=\"line\">        &#125;   </span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h4><p>收缩和伸展均以较高的速度进行，原因在于原程序中使用了编码器检测速度变化的方式，来自动停止伸缩和伸长。</p>\n<p>当速度较低的时，会影响其正常工作，且一般伸长、收缩需要尽快完成。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>树莓派作为服务器，接收手机/PC端发送的控制指令后，通过UART串口将控制指令进行转发，这里对指令协议进行说明</p>\n<h2 id=\"通讯协议\"><a href=\"#通讯协议\" class=\"headerlink\" title=\"通讯协议\"></a>通讯协议</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">数据编号</th>\n<th style=\"text-align:right\">数据内容</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:right\">0x55</td>\n<td style=\"text-align:center\">包头</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:right\">command</td>\n<td style=\"text-align:center\">控制指令</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:right\">speed</td>\n<td style=\"text-align:center\">速度</td>\n</tr>\n</tbody>\n</table>\n<p>每帧数据都包含了3个字节的数据，分别为包头、控制指令和速度，其中包头均以<code>0x55</code>开头，可以在接收数据时做简单的校验。</p>\n<h3 id=\"控制指令\"><a href=\"#控制指令\" class=\"headerlink\" title=\"控制指令\"></a>控制指令</h3><p>第二个字节控制指令主要包括了：</p>\n<ul>\n<li>前进 <code>0x01</code></li>\n<li>后退 <code>0x02</code></li>\n<li>伸张 <code>0x03</code></li>\n<li>收缩 <code>0x04</code></li>\n<li>停止 <code>0x05</code></li>\n</ul>\n<p>下位机在接受数据时，根据第二字节数据判断指令内容</p>\n<h3 id=\"速度\"><a href=\"#速度\" class=\"headerlink\" title=\"速度\"></a>速度</h3><p>第三个字节是速度，范围是<code>[0x00,0x64]</code>(即十进制的0~100)。</p>\n<p>下位机在接收到数据时，可以根据速度对电机的转速进行相应的控制</p>\n<h2 id=\"下位机程序参考\"><a href=\"#下位机程序参考\" class=\"headerlink\" title=\"下位机程序参考\"></a>下位机程序参考</h2><p>下位机使用ARM系列芯片，实现对机器人的控制，这里主要对串口协议部分给出程序参考</p>\n<h3 id=\"中断部分\"><a href=\"#中断部分\" class=\"headerlink\" title=\"中断部分\"></a>中断部分</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> Re_buf[<span class=\"number\">11</span>],counter=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> sign;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">USART2_IRQHandler</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span>\t\t   <span class=\"comment\">//串口2全局中断服务函数</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)  <span class=\"comment\">//接收中断有效,若接收数据寄存器满</span></span><br><span class=\"line\">  \t&#123;</span><br><span class=\"line\">\t\tRe_buf[counter] = USART_ReceiveData(USART2);\t<span class=\"comment\">//接收数据</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(counter == <span class=\"number\">0</span> &amp;&amp; Re_buf[<span class=\"number\">0</span>] != <span class=\"number\">0x55</span>) <span class=\"keyword\">return</span>;      <span class=\"comment\">//第 0 号数据不是帧头，跳过</span></span><br><span class=\"line\">\t\tcounter++; </span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(counter==<span class=\"number\">3</span>) <span class=\"comment\">//接收到 11 个数据</span></span><br><span class=\"line\">\t\t&#123; </span><br><span class=\"line\">\t\t\tcounter=<span class=\"number\">0</span>; <span class=\"comment\">//重新赋值，准备下一帧数据的接收</span></span><br><span class=\"line\">\t\t\tsign=<span class=\"number\">1</span>;  <span class=\"comment\">//sign作为标志，表示收到数据，可以在主程序中检测该状态，以进行相应的内容</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"主程序\"><a href=\"#主程序\" class=\"headerlink\" title=\"主程序\"></a>主程序</h3><p>在主程序中，根据指令的内容，进行不同的控制<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">u16 speed;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> Re_buf[<span class=\"number\">11</span>],counter;</span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> sign;</span><br><span class=\"line\"> <span class=\"keyword\">while</span> (<span class=\"number\">1</span>)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(sign)</span><br><span class=\"line\">      &#123;  </span><br><span class=\"line\">        sign = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(Re_buf[<span class=\"number\">0</span>]==<span class=\"number\">0x55</span>)       <span class=\"comment\">//检查帧头</span></span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">           speed = speedMap(Re_buf[<span class=\"number\">2</span>]); <span class=\"comment\">//写一个函数，将0~100映射到0~999</span></span><br><span class=\"line\">           <span class=\"keyword\">switch</span>(Re_buf[<span class=\"number\">1</span>])</span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">              <span class=\"keyword\">case</span> <span class=\"number\">0x01</span>: <span class=\"comment\">//标识前进</span></span><br><span class=\"line\">                Motor1_control(<span class=\"number\">0</span>,speed) <span class=\"comment\">//前进</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">              <span class=\"keyword\">case</span> <span class=\"number\">0x02</span>: <span class=\"comment\">//标识后退</span></span><br><span class=\"line\">                Motor1_control(speed,<span class=\"number\">0</span>) <span class=\"comment\">//前进</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">              <span class=\"keyword\">case</span> <span class=\"number\">0x53</span>: <span class=\"comment\">//标识伸长</span></span><br><span class=\"line\">                Motor2_control(<span class=\"number\">900</span>,<span class=\"number\">0</span>); <span class=\"comment\">//直接900的速度伸长，忽略速度</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">              <span class=\"keyword\">case</span> <span class=\"number\">0x54</span>: <span class=\"comment\">//标识收缩</span></span><br><span class=\"line\">                Motor2_control(<span class=\"number\">0</span>,<span class=\"number\">900</span>);直接<span class=\"number\">900</span>的速度收缩，忽略速度</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">              <span class=\"keyword\">case</span> <span class=\"number\">0x55</span>: <span class=\"comment\">//标识停止</span></span><br><span class=\"line\">                GPIO_ResetBits(GPIOC,GPIO_Pin_7); <span class=\"comment\">//拉低使能端</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">              <span class=\"keyword\">default</span>:  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">           &#125;\t\t\t</span><br><span class=\"line\">        &#125;   </span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h4><p>收缩和伸展均以较高的速度进行，原因在于原程序中使用了编码器检测速度变化的方式，来自动停止伸缩和伸长。</p>\n<p>当速度较低的时，会影响其正常工作，且一般伸长、收缩需要尽快完成。</p>\n"},{"title":"D3 动画与插值","date":"2020-03-13T12:15:24.000Z","author":"Vinecnt Ko","_content":"\n## D3 动画\n\nD3.js提供了多种工具支持数据可视化的交互，其中`d3.transition`让简单而高效的为图像添加动画成为了可能。\n\n单单从API来讲，`d3.transition`非常简单，用法类似Jquery。 但是想要设计出理想的动画效果，就不得不提到D3绘制图形的一个核心概念`General Update Pattern`. D3的数据驱动特性的核心和实现就是依靠这个Pattern，而动画和交互自然要从它说起了。\n\n> 并不是所有图形都必须遵循Update Pattern，比如一次性绘图，无交互的静态图形等。但如果涉及到了动态数据，这个Update Pattern不仅利于写出易于维护的代码，也能更好的发挥D3强大的功能。\n\n## General Update Pattern\n\n![image-20200308211328582](/../images/update-pattern.png)\n\nD3的数据驱动模式如上图所示，当使用`d3.data()`将数据`Array`与DOM元素绑定的时，数据与元素之间有着三个阶段，即\n\n- Enter 已有数据，但页面还未有与之对应的DOM\n- Update 数据元素与DOM元素相绑定\n- Exit 数据元素已经被删除，但DOM元素还存在，即失去了绑定元素的DOM\n\n关于这个点，这里不做详细赘述，可参考文档。这里直接对V4和V5版本的`General Update Pattern`进行介绍。举一个简单的例子：\n\n> 假设目前已有数据['a', 'b', 'c'....]等字母序列，现在希望通过D3,使用SVG将其呈现在页面上\n\n### V4\n\n通过`selection.enter()`, `selection.exit()`与 `selection`（update）分别指定相应逻辑，内容如下：\n\n```js\nconst d3Pattern = (dataSet) => {\n  const text = g.selectAll('text').data(dataSet)  // 数据绑定\n  \n  text.enter()     // enter() 返回绑定数据但是还未生成dom元素的部分\n      .append('text')\n      .attr('class', 'new')\n      .text(d => d)\n      .merge(text)  // merge后面的代码，将会分别应用于enter于update两个部分，省略写法\n  \t\t\t.attr('x', (d, i) => 18 * i)\n  \n  text.attr('class', 'update')  // text 本身是update部分\n\n  text.exit().remove()  // exit() 返回数据已经被删除，但是还存在dom的元素\n}\n```\n\n### V5\n\nd3 V5.8.0 引入了一个新的API， `selection.join` \n\n这个API的优势在于，对于一些比较简单、不需要特殊定义enter\\exit过程的动作的d3图形，可以简化代码，以上的代码，使用V5的版本写，即\n\n```js\nconst d3Pattern = (dataSet) => {\n  const text = g.selectAll('text').data(dataSet)  // 数据绑定\n  \n  text.join(\n    enter => enter.append('text')\n    \t.attr('calss', 'new')\n    \t.text(d => d),\n    update => update.attr('class', 'update')\n  )\n    .attr('x', (d, i) => 18 * i)\n  \n  // join的exit默认就是 exit().remove()，因此可以免去\n}\n```\n\n可以发现，使用`selection.join()`, 并不需要再手动写`selection.exit().remove()`，这是因为`selection.join()`这个函数默认的`exit()`函数已经帮你写好了，该API下，d3的Update Pattern可以写为\n\n```js\nselection.join(\n    enter => // enter.. ,\n    update => // update.. ,\n    exit => // exit.. \n  )\n  // 注意，enter，update等函数一定要return，这样可以对selection继续链式调用\n```\n\n当然，这个API的好处在于，一般的使用场景下（不需要在enter、exit等加特殊的动画或操作），完全可以简写，比如：\n\n```js\nsvg.selectAll(\"circle\")\n  .data(data)\n  .join(\"circle\")\n    .attr(\"fill\", \"none\")\n    .attr(\"stroke\", \"black\");\n```\n\n以上的写法，完全等价于\n\n```js\nsvg.selectAll(\"circle\")\n  .data(data)\n  .join(\n    enter => enter.append(\"circle\"),\n    update => update,\n    exit => exit.remove()\n  )\n    .attr(\"fill\", \"none\")\n    .attr(\"stroke\", \"black\");\n```\n\n等价于V4版本的\n\n```js\ncircles = svg.selectAll('circle')\n\t.data(data)\n\ncircles.enter()\n\t.append('circle')\n\t.merge('circle')\n\t\t.attr('fill', 'none')\n\t\t.attr('stroke', 'black')\n\ncircles.exit().remove()\n```\n\n当然，V5完全兼容V4的update Pattern，无论是V4还是V5的新版API，这种Update Pattern的本质没有变，D3仍然是数据绑定，enter/update/exit的工作模式。\n\n### Pattern中的key\n\n当使用`d3.data()`绑定数据和dom时，相对应的关系，可能第一个元素对应第一个dom，第二元素对应第二dom等； 但当`Array`发生变化时，比如重新排序、插入等操作，这时候，数组中元素可能与dom的绑定关系就发生了一些微妙的变化。\n\n最直观的例子就比如动态改变字符的例子\n\n![Kapture 2020-03-08 at 21.56.19](/../images/text-transition.gif)\n\n如图，发现新增的字符总是排在最后，实际上，如果数据一致保持和dom绑定的话，理论随机生成新字符，完全应该有机会出现在中间的。\n\n在数据绑定时，传入一个唯一的key值，即可避免这种情况发生\n\n```js\nselection.data(data, d => d.id)\n```\n\n完成以上步骤，只要定时的调用函数`d3Pattern`，传入不同的data，即可实现上图的效果\n\n[完整代码](https://codepen.io/vincenttgao/pen/rNVYoYw)\n\n## Transition\n\n好了，前面铺垫了这么多，终于到了主角`d3.transition`了，但实际上，与之相关API屈指可数，想要让d3画出带交互和炫酷过渡效果的，重点还是对Update Pattern理解透彻。\n\n### 基本动画使用\n\n`transition` 的使用，与jquery十分类似，使用时，只需要对选择的元素调用，并指定修改的属性即可，即`selection.transition().attr(...)`\n\n比如现在画布上有一个方块，该元素为`rect`,我想要使其位置从默认的地方，到30位置，并加上动画，代码为\n\n```js\nrect.transition()\n\t.attr('x', 30)  //  设置新位置\n```\n\n效果如下\n\n![Kapture 2020-03-08 at 22.17.46](/../images/move-box.gif)\n\n动画的基本使用，就是如此简单，下面简单看下相关的api\n\n| 方法                   | 描述                                                         |\n| ---------------------- | ------------------------------------------------------------ |\n| selection.transition() | this schedules a transition for the selected elements        |\n| transition.duration()  | duration specifies the animation duration in milliseconds for each element |\n| transition.ease()      | ease specifies the easing function, example: linear, elastic, bounce |\n| transition.delay()     | delay specifies the delay in animation in milliseconds for each element |\n\n这里注意d3的api都支持链式调用，因此比如上面的例子，希望将动画时间设置为1s，可以\n\n```js\nrect.transition()\n\t.duration(1000)\n\t.attr('x', 30)  //  设置新位置\n```\n\n同理，ease和delay可以分别设置动画曲线和延迟。\n\n### Update Pattern下的动画\n\n回到最开始的例子，这里用V4版本的Update Pattern举例\n\n因为transition是应用在`selection`上的，所以为了方便使用，我们可以先定义好动画\n\n```js\nconst t = d3.transtion().duration(750)\n```\n\n接下来，我们希望新加入的文字从上面掉下来，且位置更新时，能有一个动画效果，这时候需要设置在`enter()`时，位置有一个从上倒下的过程(transtion)\n\n```js\nconst d3Pattern = (dataSet) => {\n  const t = d3.transtion().duration(750) // 定义动画\n  const text = g.selectAll('text').data(dataSet)\n  \n  text.enter()  \n      .append('text')\n      .attr('class', 'new')\n      .text(d => d)\n      .attr('y', -60)\n  \t\t\t.transition(t)\n  \t\t\t\t.attr('y', 0)\n  \t\t\t\t.attr('x', (d, i) => 18 * i)\n  \n  text.attr('class', 'update')\n  \t.attr('y', 0)\n  \t.transition(t)\n  \t\t.attr('x', (d, i) => 18 * i)\n\n  text.exit()\n    .transition(t)\n      .attr('y', 60)\n      .remove()\n}\n```\n\n![Kapture 2020-03-08 at 22.40.14](/../images/letter-transition-no-down.gif)\n\n可以看到，原来呆板的样式，已经变的灵动多了。 当然，也可以继续为退出(exit)的文字，加上红色，与掉落的动画，让整体更具有动效，只需要对exit的部分做相应的处理：\n\n```js\ntext.exit()\n\t.transition(t)\n\t\t.attr('y', 60)\n\t\t.remove()\n```\n\n![Kapture 2020-03-08 at 22.46.24](/../images/complete-transition.gif)\n\n如图，这是加了向下掉落和透明度变化的动画效果。\n\n[完整代码](https://codepen.io/vincenttgao/pen/XWbzOdY?editors=1111)\n\n### 实战应用\n\n比如现在已经有一个静态的柱状图，希望在鼠标hover的时候，有一些动态效果变化，如下图\n\n![Kapture 2020-03-08 at 23.03.53](/../images/bar-transition.gif)\n\n对于柱状图的实现，这里就不赘述，这里解释下核心代码，思路与上面提到的完全相同：\n\n1. 监听鼠标移入事件\n\n  2. 选择当前的bar，通过transition修改属性\n  3. 监听鼠标移出\n  4. 选择当前bar，鼠标移出，恢复属性\n\n核心代码如下： \n\n```js\nsvgElement\n    .on('mouseenter', (actual, i) => {\n        d3.select(this)\n          .transition()\n        \t.duration(300)\n        \t.attr('opacity', 0.6)\n        \t.attr('x', (a) => xScale(a.language) - 5)\n        \t.attr('width', xScale.bandwidth() + 10)\n    })\n    .on('mouseleave’, (actual, i) => {\n        d3.select(this)\n          .transition()\n          .duration(300)\n          .attr('opacity', 1)\n          .attr('x', (a) => xScale(a.language))\n          .attr('width', xScale.bandwidth())\n    })\n```\n\n这个柱状图的源码与教程出自[D3.js Tutorial: Building Interactive Bar Charts with JavaScript](https://blog.risingstack.com/d3-js-tutorial-bar-charts-with-javascript/)\n\n\n\n### 插值动画\n\n对于一些特殊的过渡，比如颜色的变化、数字的跳变等，如果没有插值函数，直接使用`transition().attr()`是无法实现的。\n\n因此，d3提供了插值函数和插值动画的接口用于这类动画实现。当然，对于大多数场景，非差值动画都可满足了。\n\n#### 特殊的插值\n\n对于一些常用的属性插值，d3提供了非常方便入口，分别是`attrTween`(属性插值)/`styleTween`（样式插值）/`textTween` 文字插值\n\n这类插值主要用于比如颜色、线条粗细等“属性”差值，可以使用`attrTween()`和`styleTween`，对于数字变化，连续跳变，可以使用`textTween`他们的用法类似，如下： \n\n```js\n//颜色插值，从红色变为蓝色\ntransition.attrTween('fill', function() {\n  return d3.interpolateRgb(\"red\", \"blue\");\n})\n\ntransition.styleTween('color', function() {\n  return d3.interpolateRgb(\"red\", \"blue\");\n})\n```\n\n插值函数的第一个参数，是要修改的内容或属性，功能类似`transition().attr()`里，attr的内容；第二个参数是返回的插值函数，可以使用d3提供的一些插值函数，当然也可以自定义插值函数。\n\n举个简单的例子，比如想要实现一下效果： \n\n![Kapture 2020-03-13 at 20.30.23](/../images/tween-letter.gif)\n\n只需要对元素添加鼠标事件，并通过以上的插值函数完成即可\n\n```js\nsvg.append('text')\n\t.text('A')\n\t.on('mouseenter', function() {\n  \td3.select(this)\n  \t\t.transition()\n  \t\t.attrTween('fill', function() {\n      \treturn d3.interpolateRgb(\"red\", \"blue\");\n    \t})\n\t})\n  .on('mouseleave', function() {...})\n```\n\n接下来说下自定义函数，比如仍然是红色变为蓝色，我们可以在插值函数返回自己定义的函数`func(t)`, 该函数会在动画时间内不断的运行，t为[0, 1]，借助这个思路，以上的效果可以用自定义函数实现如下: \n\n```js\nsvg.append('text')\n\t.text('A')\n\t.on('mouseenter', function() {\n  \td3.select(this)\n  \t\t.transition()\n  \t\t.attrTween('fill', function() {\n      \treturn function(i) {\n          return `rgb(${i * 255}, 0, ${255-(i * 255)})`\n        }\n    \t})\n\t})\n\t.on('mouseleave', function() {\n  \t... // 与上类似\n\t})\n```\n\n以上两种方案，均可以实现动图的效果哦。\n\n可以看到，对于插值动画，核心在于插值内容的产生。d3提供了多款插值，相关的列表如下，比如在使用数字跳变动画时，就可以使用`d3.interpolatorRound(start,end)`来产生整形的数字插值； `d3.interpolateRgb(color, color2)`来产生颜色插值等，具体的插值函数用法可查阅相关API。\n\n- `d3.interpolatNumber`\n- `d3.interpolatRound`\n- `d3.interpolatString`\n- `d3.interpolatRgb`\n- `d3.interpolatHsl`\n- `d3.interpolatLab`\n- `d3.interpolatHcl`\n- `d3.interpolatArray`\n- `d3.interpolatObject`\n- `d3.interpolatTransform`\n- `d3.interpolatZoom`\n\n### 通用插值\n\n当然，除了前面提到的API，还有一个更通用的产值函数API，`d3.tween()`\n\n同`attrTween()`等类似，它的第二个参数也是传入插值函数；不同的是，第一个参数，可以传入更通用的想要改变的内容，比如同样是上面的`fill`属性，使用通用插值函数的写法就是:\n\n```js\nselection.transition()\n\t.tween('attr.fill', function() {\n    return function(i) {\n            return `rgb(${i * 255}, 0, ${255-(i * 255)})`\n          }\n\t})\n```\n\n于是我们发现，其实通用API与前面的特殊的三个API用法及其类似，唯一不同的就是通用API的第一个参数可以接受更广泛的变更属性。\n\n这里就不多举例了，关于插值函数的一些参考实例可以在这里[查看](https://observablehq.com/@d3/transition-texttween)\n\n\n\n## 参考资料\n\n1. [D3.js Tutorial: Building Interactive Bar Charts with JavaScript](https://blog.risingstack.com/d3-js-tutorial-bar-charts-with-javascript/)\n2. [How to work with D3.js’s general update pattern](https://www.freecodecamp.org/news/how-to-work-with-d3-jss-general-update-pattern-8adce8d55418/)\n3. [Interaction and Animation: D3 Transitions, Behaviors, and Brushing](http://duspviz.mit.edu/d3-workshop/transitions-animation/)\n4. [d3-selection-join](https://observablehq.com/@d3/selection-join)\n5. [sortable-bar-chart](https://observablehq.com/@d3/sortable-bar-chart)\n6. [Using Basic and Tween Transitions in d3.js](http://4waisenkinder.de/blog/2014/05/11/d3-dot-js-tween-in-detail/)\n\n","source":"_posts/year-03-13-D3 Transition with update pattern.md","raw":"---\ntitle: D3 动画与插值\ndate: 2020-3-013 20:15:24\nauthor:  \"Vinecnt Ko\"\ntags:\n    - d3\n    - 可视化\n---\n\n## D3 动画\n\nD3.js提供了多种工具支持数据可视化的交互，其中`d3.transition`让简单而高效的为图像添加动画成为了可能。\n\n单单从API来讲，`d3.transition`非常简单，用法类似Jquery。 但是想要设计出理想的动画效果，就不得不提到D3绘制图形的一个核心概念`General Update Pattern`. D3的数据驱动特性的核心和实现就是依靠这个Pattern，而动画和交互自然要从它说起了。\n\n> 并不是所有图形都必须遵循Update Pattern，比如一次性绘图，无交互的静态图形等。但如果涉及到了动态数据，这个Update Pattern不仅利于写出易于维护的代码，也能更好的发挥D3强大的功能。\n\n## General Update Pattern\n\n![image-20200308211328582](/../images/update-pattern.png)\n\nD3的数据驱动模式如上图所示，当使用`d3.data()`将数据`Array`与DOM元素绑定的时，数据与元素之间有着三个阶段，即\n\n- Enter 已有数据，但页面还未有与之对应的DOM\n- Update 数据元素与DOM元素相绑定\n- Exit 数据元素已经被删除，但DOM元素还存在，即失去了绑定元素的DOM\n\n关于这个点，这里不做详细赘述，可参考文档。这里直接对V4和V5版本的`General Update Pattern`进行介绍。举一个简单的例子：\n\n> 假设目前已有数据['a', 'b', 'c'....]等字母序列，现在希望通过D3,使用SVG将其呈现在页面上\n\n### V4\n\n通过`selection.enter()`, `selection.exit()`与 `selection`（update）分别指定相应逻辑，内容如下：\n\n```js\nconst d3Pattern = (dataSet) => {\n  const text = g.selectAll('text').data(dataSet)  // 数据绑定\n  \n  text.enter()     // enter() 返回绑定数据但是还未生成dom元素的部分\n      .append('text')\n      .attr('class', 'new')\n      .text(d => d)\n      .merge(text)  // merge后面的代码，将会分别应用于enter于update两个部分，省略写法\n  \t\t\t.attr('x', (d, i) => 18 * i)\n  \n  text.attr('class', 'update')  // text 本身是update部分\n\n  text.exit().remove()  // exit() 返回数据已经被删除，但是还存在dom的元素\n}\n```\n\n### V5\n\nd3 V5.8.0 引入了一个新的API， `selection.join` \n\n这个API的优势在于，对于一些比较简单、不需要特殊定义enter\\exit过程的动作的d3图形，可以简化代码，以上的代码，使用V5的版本写，即\n\n```js\nconst d3Pattern = (dataSet) => {\n  const text = g.selectAll('text').data(dataSet)  // 数据绑定\n  \n  text.join(\n    enter => enter.append('text')\n    \t.attr('calss', 'new')\n    \t.text(d => d),\n    update => update.attr('class', 'update')\n  )\n    .attr('x', (d, i) => 18 * i)\n  \n  // join的exit默认就是 exit().remove()，因此可以免去\n}\n```\n\n可以发现，使用`selection.join()`, 并不需要再手动写`selection.exit().remove()`，这是因为`selection.join()`这个函数默认的`exit()`函数已经帮你写好了，该API下，d3的Update Pattern可以写为\n\n```js\nselection.join(\n    enter => // enter.. ,\n    update => // update.. ,\n    exit => // exit.. \n  )\n  // 注意，enter，update等函数一定要return，这样可以对selection继续链式调用\n```\n\n当然，这个API的好处在于，一般的使用场景下（不需要在enter、exit等加特殊的动画或操作），完全可以简写，比如：\n\n```js\nsvg.selectAll(\"circle\")\n  .data(data)\n  .join(\"circle\")\n    .attr(\"fill\", \"none\")\n    .attr(\"stroke\", \"black\");\n```\n\n以上的写法，完全等价于\n\n```js\nsvg.selectAll(\"circle\")\n  .data(data)\n  .join(\n    enter => enter.append(\"circle\"),\n    update => update,\n    exit => exit.remove()\n  )\n    .attr(\"fill\", \"none\")\n    .attr(\"stroke\", \"black\");\n```\n\n等价于V4版本的\n\n```js\ncircles = svg.selectAll('circle')\n\t.data(data)\n\ncircles.enter()\n\t.append('circle')\n\t.merge('circle')\n\t\t.attr('fill', 'none')\n\t\t.attr('stroke', 'black')\n\ncircles.exit().remove()\n```\n\n当然，V5完全兼容V4的update Pattern，无论是V4还是V5的新版API，这种Update Pattern的本质没有变，D3仍然是数据绑定，enter/update/exit的工作模式。\n\n### Pattern中的key\n\n当使用`d3.data()`绑定数据和dom时，相对应的关系，可能第一个元素对应第一个dom，第二元素对应第二dom等； 但当`Array`发生变化时，比如重新排序、插入等操作，这时候，数组中元素可能与dom的绑定关系就发生了一些微妙的变化。\n\n最直观的例子就比如动态改变字符的例子\n\n![Kapture 2020-03-08 at 21.56.19](/../images/text-transition.gif)\n\n如图，发现新增的字符总是排在最后，实际上，如果数据一致保持和dom绑定的话，理论随机生成新字符，完全应该有机会出现在中间的。\n\n在数据绑定时，传入一个唯一的key值，即可避免这种情况发生\n\n```js\nselection.data(data, d => d.id)\n```\n\n完成以上步骤，只要定时的调用函数`d3Pattern`，传入不同的data，即可实现上图的效果\n\n[完整代码](https://codepen.io/vincenttgao/pen/rNVYoYw)\n\n## Transition\n\n好了，前面铺垫了这么多，终于到了主角`d3.transition`了，但实际上，与之相关API屈指可数，想要让d3画出带交互和炫酷过渡效果的，重点还是对Update Pattern理解透彻。\n\n### 基本动画使用\n\n`transition` 的使用，与jquery十分类似，使用时，只需要对选择的元素调用，并指定修改的属性即可，即`selection.transition().attr(...)`\n\n比如现在画布上有一个方块，该元素为`rect`,我想要使其位置从默认的地方，到30位置，并加上动画，代码为\n\n```js\nrect.transition()\n\t.attr('x', 30)  //  设置新位置\n```\n\n效果如下\n\n![Kapture 2020-03-08 at 22.17.46](/../images/move-box.gif)\n\n动画的基本使用，就是如此简单，下面简单看下相关的api\n\n| 方法                   | 描述                                                         |\n| ---------------------- | ------------------------------------------------------------ |\n| selection.transition() | this schedules a transition for the selected elements        |\n| transition.duration()  | duration specifies the animation duration in milliseconds for each element |\n| transition.ease()      | ease specifies the easing function, example: linear, elastic, bounce |\n| transition.delay()     | delay specifies the delay in animation in milliseconds for each element |\n\n这里注意d3的api都支持链式调用，因此比如上面的例子，希望将动画时间设置为1s，可以\n\n```js\nrect.transition()\n\t.duration(1000)\n\t.attr('x', 30)  //  设置新位置\n```\n\n同理，ease和delay可以分别设置动画曲线和延迟。\n\n### Update Pattern下的动画\n\n回到最开始的例子，这里用V4版本的Update Pattern举例\n\n因为transition是应用在`selection`上的，所以为了方便使用，我们可以先定义好动画\n\n```js\nconst t = d3.transtion().duration(750)\n```\n\n接下来，我们希望新加入的文字从上面掉下来，且位置更新时，能有一个动画效果，这时候需要设置在`enter()`时，位置有一个从上倒下的过程(transtion)\n\n```js\nconst d3Pattern = (dataSet) => {\n  const t = d3.transtion().duration(750) // 定义动画\n  const text = g.selectAll('text').data(dataSet)\n  \n  text.enter()  \n      .append('text')\n      .attr('class', 'new')\n      .text(d => d)\n      .attr('y', -60)\n  \t\t\t.transition(t)\n  \t\t\t\t.attr('y', 0)\n  \t\t\t\t.attr('x', (d, i) => 18 * i)\n  \n  text.attr('class', 'update')\n  \t.attr('y', 0)\n  \t.transition(t)\n  \t\t.attr('x', (d, i) => 18 * i)\n\n  text.exit()\n    .transition(t)\n      .attr('y', 60)\n      .remove()\n}\n```\n\n![Kapture 2020-03-08 at 22.40.14](/../images/letter-transition-no-down.gif)\n\n可以看到，原来呆板的样式，已经变的灵动多了。 当然，也可以继续为退出(exit)的文字，加上红色，与掉落的动画，让整体更具有动效，只需要对exit的部分做相应的处理：\n\n```js\ntext.exit()\n\t.transition(t)\n\t\t.attr('y', 60)\n\t\t.remove()\n```\n\n![Kapture 2020-03-08 at 22.46.24](/../images/complete-transition.gif)\n\n如图，这是加了向下掉落和透明度变化的动画效果。\n\n[完整代码](https://codepen.io/vincenttgao/pen/XWbzOdY?editors=1111)\n\n### 实战应用\n\n比如现在已经有一个静态的柱状图，希望在鼠标hover的时候，有一些动态效果变化，如下图\n\n![Kapture 2020-03-08 at 23.03.53](/../images/bar-transition.gif)\n\n对于柱状图的实现，这里就不赘述，这里解释下核心代码，思路与上面提到的完全相同：\n\n1. 监听鼠标移入事件\n\n  2. 选择当前的bar，通过transition修改属性\n  3. 监听鼠标移出\n  4. 选择当前bar，鼠标移出，恢复属性\n\n核心代码如下： \n\n```js\nsvgElement\n    .on('mouseenter', (actual, i) => {\n        d3.select(this)\n          .transition()\n        \t.duration(300)\n        \t.attr('opacity', 0.6)\n        \t.attr('x', (a) => xScale(a.language) - 5)\n        \t.attr('width', xScale.bandwidth() + 10)\n    })\n    .on('mouseleave’, (actual, i) => {\n        d3.select(this)\n          .transition()\n          .duration(300)\n          .attr('opacity', 1)\n          .attr('x', (a) => xScale(a.language))\n          .attr('width', xScale.bandwidth())\n    })\n```\n\n这个柱状图的源码与教程出自[D3.js Tutorial: Building Interactive Bar Charts with JavaScript](https://blog.risingstack.com/d3-js-tutorial-bar-charts-with-javascript/)\n\n\n\n### 插值动画\n\n对于一些特殊的过渡，比如颜色的变化、数字的跳变等，如果没有插值函数，直接使用`transition().attr()`是无法实现的。\n\n因此，d3提供了插值函数和插值动画的接口用于这类动画实现。当然，对于大多数场景，非差值动画都可满足了。\n\n#### 特殊的插值\n\n对于一些常用的属性插值，d3提供了非常方便入口，分别是`attrTween`(属性插值)/`styleTween`（样式插值）/`textTween` 文字插值\n\n这类插值主要用于比如颜色、线条粗细等“属性”差值，可以使用`attrTween()`和`styleTween`，对于数字变化，连续跳变，可以使用`textTween`他们的用法类似，如下： \n\n```js\n//颜色插值，从红色变为蓝色\ntransition.attrTween('fill', function() {\n  return d3.interpolateRgb(\"red\", \"blue\");\n})\n\ntransition.styleTween('color', function() {\n  return d3.interpolateRgb(\"red\", \"blue\");\n})\n```\n\n插值函数的第一个参数，是要修改的内容或属性，功能类似`transition().attr()`里，attr的内容；第二个参数是返回的插值函数，可以使用d3提供的一些插值函数，当然也可以自定义插值函数。\n\n举个简单的例子，比如想要实现一下效果： \n\n![Kapture 2020-03-13 at 20.30.23](/../images/tween-letter.gif)\n\n只需要对元素添加鼠标事件，并通过以上的插值函数完成即可\n\n```js\nsvg.append('text')\n\t.text('A')\n\t.on('mouseenter', function() {\n  \td3.select(this)\n  \t\t.transition()\n  \t\t.attrTween('fill', function() {\n      \treturn d3.interpolateRgb(\"red\", \"blue\");\n    \t})\n\t})\n  .on('mouseleave', function() {...})\n```\n\n接下来说下自定义函数，比如仍然是红色变为蓝色，我们可以在插值函数返回自己定义的函数`func(t)`, 该函数会在动画时间内不断的运行，t为[0, 1]，借助这个思路，以上的效果可以用自定义函数实现如下: \n\n```js\nsvg.append('text')\n\t.text('A')\n\t.on('mouseenter', function() {\n  \td3.select(this)\n  \t\t.transition()\n  \t\t.attrTween('fill', function() {\n      \treturn function(i) {\n          return `rgb(${i * 255}, 0, ${255-(i * 255)})`\n        }\n    \t})\n\t})\n\t.on('mouseleave', function() {\n  \t... // 与上类似\n\t})\n```\n\n以上两种方案，均可以实现动图的效果哦。\n\n可以看到，对于插值动画，核心在于插值内容的产生。d3提供了多款插值，相关的列表如下，比如在使用数字跳变动画时，就可以使用`d3.interpolatorRound(start,end)`来产生整形的数字插值； `d3.interpolateRgb(color, color2)`来产生颜色插值等，具体的插值函数用法可查阅相关API。\n\n- `d3.interpolatNumber`\n- `d3.interpolatRound`\n- `d3.interpolatString`\n- `d3.interpolatRgb`\n- `d3.interpolatHsl`\n- `d3.interpolatLab`\n- `d3.interpolatHcl`\n- `d3.interpolatArray`\n- `d3.interpolatObject`\n- `d3.interpolatTransform`\n- `d3.interpolatZoom`\n\n### 通用插值\n\n当然，除了前面提到的API，还有一个更通用的产值函数API，`d3.tween()`\n\n同`attrTween()`等类似，它的第二个参数也是传入插值函数；不同的是，第一个参数，可以传入更通用的想要改变的内容，比如同样是上面的`fill`属性，使用通用插值函数的写法就是:\n\n```js\nselection.transition()\n\t.tween('attr.fill', function() {\n    return function(i) {\n            return `rgb(${i * 255}, 0, ${255-(i * 255)})`\n          }\n\t})\n```\n\n于是我们发现，其实通用API与前面的特殊的三个API用法及其类似，唯一不同的就是通用API的第一个参数可以接受更广泛的变更属性。\n\n这里就不多举例了，关于插值函数的一些参考实例可以在这里[查看](https://observablehq.com/@d3/transition-texttween)\n\n\n\n## 参考资料\n\n1. [D3.js Tutorial: Building Interactive Bar Charts with JavaScript](https://blog.risingstack.com/d3-js-tutorial-bar-charts-with-javascript/)\n2. [How to work with D3.js’s general update pattern](https://www.freecodecamp.org/news/how-to-work-with-d3-jss-general-update-pattern-8adce8d55418/)\n3. [Interaction and Animation: D3 Transitions, Behaviors, and Brushing](http://duspviz.mit.edu/d3-workshop/transitions-animation/)\n4. [d3-selection-join](https://observablehq.com/@d3/selection-join)\n5. [sortable-bar-chart](https://observablehq.com/@d3/sortable-bar-chart)\n6. [Using Basic and Tween Transitions in d3.js](http://4waisenkinder.de/blog/2014/05/11/d3-dot-js-tween-in-detail/)\n\n","slug":"D3 Transition with update pattern","published":1,"updated":"2022-08-17T07:53:21.232Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6xbhzkb0013zk08e2bg2tf1","content":"<h2 id=\"D3-动画\"><a href=\"#D3-动画\" class=\"headerlink\" title=\"D3 动画\"></a>D3 动画</h2><p>D3.js提供了多种工具支持数据可视化的交互，其中<code>d3.transition</code>让简单而高效的为图像添加动画成为了可能。</p>\n<p>单单从API来讲，<code>d3.transition</code>非常简单，用法类似Jquery。 但是想要设计出理想的动画效果，就不得不提到D3绘制图形的一个核心概念<code>General Update Pattern</code>. D3的数据驱动特性的核心和实现就是依靠这个Pattern，而动画和交互自然要从它说起了。</p>\n<blockquote>\n<p>并不是所有图形都必须遵循Update Pattern，比如一次性绘图，无交互的静态图形等。但如果涉及到了动态数据，这个Update Pattern不仅利于写出易于维护的代码，也能更好的发挥D3强大的功能。</p>\n</blockquote>\n<h2 id=\"General-Update-Pattern\"><a href=\"#General-Update-Pattern\" class=\"headerlink\" title=\"General Update Pattern\"></a>General Update Pattern</h2><p><img src=\"/../images/update-pattern.png\" alt=\"image-20200308211328582\"></p>\n<p>D3的数据驱动模式如上图所示，当使用<code>d3.data()</code>将数据<code>Array</code>与DOM元素绑定的时，数据与元素之间有着三个阶段，即</p>\n<ul>\n<li>Enter 已有数据，但页面还未有与之对应的DOM</li>\n<li>Update 数据元素与DOM元素相绑定</li>\n<li>Exit 数据元素已经被删除，但DOM元素还存在，即失去了绑定元素的DOM</li>\n</ul>\n<p>关于这个点，这里不做详细赘述，可参考文档。这里直接对V4和V5版本的<code>General Update Pattern</code>进行介绍。举一个简单的例子：</p>\n<blockquote>\n<p>假设目前已有数据[‘a’, ‘b’, ‘c’….]等字母序列，现在希望通过D3,使用SVG将其呈现在页面上</p>\n</blockquote>\n<h3 id=\"V4\"><a href=\"#V4\" class=\"headerlink\" title=\"V4\"></a>V4</h3><p>通过<code>selection.enter()</code>, <code>selection.exit()</code>与 <code>selection</code>（update）分别指定相应逻辑，内容如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> d3Pattern = <span class=\"function\">(<span class=\"params\">dataSet</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> text = g.selectAll(<span class=\"string\">'text'</span>).data(dataSet)  <span class=\"comment\">// 数据绑定</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  text.enter()     <span class=\"comment\">// enter() 返回绑定数据但是还未生成dom元素的部分</span></span><br><span class=\"line\">      .append(<span class=\"string\">'text'</span>)</span><br><span class=\"line\">      .attr(<span class=\"string\">'class'</span>, <span class=\"string\">'new'</span>)</span><br><span class=\"line\">      .text(<span class=\"function\"><span class=\"params\">d</span> =&gt;</span> d)</span><br><span class=\"line\">      .merge(text)  <span class=\"comment\">// merge后面的代码，将会分别应用于enter于update两个部分，省略写法</span></span><br><span class=\"line\">  \t\t\t.attr(<span class=\"string\">'x'</span>, (d, i) =&gt; <span class=\"number\">18</span> * i)</span><br><span class=\"line\">  </span><br><span class=\"line\">  text.attr(<span class=\"string\">'class'</span>, <span class=\"string\">'update'</span>)  <span class=\"comment\">// text 本身是update部分</span></span><br><span class=\"line\"></span><br><span class=\"line\">  text.exit().remove()  <span class=\"comment\">// exit() 返回数据已经被删除，但是还存在dom的元素</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"V5\"><a href=\"#V5\" class=\"headerlink\" title=\"V5\"></a>V5</h3><p>d3 V5.8.0 引入了一个新的API， <code>selection.join</code> </p>\n<p>这个API的优势在于，对于一些比较简单、不需要特殊定义enter\\exit过程的动作的d3图形，可以简化代码，以上的代码，使用V5的版本写，即</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> d3Pattern = <span class=\"function\">(<span class=\"params\">dataSet</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> text = g.selectAll(<span class=\"string\">'text'</span>).data(dataSet)  <span class=\"comment\">// 数据绑定</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  text.join(</span><br><span class=\"line\">    enter =&gt; enter.append(<span class=\"string\">'text'</span>)</span><br><span class=\"line\">    \t.attr(<span class=\"string\">'calss'</span>, <span class=\"string\">'new'</span>)</span><br><span class=\"line\">    \t.text(<span class=\"function\"><span class=\"params\">d</span> =&gt;</span> d),</span><br><span class=\"line\">    update =&gt; update.attr(<span class=\"string\">'class'</span>, <span class=\"string\">'update'</span>)</span><br><span class=\"line\">  )</span><br><span class=\"line\">    .attr(<span class=\"string\">'x'</span>, (d, i) =&gt; <span class=\"number\">18</span> * i)</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// join的exit默认就是 exit().remove()，因此可以免去</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以发现，使用<code>selection.join()</code>, 并不需要再手动写<code>selection.exit().remove()</code>，这是因为<code>selection.join()</code>这个函数默认的<code>exit()</code>函数已经帮你写好了，该API下，d3的Update Pattern可以写为</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">selection.join(</span><br><span class=\"line\">    enter =&gt; <span class=\"comment\">// enter.. ,</span></span><br><span class=\"line\">    update =&gt; <span class=\"comment\">// update.. ,</span></span><br><span class=\"line\">    exit =&gt; <span class=\"comment\">// exit.. </span></span><br><span class=\"line\">  )</span><br><span class=\"line\">  <span class=\"comment\">// 注意，enter，update等函数一定要return，这样可以对selection继续链式调用</span></span><br></pre></td></tr></table></figure>\n<p>当然，这个API的好处在于，一般的使用场景下（不需要在enter、exit等加特殊的动画或操作），完全可以简写，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svg.selectAll(<span class=\"string\">\"circle\"</span>)</span><br><span class=\"line\">  .data(data)</span><br><span class=\"line\">  .join(<span class=\"string\">\"circle\"</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">\"fill\"</span>, <span class=\"string\">\"none\"</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">\"stroke\"</span>, <span class=\"string\">\"black\"</span>);</span><br></pre></td></tr></table></figure>\n<p>以上的写法，完全等价于</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svg.selectAll(<span class=\"string\">\"circle\"</span>)</span><br><span class=\"line\">  .data(data)</span><br><span class=\"line\">  .join(</span><br><span class=\"line\">    enter =&gt; enter.append(<span class=\"string\">\"circle\"</span>),</span><br><span class=\"line\">    update =&gt; update,</span><br><span class=\"line\">    exit =&gt; exit.remove()</span><br><span class=\"line\">  )</span><br><span class=\"line\">    .attr(<span class=\"string\">\"fill\"</span>, <span class=\"string\">\"none\"</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">\"stroke\"</span>, <span class=\"string\">\"black\"</span>);</span><br></pre></td></tr></table></figure>\n<p>等价于V4版本的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">circles = svg.selectAll(<span class=\"string\">'circle'</span>)</span><br><span class=\"line\">\t.data(data)</span><br><span class=\"line\"></span><br><span class=\"line\">circles.enter()</span><br><span class=\"line\">\t.append(<span class=\"string\">'circle'</span>)</span><br><span class=\"line\">\t.merge(<span class=\"string\">'circle'</span>)</span><br><span class=\"line\">\t\t.attr(<span class=\"string\">'fill'</span>, <span class=\"string\">'none'</span>)</span><br><span class=\"line\">\t\t.attr(<span class=\"string\">'stroke'</span>, <span class=\"string\">'black'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">circles.exit().remove()</span><br></pre></td></tr></table></figure>\n<p>当然，V5完全兼容V4的update Pattern，无论是V4还是V5的新版API，这种Update Pattern的本质没有变，D3仍然是数据绑定，enter/update/exit的工作模式。</p>\n<h3 id=\"Pattern中的key\"><a href=\"#Pattern中的key\" class=\"headerlink\" title=\"Pattern中的key\"></a>Pattern中的key</h3><p>当使用<code>d3.data()</code>绑定数据和dom时，相对应的关系，可能第一个元素对应第一个dom，第二元素对应第二dom等； 但当<code>Array</code>发生变化时，比如重新排序、插入等操作，这时候，数组中元素可能与dom的绑定关系就发生了一些微妙的变化。</p>\n<p>最直观的例子就比如动态改变字符的例子</p>\n<p><img src=\"/../images/text-transition.gif\" alt=\"Kapture 2020-03-08 at 21.56.19\"></p>\n<p>如图，发现新增的字符总是排在最后，实际上，如果数据一致保持和dom绑定的话，理论随机生成新字符，完全应该有机会出现在中间的。</p>\n<p>在数据绑定时，传入一个唯一的key值，即可避免这种情况发生</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">selection.data(data, d =&gt; d.id)</span><br></pre></td></tr></table></figure>\n<p>完成以上步骤，只要定时的调用函数<code>d3Pattern</code>，传入不同的data，即可实现上图的效果</p>\n<p><a href=\"https://codepen.io/vincenttgao/pen/rNVYoYw\" target=\"_blank\" rel=\"noopener\">完整代码</a></p>\n<h2 id=\"Transition\"><a href=\"#Transition\" class=\"headerlink\" title=\"Transition\"></a>Transition</h2><p>好了，前面铺垫了这么多，终于到了主角<code>d3.transition</code>了，但实际上，与之相关API屈指可数，想要让d3画出带交互和炫酷过渡效果的，重点还是对Update Pattern理解透彻。</p>\n<h3 id=\"基本动画使用\"><a href=\"#基本动画使用\" class=\"headerlink\" title=\"基本动画使用\"></a>基本动画使用</h3><p><code>transition</code> 的使用，与jquery十分类似，使用时，只需要对选择的元素调用，并指定修改的属性即可，即<code>selection.transition().attr(...)</code></p>\n<p>比如现在画布上有一个方块，该元素为<code>rect</code>,我想要使其位置从默认的地方，到30位置，并加上动画，代码为</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rect.transition()</span><br><span class=\"line\">\t.attr(<span class=\"string\">'x'</span>, <span class=\"number\">30</span>)  <span class=\"comment\">//  设置新位置</span></span><br></pre></td></tr></table></figure>\n<p>效果如下</p>\n<p><img src=\"/../images/move-box.gif\" alt=\"Kapture 2020-03-08 at 22.17.46\"></p>\n<p>动画的基本使用，就是如此简单，下面简单看下相关的api</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>selection.transition()</td>\n<td>this schedules a transition for the selected elements</td>\n</tr>\n<tr>\n<td>transition.duration()</td>\n<td>duration specifies the animation duration in milliseconds for each element</td>\n</tr>\n<tr>\n<td>transition.ease()</td>\n<td>ease specifies the easing function, example: linear, elastic, bounce</td>\n</tr>\n<tr>\n<td>transition.delay()</td>\n<td>delay specifies the delay in animation in milliseconds for each element</td>\n</tr>\n</tbody>\n</table>\n<p>这里注意d3的api都支持链式调用，因此比如上面的例子，希望将动画时间设置为1s，可以</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rect.transition()</span><br><span class=\"line\">\t.duration(<span class=\"number\">1000</span>)</span><br><span class=\"line\">\t.attr(<span class=\"string\">'x'</span>, <span class=\"number\">30</span>)  <span class=\"comment\">//  设置新位置</span></span><br></pre></td></tr></table></figure>\n<p>同理，ease和delay可以分别设置动画曲线和延迟。</p>\n<h3 id=\"Update-Pattern下的动画\"><a href=\"#Update-Pattern下的动画\" class=\"headerlink\" title=\"Update Pattern下的动画\"></a>Update Pattern下的动画</h3><p>回到最开始的例子，这里用V4版本的Update Pattern举例</p>\n<p>因为transition是应用在<code>selection</code>上的，所以为了方便使用，我们可以先定义好动画</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> t = d3.transtion().duration(<span class=\"number\">750</span>)</span><br></pre></td></tr></table></figure>\n<p>接下来，我们希望新加入的文字从上面掉下来，且位置更新时，能有一个动画效果，这时候需要设置在<code>enter()</code>时，位置有一个从上倒下的过程(transtion)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> d3Pattern = <span class=\"function\">(<span class=\"params\">dataSet</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> t = d3.transtion().duration(<span class=\"number\">750</span>) <span class=\"comment\">// 定义动画</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> text = g.selectAll(<span class=\"string\">'text'</span>).data(dataSet)</span><br><span class=\"line\">  </span><br><span class=\"line\">  text.enter()  </span><br><span class=\"line\">      .append(<span class=\"string\">'text'</span>)</span><br><span class=\"line\">      .attr(<span class=\"string\">'class'</span>, <span class=\"string\">'new'</span>)</span><br><span class=\"line\">      .text(<span class=\"function\"><span class=\"params\">d</span> =&gt;</span> d)</span><br><span class=\"line\">      .attr(<span class=\"string\">'y'</span>, <span class=\"number\">-60</span>)</span><br><span class=\"line\">  \t\t\t.transition(t)</span><br><span class=\"line\">  \t\t\t\t.attr(<span class=\"string\">'y'</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">  \t\t\t\t.attr(<span class=\"string\">'x'</span>, (d, i) =&gt; <span class=\"number\">18</span> * i)</span><br><span class=\"line\">  </span><br><span class=\"line\">  text.attr(<span class=\"string\">'class'</span>, <span class=\"string\">'update'</span>)</span><br><span class=\"line\">  \t.attr(<span class=\"string\">'y'</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">  \t.transition(t)</span><br><span class=\"line\">  \t\t.attr(<span class=\"string\">'x'</span>, (d, i) =&gt; <span class=\"number\">18</span> * i)</span><br><span class=\"line\"></span><br><span class=\"line\">  text.exit()</span><br><span class=\"line\">    .transition(t)</span><br><span class=\"line\">      .attr(<span class=\"string\">'y'</span>, <span class=\"number\">60</span>)</span><br><span class=\"line\">      .remove()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/../images/letter-transition-no-down.gif\" alt=\"Kapture 2020-03-08 at 22.40.14\"></p>\n<p>可以看到，原来呆板的样式，已经变的灵动多了。 当然，也可以继续为退出(exit)的文字，加上红色，与掉落的动画，让整体更具有动效，只需要对exit的部分做相应的处理：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">text.exit()</span><br><span class=\"line\">\t.transition(t)</span><br><span class=\"line\">\t\t.attr(<span class=\"string\">'y'</span>, <span class=\"number\">60</span>)</span><br><span class=\"line\">\t\t.remove()</span><br></pre></td></tr></table></figure>\n<p><img src=\"/../images/complete-transition.gif\" alt=\"Kapture 2020-03-08 at 22.46.24\"></p>\n<p>如图，这是加了向下掉落和透明度变化的动画效果。</p>\n<p><a href=\"https://codepen.io/vincenttgao/pen/XWbzOdY?editors=1111\" target=\"_blank\" rel=\"noopener\">完整代码</a></p>\n<h3 id=\"实战应用\"><a href=\"#实战应用\" class=\"headerlink\" title=\"实战应用\"></a>实战应用</h3><p>比如现在已经有一个静态的柱状图，希望在鼠标hover的时候，有一些动态效果变化，如下图</p>\n<p><img src=\"/../images/bar-transition.gif\" alt=\"Kapture 2020-03-08 at 23.03.53\"></p>\n<p>对于柱状图的实现，这里就不赘述，这里解释下核心代码，思路与上面提到的完全相同：</p>\n<ol>\n<li><p>监听鼠标移入事件</p>\n<ol start=\"2\">\n<li>选择当前的bar，通过transition修改属性</li>\n<li>监听鼠标移出</li>\n<li>选择当前bar，鼠标移出，恢复属性</li>\n</ol>\n</li>\n</ol>\n<p>核心代码如下： </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svgElement</span><br><span class=\"line\">    .on(<span class=\"string\">'mouseenter'</span>, (actual, i) =&gt; &#123;</span><br><span class=\"line\">        d3.select(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">          .transition()</span><br><span class=\"line\">        \t.duration(<span class=\"number\">300</span>)</span><br><span class=\"line\">        \t.attr(<span class=\"string\">'opacity'</span>, <span class=\"number\">0.6</span>)</span><br><span class=\"line\">        \t.attr(<span class=\"string\">'x'</span>, (a) =&gt; xScale(a.language) - <span class=\"number\">5</span>)</span><br><span class=\"line\">        \t.attr(<span class=\"string\">'width'</span>, xScale.bandwidth() + <span class=\"number\">10</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .on(<span class=\"string\">'mouseleave’, (actual, i) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"string\">        d3.select(this)</span></span><br><span class=\"line\"><span class=\"string\">          .transition()</span></span><br><span class=\"line\"><span class=\"string\">          .duration(300)</span></span><br><span class=\"line\"><span class=\"string\">          .attr('</span>opacity<span class=\"string\">', 1)</span></span><br><span class=\"line\"><span class=\"string\">          .attr('</span>x<span class=\"string\">', (a) =&gt; xScale(a.language))</span></span><br><span class=\"line\"><span class=\"string\">          .attr('</span>width<span class=\"string\">', xScale.bandwidth())</span></span><br><span class=\"line\"><span class=\"string\">    &#125;)</span></span><br></pre></td></tr></table></figure>\n<p>这个柱状图的源码与教程出自<a href=\"https://blog.risingstack.com/d3-js-tutorial-bar-charts-with-javascript/\" target=\"_blank\" rel=\"noopener\">D3.js Tutorial: Building Interactive Bar Charts with JavaScript</a></p>\n<h3 id=\"插值动画\"><a href=\"#插值动画\" class=\"headerlink\" title=\"插值动画\"></a>插值动画</h3><p>对于一些特殊的过渡，比如颜色的变化、数字的跳变等，如果没有插值函数，直接使用<code>transition().attr()</code>是无法实现的。</p>\n<p>因此，d3提供了插值函数和插值动画的接口用于这类动画实现。当然，对于大多数场景，非差值动画都可满足了。</p>\n<h4 id=\"特殊的插值\"><a href=\"#特殊的插值\" class=\"headerlink\" title=\"特殊的插值\"></a>特殊的插值</h4><p>对于一些常用的属性插值，d3提供了非常方便入口，分别是<code>attrTween</code>(属性插值)/<code>styleTween</code>（样式插值）/<code>textTween</code> 文字插值</p>\n<p>这类插值主要用于比如颜色、线条粗细等“属性”差值，可以使用<code>attrTween()</code>和<code>styleTween</code>，对于数字变化，连续跳变，可以使用<code>textTween</code>他们的用法类似，如下： </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//颜色插值，从红色变为蓝色</span></span><br><span class=\"line\">transition.attrTween(<span class=\"string\">'fill'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> d3.interpolateRgb(<span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">transition.styleTween(<span class=\"string\">'color'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> d3.interpolateRgb(<span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>插值函数的第一个参数，是要修改的内容或属性，功能类似<code>transition().attr()</code>里，attr的内容；第二个参数是返回的插值函数，可以使用d3提供的一些插值函数，当然也可以自定义插值函数。</p>\n<p>举个简单的例子，比如想要实现一下效果： </p>\n<p><img src=\"/../images/tween-letter.gif\" alt=\"Kapture 2020-03-13 at 20.30.23\"></p>\n<p>只需要对元素添加鼠标事件，并通过以上的插值函数完成即可</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svg.append(<span class=\"string\">'text'</span>)</span><br><span class=\"line\">\t.text(<span class=\"string\">'A'</span>)</span><br><span class=\"line\">\t.on(<span class=\"string\">'mouseenter'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  \td3.select(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  \t\t.transition()</span><br><span class=\"line\">  \t\t.attrTween(<span class=\"string\">'fill'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      \t<span class=\"keyword\">return</span> d3.interpolateRgb(<span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span>);</span><br><span class=\"line\">    \t&#125;)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">  .on(<span class=\"string\">'mouseleave'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;...&#125;)</span><br></pre></td></tr></table></figure>\n<p>接下来说下自定义函数，比如仍然是红色变为蓝色，我们可以在插值函数返回自己定义的函数<code>func(t)</code>, 该函数会在动画时间内不断的运行，t为[0, 1]，借助这个思路，以上的效果可以用自定义函数实现如下: </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svg.append(<span class=\"string\">'text'</span>)</span><br><span class=\"line\">\t.text(<span class=\"string\">'A'</span>)</span><br><span class=\"line\">\t.on(<span class=\"string\">'mouseenter'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  \td3.select(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  \t\t.transition()</span><br><span class=\"line\">  \t\t.attrTween(<span class=\"string\">'fill'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      \t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"string\">`rgb(<span class=\"subst\">$&#123;i * <span class=\"number\">255</span>&#125;</span>, 0, <span class=\"subst\">$&#123;<span class=\"number\">255</span>-(i * <span class=\"number\">255</span>)&#125;</span>)`</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    \t&#125;)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t.on(<span class=\"string\">'mouseleave'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  \t... <span class=\"comment\">// 与上类似</span></span><br><span class=\"line\">\t&#125;)</span><br></pre></td></tr></table></figure>\n<p>以上两种方案，均可以实现动图的效果哦。</p>\n<p>可以看到，对于插值动画，核心在于插值内容的产生。d3提供了多款插值，相关的列表如下，比如在使用数字跳变动画时，就可以使用<code>d3.interpolatorRound(start,end)</code>来产生整形的数字插值； <code>d3.interpolateRgb(color, color2)</code>来产生颜色插值等，具体的插值函数用法可查阅相关API。</p>\n<ul>\n<li><code>d3.interpolatNumber</code></li>\n<li><code>d3.interpolatRound</code></li>\n<li><code>d3.interpolatString</code></li>\n<li><code>d3.interpolatRgb</code></li>\n<li><code>d3.interpolatHsl</code></li>\n<li><code>d3.interpolatLab</code></li>\n<li><code>d3.interpolatHcl</code></li>\n<li><code>d3.interpolatArray</code></li>\n<li><code>d3.interpolatObject</code></li>\n<li><code>d3.interpolatTransform</code></li>\n<li><code>d3.interpolatZoom</code></li>\n</ul>\n<h3 id=\"通用插值\"><a href=\"#通用插值\" class=\"headerlink\" title=\"通用插值\"></a>通用插值</h3><p>当然，除了前面提到的API，还有一个更通用的产值函数API，<code>d3.tween()</code></p>\n<p>同<code>attrTween()</code>等类似，它的第二个参数也是传入插值函数；不同的是，第一个参数，可以传入更通用的想要改变的内容，比如同样是上面的<code>fill</code>属性，使用通用插值函数的写法就是:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">selection.transition()</span><br><span class=\"line\">\t.tween(<span class=\"string\">'attr.fill'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">`rgb(<span class=\"subst\">$&#123;i * <span class=\"number\">255</span>&#125;</span>, 0, <span class=\"subst\">$&#123;<span class=\"number\">255</span>-(i * <span class=\"number\">255</span>)&#125;</span>)`</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">\t&#125;)</span><br></pre></td></tr></table></figure>\n<p>于是我们发现，其实通用API与前面的特殊的三个API用法及其类似，唯一不同的就是通用API的第一个参数可以接受更广泛的变更属性。</p>\n<p>这里就不多举例了，关于插值函数的一些参考实例可以在这里<a href=\"https://observablehq.com/@d3/transition-texttween\" target=\"_blank\" rel=\"noopener\">查看</a></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ol>\n<li><a href=\"https://blog.risingstack.com/d3-js-tutorial-bar-charts-with-javascript/\" target=\"_blank\" rel=\"noopener\">D3.js Tutorial: Building Interactive Bar Charts with JavaScript</a></li>\n<li><a href=\"https://www.freecodecamp.org/news/how-to-work-with-d3-jss-general-update-pattern-8adce8d55418/\" target=\"_blank\" rel=\"noopener\">How to work with D3.js’s general update pattern</a></li>\n<li><a href=\"http://duspviz.mit.edu/d3-workshop/transitions-animation/\" target=\"_blank\" rel=\"noopener\">Interaction and Animation: D3 Transitions, Behaviors, and Brushing</a></li>\n<li><a href=\"https://observablehq.com/@d3/selection-join\" target=\"_blank\" rel=\"noopener\">d3-selection-join</a></li>\n<li><a href=\"https://observablehq.com/@d3/sortable-bar-chart\" target=\"_blank\" rel=\"noopener\">sortable-bar-chart</a></li>\n<li><a href=\"http://4waisenkinder.de/blog/2014/05/11/d3-dot-js-tween-in-detail/\" target=\"_blank\" rel=\"noopener\">Using Basic and Tween Transitions in d3.js</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"D3-动画\"><a href=\"#D3-动画\" class=\"headerlink\" title=\"D3 动画\"></a>D3 动画</h2><p>D3.js提供了多种工具支持数据可视化的交互，其中<code>d3.transition</code>让简单而高效的为图像添加动画成为了可能。</p>\n<p>单单从API来讲，<code>d3.transition</code>非常简单，用法类似Jquery。 但是想要设计出理想的动画效果，就不得不提到D3绘制图形的一个核心概念<code>General Update Pattern</code>. D3的数据驱动特性的核心和实现就是依靠这个Pattern，而动画和交互自然要从它说起了。</p>\n<blockquote>\n<p>并不是所有图形都必须遵循Update Pattern，比如一次性绘图，无交互的静态图形等。但如果涉及到了动态数据，这个Update Pattern不仅利于写出易于维护的代码，也能更好的发挥D3强大的功能。</p>\n</blockquote>\n<h2 id=\"General-Update-Pattern\"><a href=\"#General-Update-Pattern\" class=\"headerlink\" title=\"General Update Pattern\"></a>General Update Pattern</h2><p><img src=\"/../images/update-pattern.png\" alt=\"image-20200308211328582\"></p>\n<p>D3的数据驱动模式如上图所示，当使用<code>d3.data()</code>将数据<code>Array</code>与DOM元素绑定的时，数据与元素之间有着三个阶段，即</p>\n<ul>\n<li>Enter 已有数据，但页面还未有与之对应的DOM</li>\n<li>Update 数据元素与DOM元素相绑定</li>\n<li>Exit 数据元素已经被删除，但DOM元素还存在，即失去了绑定元素的DOM</li>\n</ul>\n<p>关于这个点，这里不做详细赘述，可参考文档。这里直接对V4和V5版本的<code>General Update Pattern</code>进行介绍。举一个简单的例子：</p>\n<blockquote>\n<p>假设目前已有数据[‘a’, ‘b’, ‘c’….]等字母序列，现在希望通过D3,使用SVG将其呈现在页面上</p>\n</blockquote>\n<h3 id=\"V4\"><a href=\"#V4\" class=\"headerlink\" title=\"V4\"></a>V4</h3><p>通过<code>selection.enter()</code>, <code>selection.exit()</code>与 <code>selection</code>（update）分别指定相应逻辑，内容如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> d3Pattern = <span class=\"function\">(<span class=\"params\">dataSet</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> text = g.selectAll(<span class=\"string\">'text'</span>).data(dataSet)  <span class=\"comment\">// 数据绑定</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  text.enter()     <span class=\"comment\">// enter() 返回绑定数据但是还未生成dom元素的部分</span></span><br><span class=\"line\">      .append(<span class=\"string\">'text'</span>)</span><br><span class=\"line\">      .attr(<span class=\"string\">'class'</span>, <span class=\"string\">'new'</span>)</span><br><span class=\"line\">      .text(<span class=\"function\"><span class=\"params\">d</span> =&gt;</span> d)</span><br><span class=\"line\">      .merge(text)  <span class=\"comment\">// merge后面的代码，将会分别应用于enter于update两个部分，省略写法</span></span><br><span class=\"line\">  \t\t\t.attr(<span class=\"string\">'x'</span>, (d, i) =&gt; <span class=\"number\">18</span> * i)</span><br><span class=\"line\">  </span><br><span class=\"line\">  text.attr(<span class=\"string\">'class'</span>, <span class=\"string\">'update'</span>)  <span class=\"comment\">// text 本身是update部分</span></span><br><span class=\"line\"></span><br><span class=\"line\">  text.exit().remove()  <span class=\"comment\">// exit() 返回数据已经被删除，但是还存在dom的元素</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"V5\"><a href=\"#V5\" class=\"headerlink\" title=\"V5\"></a>V5</h3><p>d3 V5.8.0 引入了一个新的API， <code>selection.join</code> </p>\n<p>这个API的优势在于，对于一些比较简单、不需要特殊定义enter\\exit过程的动作的d3图形，可以简化代码，以上的代码，使用V5的版本写，即</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> d3Pattern = <span class=\"function\">(<span class=\"params\">dataSet</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> text = g.selectAll(<span class=\"string\">'text'</span>).data(dataSet)  <span class=\"comment\">// 数据绑定</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  text.join(</span><br><span class=\"line\">    enter =&gt; enter.append(<span class=\"string\">'text'</span>)</span><br><span class=\"line\">    \t.attr(<span class=\"string\">'calss'</span>, <span class=\"string\">'new'</span>)</span><br><span class=\"line\">    \t.text(<span class=\"function\"><span class=\"params\">d</span> =&gt;</span> d),</span><br><span class=\"line\">    update =&gt; update.attr(<span class=\"string\">'class'</span>, <span class=\"string\">'update'</span>)</span><br><span class=\"line\">  )</span><br><span class=\"line\">    .attr(<span class=\"string\">'x'</span>, (d, i) =&gt; <span class=\"number\">18</span> * i)</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// join的exit默认就是 exit().remove()，因此可以免去</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以发现，使用<code>selection.join()</code>, 并不需要再手动写<code>selection.exit().remove()</code>，这是因为<code>selection.join()</code>这个函数默认的<code>exit()</code>函数已经帮你写好了，该API下，d3的Update Pattern可以写为</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">selection.join(</span><br><span class=\"line\">    enter =&gt; <span class=\"comment\">// enter.. ,</span></span><br><span class=\"line\">    update =&gt; <span class=\"comment\">// update.. ,</span></span><br><span class=\"line\">    exit =&gt; <span class=\"comment\">// exit.. </span></span><br><span class=\"line\">  )</span><br><span class=\"line\">  <span class=\"comment\">// 注意，enter，update等函数一定要return，这样可以对selection继续链式调用</span></span><br></pre></td></tr></table></figure>\n<p>当然，这个API的好处在于，一般的使用场景下（不需要在enter、exit等加特殊的动画或操作），完全可以简写，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svg.selectAll(<span class=\"string\">\"circle\"</span>)</span><br><span class=\"line\">  .data(data)</span><br><span class=\"line\">  .join(<span class=\"string\">\"circle\"</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">\"fill\"</span>, <span class=\"string\">\"none\"</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">\"stroke\"</span>, <span class=\"string\">\"black\"</span>);</span><br></pre></td></tr></table></figure>\n<p>以上的写法，完全等价于</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svg.selectAll(<span class=\"string\">\"circle\"</span>)</span><br><span class=\"line\">  .data(data)</span><br><span class=\"line\">  .join(</span><br><span class=\"line\">    enter =&gt; enter.append(<span class=\"string\">\"circle\"</span>),</span><br><span class=\"line\">    update =&gt; update,</span><br><span class=\"line\">    exit =&gt; exit.remove()</span><br><span class=\"line\">  )</span><br><span class=\"line\">    .attr(<span class=\"string\">\"fill\"</span>, <span class=\"string\">\"none\"</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">\"stroke\"</span>, <span class=\"string\">\"black\"</span>);</span><br></pre></td></tr></table></figure>\n<p>等价于V4版本的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">circles = svg.selectAll(<span class=\"string\">'circle'</span>)</span><br><span class=\"line\">\t.data(data)</span><br><span class=\"line\"></span><br><span class=\"line\">circles.enter()</span><br><span class=\"line\">\t.append(<span class=\"string\">'circle'</span>)</span><br><span class=\"line\">\t.merge(<span class=\"string\">'circle'</span>)</span><br><span class=\"line\">\t\t.attr(<span class=\"string\">'fill'</span>, <span class=\"string\">'none'</span>)</span><br><span class=\"line\">\t\t.attr(<span class=\"string\">'stroke'</span>, <span class=\"string\">'black'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">circles.exit().remove()</span><br></pre></td></tr></table></figure>\n<p>当然，V5完全兼容V4的update Pattern，无论是V4还是V5的新版API，这种Update Pattern的本质没有变，D3仍然是数据绑定，enter/update/exit的工作模式。</p>\n<h3 id=\"Pattern中的key\"><a href=\"#Pattern中的key\" class=\"headerlink\" title=\"Pattern中的key\"></a>Pattern中的key</h3><p>当使用<code>d3.data()</code>绑定数据和dom时，相对应的关系，可能第一个元素对应第一个dom，第二元素对应第二dom等； 但当<code>Array</code>发生变化时，比如重新排序、插入等操作，这时候，数组中元素可能与dom的绑定关系就发生了一些微妙的变化。</p>\n<p>最直观的例子就比如动态改变字符的例子</p>\n<p><img src=\"/../images/text-transition.gif\" alt=\"Kapture 2020-03-08 at 21.56.19\"></p>\n<p>如图，发现新增的字符总是排在最后，实际上，如果数据一致保持和dom绑定的话，理论随机生成新字符，完全应该有机会出现在中间的。</p>\n<p>在数据绑定时，传入一个唯一的key值，即可避免这种情况发生</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">selection.data(data, d =&gt; d.id)</span><br></pre></td></tr></table></figure>\n<p>完成以上步骤，只要定时的调用函数<code>d3Pattern</code>，传入不同的data，即可实现上图的效果</p>\n<p><a href=\"https://codepen.io/vincenttgao/pen/rNVYoYw\" target=\"_blank\" rel=\"noopener\">完整代码</a></p>\n<h2 id=\"Transition\"><a href=\"#Transition\" class=\"headerlink\" title=\"Transition\"></a>Transition</h2><p>好了，前面铺垫了这么多，终于到了主角<code>d3.transition</code>了，但实际上，与之相关API屈指可数，想要让d3画出带交互和炫酷过渡效果的，重点还是对Update Pattern理解透彻。</p>\n<h3 id=\"基本动画使用\"><a href=\"#基本动画使用\" class=\"headerlink\" title=\"基本动画使用\"></a>基本动画使用</h3><p><code>transition</code> 的使用，与jquery十分类似，使用时，只需要对选择的元素调用，并指定修改的属性即可，即<code>selection.transition().attr(...)</code></p>\n<p>比如现在画布上有一个方块，该元素为<code>rect</code>,我想要使其位置从默认的地方，到30位置，并加上动画，代码为</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rect.transition()</span><br><span class=\"line\">\t.attr(<span class=\"string\">'x'</span>, <span class=\"number\">30</span>)  <span class=\"comment\">//  设置新位置</span></span><br></pre></td></tr></table></figure>\n<p>效果如下</p>\n<p><img src=\"/../images/move-box.gif\" alt=\"Kapture 2020-03-08 at 22.17.46\"></p>\n<p>动画的基本使用，就是如此简单，下面简单看下相关的api</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>selection.transition()</td>\n<td>this schedules a transition for the selected elements</td>\n</tr>\n<tr>\n<td>transition.duration()</td>\n<td>duration specifies the animation duration in milliseconds for each element</td>\n</tr>\n<tr>\n<td>transition.ease()</td>\n<td>ease specifies the easing function, example: linear, elastic, bounce</td>\n</tr>\n<tr>\n<td>transition.delay()</td>\n<td>delay specifies the delay in animation in milliseconds for each element</td>\n</tr>\n</tbody>\n</table>\n<p>这里注意d3的api都支持链式调用，因此比如上面的例子，希望将动画时间设置为1s，可以</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rect.transition()</span><br><span class=\"line\">\t.duration(<span class=\"number\">1000</span>)</span><br><span class=\"line\">\t.attr(<span class=\"string\">'x'</span>, <span class=\"number\">30</span>)  <span class=\"comment\">//  设置新位置</span></span><br></pre></td></tr></table></figure>\n<p>同理，ease和delay可以分别设置动画曲线和延迟。</p>\n<h3 id=\"Update-Pattern下的动画\"><a href=\"#Update-Pattern下的动画\" class=\"headerlink\" title=\"Update Pattern下的动画\"></a>Update Pattern下的动画</h3><p>回到最开始的例子，这里用V4版本的Update Pattern举例</p>\n<p>因为transition是应用在<code>selection</code>上的，所以为了方便使用，我们可以先定义好动画</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> t = d3.transtion().duration(<span class=\"number\">750</span>)</span><br></pre></td></tr></table></figure>\n<p>接下来，我们希望新加入的文字从上面掉下来，且位置更新时，能有一个动画效果，这时候需要设置在<code>enter()</code>时，位置有一个从上倒下的过程(transtion)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> d3Pattern = <span class=\"function\">(<span class=\"params\">dataSet</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> t = d3.transtion().duration(<span class=\"number\">750</span>) <span class=\"comment\">// 定义动画</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> text = g.selectAll(<span class=\"string\">'text'</span>).data(dataSet)</span><br><span class=\"line\">  </span><br><span class=\"line\">  text.enter()  </span><br><span class=\"line\">      .append(<span class=\"string\">'text'</span>)</span><br><span class=\"line\">      .attr(<span class=\"string\">'class'</span>, <span class=\"string\">'new'</span>)</span><br><span class=\"line\">      .text(<span class=\"function\"><span class=\"params\">d</span> =&gt;</span> d)</span><br><span class=\"line\">      .attr(<span class=\"string\">'y'</span>, <span class=\"number\">-60</span>)</span><br><span class=\"line\">  \t\t\t.transition(t)</span><br><span class=\"line\">  \t\t\t\t.attr(<span class=\"string\">'y'</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">  \t\t\t\t.attr(<span class=\"string\">'x'</span>, (d, i) =&gt; <span class=\"number\">18</span> * i)</span><br><span class=\"line\">  </span><br><span class=\"line\">  text.attr(<span class=\"string\">'class'</span>, <span class=\"string\">'update'</span>)</span><br><span class=\"line\">  \t.attr(<span class=\"string\">'y'</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">  \t.transition(t)</span><br><span class=\"line\">  \t\t.attr(<span class=\"string\">'x'</span>, (d, i) =&gt; <span class=\"number\">18</span> * i)</span><br><span class=\"line\"></span><br><span class=\"line\">  text.exit()</span><br><span class=\"line\">    .transition(t)</span><br><span class=\"line\">      .attr(<span class=\"string\">'y'</span>, <span class=\"number\">60</span>)</span><br><span class=\"line\">      .remove()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/../images/letter-transition-no-down.gif\" alt=\"Kapture 2020-03-08 at 22.40.14\"></p>\n<p>可以看到，原来呆板的样式，已经变的灵动多了。 当然，也可以继续为退出(exit)的文字，加上红色，与掉落的动画，让整体更具有动效，只需要对exit的部分做相应的处理：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">text.exit()</span><br><span class=\"line\">\t.transition(t)</span><br><span class=\"line\">\t\t.attr(<span class=\"string\">'y'</span>, <span class=\"number\">60</span>)</span><br><span class=\"line\">\t\t.remove()</span><br></pre></td></tr></table></figure>\n<p><img src=\"/../images/complete-transition.gif\" alt=\"Kapture 2020-03-08 at 22.46.24\"></p>\n<p>如图，这是加了向下掉落和透明度变化的动画效果。</p>\n<p><a href=\"https://codepen.io/vincenttgao/pen/XWbzOdY?editors=1111\" target=\"_blank\" rel=\"noopener\">完整代码</a></p>\n<h3 id=\"实战应用\"><a href=\"#实战应用\" class=\"headerlink\" title=\"实战应用\"></a>实战应用</h3><p>比如现在已经有一个静态的柱状图，希望在鼠标hover的时候，有一些动态效果变化，如下图</p>\n<p><img src=\"/../images/bar-transition.gif\" alt=\"Kapture 2020-03-08 at 23.03.53\"></p>\n<p>对于柱状图的实现，这里就不赘述，这里解释下核心代码，思路与上面提到的完全相同：</p>\n<ol>\n<li><p>监听鼠标移入事件</p>\n<ol start=\"2\">\n<li>选择当前的bar，通过transition修改属性</li>\n<li>监听鼠标移出</li>\n<li>选择当前bar，鼠标移出，恢复属性</li>\n</ol>\n</li>\n</ol>\n<p>核心代码如下： </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svgElement</span><br><span class=\"line\">    .on(<span class=\"string\">'mouseenter'</span>, (actual, i) =&gt; &#123;</span><br><span class=\"line\">        d3.select(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">          .transition()</span><br><span class=\"line\">        \t.duration(<span class=\"number\">300</span>)</span><br><span class=\"line\">        \t.attr(<span class=\"string\">'opacity'</span>, <span class=\"number\">0.6</span>)</span><br><span class=\"line\">        \t.attr(<span class=\"string\">'x'</span>, (a) =&gt; xScale(a.language) - <span class=\"number\">5</span>)</span><br><span class=\"line\">        \t.attr(<span class=\"string\">'width'</span>, xScale.bandwidth() + <span class=\"number\">10</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .on(<span class=\"string\">'mouseleave’, (actual, i) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"string\">        d3.select(this)</span></span><br><span class=\"line\"><span class=\"string\">          .transition()</span></span><br><span class=\"line\"><span class=\"string\">          .duration(300)</span></span><br><span class=\"line\"><span class=\"string\">          .attr('</span>opacity<span class=\"string\">', 1)</span></span><br><span class=\"line\"><span class=\"string\">          .attr('</span>x<span class=\"string\">', (a) =&gt; xScale(a.language))</span></span><br><span class=\"line\"><span class=\"string\">          .attr('</span>width<span class=\"string\">', xScale.bandwidth())</span></span><br><span class=\"line\"><span class=\"string\">    &#125;)</span></span><br></pre></td></tr></table></figure>\n<p>这个柱状图的源码与教程出自<a href=\"https://blog.risingstack.com/d3-js-tutorial-bar-charts-with-javascript/\" target=\"_blank\" rel=\"noopener\">D3.js Tutorial: Building Interactive Bar Charts with JavaScript</a></p>\n<h3 id=\"插值动画\"><a href=\"#插值动画\" class=\"headerlink\" title=\"插值动画\"></a>插值动画</h3><p>对于一些特殊的过渡，比如颜色的变化、数字的跳变等，如果没有插值函数，直接使用<code>transition().attr()</code>是无法实现的。</p>\n<p>因此，d3提供了插值函数和插值动画的接口用于这类动画实现。当然，对于大多数场景，非差值动画都可满足了。</p>\n<h4 id=\"特殊的插值\"><a href=\"#特殊的插值\" class=\"headerlink\" title=\"特殊的插值\"></a>特殊的插值</h4><p>对于一些常用的属性插值，d3提供了非常方便入口，分别是<code>attrTween</code>(属性插值)/<code>styleTween</code>（样式插值）/<code>textTween</code> 文字插值</p>\n<p>这类插值主要用于比如颜色、线条粗细等“属性”差值，可以使用<code>attrTween()</code>和<code>styleTween</code>，对于数字变化，连续跳变，可以使用<code>textTween</code>他们的用法类似，如下： </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//颜色插值，从红色变为蓝色</span></span><br><span class=\"line\">transition.attrTween(<span class=\"string\">'fill'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> d3.interpolateRgb(<span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">transition.styleTween(<span class=\"string\">'color'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> d3.interpolateRgb(<span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>插值函数的第一个参数，是要修改的内容或属性，功能类似<code>transition().attr()</code>里，attr的内容；第二个参数是返回的插值函数，可以使用d3提供的一些插值函数，当然也可以自定义插值函数。</p>\n<p>举个简单的例子，比如想要实现一下效果： </p>\n<p><img src=\"/../images/tween-letter.gif\" alt=\"Kapture 2020-03-13 at 20.30.23\"></p>\n<p>只需要对元素添加鼠标事件，并通过以上的插值函数完成即可</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svg.append(<span class=\"string\">'text'</span>)</span><br><span class=\"line\">\t.text(<span class=\"string\">'A'</span>)</span><br><span class=\"line\">\t.on(<span class=\"string\">'mouseenter'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  \td3.select(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  \t\t.transition()</span><br><span class=\"line\">  \t\t.attrTween(<span class=\"string\">'fill'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      \t<span class=\"keyword\">return</span> d3.interpolateRgb(<span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span>);</span><br><span class=\"line\">    \t&#125;)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">  .on(<span class=\"string\">'mouseleave'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;...&#125;)</span><br></pre></td></tr></table></figure>\n<p>接下来说下自定义函数，比如仍然是红色变为蓝色，我们可以在插值函数返回自己定义的函数<code>func(t)</code>, 该函数会在动画时间内不断的运行，t为[0, 1]，借助这个思路，以上的效果可以用自定义函数实现如下: </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">svg.append(<span class=\"string\">'text'</span>)</span><br><span class=\"line\">\t.text(<span class=\"string\">'A'</span>)</span><br><span class=\"line\">\t.on(<span class=\"string\">'mouseenter'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  \td3.select(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  \t\t.transition()</span><br><span class=\"line\">  \t\t.attrTween(<span class=\"string\">'fill'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      \t<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"string\">`rgb(<span class=\"subst\">$&#123;i * <span class=\"number\">255</span>&#125;</span>, 0, <span class=\"subst\">$&#123;<span class=\"number\">255</span>-(i * <span class=\"number\">255</span>)&#125;</span>)`</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    \t&#125;)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\t.on(<span class=\"string\">'mouseleave'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  \t... <span class=\"comment\">// 与上类似</span></span><br><span class=\"line\">\t&#125;)</span><br></pre></td></tr></table></figure>\n<p>以上两种方案，均可以实现动图的效果哦。</p>\n<p>可以看到，对于插值动画，核心在于插值内容的产生。d3提供了多款插值，相关的列表如下，比如在使用数字跳变动画时，就可以使用<code>d3.interpolatorRound(start,end)</code>来产生整形的数字插值； <code>d3.interpolateRgb(color, color2)</code>来产生颜色插值等，具体的插值函数用法可查阅相关API。</p>\n<ul>\n<li><code>d3.interpolatNumber</code></li>\n<li><code>d3.interpolatRound</code></li>\n<li><code>d3.interpolatString</code></li>\n<li><code>d3.interpolatRgb</code></li>\n<li><code>d3.interpolatHsl</code></li>\n<li><code>d3.interpolatLab</code></li>\n<li><code>d3.interpolatHcl</code></li>\n<li><code>d3.interpolatArray</code></li>\n<li><code>d3.interpolatObject</code></li>\n<li><code>d3.interpolatTransform</code></li>\n<li><code>d3.interpolatZoom</code></li>\n</ul>\n<h3 id=\"通用插值\"><a href=\"#通用插值\" class=\"headerlink\" title=\"通用插值\"></a>通用插值</h3><p>当然，除了前面提到的API，还有一个更通用的产值函数API，<code>d3.tween()</code></p>\n<p>同<code>attrTween()</code>等类似，它的第二个参数也是传入插值函数；不同的是，第一个参数，可以传入更通用的想要改变的内容，比如同样是上面的<code>fill</code>属性，使用通用插值函数的写法就是:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">selection.transition()</span><br><span class=\"line\">\t.tween(<span class=\"string\">'attr.fill'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">`rgb(<span class=\"subst\">$&#123;i * <span class=\"number\">255</span>&#125;</span>, 0, <span class=\"subst\">$&#123;<span class=\"number\">255</span>-(i * <span class=\"number\">255</span>)&#125;</span>)`</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">\t&#125;)</span><br></pre></td></tr></table></figure>\n<p>于是我们发现，其实通用API与前面的特殊的三个API用法及其类似，唯一不同的就是通用API的第一个参数可以接受更广泛的变更属性。</p>\n<p>这里就不多举例了，关于插值函数的一些参考实例可以在这里<a href=\"https://observablehq.com/@d3/transition-texttween\" target=\"_blank\" rel=\"noopener\">查看</a></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ol>\n<li><a href=\"https://blog.risingstack.com/d3-js-tutorial-bar-charts-with-javascript/\" target=\"_blank\" rel=\"noopener\">D3.js Tutorial: Building Interactive Bar Charts with JavaScript</a></li>\n<li><a href=\"https://www.freecodecamp.org/news/how-to-work-with-d3-jss-general-update-pattern-8adce8d55418/\" target=\"_blank\" rel=\"noopener\">How to work with D3.js’s general update pattern</a></li>\n<li><a href=\"http://duspviz.mit.edu/d3-workshop/transitions-animation/\" target=\"_blank\" rel=\"noopener\">Interaction and Animation: D3 Transitions, Behaviors, and Brushing</a></li>\n<li><a href=\"https://observablehq.com/@d3/selection-join\" target=\"_blank\" rel=\"noopener\">d3-selection-join</a></li>\n<li><a href=\"https://observablehq.com/@d3/sortable-bar-chart\" target=\"_blank\" rel=\"noopener\">sortable-bar-chart</a></li>\n<li><a href=\"http://4waisenkinder.de/blog/2014/05/11/d3-dot-js-tween-in-detail/\" target=\"_blank\" rel=\"noopener\">Using Basic and Tween Transitions in d3.js</a></li>\n</ol>\n"},{"title":"小米路由器R3G刷机指南","date":"2018-12-20T05:37:21.000Z","_content":"# 小米路由刷机指南\n\n## 1. 开箱并刷机至开发板\n\n为了能够获得更高权限，开箱后必须要刷开发板，这个是官方支持的，没有什么风险，步骤如下：\n\n1. 在miwifi.com官网下载路由器对应的开发版ROM包，并将其放在U盘的根目录下，命名为miwifi.bin\n2. 断开小米路由器的电源，将U盘插入路由器的USB接口\n3. 按下reset按钮后重新接入电源，待指示灯变为黄色闪烁状态后松开reset键\n4. 等待5~8分钟，刷机完成之后系统会自动重启并进入正常的启动状态（指示灯由黄灯常亮变为蓝灯常亮），此时，说明刷机成功完成\n\n## 2. 开启SSH权限\n\n与一般的OPENWRT的路由器不太相同，开启SSH权限需要小米账号以及官方文件的支持。主要有以下步骤:\n\n- 使用小米路由APP登陆管理界面，绑定小米账号\n- 到[小米路由官网](http://miwifi.com/miwifi_open.html)下载SSH工具，如下图\n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fxnk3n9fgnj211v0f8aeq.jpg)\n\n- 根据官网提示，将SSH工具下载到U盘，开启SSH权限\n\n\n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fyd5qt2xq0j20nj0b2my6.jpg)\n\n## 3. 刷入Breed\n\nBreed就是一个不死UBOOT，有了它，不用担心刷机成砖的问题，因此首先刷入该文件，为了方便，将之后用的文件全部下载好\n\n- breed 链接：https://pan.baidu.com/s/1zI0e_R6qySDj-TpjqracUw \n  提取码：n41w \n  复制这段内容后打开百度网盘手机App，操作更方便哦\n- padavan固件：链接：https://pan.baidu.com/s/14DYiNJWjpN3_S6eCoRHT_Q \n  提取码：9gpj \n  复制这段内容后打开百度网盘手机App，操作更方便哦\n\n首先刷入breed，通过WINSCP与路由连接，小米官方固件下，地址为196.168.31.1，登录名root，密码为刚才ssh工具官网中所给的密码。\n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fyd5rw9x4ej20go0aoad1.jpg)\n\n登陆后，将breed.bin文件拖入根目录下的tmp文件夹，打开终端，输入指令`mtd -r write /tmp/breed.bin Bootloader`\n\n1. 刷入后，机器会重新启动，手动设置电脑有线网卡的IP为192.168.1.3\n2. 电脑与路由器WAN口连接\n3. 用牙签顶住路由的reset键再开机，等到路由的灯狂闪的时候，松开reset键，\n4. 电脑上在浏览器中输入192.168.1.1，就进入不死breed的控制台了\n\n## 4. 进入Breed，备份原来的固件\n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fyd5sbhuirj20go09sjul.jpg)\n\n进入Breed，选择固件备份，然后将原来的内容进行备份，有备无患。\n\n[备份](https://pan.baidu.com/s/13GxeuCdm1S7cfpP0fuuGnA) 提取码：k2x7 \n\n## 5. 刷入固件\n\n刷入刚才下载的padavan固件\n\n刷入后，路由管理地址变为: `192.168.123.1`  \n\n管理账号和密码均为`admin`\n\n## 6. 补充\n\ngl-inet 6404路由的管理页面为`192.168.8.1`\n\n","source":"_posts/year-12-20-小米路由器R3G刷机指南.md","raw":"---\ntitle: 小米路由器R3G刷机指南\ndate: 2018-12-20 13:37:21\ntags: \n     - 黑科技 \n     - 路由器 \n     - 刷机\n---\n# 小米路由刷机指南\n\n## 1. 开箱并刷机至开发板\n\n为了能够获得更高权限，开箱后必须要刷开发板，这个是官方支持的，没有什么风险，步骤如下：\n\n1. 在miwifi.com官网下载路由器对应的开发版ROM包，并将其放在U盘的根目录下，命名为miwifi.bin\n2. 断开小米路由器的电源，将U盘插入路由器的USB接口\n3. 按下reset按钮后重新接入电源，待指示灯变为黄色闪烁状态后松开reset键\n4. 等待5~8分钟，刷机完成之后系统会自动重启并进入正常的启动状态（指示灯由黄灯常亮变为蓝灯常亮），此时，说明刷机成功完成\n\n## 2. 开启SSH权限\n\n与一般的OPENWRT的路由器不太相同，开启SSH权限需要小米账号以及官方文件的支持。主要有以下步骤:\n\n- 使用小米路由APP登陆管理界面，绑定小米账号\n- 到[小米路由官网](http://miwifi.com/miwifi_open.html)下载SSH工具，如下图\n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fxnk3n9fgnj211v0f8aeq.jpg)\n\n- 根据官网提示，将SSH工具下载到U盘，开启SSH权限\n\n\n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fyd5qt2xq0j20nj0b2my6.jpg)\n\n## 3. 刷入Breed\n\nBreed就是一个不死UBOOT，有了它，不用担心刷机成砖的问题，因此首先刷入该文件，为了方便，将之后用的文件全部下载好\n\n- breed 链接：https://pan.baidu.com/s/1zI0e_R6qySDj-TpjqracUw \n  提取码：n41w \n  复制这段内容后打开百度网盘手机App，操作更方便哦\n- padavan固件：链接：https://pan.baidu.com/s/14DYiNJWjpN3_S6eCoRHT_Q \n  提取码：9gpj \n  复制这段内容后打开百度网盘手机App，操作更方便哦\n\n首先刷入breed，通过WINSCP与路由连接，小米官方固件下，地址为196.168.31.1，登录名root，密码为刚才ssh工具官网中所给的密码。\n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fyd5rw9x4ej20go0aoad1.jpg)\n\n登陆后，将breed.bin文件拖入根目录下的tmp文件夹，打开终端，输入指令`mtd -r write /tmp/breed.bin Bootloader`\n\n1. 刷入后，机器会重新启动，手动设置电脑有线网卡的IP为192.168.1.3\n2. 电脑与路由器WAN口连接\n3. 用牙签顶住路由的reset键再开机，等到路由的灯狂闪的时候，松开reset键，\n4. 电脑上在浏览器中输入192.168.1.1，就进入不死breed的控制台了\n\n## 4. 进入Breed，备份原来的固件\n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1fyd5sbhuirj20go09sjul.jpg)\n\n进入Breed，选择固件备份，然后将原来的内容进行备份，有备无患。\n\n[备份](https://pan.baidu.com/s/13GxeuCdm1S7cfpP0fuuGnA) 提取码：k2x7 \n\n## 5. 刷入固件\n\n刷入刚才下载的padavan固件\n\n刷入后，路由管理地址变为: `192.168.123.1`  \n\n管理账号和密码均为`admin`\n\n## 6. 补充\n\ngl-inet 6404路由的管理页面为`192.168.8.1`\n\n","slug":"小米路由器R3G刷机指南","published":1,"updated":"2022-08-17T07:53:21.232Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6xbhzkc0015zk08dou3rm37","content":"<h1 id=\"小米路由刷机指南\"><a href=\"#小米路由刷机指南\" class=\"headerlink\" title=\"小米路由刷机指南\"></a>小米路由刷机指南</h1><h2 id=\"1-开箱并刷机至开发板\"><a href=\"#1-开箱并刷机至开发板\" class=\"headerlink\" title=\"1. 开箱并刷机至开发板\"></a>1. 开箱并刷机至开发板</h2><p>为了能够获得更高权限，开箱后必须要刷开发板，这个是官方支持的，没有什么风险，步骤如下：</p>\n<ol>\n<li>在miwifi.com官网下载路由器对应的开发版ROM包，并将其放在U盘的根目录下，命名为miwifi.bin</li>\n<li>断开小米路由器的电源，将U盘插入路由器的USB接口</li>\n<li>按下reset按钮后重新接入电源，待指示灯变为黄色闪烁状态后松开reset键</li>\n<li>等待5~8分钟，刷机完成之后系统会自动重启并进入正常的启动状态（指示灯由黄灯常亮变为蓝灯常亮），此时，说明刷机成功完成</li>\n</ol>\n<h2 id=\"2-开启SSH权限\"><a href=\"#2-开启SSH权限\" class=\"headerlink\" title=\"2. 开启SSH权限\"></a>2. 开启SSH权限</h2><p>与一般的OPENWRT的路由器不太相同，开启SSH权限需要小米账号以及官方文件的支持。主要有以下步骤:</p>\n<ul>\n<li>使用小米路由APP登陆管理界面，绑定小米账号</li>\n<li>到<a href=\"http://miwifi.com/miwifi_open.html\" target=\"_blank\" rel=\"noopener\">小米路由官网</a>下载SSH工具，如下图</li>\n</ul>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fxnk3n9fgnj211v0f8aeq.jpg\" alt=\"\"></p>\n<ul>\n<li>根据官网提示，将SSH工具下载到U盘，开启SSH权限</li>\n</ul>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fyd5qt2xq0j20nj0b2my6.jpg\" alt=\"\"></p>\n<h2 id=\"3-刷入Breed\"><a href=\"#3-刷入Breed\" class=\"headerlink\" title=\"3. 刷入Breed\"></a>3. 刷入Breed</h2><p>Breed就是一个不死UBOOT，有了它，不用担心刷机成砖的问题，因此首先刷入该文件，为了方便，将之后用的文件全部下载好</p>\n<ul>\n<li>breed 链接：<a href=\"https://pan.baidu.com/s/1zI0e_R6qySDj-TpjqracUw\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1zI0e_R6qySDj-TpjqracUw</a><br>提取码：n41w<br>复制这段内容后打开百度网盘手机App，操作更方便哦</li>\n<li>padavan固件：链接：<a href=\"https://pan.baidu.com/s/14DYiNJWjpN3_S6eCoRHT_Q\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/14DYiNJWjpN3_S6eCoRHT_Q</a><br>提取码：9gpj<br>复制这段内容后打开百度网盘手机App，操作更方便哦</li>\n</ul>\n<p>首先刷入breed，通过WINSCP与路由连接，小米官方固件下，地址为196.168.31.1，登录名root，密码为刚才ssh工具官网中所给的密码。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fyd5rw9x4ej20go0aoad1.jpg\" alt=\"\"></p>\n<p>登陆后，将breed.bin文件拖入根目录下的tmp文件夹，打开终端，输入指令<code>mtd -r write /tmp/breed.bin Bootloader</code></p>\n<ol>\n<li>刷入后，机器会重新启动，手动设置电脑有线网卡的IP为192.168.1.3</li>\n<li>电脑与路由器WAN口连接</li>\n<li>用牙签顶住路由的reset键再开机，等到路由的灯狂闪的时候，松开reset键，</li>\n<li>电脑上在浏览器中输入192.168.1.1，就进入不死breed的控制台了</li>\n</ol>\n<h2 id=\"4-进入Breed，备份原来的固件\"><a href=\"#4-进入Breed，备份原来的固件\" class=\"headerlink\" title=\"4. 进入Breed，备份原来的固件\"></a>4. 进入Breed，备份原来的固件</h2><p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fyd5sbhuirj20go09sjul.jpg\" alt=\"\"></p>\n<p>进入Breed，选择固件备份，然后将原来的内容进行备份，有备无患。</p>\n<p><a href=\"https://pan.baidu.com/s/13GxeuCdm1S7cfpP0fuuGnA\" target=\"_blank\" rel=\"noopener\">备份</a> 提取码：k2x7 </p>\n<h2 id=\"5-刷入固件\"><a href=\"#5-刷入固件\" class=\"headerlink\" title=\"5. 刷入固件\"></a>5. 刷入固件</h2><p>刷入刚才下载的padavan固件</p>\n<p>刷入后，路由管理地址变为: <code>192.168.123.1</code>  </p>\n<p>管理账号和密码均为<code>admin</code></p>\n<h2 id=\"6-补充\"><a href=\"#6-补充\" class=\"headerlink\" title=\"6. 补充\"></a>6. 补充</h2><p>gl-inet 6404路由的管理页面为<code>192.168.8.1</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"小米路由刷机指南\"><a href=\"#小米路由刷机指南\" class=\"headerlink\" title=\"小米路由刷机指南\"></a>小米路由刷机指南</h1><h2 id=\"1-开箱并刷机至开发板\"><a href=\"#1-开箱并刷机至开发板\" class=\"headerlink\" title=\"1. 开箱并刷机至开发板\"></a>1. 开箱并刷机至开发板</h2><p>为了能够获得更高权限，开箱后必须要刷开发板，这个是官方支持的，没有什么风险，步骤如下：</p>\n<ol>\n<li>在miwifi.com官网下载路由器对应的开发版ROM包，并将其放在U盘的根目录下，命名为miwifi.bin</li>\n<li>断开小米路由器的电源，将U盘插入路由器的USB接口</li>\n<li>按下reset按钮后重新接入电源，待指示灯变为黄色闪烁状态后松开reset键</li>\n<li>等待5~8分钟，刷机完成之后系统会自动重启并进入正常的启动状态（指示灯由黄灯常亮变为蓝灯常亮），此时，说明刷机成功完成</li>\n</ol>\n<h2 id=\"2-开启SSH权限\"><a href=\"#2-开启SSH权限\" class=\"headerlink\" title=\"2. 开启SSH权限\"></a>2. 开启SSH权限</h2><p>与一般的OPENWRT的路由器不太相同，开启SSH权限需要小米账号以及官方文件的支持。主要有以下步骤:</p>\n<ul>\n<li>使用小米路由APP登陆管理界面，绑定小米账号</li>\n<li>到<a href=\"http://miwifi.com/miwifi_open.html\" target=\"_blank\" rel=\"noopener\">小米路由官网</a>下载SSH工具，如下图</li>\n</ul>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fxnk3n9fgnj211v0f8aeq.jpg\" alt=\"\"></p>\n<ul>\n<li>根据官网提示，将SSH工具下载到U盘，开启SSH权限</li>\n</ul>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fyd5qt2xq0j20nj0b2my6.jpg\" alt=\"\"></p>\n<h2 id=\"3-刷入Breed\"><a href=\"#3-刷入Breed\" class=\"headerlink\" title=\"3. 刷入Breed\"></a>3. 刷入Breed</h2><p>Breed就是一个不死UBOOT，有了它，不用担心刷机成砖的问题，因此首先刷入该文件，为了方便，将之后用的文件全部下载好</p>\n<ul>\n<li>breed 链接：<a href=\"https://pan.baidu.com/s/1zI0e_R6qySDj-TpjqracUw\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1zI0e_R6qySDj-TpjqracUw</a><br>提取码：n41w<br>复制这段内容后打开百度网盘手机App，操作更方便哦</li>\n<li>padavan固件：链接：<a href=\"https://pan.baidu.com/s/14DYiNJWjpN3_S6eCoRHT_Q\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/14DYiNJWjpN3_S6eCoRHT_Q</a><br>提取码：9gpj<br>复制这段内容后打开百度网盘手机App，操作更方便哦</li>\n</ul>\n<p>首先刷入breed，通过WINSCP与路由连接，小米官方固件下，地址为196.168.31.1，登录名root，密码为刚才ssh工具官网中所给的密码。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fyd5rw9x4ej20go0aoad1.jpg\" alt=\"\"></p>\n<p>登陆后，将breed.bin文件拖入根目录下的tmp文件夹，打开终端，输入指令<code>mtd -r write /tmp/breed.bin Bootloader</code></p>\n<ol>\n<li>刷入后，机器会重新启动，手动设置电脑有线网卡的IP为192.168.1.3</li>\n<li>电脑与路由器WAN口连接</li>\n<li>用牙签顶住路由的reset键再开机，等到路由的灯狂闪的时候，松开reset键，</li>\n<li>电脑上在浏览器中输入192.168.1.1，就进入不死breed的控制台了</li>\n</ol>\n<h2 id=\"4-进入Breed，备份原来的固件\"><a href=\"#4-进入Breed，备份原来的固件\" class=\"headerlink\" title=\"4. 进入Breed，备份原来的固件\"></a>4. 进入Breed，备份原来的固件</h2><p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1fyd5sbhuirj20go09sjul.jpg\" alt=\"\"></p>\n<p>进入Breed，选择固件备份，然后将原来的内容进行备份，有备无患。</p>\n<p><a href=\"https://pan.baidu.com/s/13GxeuCdm1S7cfpP0fuuGnA\" target=\"_blank\" rel=\"noopener\">备份</a> 提取码：k2x7 </p>\n<h2 id=\"5-刷入固件\"><a href=\"#5-刷入固件\" class=\"headerlink\" title=\"5. 刷入固件\"></a>5. 刷入固件</h2><p>刷入刚才下载的padavan固件</p>\n<p>刷入后，路由管理地址变为: <code>192.168.123.1</code>  </p>\n<p>管理账号和密码均为<code>admin</code></p>\n<h2 id=\"6-补充\"><a href=\"#6-补充\" class=\"headerlink\" title=\"6. 补充\"></a>6. 补充</h2><p>gl-inet 6404路由的管理页面为<code>192.168.8.1</code></p>\n"},{"title":"Mjpg-Streamer+Node.js实现在树莓派上的监控与拍照","date":"2019-03-09T14:42:45.000Z","_content":"\n最近在做一个机器人项目，需要将试试捕获安装于机器人身上的视频图像，并能够对机器人进行无线运动控制。作为前端工程师的我，很自然的想到了使用Node作为服务器和机器人的控制中心，通过前端页面实现对机器人控制和视频图像的捕捉。\n\n本文主要对项目中的一个单元：视频图像的捕捉和拍照功能进行开发记录和解析。\n\n实现功能\n一： 远程视频图像获取\n二： 视频图像清晰度调节\n三： 拍照功能\n\n---\n## 基于Express的服务器环境搭建\n\nExpress是基于Node的一个快速搭建服务器的框架，项目使用Express快速搭建服务器。\n### node的安装\n首先，更新所有安装列表到最新的状态：\n``` bash\npi@raspberrypi:~$ sudo apt-get update\n```\n\n升级所有安装包到最新版本：\n\n```bash\npi@raspberrypi:~$ sudo apt-get dist-upgrade\n```\n接下来，下载和安装node(注意版本号使用_8.x)\n\n```bash\npi@raspberrypi:~$ curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -\n```\n\n现在可以安装了：\n\n```bash\npi@raspberrypi:~$ sudo apt-get install -y nodejs\n```\n\n测试是否安装成功：\n\n```bash\npi@raspberrypi:~$ node -v\n```\n\n### Express安装\n\n使用Node的包管理工具npm来新建项目和安装框架\n\n首先，进入项目目录，并新建工程:\n```bash\n$ cd Public/WebProject/FisrtPage/\n$ npm init -y\n```\n安装 Express 并将其保存到依赖列表中：\n以下命令会将 Express 框架安装在当前目录的 node_modules 目录中\n```bash\n$ npm install express --save\n```\n然后，在该项目文件下新建`server.js`文件，引入Express就可以很方便的搭建起一个服务器。具体的内容在后面进行分析。\n\n### Mjpg-Streamer\n\n项目使用的是一个USB摄像头，为了能将图像捕获并通过HTTP转发，项目使用Mjpg-Streamer实现这一功能。\n1. 安装必要的库\n```bash\nsudo apt-get update\nsudo apt-get install libjpeg8-dev\nsudo apt-get install imagemagick\nsudo apt-get install libv4l-dev //\nsudo apt-get install cmake //编译工具\n```\n 2. 为了向后兼容，链接videodev2.h和videodev.h\n```bash\nsudo ln -s /usr/include/linux/videodev2.h /usr/include/linux/videodev/h\n```\n注意，这里的`sudo ln -s`是非常重要的操作命令，类似于为a做一个超链接\n\n3. git开源代码到本地，编译进入到home目录，然后开始克隆\n```bash\ncd ~\nsudo git clone https://github.com/jacksonliam/mjpg-streamer.git\ncd mjpg-streamer/mjpg-streamer-experimental\n```\n4. 编译和安装\n```bash\nsudo make\nsudo make install\n```\n5. 测试和使用\n\n完成以上步骤之后，可以开始测试一下。 插入摄像头，执行以下命令，分别在两个窗口打开\n```bash\nsudo mjpg_streamer -i \"./input_uvc.so -r 640x480 -q 70 -f 15 -d /dev/video1 -n\" -o \"./output_http.so -p 8080 -w /usr/local/www\"\n```\n出现一下的内容，表明安装成功\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1g0wxsj1795j20dw09gads.jpg)\n这样，打开浏览器输入`http://localhost:8080/?action=stream`就可以看到视频图像，其中`localhost`在实际使用中，换成了树莓派的IP地址，树莓派已经提前设置了静态地址，我使用的是`192.168.123.251`，因此，视频的地址就顾定成了：\n\n`http://192.168.123.251:8080/?action=stream`\n\n## 依赖模块\n### shelljs\n上面使用的Mjpg-Streamer可以通过改变参数实现对清晰度、帧率的调整，比如将上面的图像修改为720P、15帧的指令为：\n```bash\nmjpg_streamer -i \"input_uvc.so -r 1280x720 -f 15 -n\" -o \"output_http.so \"\n```\n但是这个是在终端中执行的命令，而服务器是使用Node，因此这里使用了shelljs实现在Node运行shell指令。\n\n首先安装shelljs\n```bash\nnpm install shelljs -S\n```\n有关该模块的具体使用及相关API可以查阅[官网](https://github.com/shelljs/shelljs),本项目中主要使用了两个指令是：\n- `shell.exec()` 执行某个指令\n- `shell.cd()` 进入某个目录\n\n为了在后台实现不同分辨率图像的转换，专门写一个函数来实现切换，并通过变量`videoStatus`的状态来表示不同的分辨率，与前端相对应的:\n* videoStatus: 1-流畅\n* videoStatus: 2-清晰\n* videoStatus: 3-高清\n  \n清晰度切换的函数实现如下:\n```JavaScript\nvar videoStatus = 0;  // 1-流畅； 2-清晰； 3-高清， 默认清晰\nconst videoCommand = [\n\t'mjpg_streamer -i \"./input_uvc.so -r 640x480 -q 70 -f 30 -d /dev/video0 -n\" -o \"./output_http.so -p 8082 -w /usr/local/www\"',\n\t'mjpg_streamer -i \"./input_uvc.so -r 1280x720 -q 70 -f 15 -d /dev/video0 -n\" -o \"./output_http.so -p 8082 -w /usr/local/www\"',\n\t'mjpg_streamer -i \"./input_uvc.so -r 1920x1080 -q 70 -f 15 -d /dev/video0 -n\" -o \"./output_http.so -p 8082 -w /usr/local/www\"'\n]\nfunction openVideo(qulity) {\n\treturn new Promise((resolve,reject) => {\n\t\tif (shell.exec('pgrep mjpg_streamer').stdout !== '') {\n\t\t\tshell.exec('killall mjpg_streamer');\n\t\t}\n\t\tlet command = videoCommand[qulity];\n\t\tshell.cd('~');\n\t\tshell.cd('mjpg-streamer/mjpg-streamer-experimental/')\n\t\tshell.exec(command, (code, std, err) => {\n\t\t\tconsole.log('Exit code:', code);\n\t\t\tconsole.log('Program output:', std);\n\t\t\tconsole.log('Program stderr:', err);\n\t\t})\n\t\tvideoStatus = +qulity + 1;\n\t\tresolve('Success');\n\t})\n}\n```\n对关键的几条指令进行一下说明：\n* `shell.exec('pgrep mjpg_streamer').stdout !== ''`\n\n\n`pgrep`以名称为依据从运行进程队列中查找进程,并显示查找到进程的id。在shelljs中，stdout是指令的输出，如果不存在进程，则返回为空； 这里加判断的意思主要**在于如果`mjpg`已经在运行，则要杀死该进程（清晰度更换通过重启`mjpg`实现）**\n* `let command = videoCommand[qulity]`\n\n\n具体的程序执行取决于前端的请求，根据`qulity`来开启不同清晰度的摄像头。\n\n接下里，对设置清晰度的请求，设置服务器响应,并开启服务器:\n```JavaScript\nvar express = require('express');\nvar app = express();\nvar bodyParse = require(\"body-parser\");\n\napp.post('/VideoSet',(req,res) => {\n\tif(+req.body.Video === videoStatus) {\n\t\tres.end('Same Video Set');\n\t\treturn;\n\t}\n\tswitch (req.body.Video) {\n\t\tcase \"1\": \n\t\t\topenVideo(0);\n\t\t\tres.end('Success');\n\t\t\tbreak;\n\t\tcase \"2\":\n\t\t\topenVideo(1);\n\t\t\tres.end('Success');\n\t\t\tbreak;\n\t\tcase \"3\": \n\t\t\topenVideo(2);\n\t\t\tres.end('Success');\n\t\t\tbreak;\n\t}\n})\n\nvar server = app.listen(8081,function(){\n\tconsole.log(\"Server is running at 8081 port...\");\n});\n```\n\n### serialport\n\n项目除了传统前端的内容，还涉及了对机器人的控制，而机器人控制主要通过基于STM系列的下位机实现。所以RaspberryPi在作为服务器接收到前端控制请求后，需要将控制请求发送至下位机，实现控制，项目中使用了UART串口进行相互连接。\n\n#### 打开RaspberryPi 3B的串口通讯能力\n之前项目中，使用了USB转串口模块直接插在RaspberryPI的USB接口上，然后通过`serialport`打开相应的串口实现串口通讯。\n\n本项目中，为了节约USB资源和空间，要使用GPIO口的TX/RX进行UART通讯。RaspberryPi 3B与之前的版本不同，它带了两个串口，分别是：\n1. /dev/ttyAMA0：\nRPI3配备了蓝牙，为了保证蓝牙的正确使用，/dev/ttyAMA0则不再为GPIO串口服务，而是为蓝牙模块服务。\n2. /dev/ttyS0：\n被称为\"mini uart\"，此串口代表了\"Physical pin 8|10 BCM pin 14|15Wiring Pi pin 15|16\".\n但是由于次串口波特率收到cpu频率影响，并不稳定，所以实际上无法被用来串口通信。\n\n正因如此，网络上大部分教程，直接使用/dev/ttyAMA0作为串口的方法就无法使用RPI3了，查了相关资料，通过以下方法解决[(参考自简书R4L)](https://www.jianshu.com/p/26409ddf6a9b)：\n>将ttyAMA0和ttyS0互换，那么gpio tx\\rx串口映射给ttyAMA0，ttyS0则映射给蓝牙设备。\n这样gpio 14、15串口就拥有了稳定，强大的通信功能,而蓝牙串口则无法正常使用。\n\n**1) 激活串口**\n```bash\n$ sudo nano /boot/config.txt\n```\n改变使得：enable_uart=1.\n若无此参数，则在最后一行添加：enable_uart=1.\n重启设备。\n\n**2)查看串口别名**\n```bash\nls -l /dev\n```\n会发现:\nlrwxrwxrwx 1 root root 7 Aug 28 07:41 serial0 -> ttyS0\nlrwxrwxrwx 1 root root 5 Aug 28 07:41 serial1 -> ttyAMA0\n\n**3)禁用/dev/ttyS0的console功能**\n```bash\n$ sudo systemctl stop serial-getty@ttyS0.service\n$ sudo systemctl disable serial-getty@ttyS0.service\n```\n并且修改cmdline.txt文件\n```bash\n$ sudo nano /boot/cmdline.txt\n```\n删除“console=serial0,115200”，保存并重启\n\n4) 交换串口\n```bash\n$ sudo nano /boot/config.txt\n```\n在最下面添加：dtoverlay=pi3-miniuart-bt\n保存并重启。\n此时查看串口别名则发现：\nlrwxrwxrwx 1 root root           7 Aug 28 07:41 serial0 -> ttyAMA0\nlrwxrwxrwx 1 root root           5 Aug 28 07:41 serial1 -> ttyS0\n此时，ttyAMA0串口可以正常用于串口通信，ttyS0则无法被用于串口通信，蓝牙功能失效。\n\n#### 使用`serialport`打开通讯\n1) 安装serialport\n```node\nnpm install serialport -S\n```\n\n2) 引入serialport，并开启串口\n```node\nvar SerialPort = require('serialport');\nconst port = new SerialPort('/dev/ttyAMA0', {\n\tbaudRate: 9600\n})   //使用串口，与下位机机型通讯\n```\n\n3) 串口通讯\n\n`serialport`的api非常简单，使用相关进行通讯即可\n```node\nport.write('main screen turn on', function (err) {\n\tif (err) {\n\t\treturn console.log('Error on write: ', err.message)\n\t}\n\tconsole.log('message written')  //打开串口\n})\n\n// Open errors will be emitted as an error event\nport.on('error', function (err) {\n\tconsole.log('Error: ', err.message)\n})\n\n// Switches the port into \"flowing mode\"\nport.on('data', function (data) {\n\tconsole.log('Data:', data.toString())  //接收到数据，打印出来\n})\n```\n\n## 拍照与保存功能\n\n`MJPG-STREAMER`支持保存当前帧，只需要将视频画面地址`http://192.168.123.251:8082/?action=stream`中的最后一个`stream`改为`snapshot`即可。\n\n一开始初步的想法是完全同通前端实现，通过`<img src=\"http://192.168.123.251:8080/?action=action\" />`标签来实现拍照功能，但是这种放有两个问题：\n1. 所见非所得，假如在t0时刻拍照为img1，接着点击保存到本地的时候，下载和保存的图片是t1时刻的另一张照片，这是不满足需求的；\n2. 图片下载功能通过`<a>`标签＋`download`属性实现，但是chrome浏览器对与跨域的图像无法实现保存，只能在新页面打开。\n\n 因此拍照与保存功能设计成如下的流程：\n![](http://ww1.sinaimg.cn/mw690/6f9f3683ly1g1707sek53j20av0bt0sx.jpg)\n\n### 服务器端配置\n**1） 获取图片地址**\n\n服务器端要实现保存图片到本地，首先需要获取图片的地址。图片地址为`http://IP:PORT/?action=action`\n\n项目中，将视频画面的地址端口设置为8082，即`PORT=8082`，IP地址则是RaspberryPi本机的地址，在NODE中获取本机地址的方法如下：\n```node\nfunction getIPAdress() {\n\tvar interfaces = require('os').networkInterfaces();\n\tfor (var devName in interfaces) {\n\t\tvar iface = interfaces[devName];\n\t\tfor (var i = 0; i < iface.length; i++) {\n\t\t\tvar alias = iface[i];\n\t\t\tif (alias.family === 'IPv4' && alias.address !== '127.0.0.1' && !alias.internal) {\n\t\t\t\treturn alias.address;\n\t\t\t}\n\t\t}\n\t}\n} \n```\n\n**2） 下载图片**\n\n图片下载，使用到了`request`这个模块，首先在项目中安装该模块\n```node\nnpm install request -S\n```\n\n接下来，写一个下载图片的函数，创建一个文件`downIMG.js`\n```bash\n$ vim downIMG.js\n```\n\n写下载图片的函数，并将函数导出\n```node\nconst fs = require('fs');\nconst request = require('request');\n\nconst download = function(uri, filename, callback) {\n    request.head(uri, function(err, res, body) {\n        request(uri).pipe(fs.createWriteStream(__dirname +'/public/SnapShoot/' + filename)).on('close', callback);\n    });\n};\n\nmodule.exports = download\n```\n在项目所在文件夹下，新建一个`SnapShoot`的文件夹。\n\n**3） 引入图片下载函数，服务器实现响应**\n\n在主文件`server.js`中，实现服务器的响应\n```node\nvar download = require('./downIMG');\n\napp.use(express.static(path.join(__dirname, 'public'))); //将public设置为静态资源，这样保存的截图才可以被访问得到\napp.use(bodyParse.json({ limit: '1mb' }));  //body-parser 解析json格式数据\napp.use(bodyParse.urlencoded({extended:false}));\n\napp.get('/capture', function (req, res) {\n\tdownload(snapAddress,'current.png',function(){\n\t\tres.send('Capture Sussess');\n\t})\n})   //拍照请求\n```\n至此，前端只需要通过`<a>`标签配合`download`属性，就可以实现拍照和下载的功能了，样例：\n```html\n<a target=\"_blank\" id=\"down\" :href=\"snapAdd\" :download=\"currentDate\">点击下载</a>\n```\n\n## 完整代码\n\n服务器端包括了 server.js + downIMG.js，以及前端的页面及静态资源。\n\n* downIMG.js\n\n```node\nvar fs = require('fs'),\n    request = require('request');\n\nvar download = function(uri, filename, callback) {\n    request.head(uri, function(err, res, body) {\n        request(uri).pipe(fs.createWriteStream(__dirname +'/public/SnapShoot/' + filename)).on('close', callback);\n    });\n};\n\nmodule.exports = download\n```\n\n* server.js\n\n```node\nconst express = require('express');\nconst app = express();\nconst bodyParse = require(\"body-parser\");\nconst shell = require('shelljs');\nconst download = require('./downIMG');\nconst path = require('path');\nconst SerialPort = require('serialport');\nconst IP = getIPAdress();\nconst PORT = '8082';\nconst videoCommand = [\n\t'mjpg_streamer -i \"./input_uvc.so -r 640x480 -q 70 -f 30 -d /dev/video0 -n\" -o \"./output_http.so -p 8082 -w /usr/local/www\"',\n\t'mjpg_streamer -i \"./input_uvc.so -r 1280x720 -q 70 -f 15 -d /dev/video0 -n\" -o \"./output_http.so -p 8082 -w /usr/local/www\"',\n\t'mjpg_streamer -i \"./input_uvc.so -r 1920x1080 -q 70 -f 15 -d /dev/video0 -n\" -o \"./output_http.so -p 8082 -w /usr/local/www\"'\n]\n\nconst snapAddress = `http://${IP}:${PORT}/?action=snapshot`;\n\nvar speed = 50; //运动速度\nvar videoStatus = 0;  // 1-流畅； 2-清晰； 3-高清， 默认清晰\nconst port = new SerialPort('/dev/ttyAMA0', {\n\tbaudRate: 9600\n})   //使用串口，与下位机机型通讯\n\nport.write('main screen turn on', function (err) {\n\tif (err) {\n\t\treturn console.log('Error on write: ', err.message)\n\t}\n\tconsole.log('message written')\n})\n\n// Open errors will be emitted as an error event\nport.on('error', function (err) {\n\tconsole.log('Error: ', err.message)\n})\n\n// Switches the port into \"flowing mode\"\nport.on('data', function (data) {\n\tconsole.log('Data:', data.toString())\n})\n const buf1 = Buffer.alloc(1,1),  //前进\n\tbuf2 = Buffer.alloc(1,2),  //后退\n\tbuf3 = Buffer.alloc(1,3),  //伸张\n\tbuf4 = Buffer.alloc(1,4),  //收缩\n\tbuf5 = Buffer.alloc(1,5);  //停止\n\napp.use(express.static(path.join(__dirname, 'public')));\napp.use(bodyParse.json({ limit: '1mb' }));  //body-parser 解析json格式数据\napp.use(bodyParse.urlencoded({extended:false}));\napp.post('/VideoSet',(req,res) => {\n\tif(+req.body.Video === videoStatus) {\n\t\tres.end('Same Video Set');\n\t\treturn;\n\t}\n\tswitch (req.body.Video) {\n\t\tcase \"1\": \n\t\t\topenVideo(0);\n\t\t\tres.end('Success');\n\t\t\tbreak;\n\t\tcase \"2\":\n\t\t\topenVideo(1);\n\t\t\tres.end('Success');\n\t\t\tbreak;\n\t\tcase \"3\": \n\t\t\topenVideo(2);\n\t\t\tres.end('Success');\n\t\t\tbreak;\n\t}\n})\napp.get('/capture', function (req, res) {\n\tdownload(snapAddress,'current.png',function(){\n\t\tres.send('Capture Sussess');\n\t})\n}) \napp.get('/speed',function(req,res) {\n\tres.send({'speed':speed});\n}) \napp.post('/speedSet',(req,res) => {\n\tspeed = req.body.speed;\n\tres.end('Speed Set Success');\n})\n\napp.get('/VideoStatus', function(req, res){\n\tres.send(videoStatus.toString());\n})\n\napp.get('/',function(req,res){\n\tres.sendFile(__dirname + '/' + \"index.html\");\n})\napp.get('/up',function(req,res){\n\tconsole.log(\"up recieve\");\n\tres.send('ok');\n\tport.write(buf1,'hex');\n})\napp.get('/down',function(req,res){\n\tconsole.log('down recieve');\n\tres.send('ok');\n\tport.write(buf2,'hex');\n\t\n})\napp.get('/stretch', function (req, res) {\n\tconsole.log('stretch');\n\tres.send('ok');\n\tport.write(buf3,'hex');\n\n})\napp.get('/shrink',function(req,res){\n\tconsole.log('shrink recieve');\n\tres.send('ok');\n\tport.write(buf4);\n})\napp.get('/stop',function(req,res){\n\tconsole.log('stop!!!');\n\tres.send('ok');\n\tport.write(buf5);\n})\nvar server = app.listen(8081,function(){\n\tconsole.log(\"Server is running at 8081 port...\");\n});\n\nfunction openVideo(qulity) {\n\treturn new Promise((resolve,reject) => {\n\t\tif (shell.exec('pgrep mjpg_streamer').stdout !== '') {\n\t\t\tshell.exec('killall mjpg_streamer');\n\t\t}\n\t\tlet command = videoCommand[qulity];\n\t\tshell.cd('~');\n\t\tshell.cd('mjpg-streamer/mjpg-streamer-experimental/')\n\t\tshell.exec(command, (code, std, err) => {\n\t\t\tconsole.log('Exit code:', code);\n\t\t\tconsole.log('Program output:', std);\n\t\t\tconsole.log('Program stderr:', err);\n\t\t})\n\t\tvideoStatus = +qulity + 1;\n\t\tresolve('Success');\n\t})\n}\n\nfunction getIPAdress() {\n\tvar interfaces = require('os').networkInterfaces();\n\tfor (var devName in interfaces) {\n\t\tvar iface = interfaces[devName];\n\t\tfor (var i = 0; i < iface.length; i++) {\n\t\t\tvar alias = iface[i];\n\t\t\tif (alias.family === 'IPv4' && alias.address !== '127.0.0.1' && !alias.internal) {\n\t\t\t\treturn alias.address;\n\t\t\t}\n\t\t}\n\t}\n} \n```","source":"_posts/year-03-09-基于Mjpg-Streamer与树莓派的监控与拍照.md","raw":"---\ntitle: Mjpg-Streamer+Node.js实现在树莓派上的监控与拍照\ndate: 2019-03-09 22:42:45\ntags:\n    - JavaScript\n    - Mjpg-Streamer\n    - Raspberry Pi\n---\n\n最近在做一个机器人项目，需要将试试捕获安装于机器人身上的视频图像，并能够对机器人进行无线运动控制。作为前端工程师的我，很自然的想到了使用Node作为服务器和机器人的控制中心，通过前端页面实现对机器人控制和视频图像的捕捉。\n\n本文主要对项目中的一个单元：视频图像的捕捉和拍照功能进行开发记录和解析。\n\n实现功能\n一： 远程视频图像获取\n二： 视频图像清晰度调节\n三： 拍照功能\n\n---\n## 基于Express的服务器环境搭建\n\nExpress是基于Node的一个快速搭建服务器的框架，项目使用Express快速搭建服务器。\n### node的安装\n首先，更新所有安装列表到最新的状态：\n``` bash\npi@raspberrypi:~$ sudo apt-get update\n```\n\n升级所有安装包到最新版本：\n\n```bash\npi@raspberrypi:~$ sudo apt-get dist-upgrade\n```\n接下来，下载和安装node(注意版本号使用_8.x)\n\n```bash\npi@raspberrypi:~$ curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -\n```\n\n现在可以安装了：\n\n```bash\npi@raspberrypi:~$ sudo apt-get install -y nodejs\n```\n\n测试是否安装成功：\n\n```bash\npi@raspberrypi:~$ node -v\n```\n\n### Express安装\n\n使用Node的包管理工具npm来新建项目和安装框架\n\n首先，进入项目目录，并新建工程:\n```bash\n$ cd Public/WebProject/FisrtPage/\n$ npm init -y\n```\n安装 Express 并将其保存到依赖列表中：\n以下命令会将 Express 框架安装在当前目录的 node_modules 目录中\n```bash\n$ npm install express --save\n```\n然后，在该项目文件下新建`server.js`文件，引入Express就可以很方便的搭建起一个服务器。具体的内容在后面进行分析。\n\n### Mjpg-Streamer\n\n项目使用的是一个USB摄像头，为了能将图像捕获并通过HTTP转发，项目使用Mjpg-Streamer实现这一功能。\n1. 安装必要的库\n```bash\nsudo apt-get update\nsudo apt-get install libjpeg8-dev\nsudo apt-get install imagemagick\nsudo apt-get install libv4l-dev //\nsudo apt-get install cmake //编译工具\n```\n 2. 为了向后兼容，链接videodev2.h和videodev.h\n```bash\nsudo ln -s /usr/include/linux/videodev2.h /usr/include/linux/videodev/h\n```\n注意，这里的`sudo ln -s`是非常重要的操作命令，类似于为a做一个超链接\n\n3. git开源代码到本地，编译进入到home目录，然后开始克隆\n```bash\ncd ~\nsudo git clone https://github.com/jacksonliam/mjpg-streamer.git\ncd mjpg-streamer/mjpg-streamer-experimental\n```\n4. 编译和安装\n```bash\nsudo make\nsudo make install\n```\n5. 测试和使用\n\n完成以上步骤之后，可以开始测试一下。 插入摄像头，执行以下命令，分别在两个窗口打开\n```bash\nsudo mjpg_streamer -i \"./input_uvc.so -r 640x480 -q 70 -f 15 -d /dev/video1 -n\" -o \"./output_http.so -p 8080 -w /usr/local/www\"\n```\n出现一下的内容，表明安装成功\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1g0wxsj1795j20dw09gads.jpg)\n这样，打开浏览器输入`http://localhost:8080/?action=stream`就可以看到视频图像，其中`localhost`在实际使用中，换成了树莓派的IP地址，树莓派已经提前设置了静态地址，我使用的是`192.168.123.251`，因此，视频的地址就顾定成了：\n\n`http://192.168.123.251:8080/?action=stream`\n\n## 依赖模块\n### shelljs\n上面使用的Mjpg-Streamer可以通过改变参数实现对清晰度、帧率的调整，比如将上面的图像修改为720P、15帧的指令为：\n```bash\nmjpg_streamer -i \"input_uvc.so -r 1280x720 -f 15 -n\" -o \"output_http.so \"\n```\n但是这个是在终端中执行的命令，而服务器是使用Node，因此这里使用了shelljs实现在Node运行shell指令。\n\n首先安装shelljs\n```bash\nnpm install shelljs -S\n```\n有关该模块的具体使用及相关API可以查阅[官网](https://github.com/shelljs/shelljs),本项目中主要使用了两个指令是：\n- `shell.exec()` 执行某个指令\n- `shell.cd()` 进入某个目录\n\n为了在后台实现不同分辨率图像的转换，专门写一个函数来实现切换，并通过变量`videoStatus`的状态来表示不同的分辨率，与前端相对应的:\n* videoStatus: 1-流畅\n* videoStatus: 2-清晰\n* videoStatus: 3-高清\n  \n清晰度切换的函数实现如下:\n```JavaScript\nvar videoStatus = 0;  // 1-流畅； 2-清晰； 3-高清， 默认清晰\nconst videoCommand = [\n\t'mjpg_streamer -i \"./input_uvc.so -r 640x480 -q 70 -f 30 -d /dev/video0 -n\" -o \"./output_http.so -p 8082 -w /usr/local/www\"',\n\t'mjpg_streamer -i \"./input_uvc.so -r 1280x720 -q 70 -f 15 -d /dev/video0 -n\" -o \"./output_http.so -p 8082 -w /usr/local/www\"',\n\t'mjpg_streamer -i \"./input_uvc.so -r 1920x1080 -q 70 -f 15 -d /dev/video0 -n\" -o \"./output_http.so -p 8082 -w /usr/local/www\"'\n]\nfunction openVideo(qulity) {\n\treturn new Promise((resolve,reject) => {\n\t\tif (shell.exec('pgrep mjpg_streamer').stdout !== '') {\n\t\t\tshell.exec('killall mjpg_streamer');\n\t\t}\n\t\tlet command = videoCommand[qulity];\n\t\tshell.cd('~');\n\t\tshell.cd('mjpg-streamer/mjpg-streamer-experimental/')\n\t\tshell.exec(command, (code, std, err) => {\n\t\t\tconsole.log('Exit code:', code);\n\t\t\tconsole.log('Program output:', std);\n\t\t\tconsole.log('Program stderr:', err);\n\t\t})\n\t\tvideoStatus = +qulity + 1;\n\t\tresolve('Success');\n\t})\n}\n```\n对关键的几条指令进行一下说明：\n* `shell.exec('pgrep mjpg_streamer').stdout !== ''`\n\n\n`pgrep`以名称为依据从运行进程队列中查找进程,并显示查找到进程的id。在shelljs中，stdout是指令的输出，如果不存在进程，则返回为空； 这里加判断的意思主要**在于如果`mjpg`已经在运行，则要杀死该进程（清晰度更换通过重启`mjpg`实现）**\n* `let command = videoCommand[qulity]`\n\n\n具体的程序执行取决于前端的请求，根据`qulity`来开启不同清晰度的摄像头。\n\n接下里，对设置清晰度的请求，设置服务器响应,并开启服务器:\n```JavaScript\nvar express = require('express');\nvar app = express();\nvar bodyParse = require(\"body-parser\");\n\napp.post('/VideoSet',(req,res) => {\n\tif(+req.body.Video === videoStatus) {\n\t\tres.end('Same Video Set');\n\t\treturn;\n\t}\n\tswitch (req.body.Video) {\n\t\tcase \"1\": \n\t\t\topenVideo(0);\n\t\t\tres.end('Success');\n\t\t\tbreak;\n\t\tcase \"2\":\n\t\t\topenVideo(1);\n\t\t\tres.end('Success');\n\t\t\tbreak;\n\t\tcase \"3\": \n\t\t\topenVideo(2);\n\t\t\tres.end('Success');\n\t\t\tbreak;\n\t}\n})\n\nvar server = app.listen(8081,function(){\n\tconsole.log(\"Server is running at 8081 port...\");\n});\n```\n\n### serialport\n\n项目除了传统前端的内容，还涉及了对机器人的控制，而机器人控制主要通过基于STM系列的下位机实现。所以RaspberryPi在作为服务器接收到前端控制请求后，需要将控制请求发送至下位机，实现控制，项目中使用了UART串口进行相互连接。\n\n#### 打开RaspberryPi 3B的串口通讯能力\n之前项目中，使用了USB转串口模块直接插在RaspberryPI的USB接口上，然后通过`serialport`打开相应的串口实现串口通讯。\n\n本项目中，为了节约USB资源和空间，要使用GPIO口的TX/RX进行UART通讯。RaspberryPi 3B与之前的版本不同，它带了两个串口，分别是：\n1. /dev/ttyAMA0：\nRPI3配备了蓝牙，为了保证蓝牙的正确使用，/dev/ttyAMA0则不再为GPIO串口服务，而是为蓝牙模块服务。\n2. /dev/ttyS0：\n被称为\"mini uart\"，此串口代表了\"Physical pin 8|10 BCM pin 14|15Wiring Pi pin 15|16\".\n但是由于次串口波特率收到cpu频率影响，并不稳定，所以实际上无法被用来串口通信。\n\n正因如此，网络上大部分教程，直接使用/dev/ttyAMA0作为串口的方法就无法使用RPI3了，查了相关资料，通过以下方法解决[(参考自简书R4L)](https://www.jianshu.com/p/26409ddf6a9b)：\n>将ttyAMA0和ttyS0互换，那么gpio tx\\rx串口映射给ttyAMA0，ttyS0则映射给蓝牙设备。\n这样gpio 14、15串口就拥有了稳定，强大的通信功能,而蓝牙串口则无法正常使用。\n\n**1) 激活串口**\n```bash\n$ sudo nano /boot/config.txt\n```\n改变使得：enable_uart=1.\n若无此参数，则在最后一行添加：enable_uart=1.\n重启设备。\n\n**2)查看串口别名**\n```bash\nls -l /dev\n```\n会发现:\nlrwxrwxrwx 1 root root 7 Aug 28 07:41 serial0 -> ttyS0\nlrwxrwxrwx 1 root root 5 Aug 28 07:41 serial1 -> ttyAMA0\n\n**3)禁用/dev/ttyS0的console功能**\n```bash\n$ sudo systemctl stop serial-getty@ttyS0.service\n$ sudo systemctl disable serial-getty@ttyS0.service\n```\n并且修改cmdline.txt文件\n```bash\n$ sudo nano /boot/cmdline.txt\n```\n删除“console=serial0,115200”，保存并重启\n\n4) 交换串口\n```bash\n$ sudo nano /boot/config.txt\n```\n在最下面添加：dtoverlay=pi3-miniuart-bt\n保存并重启。\n此时查看串口别名则发现：\nlrwxrwxrwx 1 root root           7 Aug 28 07:41 serial0 -> ttyAMA0\nlrwxrwxrwx 1 root root           5 Aug 28 07:41 serial1 -> ttyS0\n此时，ttyAMA0串口可以正常用于串口通信，ttyS0则无法被用于串口通信，蓝牙功能失效。\n\n#### 使用`serialport`打开通讯\n1) 安装serialport\n```node\nnpm install serialport -S\n```\n\n2) 引入serialport，并开启串口\n```node\nvar SerialPort = require('serialport');\nconst port = new SerialPort('/dev/ttyAMA0', {\n\tbaudRate: 9600\n})   //使用串口，与下位机机型通讯\n```\n\n3) 串口通讯\n\n`serialport`的api非常简单，使用相关进行通讯即可\n```node\nport.write('main screen turn on', function (err) {\n\tif (err) {\n\t\treturn console.log('Error on write: ', err.message)\n\t}\n\tconsole.log('message written')  //打开串口\n})\n\n// Open errors will be emitted as an error event\nport.on('error', function (err) {\n\tconsole.log('Error: ', err.message)\n})\n\n// Switches the port into \"flowing mode\"\nport.on('data', function (data) {\n\tconsole.log('Data:', data.toString())  //接收到数据，打印出来\n})\n```\n\n## 拍照与保存功能\n\n`MJPG-STREAMER`支持保存当前帧，只需要将视频画面地址`http://192.168.123.251:8082/?action=stream`中的最后一个`stream`改为`snapshot`即可。\n\n一开始初步的想法是完全同通前端实现，通过`<img src=\"http://192.168.123.251:8080/?action=action\" />`标签来实现拍照功能，但是这种放有两个问题：\n1. 所见非所得，假如在t0时刻拍照为img1，接着点击保存到本地的时候，下载和保存的图片是t1时刻的另一张照片，这是不满足需求的；\n2. 图片下载功能通过`<a>`标签＋`download`属性实现，但是chrome浏览器对与跨域的图像无法实现保存，只能在新页面打开。\n\n 因此拍照与保存功能设计成如下的流程：\n![](http://ww1.sinaimg.cn/mw690/6f9f3683ly1g1707sek53j20av0bt0sx.jpg)\n\n### 服务器端配置\n**1） 获取图片地址**\n\n服务器端要实现保存图片到本地，首先需要获取图片的地址。图片地址为`http://IP:PORT/?action=action`\n\n项目中，将视频画面的地址端口设置为8082，即`PORT=8082`，IP地址则是RaspberryPi本机的地址，在NODE中获取本机地址的方法如下：\n```node\nfunction getIPAdress() {\n\tvar interfaces = require('os').networkInterfaces();\n\tfor (var devName in interfaces) {\n\t\tvar iface = interfaces[devName];\n\t\tfor (var i = 0; i < iface.length; i++) {\n\t\t\tvar alias = iface[i];\n\t\t\tif (alias.family === 'IPv4' && alias.address !== '127.0.0.1' && !alias.internal) {\n\t\t\t\treturn alias.address;\n\t\t\t}\n\t\t}\n\t}\n} \n```\n\n**2） 下载图片**\n\n图片下载，使用到了`request`这个模块，首先在项目中安装该模块\n```node\nnpm install request -S\n```\n\n接下来，写一个下载图片的函数，创建一个文件`downIMG.js`\n```bash\n$ vim downIMG.js\n```\n\n写下载图片的函数，并将函数导出\n```node\nconst fs = require('fs');\nconst request = require('request');\n\nconst download = function(uri, filename, callback) {\n    request.head(uri, function(err, res, body) {\n        request(uri).pipe(fs.createWriteStream(__dirname +'/public/SnapShoot/' + filename)).on('close', callback);\n    });\n};\n\nmodule.exports = download\n```\n在项目所在文件夹下，新建一个`SnapShoot`的文件夹。\n\n**3） 引入图片下载函数，服务器实现响应**\n\n在主文件`server.js`中，实现服务器的响应\n```node\nvar download = require('./downIMG');\n\napp.use(express.static(path.join(__dirname, 'public'))); //将public设置为静态资源，这样保存的截图才可以被访问得到\napp.use(bodyParse.json({ limit: '1mb' }));  //body-parser 解析json格式数据\napp.use(bodyParse.urlencoded({extended:false}));\n\napp.get('/capture', function (req, res) {\n\tdownload(snapAddress,'current.png',function(){\n\t\tres.send('Capture Sussess');\n\t})\n})   //拍照请求\n```\n至此，前端只需要通过`<a>`标签配合`download`属性，就可以实现拍照和下载的功能了，样例：\n```html\n<a target=\"_blank\" id=\"down\" :href=\"snapAdd\" :download=\"currentDate\">点击下载</a>\n```\n\n## 完整代码\n\n服务器端包括了 server.js + downIMG.js，以及前端的页面及静态资源。\n\n* downIMG.js\n\n```node\nvar fs = require('fs'),\n    request = require('request');\n\nvar download = function(uri, filename, callback) {\n    request.head(uri, function(err, res, body) {\n        request(uri).pipe(fs.createWriteStream(__dirname +'/public/SnapShoot/' + filename)).on('close', callback);\n    });\n};\n\nmodule.exports = download\n```\n\n* server.js\n\n```node\nconst express = require('express');\nconst app = express();\nconst bodyParse = require(\"body-parser\");\nconst shell = require('shelljs');\nconst download = require('./downIMG');\nconst path = require('path');\nconst SerialPort = require('serialport');\nconst IP = getIPAdress();\nconst PORT = '8082';\nconst videoCommand = [\n\t'mjpg_streamer -i \"./input_uvc.so -r 640x480 -q 70 -f 30 -d /dev/video0 -n\" -o \"./output_http.so -p 8082 -w /usr/local/www\"',\n\t'mjpg_streamer -i \"./input_uvc.so -r 1280x720 -q 70 -f 15 -d /dev/video0 -n\" -o \"./output_http.so -p 8082 -w /usr/local/www\"',\n\t'mjpg_streamer -i \"./input_uvc.so -r 1920x1080 -q 70 -f 15 -d /dev/video0 -n\" -o \"./output_http.so -p 8082 -w /usr/local/www\"'\n]\n\nconst snapAddress = `http://${IP}:${PORT}/?action=snapshot`;\n\nvar speed = 50; //运动速度\nvar videoStatus = 0;  // 1-流畅； 2-清晰； 3-高清， 默认清晰\nconst port = new SerialPort('/dev/ttyAMA0', {\n\tbaudRate: 9600\n})   //使用串口，与下位机机型通讯\n\nport.write('main screen turn on', function (err) {\n\tif (err) {\n\t\treturn console.log('Error on write: ', err.message)\n\t}\n\tconsole.log('message written')\n})\n\n// Open errors will be emitted as an error event\nport.on('error', function (err) {\n\tconsole.log('Error: ', err.message)\n})\n\n// Switches the port into \"flowing mode\"\nport.on('data', function (data) {\n\tconsole.log('Data:', data.toString())\n})\n const buf1 = Buffer.alloc(1,1),  //前进\n\tbuf2 = Buffer.alloc(1,2),  //后退\n\tbuf3 = Buffer.alloc(1,3),  //伸张\n\tbuf4 = Buffer.alloc(1,4),  //收缩\n\tbuf5 = Buffer.alloc(1,5);  //停止\n\napp.use(express.static(path.join(__dirname, 'public')));\napp.use(bodyParse.json({ limit: '1mb' }));  //body-parser 解析json格式数据\napp.use(bodyParse.urlencoded({extended:false}));\napp.post('/VideoSet',(req,res) => {\n\tif(+req.body.Video === videoStatus) {\n\t\tres.end('Same Video Set');\n\t\treturn;\n\t}\n\tswitch (req.body.Video) {\n\t\tcase \"1\": \n\t\t\topenVideo(0);\n\t\t\tres.end('Success');\n\t\t\tbreak;\n\t\tcase \"2\":\n\t\t\topenVideo(1);\n\t\t\tres.end('Success');\n\t\t\tbreak;\n\t\tcase \"3\": \n\t\t\topenVideo(2);\n\t\t\tres.end('Success');\n\t\t\tbreak;\n\t}\n})\napp.get('/capture', function (req, res) {\n\tdownload(snapAddress,'current.png',function(){\n\t\tres.send('Capture Sussess');\n\t})\n}) \napp.get('/speed',function(req,res) {\n\tres.send({'speed':speed});\n}) \napp.post('/speedSet',(req,res) => {\n\tspeed = req.body.speed;\n\tres.end('Speed Set Success');\n})\n\napp.get('/VideoStatus', function(req, res){\n\tres.send(videoStatus.toString());\n})\n\napp.get('/',function(req,res){\n\tres.sendFile(__dirname + '/' + \"index.html\");\n})\napp.get('/up',function(req,res){\n\tconsole.log(\"up recieve\");\n\tres.send('ok');\n\tport.write(buf1,'hex');\n})\napp.get('/down',function(req,res){\n\tconsole.log('down recieve');\n\tres.send('ok');\n\tport.write(buf2,'hex');\n\t\n})\napp.get('/stretch', function (req, res) {\n\tconsole.log('stretch');\n\tres.send('ok');\n\tport.write(buf3,'hex');\n\n})\napp.get('/shrink',function(req,res){\n\tconsole.log('shrink recieve');\n\tres.send('ok');\n\tport.write(buf4);\n})\napp.get('/stop',function(req,res){\n\tconsole.log('stop!!!');\n\tres.send('ok');\n\tport.write(buf5);\n})\nvar server = app.listen(8081,function(){\n\tconsole.log(\"Server is running at 8081 port...\");\n});\n\nfunction openVideo(qulity) {\n\treturn new Promise((resolve,reject) => {\n\t\tif (shell.exec('pgrep mjpg_streamer').stdout !== '') {\n\t\t\tshell.exec('killall mjpg_streamer');\n\t\t}\n\t\tlet command = videoCommand[qulity];\n\t\tshell.cd('~');\n\t\tshell.cd('mjpg-streamer/mjpg-streamer-experimental/')\n\t\tshell.exec(command, (code, std, err) => {\n\t\t\tconsole.log('Exit code:', code);\n\t\t\tconsole.log('Program output:', std);\n\t\t\tconsole.log('Program stderr:', err);\n\t\t})\n\t\tvideoStatus = +qulity + 1;\n\t\tresolve('Success');\n\t})\n}\n\nfunction getIPAdress() {\n\tvar interfaces = require('os').networkInterfaces();\n\tfor (var devName in interfaces) {\n\t\tvar iface = interfaces[devName];\n\t\tfor (var i = 0; i < iface.length; i++) {\n\t\t\tvar alias = iface[i];\n\t\t\tif (alias.family === 'IPv4' && alias.address !== '127.0.0.1' && !alias.internal) {\n\t\t\t\treturn alias.address;\n\t\t\t}\n\t\t}\n\t}\n} \n```","slug":"基于Mjpg-Streamer与树莓派的监控与拍照","published":1,"updated":"2022-08-17T07:53:21.232Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6xbhzkd0016zk083ejqn17j","content":"<p>最近在做一个机器人项目，需要将试试捕获安装于机器人身上的视频图像，并能够对机器人进行无线运动控制。作为前端工程师的我，很自然的想到了使用Node作为服务器和机器人的控制中心，通过前端页面实现对机器人控制和视频图像的捕捉。</p>\n<p>本文主要对项目中的一个单元：视频图像的捕捉和拍照功能进行开发记录和解析。</p>\n<p>实现功能<br>一： 远程视频图像获取<br>二： 视频图像清晰度调节<br>三： 拍照功能</p>\n<hr>\n<h2 id=\"基于Express的服务器环境搭建\"><a href=\"#基于Express的服务器环境搭建\" class=\"headerlink\" title=\"基于Express的服务器环境搭建\"></a>基于Express的服务器环境搭建</h2><p>Express是基于Node的一个快速搭建服务器的框架，项目使用Express快速搭建服务器。</p>\n<h3 id=\"node的安装\"><a href=\"#node的安装\" class=\"headerlink\" title=\"node的安装\"></a>node的安装</h3><p>首先，更新所有安装列表到最新的状态：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pi@raspberrypi:~$ sudo apt-get update</span><br></pre></td></tr></table></figure></p>\n<p>升级所有安装包到最新版本：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pi@raspberrypi:~$ sudo apt-get dist-upgrade</span><br></pre></td></tr></table></figure>\n<p>接下来，下载和安装node(注意版本号使用_8.x)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pi@raspberrypi:~$ curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -</span><br></pre></td></tr></table></figure>\n<p>现在可以安装了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pi@raspberrypi:~$ sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure>\n<p>测试是否安装成功：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pi@raspberrypi:~$ node -v</span><br></pre></td></tr></table></figure>\n<h3 id=\"Express安装\"><a href=\"#Express安装\" class=\"headerlink\" title=\"Express安装\"></a>Express安装</h3><p>使用Node的包管理工具npm来新建项目和安装框架</p>\n<p>首先，进入项目目录，并新建工程:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> Public/WebProject/FisrtPage/</span><br><span class=\"line\">$ npm init -y</span><br></pre></td></tr></table></figure></p>\n<p>安装 Express 并将其保存到依赖列表中：<br>以下命令会将 Express 框架安装在当前目录的 node_modules 目录中<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install express --save</span><br></pre></td></tr></table></figure></p>\n<p>然后，在该项目文件下新建<code>server.js</code>文件，引入Express就可以很方便的搭建起一个服务器。具体的内容在后面进行分析。</p>\n<h3 id=\"Mjpg-Streamer\"><a href=\"#Mjpg-Streamer\" class=\"headerlink\" title=\"Mjpg-Streamer\"></a>Mjpg-Streamer</h3><p>项目使用的是一个USB摄像头，为了能将图像捕获并通过HTTP转发，项目使用Mjpg-Streamer实现这一功能。</p>\n<ol>\n<li><p>安装必要的库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install libjpeg8-dev</span><br><span class=\"line\">sudo apt-get install imagemagick</span><br><span class=\"line\">sudo apt-get install libv4l-dev //</span><br><span class=\"line\">sudo apt-get install cmake //编译工具</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>为了向后兼容，链接videodev2.h和videodev.h<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo ln -s /usr/include/linux/videodev2.h /usr/include/linux/videodev/h</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ol>\n<p>注意，这里的<code>sudo ln -s</code>是非常重要的操作命令，类似于为a做一个超链接</p>\n<ol start=\"3\">\n<li><p>git开源代码到本地，编译进入到home目录，然后开始克隆</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~</span><br><span class=\"line\">sudo git <span class=\"built_in\">clone</span> https://github.com/jacksonliam/mjpg-streamer.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> mjpg-streamer/mjpg-streamer-experimental</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编译和安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo make</span><br><span class=\"line\">sudo make install</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>测试和使用</p>\n</li>\n</ol>\n<p>完成以上步骤之后，可以开始测试一下。 插入摄像头，执行以下命令，分别在两个窗口打开<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mjpg_streamer -i <span class=\"string\">\"./input_uvc.so -r 640x480 -q 70 -f 15 -d /dev/video1 -n\"</span> -o <span class=\"string\">\"./output_http.so -p 8080 -w /usr/local/www\"</span></span><br></pre></td></tr></table></figure></p>\n<p>出现一下的内容，表明安装成功<br><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1g0wxsj1795j20dw09gads.jpg\" alt=\"\"><br>这样，打开浏览器输入<code>http://localhost:8080/?action=stream</code>就可以看到视频图像，其中<code>localhost</code>在实际使用中，换成了树莓派的IP地址，树莓派已经提前设置了静态地址，我使用的是<code>192.168.123.251</code>，因此，视频的地址就顾定成了：</p>\n<p><code>http://192.168.123.251:8080/?action=stream</code></p>\n<h2 id=\"依赖模块\"><a href=\"#依赖模块\" class=\"headerlink\" title=\"依赖模块\"></a>依赖模块</h2><h3 id=\"shelljs\"><a href=\"#shelljs\" class=\"headerlink\" title=\"shelljs\"></a>shelljs</h3><p>上面使用的Mjpg-Streamer可以通过改变参数实现对清晰度、帧率的调整，比如将上面的图像修改为720P、15帧的指令为：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mjpg_streamer -i <span class=\"string\">\"input_uvc.so -r 1280x720 -f 15 -n\"</span> -o <span class=\"string\">\"output_http.so \"</span></span><br></pre></td></tr></table></figure></p>\n<p>但是这个是在终端中执行的命令，而服务器是使用Node，因此这里使用了shelljs实现在Node运行shell指令。</p>\n<p>首先安装shelljs<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install shelljs -S</span><br></pre></td></tr></table></figure></p>\n<p>有关该模块的具体使用及相关API可以查阅<a href=\"https://github.com/shelljs/shelljs\" target=\"_blank\" rel=\"noopener\">官网</a>,本项目中主要使用了两个指令是：</p>\n<ul>\n<li><code>shell.exec()</code> 执行某个指令</li>\n<li><code>shell.cd()</code> 进入某个目录</li>\n</ul>\n<p>为了在后台实现不同分辨率图像的转换，专门写一个函数来实现切换，并通过变量<code>videoStatus</code>的状态来表示不同的分辨率，与前端相对应的:</p>\n<ul>\n<li>videoStatus: 1-流畅</li>\n<li>videoStatus: 2-清晰</li>\n<li>videoStatus: 3-高清</li>\n</ul>\n<p>清晰度切换的函数实现如下:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> videoStatus = <span class=\"number\">0</span>;  <span class=\"comment\">// 1-流畅； 2-清晰； 3-高清， 默认清晰</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> videoCommand = [</span><br><span class=\"line\">\t<span class=\"string\">'mjpg_streamer -i \"./input_uvc.so -r 640x480 -q 70 -f 30 -d /dev/video0 -n\" -o \"./output_http.so -p 8082 -w /usr/local/www\"'</span>,</span><br><span class=\"line\">\t<span class=\"string\">'mjpg_streamer -i \"./input_uvc.so -r 1280x720 -q 70 -f 15 -d /dev/video0 -n\" -o \"./output_http.so -p 8082 -w /usr/local/www\"'</span>,</span><br><span class=\"line\">\t<span class=\"string\">'mjpg_streamer -i \"./input_uvc.so -r 1920x1080 -q 70 -f 15 -d /dev/video0 -n\" -o \"./output_http.so -p 8082 -w /usr/local/www\"'</span></span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">openVideo</span>(<span class=\"params\">qulity</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (shell.exec(<span class=\"string\">'pgrep mjpg_streamer'</span>).stdout !== <span class=\"string\">''</span>) &#123;</span><br><span class=\"line\">\t\t\tshell.exec(<span class=\"string\">'killall mjpg_streamer'</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">let</span> command = videoCommand[qulity];</span><br><span class=\"line\">\t\tshell.cd(<span class=\"string\">'~'</span>);</span><br><span class=\"line\">\t\tshell.cd(<span class=\"string\">'mjpg-streamer/mjpg-streamer-experimental/'</span>)</span><br><span class=\"line\">\t\tshell.exec(command, (code, std, err) =&gt; &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'Exit code:'</span>, code);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'Program output:'</span>, std);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'Program stderr:'</span>, err);</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t\tvideoStatus = +qulity + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tresolve(<span class=\"string\">'Success'</span>);</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>对关键的几条指令进行一下说明：</p>\n<ul>\n<li><code>shell.exec(&#39;pgrep mjpg_streamer&#39;).stdout !== &#39;&#39;</code></li>\n</ul>\n<p><code>pgrep</code>以名称为依据从运行进程队列中查找进程,并显示查找到进程的id。在shelljs中，stdout是指令的输出，如果不存在进程，则返回为空； 这里加判断的意思主要<strong>在于如果<code>mjpg</code>已经在运行，则要杀死该进程（清晰度更换通过重启<code>mjpg</code>实现）</strong></p>\n<ul>\n<li><code>let command = videoCommand[qulity]</code></li>\n</ul>\n<p>具体的程序执行取决于前端的请求，根据<code>qulity</code>来开启不同清晰度的摄像头。</p>\n<p>接下里，对设置清晰度的请求，设置服务器响应,并开启服务器:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"><span class=\"keyword\">var</span> bodyParse = <span class=\"built_in\">require</span>(<span class=\"string\">\"body-parser\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">app.post(<span class=\"string\">'/VideoSet'</span>,(req,res) =&gt; &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(+req.body.Video === videoStatus) &#123;</span><br><span class=\"line\">\t\tres.end(<span class=\"string\">'Same Video Set'</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> (req.body.Video) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">\"1\"</span>: </span><br><span class=\"line\">\t\t\topenVideo(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t\tres.end(<span class=\"string\">'Success'</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">\"2\"</span>:</span><br><span class=\"line\">\t\t\topenVideo(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\tres.end(<span class=\"string\">'Success'</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">\"3\"</span>: </span><br><span class=\"line\">\t\t\topenVideo(<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t\tres.end(<span class=\"string\">'Success'</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> server = app.listen(<span class=\"number\">8081</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"Server is running at 8081 port...\"</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"serialport\"><a href=\"#serialport\" class=\"headerlink\" title=\"serialport\"></a>serialport</h3><p>项目除了传统前端的内容，还涉及了对机器人的控制，而机器人控制主要通过基于STM系列的下位机实现。所以RaspberryPi在作为服务器接收到前端控制请求后，需要将控制请求发送至下位机，实现控制，项目中使用了UART串口进行相互连接。</p>\n<h4 id=\"打开RaspberryPi-3B的串口通讯能力\"><a href=\"#打开RaspberryPi-3B的串口通讯能力\" class=\"headerlink\" title=\"打开RaspberryPi 3B的串口通讯能力\"></a>打开RaspberryPi 3B的串口通讯能力</h4><p>之前项目中，使用了USB转串口模块直接插在RaspberryPI的USB接口上，然后通过<code>serialport</code>打开相应的串口实现串口通讯。</p>\n<p>本项目中，为了节约USB资源和空间，要使用GPIO口的TX/RX进行UART通讯。RaspberryPi 3B与之前的版本不同，它带了两个串口，分别是：</p>\n<ol>\n<li>/dev/ttyAMA0：<br>RPI3配备了蓝牙，为了保证蓝牙的正确使用，/dev/ttyAMA0则不再为GPIO串口服务，而是为蓝牙模块服务。</li>\n<li>/dev/ttyS0：<br>被称为”mini uart”，此串口代表了”Physical pin 8|10 BCM pin 14|15Wiring Pi pin 15|16”.<br>但是由于次串口波特率收到cpu频率影响，并不稳定，所以实际上无法被用来串口通信。</li>\n</ol>\n<p>正因如此，网络上大部分教程，直接使用/dev/ttyAMA0作为串口的方法就无法使用RPI3了，查了相关资料，通过以下方法解决<a href=\"https://www.jianshu.com/p/26409ddf6a9b\" target=\"_blank\" rel=\"noopener\">(参考自简书R4L)</a>：</p>\n<blockquote>\n<p>将ttyAMA0和ttyS0互换，那么gpio tx\\rx串口映射给ttyAMA0，ttyS0则映射给蓝牙设备。<br>这样gpio 14、15串口就拥有了稳定，强大的通信功能,而蓝牙串口则无法正常使用。</p>\n</blockquote>\n<p><strong>1) 激活串口</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo nano /boot/config.txt</span><br></pre></td></tr></table></figure></p>\n<p>改变使得：enable_uart=1.<br>若无此参数，则在最后一行添加：enable_uart=1.<br>重启设备。</p>\n<p><strong>2)查看串口别名</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -l /dev</span><br></pre></td></tr></table></figure></p>\n<p>会发现:<br>lrwxrwxrwx 1 root root 7 Aug 28 07:41 serial0 -&gt; ttyS0<br>lrwxrwxrwx 1 root root 5 Aug 28 07:41 serial1 -&gt; ttyAMA0</p>\n<p><strong>3)禁用/dev/ttyS0的console功能</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo systemctl stop serial-getty@ttyS0.service</span><br><span class=\"line\">$ sudo systemctl <span class=\"built_in\">disable</span> serial-getty@ttyS0.service</span><br></pre></td></tr></table></figure></p>\n<p>并且修改cmdline.txt文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo nano /boot/cmdline.txt</span><br></pre></td></tr></table></figure></p>\n<p>删除“console=serial0,115200”，保存并重启</p>\n<p>4) 交换串口<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo nano /boot/config.txt</span><br></pre></td></tr></table></figure></p>\n<p>在最下面添加：dtoverlay=pi3-miniuart-bt<br>保存并重启。<br>此时查看串口别名则发现：<br>lrwxrwxrwx 1 root root           7 Aug 28 07:41 serial0 -&gt; ttyAMA0<br>lrwxrwxrwx 1 root root           5 Aug 28 07:41 serial1 -&gt; ttyS0<br>此时，ttyAMA0串口可以正常用于串口通信，ttyS0则无法被用于串口通信，蓝牙功能失效。</p>\n<h4 id=\"使用serialport打开通讯\"><a href=\"#使用serialport打开通讯\" class=\"headerlink\" title=\"使用serialport打开通讯\"></a>使用<code>serialport</code>打开通讯</h4><p>1) 安装serialport<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install serialport -S</span><br></pre></td></tr></table></figure></p>\n<p>2) 引入serialport，并开启串口<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var SerialPort = require(&apos;serialport&apos;);</span><br><span class=\"line\">const port = new SerialPort(&apos;/dev/ttyAMA0&apos;, &#123;</span><br><span class=\"line\">\tbaudRate: 9600</span><br><span class=\"line\">&#125;)   //使用串口，与下位机机型通讯</span><br></pre></td></tr></table></figure></p>\n<p>3) 串口通讯</p>\n<p><code>serialport</code>的api非常简单，使用相关进行通讯即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">port.write(&apos;main screen turn on&apos;, function (err) &#123;</span><br><span class=\"line\">\tif (err) &#123;</span><br><span class=\"line\">\t\treturn console.log(&apos;Error on write: &apos;, err.message)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tconsole.log(&apos;message written&apos;)  //打开串口</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// Open errors will be emitted as an error event</span><br><span class=\"line\">port.on(&apos;error&apos;, function (err) &#123;</span><br><span class=\"line\">\tconsole.log(&apos;Error: &apos;, err.message)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// Switches the port into &quot;flowing mode&quot;</span><br><span class=\"line\">port.on(&apos;data&apos;, function (data) &#123;</span><br><span class=\"line\">\tconsole.log(&apos;Data:&apos;, data.toString())  //接收到数据，打印出来</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"拍照与保存功能\"><a href=\"#拍照与保存功能\" class=\"headerlink\" title=\"拍照与保存功能\"></a>拍照与保存功能</h2><p><code>MJPG-STREAMER</code>支持保存当前帧，只需要将视频画面地址<code>http://192.168.123.251:8082/?action=stream</code>中的最后一个<code>stream</code>改为<code>snapshot</code>即可。</p>\n<p>一开始初步的想法是完全同通前端实现，通过<code>&lt;img src=&quot;http://192.168.123.251:8080/?action=action&quot; /&gt;</code>标签来实现拍照功能，但是这种放有两个问题：</p>\n<ol>\n<li>所见非所得，假如在t0时刻拍照为img1，接着点击保存到本地的时候，下载和保存的图片是t1时刻的另一张照片，这是不满足需求的；</li>\n<li><p>图片下载功能通过<code>&lt;a&gt;</code>标签＋<code>download</code>属性实现，但是chrome浏览器对与跨域的图像无法实现保存，只能在新页面打开。</p>\n<p>因此拍照与保存功能设计成如下的流程：<br><img src=\"http://ww1.sinaimg.cn/mw690/6f9f3683ly1g1707sek53j20av0bt0sx.jpg\" alt=\"\"></p>\n</li>\n</ol>\n<h3 id=\"服务器端配置\"><a href=\"#服务器端配置\" class=\"headerlink\" title=\"服务器端配置\"></a>服务器端配置</h3><p><strong>1） 获取图片地址</strong></p>\n<p>服务器端要实现保存图片到本地，首先需要获取图片的地址。图片地址为<code>http://IP:PORT/?action=action</code></p>\n<p>项目中，将视频画面的地址端口设置为8082，即<code>PORT=8082</code>，IP地址则是RaspberryPi本机的地址，在NODE中获取本机地址的方法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getIPAdress() &#123;</span><br><span class=\"line\">\tvar interfaces = require(&apos;os&apos;).networkInterfaces();</span><br><span class=\"line\">\tfor (var devName in interfaces) &#123;</span><br><span class=\"line\">\t\tvar iface = interfaces[devName];</span><br><span class=\"line\">\t\tfor (var i = 0; i &lt; iface.length; i++) &#123;</span><br><span class=\"line\">\t\t\tvar alias = iface[i];</span><br><span class=\"line\">\t\t\tif (alias.family === &apos;IPv4&apos; &amp;&amp; alias.address !== &apos;127.0.0.1&apos; &amp;&amp; !alias.internal) &#123;</span><br><span class=\"line\">\t\t\t\treturn alias.address;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>2） 下载图片</strong></p>\n<p>图片下载，使用到了<code>request</code>这个模块，首先在项目中安装该模块<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install request -S</span><br></pre></td></tr></table></figure></p>\n<p>接下来，写一个下载图片的函数，创建一个文件<code>downIMG.js</code><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vim downIMG.js</span><br></pre></td></tr></table></figure></p>\n<p>写下载图片的函数，并将函数导出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&apos;fs&apos;);</span><br><span class=\"line\">const request = require(&apos;request&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const download = function(uri, filename, callback) &#123;</span><br><span class=\"line\">    request.head(uri, function(err, res, body) &#123;</span><br><span class=\"line\">        request(uri).pipe(fs.createWriteStream(__dirname +&apos;/public/SnapShoot/&apos; + filename)).on(&apos;close&apos;, callback);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = download</span><br></pre></td></tr></table></figure></p>\n<p>在项目所在文件夹下，新建一个<code>SnapShoot</code>的文件夹。</p>\n<p><strong>3） 引入图片下载函数，服务器实现响应</strong></p>\n<p>在主文件<code>server.js</code>中，实现服务器的响应<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var download = require(&apos;./downIMG&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(express.static(path.join(__dirname, &apos;public&apos;))); //将public设置为静态资源，这样保存的截图才可以被访问得到</span><br><span class=\"line\">app.use(bodyParse.json(&#123; limit: &apos;1mb&apos; &#125;));  //body-parser 解析json格式数据</span><br><span class=\"line\">app.use(bodyParse.urlencoded(&#123;extended:false&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&apos;/capture&apos;, function (req, res) &#123;</span><br><span class=\"line\">\tdownload(snapAddress,&apos;current.png&apos;,function()&#123;</span><br><span class=\"line\">\t\tres.send(&apos;Capture Sussess&apos;);</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;)   //拍照请求</span><br></pre></td></tr></table></figure></p>\n<p>至此，前端只需要通过<code>&lt;a&gt;</code>标签配合<code>download</code>属性，就可以实现拍照和下载的功能了，样例：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_blank\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"down\"</span> <span class=\"attr\">:href</span>=<span class=\"string\">\"snapAdd\"</span> <span class=\"attr\">:download</span>=<span class=\"string\">\"currentDate\"</span>&gt;</span>点击下载<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><p>服务器端包括了 server.js + downIMG.js，以及前端的页面及静态资源。</p>\n<ul>\n<li>downIMG.js</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs = require(&apos;fs&apos;),</span><br><span class=\"line\">    request = require(&apos;request&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">var download = function(uri, filename, callback) &#123;</span><br><span class=\"line\">    request.head(uri, function(err, res, body) &#123;</span><br><span class=\"line\">        request(uri).pipe(fs.createWriteStream(__dirname +&apos;/public/SnapShoot/&apos; + filename)).on(&apos;close&apos;, callback);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = download</span><br></pre></td></tr></table></figure>\n<ul>\n<li>server.js</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const express = require(&apos;express&apos;);</span><br><span class=\"line\">const app = express();</span><br><span class=\"line\">const bodyParse = require(&quot;body-parser&quot;);</span><br><span class=\"line\">const shell = require(&apos;shelljs&apos;);</span><br><span class=\"line\">const download = require(&apos;./downIMG&apos;);</span><br><span class=\"line\">const path = require(&apos;path&apos;);</span><br><span class=\"line\">const SerialPort = require(&apos;serialport&apos;);</span><br><span class=\"line\">const IP = getIPAdress();</span><br><span class=\"line\">const PORT = &apos;8082&apos;;</span><br><span class=\"line\">const videoCommand = [</span><br><span class=\"line\">\t&apos;mjpg_streamer -i &quot;./input_uvc.so -r 640x480 -q 70 -f 30 -d /dev/video0 -n&quot; -o &quot;./output_http.so -p 8082 -w /usr/local/www&quot;&apos;,</span><br><span class=\"line\">\t&apos;mjpg_streamer -i &quot;./input_uvc.so -r 1280x720 -q 70 -f 15 -d /dev/video0 -n&quot; -o &quot;./output_http.so -p 8082 -w /usr/local/www&quot;&apos;,</span><br><span class=\"line\">\t&apos;mjpg_streamer -i &quot;./input_uvc.so -r 1920x1080 -q 70 -f 15 -d /dev/video0 -n&quot; -o &quot;./output_http.so -p 8082 -w /usr/local/www&quot;&apos;</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">const snapAddress = `http://$&#123;IP&#125;:$&#123;PORT&#125;/?action=snapshot`;</span><br><span class=\"line\"></span><br><span class=\"line\">var speed = 50; //运动速度</span><br><span class=\"line\">var videoStatus = 0;  // 1-流畅； 2-清晰； 3-高清， 默认清晰</span><br><span class=\"line\">const port = new SerialPort(&apos;/dev/ttyAMA0&apos;, &#123;</span><br><span class=\"line\">\tbaudRate: 9600</span><br><span class=\"line\">&#125;)   //使用串口，与下位机机型通讯</span><br><span class=\"line\"></span><br><span class=\"line\">port.write(&apos;main screen turn on&apos;, function (err) &#123;</span><br><span class=\"line\">\tif (err) &#123;</span><br><span class=\"line\">\t\treturn console.log(&apos;Error on write: &apos;, err.message)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tconsole.log(&apos;message written&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// Open errors will be emitted as an error event</span><br><span class=\"line\">port.on(&apos;error&apos;, function (err) &#123;</span><br><span class=\"line\">\tconsole.log(&apos;Error: &apos;, err.message)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// Switches the port into &quot;flowing mode&quot;</span><br><span class=\"line\">port.on(&apos;data&apos;, function (data) &#123;</span><br><span class=\"line\">\tconsole.log(&apos;Data:&apos;, data.toString())</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"> const buf1 = Buffer.alloc(1,1),  //前进</span><br><span class=\"line\">\tbuf2 = Buffer.alloc(1,2),  //后退</span><br><span class=\"line\">\tbuf3 = Buffer.alloc(1,3),  //伸张</span><br><span class=\"line\">\tbuf4 = Buffer.alloc(1,4),  //收缩</span><br><span class=\"line\">\tbuf5 = Buffer.alloc(1,5);  //停止</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(express.static(path.join(__dirname, &apos;public&apos;)));</span><br><span class=\"line\">app.use(bodyParse.json(&#123; limit: &apos;1mb&apos; &#125;));  //body-parser 解析json格式数据</span><br><span class=\"line\">app.use(bodyParse.urlencoded(&#123;extended:false&#125;));</span><br><span class=\"line\">app.post(&apos;/VideoSet&apos;,(req,res) =&gt; &#123;</span><br><span class=\"line\">\tif(+req.body.Video === videoStatus) &#123;</span><br><span class=\"line\">\t\tres.end(&apos;Same Video Set&apos;);</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tswitch (req.body.Video) &#123;</span><br><span class=\"line\">\t\tcase &quot;1&quot;: </span><br><span class=\"line\">\t\t\topenVideo(0);</span><br><span class=\"line\">\t\t\tres.end(&apos;Success&apos;);</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase &quot;2&quot;:</span><br><span class=\"line\">\t\t\topenVideo(1);</span><br><span class=\"line\">\t\t\tres.end(&apos;Success&apos;);</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase &quot;3&quot;: </span><br><span class=\"line\">\t\t\topenVideo(2);</span><br><span class=\"line\">\t\t\tres.end(&apos;Success&apos;);</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.get(&apos;/capture&apos;, function (req, res) &#123;</span><br><span class=\"line\">\tdownload(snapAddress,&apos;current.png&apos;,function()&#123;</span><br><span class=\"line\">\t\tres.send(&apos;Capture Sussess&apos;);</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;) </span><br><span class=\"line\">app.get(&apos;/speed&apos;,function(req,res) &#123;</span><br><span class=\"line\">\tres.send(&#123;&apos;speed&apos;:speed&#125;);</span><br><span class=\"line\">&#125;) </span><br><span class=\"line\">app.post(&apos;/speedSet&apos;,(req,res) =&gt; &#123;</span><br><span class=\"line\">\tspeed = req.body.speed;</span><br><span class=\"line\">\tres.end(&apos;Speed Set Success&apos;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&apos;/VideoStatus&apos;, function(req, res)&#123;</span><br><span class=\"line\">\tres.send(videoStatus.toString());</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&apos;/&apos;,function(req,res)&#123;</span><br><span class=\"line\">\tres.sendFile(__dirname + &apos;/&apos; + &quot;index.html&quot;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.get(&apos;/up&apos;,function(req,res)&#123;</span><br><span class=\"line\">\tconsole.log(&quot;up recieve&quot;);</span><br><span class=\"line\">\tres.send(&apos;ok&apos;);</span><br><span class=\"line\">\tport.write(buf1,&apos;hex&apos;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.get(&apos;/down&apos;,function(req,res)&#123;</span><br><span class=\"line\">\tconsole.log(&apos;down recieve&apos;);</span><br><span class=\"line\">\tres.send(&apos;ok&apos;);</span><br><span class=\"line\">\tport.write(buf2,&apos;hex&apos;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.get(&apos;/stretch&apos;, function (req, res) &#123;</span><br><span class=\"line\">\tconsole.log(&apos;stretch&apos;);</span><br><span class=\"line\">\tres.send(&apos;ok&apos;);</span><br><span class=\"line\">\tport.write(buf3,&apos;hex&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.get(&apos;/shrink&apos;,function(req,res)&#123;</span><br><span class=\"line\">\tconsole.log(&apos;shrink recieve&apos;);</span><br><span class=\"line\">\tres.send(&apos;ok&apos;);</span><br><span class=\"line\">\tport.write(buf4);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.get(&apos;/stop&apos;,function(req,res)&#123;</span><br><span class=\"line\">\tconsole.log(&apos;stop!!!&apos;);</span><br><span class=\"line\">\tres.send(&apos;ok&apos;);</span><br><span class=\"line\">\tport.write(buf5);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">var server = app.listen(8081,function()&#123;</span><br><span class=\"line\">\tconsole.log(&quot;Server is running at 8081 port...&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">function openVideo(qulity) &#123;</span><br><span class=\"line\">\treturn new Promise((resolve,reject) =&gt; &#123;</span><br><span class=\"line\">\t\tif (shell.exec(&apos;pgrep mjpg_streamer&apos;).stdout !== &apos;&apos;) &#123;</span><br><span class=\"line\">\t\t\tshell.exec(&apos;killall mjpg_streamer&apos;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlet command = videoCommand[qulity];</span><br><span class=\"line\">\t\tshell.cd(&apos;~&apos;);</span><br><span class=\"line\">\t\tshell.cd(&apos;mjpg-streamer/mjpg-streamer-experimental/&apos;)</span><br><span class=\"line\">\t\tshell.exec(command, (code, std, err) =&gt; &#123;</span><br><span class=\"line\">\t\t\tconsole.log(&apos;Exit code:&apos;, code);</span><br><span class=\"line\">\t\t\tconsole.log(&apos;Program output:&apos;, std);</span><br><span class=\"line\">\t\t\tconsole.log(&apos;Program stderr:&apos;, err);</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t\tvideoStatus = +qulity + 1;</span><br><span class=\"line\">\t\tresolve(&apos;Success&apos;);</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getIPAdress() &#123;</span><br><span class=\"line\">\tvar interfaces = require(&apos;os&apos;).networkInterfaces();</span><br><span class=\"line\">\tfor (var devName in interfaces) &#123;</span><br><span class=\"line\">\t\tvar iface = interfaces[devName];</span><br><span class=\"line\">\t\tfor (var i = 0; i &lt; iface.length; i++) &#123;</span><br><span class=\"line\">\t\t\tvar alias = iface[i];</span><br><span class=\"line\">\t\t\tif (alias.family === &apos;IPv4&apos; &amp;&amp; alias.address !== &apos;127.0.0.1&apos; &amp;&amp; !alias.internal) &#123;</span><br><span class=\"line\">\t\t\t\treturn alias.address;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>最近在做一个机器人项目，需要将试试捕获安装于机器人身上的视频图像，并能够对机器人进行无线运动控制。作为前端工程师的我，很自然的想到了使用Node作为服务器和机器人的控制中心，通过前端页面实现对机器人控制和视频图像的捕捉。</p>\n<p>本文主要对项目中的一个单元：视频图像的捕捉和拍照功能进行开发记录和解析。</p>\n<p>实现功能<br>一： 远程视频图像获取<br>二： 视频图像清晰度调节<br>三： 拍照功能</p>\n<hr>\n<h2 id=\"基于Express的服务器环境搭建\"><a href=\"#基于Express的服务器环境搭建\" class=\"headerlink\" title=\"基于Express的服务器环境搭建\"></a>基于Express的服务器环境搭建</h2><p>Express是基于Node的一个快速搭建服务器的框架，项目使用Express快速搭建服务器。</p>\n<h3 id=\"node的安装\"><a href=\"#node的安装\" class=\"headerlink\" title=\"node的安装\"></a>node的安装</h3><p>首先，更新所有安装列表到最新的状态：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pi@raspberrypi:~$ sudo apt-get update</span><br></pre></td></tr></table></figure></p>\n<p>升级所有安装包到最新版本：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pi@raspberrypi:~$ sudo apt-get dist-upgrade</span><br></pre></td></tr></table></figure>\n<p>接下来，下载和安装node(注意版本号使用_8.x)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pi@raspberrypi:~$ curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -</span><br></pre></td></tr></table></figure>\n<p>现在可以安装了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pi@raspberrypi:~$ sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure>\n<p>测试是否安装成功：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pi@raspberrypi:~$ node -v</span><br></pre></td></tr></table></figure>\n<h3 id=\"Express安装\"><a href=\"#Express安装\" class=\"headerlink\" title=\"Express安装\"></a>Express安装</h3><p>使用Node的包管理工具npm来新建项目和安装框架</p>\n<p>首先，进入项目目录，并新建工程:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> Public/WebProject/FisrtPage/</span><br><span class=\"line\">$ npm init -y</span><br></pre></td></tr></table></figure></p>\n<p>安装 Express 并将其保存到依赖列表中：<br>以下命令会将 Express 框架安装在当前目录的 node_modules 目录中<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install express --save</span><br></pre></td></tr></table></figure></p>\n<p>然后，在该项目文件下新建<code>server.js</code>文件，引入Express就可以很方便的搭建起一个服务器。具体的内容在后面进行分析。</p>\n<h3 id=\"Mjpg-Streamer\"><a href=\"#Mjpg-Streamer\" class=\"headerlink\" title=\"Mjpg-Streamer\"></a>Mjpg-Streamer</h3><p>项目使用的是一个USB摄像头，为了能将图像捕获并通过HTTP转发，项目使用Mjpg-Streamer实现这一功能。</p>\n<ol>\n<li><p>安装必要的库</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install libjpeg8-dev</span><br><span class=\"line\">sudo apt-get install imagemagick</span><br><span class=\"line\">sudo apt-get install libv4l-dev //</span><br><span class=\"line\">sudo apt-get install cmake //编译工具</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>为了向后兼容，链接videodev2.h和videodev.h<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo ln -s /usr/include/linux/videodev2.h /usr/include/linux/videodev/h</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n</ol>\n<p>注意，这里的<code>sudo ln -s</code>是非常重要的操作命令，类似于为a做一个超链接</p>\n<ol start=\"3\">\n<li><p>git开源代码到本地，编译进入到home目录，然后开始克隆</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> ~</span><br><span class=\"line\">sudo git <span class=\"built_in\">clone</span> https://github.com/jacksonliam/mjpg-streamer.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> mjpg-streamer/mjpg-streamer-experimental</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编译和安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo make</span><br><span class=\"line\">sudo make install</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>测试和使用</p>\n</li>\n</ol>\n<p>完成以上步骤之后，可以开始测试一下。 插入摄像头，执行以下命令，分别在两个窗口打开<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo mjpg_streamer -i <span class=\"string\">\"./input_uvc.so -r 640x480 -q 70 -f 15 -d /dev/video1 -n\"</span> -o <span class=\"string\">\"./output_http.so -p 8080 -w /usr/local/www\"</span></span><br></pre></td></tr></table></figure></p>\n<p>出现一下的内容，表明安装成功<br><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1g0wxsj1795j20dw09gads.jpg\" alt=\"\"><br>这样，打开浏览器输入<code>http://localhost:8080/?action=stream</code>就可以看到视频图像，其中<code>localhost</code>在实际使用中，换成了树莓派的IP地址，树莓派已经提前设置了静态地址，我使用的是<code>192.168.123.251</code>，因此，视频的地址就顾定成了：</p>\n<p><code>http://192.168.123.251:8080/?action=stream</code></p>\n<h2 id=\"依赖模块\"><a href=\"#依赖模块\" class=\"headerlink\" title=\"依赖模块\"></a>依赖模块</h2><h3 id=\"shelljs\"><a href=\"#shelljs\" class=\"headerlink\" title=\"shelljs\"></a>shelljs</h3><p>上面使用的Mjpg-Streamer可以通过改变参数实现对清晰度、帧率的调整，比如将上面的图像修改为720P、15帧的指令为：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mjpg_streamer -i <span class=\"string\">\"input_uvc.so -r 1280x720 -f 15 -n\"</span> -o <span class=\"string\">\"output_http.so \"</span></span><br></pre></td></tr></table></figure></p>\n<p>但是这个是在终端中执行的命令，而服务器是使用Node，因此这里使用了shelljs实现在Node运行shell指令。</p>\n<p>首先安装shelljs<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install shelljs -S</span><br></pre></td></tr></table></figure></p>\n<p>有关该模块的具体使用及相关API可以查阅<a href=\"https://github.com/shelljs/shelljs\" target=\"_blank\" rel=\"noopener\">官网</a>,本项目中主要使用了两个指令是：</p>\n<ul>\n<li><code>shell.exec()</code> 执行某个指令</li>\n<li><code>shell.cd()</code> 进入某个目录</li>\n</ul>\n<p>为了在后台实现不同分辨率图像的转换，专门写一个函数来实现切换，并通过变量<code>videoStatus</code>的状态来表示不同的分辨率，与前端相对应的:</p>\n<ul>\n<li>videoStatus: 1-流畅</li>\n<li>videoStatus: 2-清晰</li>\n<li>videoStatus: 3-高清</li>\n</ul>\n<p>清晰度切换的函数实现如下:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> videoStatus = <span class=\"number\">0</span>;  <span class=\"comment\">// 1-流畅； 2-清晰； 3-高清， 默认清晰</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> videoCommand = [</span><br><span class=\"line\">\t<span class=\"string\">'mjpg_streamer -i \"./input_uvc.so -r 640x480 -q 70 -f 30 -d /dev/video0 -n\" -o \"./output_http.so -p 8082 -w /usr/local/www\"'</span>,</span><br><span class=\"line\">\t<span class=\"string\">'mjpg_streamer -i \"./input_uvc.so -r 1280x720 -q 70 -f 15 -d /dev/video0 -n\" -o \"./output_http.so -p 8082 -w /usr/local/www\"'</span>,</span><br><span class=\"line\">\t<span class=\"string\">'mjpg_streamer -i \"./input_uvc.so -r 1920x1080 -q 70 -f 15 -d /dev/video0 -n\" -o \"./output_http.so -p 8082 -w /usr/local/www\"'</span></span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">openVideo</span>(<span class=\"params\">qulity</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (shell.exec(<span class=\"string\">'pgrep mjpg_streamer'</span>).stdout !== <span class=\"string\">''</span>) &#123;</span><br><span class=\"line\">\t\t\tshell.exec(<span class=\"string\">'killall mjpg_streamer'</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">let</span> command = videoCommand[qulity];</span><br><span class=\"line\">\t\tshell.cd(<span class=\"string\">'~'</span>);</span><br><span class=\"line\">\t\tshell.cd(<span class=\"string\">'mjpg-streamer/mjpg-streamer-experimental/'</span>)</span><br><span class=\"line\">\t\tshell.exec(command, (code, std, err) =&gt; &#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'Exit code:'</span>, code);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'Program output:'</span>, std);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">'Program stderr:'</span>, err);</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t\tvideoStatus = +qulity + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tresolve(<span class=\"string\">'Success'</span>);</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>对关键的几条指令进行一下说明：</p>\n<ul>\n<li><code>shell.exec(&#39;pgrep mjpg_streamer&#39;).stdout !== &#39;&#39;</code></li>\n</ul>\n<p><code>pgrep</code>以名称为依据从运行进程队列中查找进程,并显示查找到进程的id。在shelljs中，stdout是指令的输出，如果不存在进程，则返回为空； 这里加判断的意思主要<strong>在于如果<code>mjpg</code>已经在运行，则要杀死该进程（清晰度更换通过重启<code>mjpg</code>实现）</strong></p>\n<ul>\n<li><code>let command = videoCommand[qulity]</code></li>\n</ul>\n<p>具体的程序执行取决于前端的请求，根据<code>qulity</code>来开启不同清晰度的摄像头。</p>\n<p>接下里，对设置清晰度的请求，设置服务器响应,并开启服务器:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> app = express();</span><br><span class=\"line\"><span class=\"keyword\">var</span> bodyParse = <span class=\"built_in\">require</span>(<span class=\"string\">\"body-parser\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">app.post(<span class=\"string\">'/VideoSet'</span>,(req,res) =&gt; &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(+req.body.Video === videoStatus) &#123;</span><br><span class=\"line\">\t\tres.end(<span class=\"string\">'Same Video Set'</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">switch</span> (req.body.Video) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">\"1\"</span>: </span><br><span class=\"line\">\t\t\topenVideo(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t\tres.end(<span class=\"string\">'Success'</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">\"2\"</span>:</span><br><span class=\"line\">\t\t\topenVideo(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\tres.end(<span class=\"string\">'Success'</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">case</span> <span class=\"string\">\"3\"</span>: </span><br><span class=\"line\">\t\t\topenVideo(<span class=\"number\">2</span>);</span><br><span class=\"line\">\t\t\tres.end(<span class=\"string\">'Success'</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> server = app.listen(<span class=\"number\">8081</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">\"Server is running at 8081 port...\"</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"serialport\"><a href=\"#serialport\" class=\"headerlink\" title=\"serialport\"></a>serialport</h3><p>项目除了传统前端的内容，还涉及了对机器人的控制，而机器人控制主要通过基于STM系列的下位机实现。所以RaspberryPi在作为服务器接收到前端控制请求后，需要将控制请求发送至下位机，实现控制，项目中使用了UART串口进行相互连接。</p>\n<h4 id=\"打开RaspberryPi-3B的串口通讯能力\"><a href=\"#打开RaspberryPi-3B的串口通讯能力\" class=\"headerlink\" title=\"打开RaspberryPi 3B的串口通讯能力\"></a>打开RaspberryPi 3B的串口通讯能力</h4><p>之前项目中，使用了USB转串口模块直接插在RaspberryPI的USB接口上，然后通过<code>serialport</code>打开相应的串口实现串口通讯。</p>\n<p>本项目中，为了节约USB资源和空间，要使用GPIO口的TX/RX进行UART通讯。RaspberryPi 3B与之前的版本不同，它带了两个串口，分别是：</p>\n<ol>\n<li>/dev/ttyAMA0：<br>RPI3配备了蓝牙，为了保证蓝牙的正确使用，/dev/ttyAMA0则不再为GPIO串口服务，而是为蓝牙模块服务。</li>\n<li>/dev/ttyS0：<br>被称为”mini uart”，此串口代表了”Physical pin 8|10 BCM pin 14|15Wiring Pi pin 15|16”.<br>但是由于次串口波特率收到cpu频率影响，并不稳定，所以实际上无法被用来串口通信。</li>\n</ol>\n<p>正因如此，网络上大部分教程，直接使用/dev/ttyAMA0作为串口的方法就无法使用RPI3了，查了相关资料，通过以下方法解决<a href=\"https://www.jianshu.com/p/26409ddf6a9b\" target=\"_blank\" rel=\"noopener\">(参考自简书R4L)</a>：</p>\n<blockquote>\n<p>将ttyAMA0和ttyS0互换，那么gpio tx\\rx串口映射给ttyAMA0，ttyS0则映射给蓝牙设备。<br>这样gpio 14、15串口就拥有了稳定，强大的通信功能,而蓝牙串口则无法正常使用。</p>\n</blockquote>\n<p><strong>1) 激活串口</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo nano /boot/config.txt</span><br></pre></td></tr></table></figure></p>\n<p>改变使得：enable_uart=1.<br>若无此参数，则在最后一行添加：enable_uart=1.<br>重启设备。</p>\n<p><strong>2)查看串口别名</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls -l /dev</span><br></pre></td></tr></table></figure></p>\n<p>会发现:<br>lrwxrwxrwx 1 root root 7 Aug 28 07:41 serial0 -&gt; ttyS0<br>lrwxrwxrwx 1 root root 5 Aug 28 07:41 serial1 -&gt; ttyAMA0</p>\n<p><strong>3)禁用/dev/ttyS0的console功能</strong><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo systemctl stop serial-getty@ttyS0.service</span><br><span class=\"line\">$ sudo systemctl <span class=\"built_in\">disable</span> serial-getty@ttyS0.service</span><br></pre></td></tr></table></figure></p>\n<p>并且修改cmdline.txt文件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo nano /boot/cmdline.txt</span><br></pre></td></tr></table></figure></p>\n<p>删除“console=serial0,115200”，保存并重启</p>\n<p>4) 交换串口<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ sudo nano /boot/config.txt</span><br></pre></td></tr></table></figure></p>\n<p>在最下面添加：dtoverlay=pi3-miniuart-bt<br>保存并重启。<br>此时查看串口别名则发现：<br>lrwxrwxrwx 1 root root           7 Aug 28 07:41 serial0 -&gt; ttyAMA0<br>lrwxrwxrwx 1 root root           5 Aug 28 07:41 serial1 -&gt; ttyS0<br>此时，ttyAMA0串口可以正常用于串口通信，ttyS0则无法被用于串口通信，蓝牙功能失效。</p>\n<h4 id=\"使用serialport打开通讯\"><a href=\"#使用serialport打开通讯\" class=\"headerlink\" title=\"使用serialport打开通讯\"></a>使用<code>serialport</code>打开通讯</h4><p>1) 安装serialport<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install serialport -S</span><br></pre></td></tr></table></figure></p>\n<p>2) 引入serialport，并开启串口<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var SerialPort = require(&apos;serialport&apos;);</span><br><span class=\"line\">const port = new SerialPort(&apos;/dev/ttyAMA0&apos;, &#123;</span><br><span class=\"line\">\tbaudRate: 9600</span><br><span class=\"line\">&#125;)   //使用串口，与下位机机型通讯</span><br></pre></td></tr></table></figure></p>\n<p>3) 串口通讯</p>\n<p><code>serialport</code>的api非常简单，使用相关进行通讯即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">port.write(&apos;main screen turn on&apos;, function (err) &#123;</span><br><span class=\"line\">\tif (err) &#123;</span><br><span class=\"line\">\t\treturn console.log(&apos;Error on write: &apos;, err.message)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tconsole.log(&apos;message written&apos;)  //打开串口</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// Open errors will be emitted as an error event</span><br><span class=\"line\">port.on(&apos;error&apos;, function (err) &#123;</span><br><span class=\"line\">\tconsole.log(&apos;Error: &apos;, err.message)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// Switches the port into &quot;flowing mode&quot;</span><br><span class=\"line\">port.on(&apos;data&apos;, function (data) &#123;</span><br><span class=\"line\">\tconsole.log(&apos;Data:&apos;, data.toString())  //接收到数据，打印出来</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"拍照与保存功能\"><a href=\"#拍照与保存功能\" class=\"headerlink\" title=\"拍照与保存功能\"></a>拍照与保存功能</h2><p><code>MJPG-STREAMER</code>支持保存当前帧，只需要将视频画面地址<code>http://192.168.123.251:8082/?action=stream</code>中的最后一个<code>stream</code>改为<code>snapshot</code>即可。</p>\n<p>一开始初步的想法是完全同通前端实现，通过<code>&lt;img src=&quot;http://192.168.123.251:8080/?action=action&quot; /&gt;</code>标签来实现拍照功能，但是这种放有两个问题：</p>\n<ol>\n<li>所见非所得，假如在t0时刻拍照为img1，接着点击保存到本地的时候，下载和保存的图片是t1时刻的另一张照片，这是不满足需求的；</li>\n<li><p>图片下载功能通过<code>&lt;a&gt;</code>标签＋<code>download</code>属性实现，但是chrome浏览器对与跨域的图像无法实现保存，只能在新页面打开。</p>\n<p>因此拍照与保存功能设计成如下的流程：<br><img src=\"http://ww1.sinaimg.cn/mw690/6f9f3683ly1g1707sek53j20av0bt0sx.jpg\" alt=\"\"></p>\n</li>\n</ol>\n<h3 id=\"服务器端配置\"><a href=\"#服务器端配置\" class=\"headerlink\" title=\"服务器端配置\"></a>服务器端配置</h3><p><strong>1） 获取图片地址</strong></p>\n<p>服务器端要实现保存图片到本地，首先需要获取图片的地址。图片地址为<code>http://IP:PORT/?action=action</code></p>\n<p>项目中，将视频画面的地址端口设置为8082，即<code>PORT=8082</code>，IP地址则是RaspberryPi本机的地址，在NODE中获取本机地址的方法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getIPAdress() &#123;</span><br><span class=\"line\">\tvar interfaces = require(&apos;os&apos;).networkInterfaces();</span><br><span class=\"line\">\tfor (var devName in interfaces) &#123;</span><br><span class=\"line\">\t\tvar iface = interfaces[devName];</span><br><span class=\"line\">\t\tfor (var i = 0; i &lt; iface.length; i++) &#123;</span><br><span class=\"line\">\t\t\tvar alias = iface[i];</span><br><span class=\"line\">\t\t\tif (alias.family === &apos;IPv4&apos; &amp;&amp; alias.address !== &apos;127.0.0.1&apos; &amp;&amp; !alias.internal) &#123;</span><br><span class=\"line\">\t\t\t\treturn alias.address;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>2） 下载图片</strong></p>\n<p>图片下载，使用到了<code>request</code>这个模块，首先在项目中安装该模块<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install request -S</span><br></pre></td></tr></table></figure></p>\n<p>接下来，写一个下载图片的函数，创建一个文件<code>downIMG.js</code><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vim downIMG.js</span><br></pre></td></tr></table></figure></p>\n<p>写下载图片的函数，并将函数导出<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const fs = require(&apos;fs&apos;);</span><br><span class=\"line\">const request = require(&apos;request&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">const download = function(uri, filename, callback) &#123;</span><br><span class=\"line\">    request.head(uri, function(err, res, body) &#123;</span><br><span class=\"line\">        request(uri).pipe(fs.createWriteStream(__dirname +&apos;/public/SnapShoot/&apos; + filename)).on(&apos;close&apos;, callback);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = download</span><br></pre></td></tr></table></figure></p>\n<p>在项目所在文件夹下，新建一个<code>SnapShoot</code>的文件夹。</p>\n<p><strong>3） 引入图片下载函数，服务器实现响应</strong></p>\n<p>在主文件<code>server.js</code>中，实现服务器的响应<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var download = require(&apos;./downIMG&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(express.static(path.join(__dirname, &apos;public&apos;))); //将public设置为静态资源，这样保存的截图才可以被访问得到</span><br><span class=\"line\">app.use(bodyParse.json(&#123; limit: &apos;1mb&apos; &#125;));  //body-parser 解析json格式数据</span><br><span class=\"line\">app.use(bodyParse.urlencoded(&#123;extended:false&#125;));</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&apos;/capture&apos;, function (req, res) &#123;</span><br><span class=\"line\">\tdownload(snapAddress,&apos;current.png&apos;,function()&#123;</span><br><span class=\"line\">\t\tres.send(&apos;Capture Sussess&apos;);</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;)   //拍照请求</span><br></pre></td></tr></table></figure></p>\n<p>至此，前端只需要通过<code>&lt;a&gt;</code>标签配合<code>download</code>属性，就可以实现拍照和下载的功能了，样例：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_blank\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"down\"</span> <span class=\"attr\">:href</span>=<span class=\"string\">\"snapAdd\"</span> <span class=\"attr\">:download</span>=<span class=\"string\">\"currentDate\"</span>&gt;</span>点击下载<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><p>服务器端包括了 server.js + downIMG.js，以及前端的页面及静态资源。</p>\n<ul>\n<li>downIMG.js</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var fs = require(&apos;fs&apos;),</span><br><span class=\"line\">    request = require(&apos;request&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">var download = function(uri, filename, callback) &#123;</span><br><span class=\"line\">    request.head(uri, function(err, res, body) &#123;</span><br><span class=\"line\">        request(uri).pipe(fs.createWriteStream(__dirname +&apos;/public/SnapShoot/&apos; + filename)).on(&apos;close&apos;, callback);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = download</span><br></pre></td></tr></table></figure>\n<ul>\n<li>server.js</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const express = require(&apos;express&apos;);</span><br><span class=\"line\">const app = express();</span><br><span class=\"line\">const bodyParse = require(&quot;body-parser&quot;);</span><br><span class=\"line\">const shell = require(&apos;shelljs&apos;);</span><br><span class=\"line\">const download = require(&apos;./downIMG&apos;);</span><br><span class=\"line\">const path = require(&apos;path&apos;);</span><br><span class=\"line\">const SerialPort = require(&apos;serialport&apos;);</span><br><span class=\"line\">const IP = getIPAdress();</span><br><span class=\"line\">const PORT = &apos;8082&apos;;</span><br><span class=\"line\">const videoCommand = [</span><br><span class=\"line\">\t&apos;mjpg_streamer -i &quot;./input_uvc.so -r 640x480 -q 70 -f 30 -d /dev/video0 -n&quot; -o &quot;./output_http.so -p 8082 -w /usr/local/www&quot;&apos;,</span><br><span class=\"line\">\t&apos;mjpg_streamer -i &quot;./input_uvc.so -r 1280x720 -q 70 -f 15 -d /dev/video0 -n&quot; -o &quot;./output_http.so -p 8082 -w /usr/local/www&quot;&apos;,</span><br><span class=\"line\">\t&apos;mjpg_streamer -i &quot;./input_uvc.so -r 1920x1080 -q 70 -f 15 -d /dev/video0 -n&quot; -o &quot;./output_http.so -p 8082 -w /usr/local/www&quot;&apos;</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">const snapAddress = `http://$&#123;IP&#125;:$&#123;PORT&#125;/?action=snapshot`;</span><br><span class=\"line\"></span><br><span class=\"line\">var speed = 50; //运动速度</span><br><span class=\"line\">var videoStatus = 0;  // 1-流畅； 2-清晰； 3-高清， 默认清晰</span><br><span class=\"line\">const port = new SerialPort(&apos;/dev/ttyAMA0&apos;, &#123;</span><br><span class=\"line\">\tbaudRate: 9600</span><br><span class=\"line\">&#125;)   //使用串口，与下位机机型通讯</span><br><span class=\"line\"></span><br><span class=\"line\">port.write(&apos;main screen turn on&apos;, function (err) &#123;</span><br><span class=\"line\">\tif (err) &#123;</span><br><span class=\"line\">\t\treturn console.log(&apos;Error on write: &apos;, err.message)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tconsole.log(&apos;message written&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// Open errors will be emitted as an error event</span><br><span class=\"line\">port.on(&apos;error&apos;, function (err) &#123;</span><br><span class=\"line\">\tconsole.log(&apos;Error: &apos;, err.message)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// Switches the port into &quot;flowing mode&quot;</span><br><span class=\"line\">port.on(&apos;data&apos;, function (data) &#123;</span><br><span class=\"line\">\tconsole.log(&apos;Data:&apos;, data.toString())</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"> const buf1 = Buffer.alloc(1,1),  //前进</span><br><span class=\"line\">\tbuf2 = Buffer.alloc(1,2),  //后退</span><br><span class=\"line\">\tbuf3 = Buffer.alloc(1,3),  //伸张</span><br><span class=\"line\">\tbuf4 = Buffer.alloc(1,4),  //收缩</span><br><span class=\"line\">\tbuf5 = Buffer.alloc(1,5);  //停止</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(express.static(path.join(__dirname, &apos;public&apos;)));</span><br><span class=\"line\">app.use(bodyParse.json(&#123; limit: &apos;1mb&apos; &#125;));  //body-parser 解析json格式数据</span><br><span class=\"line\">app.use(bodyParse.urlencoded(&#123;extended:false&#125;));</span><br><span class=\"line\">app.post(&apos;/VideoSet&apos;,(req,res) =&gt; &#123;</span><br><span class=\"line\">\tif(+req.body.Video === videoStatus) &#123;</span><br><span class=\"line\">\t\tres.end(&apos;Same Video Set&apos;);</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tswitch (req.body.Video) &#123;</span><br><span class=\"line\">\t\tcase &quot;1&quot;: </span><br><span class=\"line\">\t\t\topenVideo(0);</span><br><span class=\"line\">\t\t\tres.end(&apos;Success&apos;);</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase &quot;2&quot;:</span><br><span class=\"line\">\t\t\topenVideo(1);</span><br><span class=\"line\">\t\t\tres.end(&apos;Success&apos;);</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t\tcase &quot;3&quot;: </span><br><span class=\"line\">\t\t\topenVideo(2);</span><br><span class=\"line\">\t\t\tres.end(&apos;Success&apos;);</span><br><span class=\"line\">\t\t\tbreak;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.get(&apos;/capture&apos;, function (req, res) &#123;</span><br><span class=\"line\">\tdownload(snapAddress,&apos;current.png&apos;,function()&#123;</span><br><span class=\"line\">\t\tres.send(&apos;Capture Sussess&apos;);</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;) </span><br><span class=\"line\">app.get(&apos;/speed&apos;,function(req,res) &#123;</span><br><span class=\"line\">\tres.send(&#123;&apos;speed&apos;:speed&#125;);</span><br><span class=\"line\">&#125;) </span><br><span class=\"line\">app.post(&apos;/speedSet&apos;,(req,res) =&gt; &#123;</span><br><span class=\"line\">\tspeed = req.body.speed;</span><br><span class=\"line\">\tres.end(&apos;Speed Set Success&apos;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&apos;/VideoStatus&apos;, function(req, res)&#123;</span><br><span class=\"line\">\tres.send(videoStatus.toString());</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.get(&apos;/&apos;,function(req,res)&#123;</span><br><span class=\"line\">\tres.sendFile(__dirname + &apos;/&apos; + &quot;index.html&quot;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.get(&apos;/up&apos;,function(req,res)&#123;</span><br><span class=\"line\">\tconsole.log(&quot;up recieve&quot;);</span><br><span class=\"line\">\tres.send(&apos;ok&apos;);</span><br><span class=\"line\">\tport.write(buf1,&apos;hex&apos;);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.get(&apos;/down&apos;,function(req,res)&#123;</span><br><span class=\"line\">\tconsole.log(&apos;down recieve&apos;);</span><br><span class=\"line\">\tres.send(&apos;ok&apos;);</span><br><span class=\"line\">\tport.write(buf2,&apos;hex&apos;);</span><br><span class=\"line\">\t</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.get(&apos;/stretch&apos;, function (req, res) &#123;</span><br><span class=\"line\">\tconsole.log(&apos;stretch&apos;);</span><br><span class=\"line\">\tres.send(&apos;ok&apos;);</span><br><span class=\"line\">\tport.write(buf3,&apos;hex&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.get(&apos;/shrink&apos;,function(req,res)&#123;</span><br><span class=\"line\">\tconsole.log(&apos;shrink recieve&apos;);</span><br><span class=\"line\">\tres.send(&apos;ok&apos;);</span><br><span class=\"line\">\tport.write(buf4);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">app.get(&apos;/stop&apos;,function(req,res)&#123;</span><br><span class=\"line\">\tconsole.log(&apos;stop!!!&apos;);</span><br><span class=\"line\">\tres.send(&apos;ok&apos;);</span><br><span class=\"line\">\tport.write(buf5);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">var server = app.listen(8081,function()&#123;</span><br><span class=\"line\">\tconsole.log(&quot;Server is running at 8081 port...&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">function openVideo(qulity) &#123;</span><br><span class=\"line\">\treturn new Promise((resolve,reject) =&gt; &#123;</span><br><span class=\"line\">\t\tif (shell.exec(&apos;pgrep mjpg_streamer&apos;).stdout !== &apos;&apos;) &#123;</span><br><span class=\"line\">\t\t\tshell.exec(&apos;killall mjpg_streamer&apos;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tlet command = videoCommand[qulity];</span><br><span class=\"line\">\t\tshell.cd(&apos;~&apos;);</span><br><span class=\"line\">\t\tshell.cd(&apos;mjpg-streamer/mjpg-streamer-experimental/&apos;)</span><br><span class=\"line\">\t\tshell.exec(command, (code, std, err) =&gt; &#123;</span><br><span class=\"line\">\t\t\tconsole.log(&apos;Exit code:&apos;, code);</span><br><span class=\"line\">\t\t\tconsole.log(&apos;Program output:&apos;, std);</span><br><span class=\"line\">\t\t\tconsole.log(&apos;Program stderr:&apos;, err);</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t\tvideoStatus = +qulity + 1;</span><br><span class=\"line\">\t\tresolve(&apos;Success&apos;);</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function getIPAdress() &#123;</span><br><span class=\"line\">\tvar interfaces = require(&apos;os&apos;).networkInterfaces();</span><br><span class=\"line\">\tfor (var devName in interfaces) &#123;</span><br><span class=\"line\">\t\tvar iface = interfaces[devName];</span><br><span class=\"line\">\t\tfor (var i = 0; i &lt; iface.length; i++) &#123;</span><br><span class=\"line\">\t\t\tvar alias = iface[i];</span><br><span class=\"line\">\t\t\tif (alias.family === &apos;IPv4&apos; &amp;&amp; alias.address !== &apos;127.0.0.1&apos; &amp;&amp; !alias.internal) &#123;</span><br><span class=\"line\">\t\t\t\treturn alias.address;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"树莓派创建热点与 node 脚本自动启动","date":"2019-03-23T07:00:10.000Z","_content":"\n## 功能实现\n> 文中所有说到的功能，均已配置好，无需再进行操作，本文只做记录以供之后的调试。\n> 使用时：\n> 1. 开机，系统会自动创建热点：`PipeRobot`\n> 2. PC 或手机等终端连接热点（密码：SJTUROBOT）\n> 3. 打开浏览器，输入地址：`192.168.123.251:8081`\n\n树莓派在 PipeRobot 中作为服务器，需要具有创建 AP 热点的能力，供下位机建立连接和控制。\n\n为此，查阅了相关资料，项目使用 create_ap 插件实现快速创建热点。\n\n除此外，Node 脚本搭建的服务器需要能够实现开机启动，项目使用了 PM2 实现。\n\n---\n## 热点\n\n### create_ap 创建热点\n\n1. git clone 该项目 `git clonehttps://github.com/oblique/create_ap.git`\n2. 进入文件夹`cd create_ap`\n3. 编译 `sudo make install 就这样安装好了`\n4. 安装依赖 `sudo apt-get install util-linux procps hostapd iproute2 iw haveged dnsmasq`\n5. 此时就可以创建热点了，这里用的指令如下：\n\n`sudo create_ap wlan0 eth0 SSID PASSWRD`\n其中，SSID 是 WIFI 的名称，PASSWRD 是要设置的密码。\n\n### 开机时自动开启热点\n\n作为机器人控制系统一部分，需要在开机时自动创建热点。`create_ap`同样提供了这样的功能。\n\n可以使用`Systemd service`实现后台开启热点，比如\n\n`systemctl start create_ap` 就是开启热点，当然，我们需要对其配置文件进行编辑，开启我们需要的热点\n\n修改/etc/create_ap.conf\n`vim /etc/create_ap.conf`\n把其中的两句 SSID 和 PASSHRASE 修改为自己希望的用户名和密码。\n```\nSSID=PipeRobot\nPASSPHRASE=SJTUROBOT\n```\n**设置开机启动**\n`systemctl enable create_ap`\n\n至此，每次重启系统，就可以实现自动创建热点了。\n\n## Node 脚本开机启动\n\n因为对 Linux 脚本不是非常熟悉，Node 脚本的自动执行使用了 PM2 模块进行辅助。\n\n首先全局安装 PM2\n`sudo npm install -g pm2`\n\n### 使用 pm2 执行 node 脚本\n\n使用 PM2 运行脚本，首先进入脚本所在文件夹\n`cd Public/PipeRobot`\n\n调用 pm2 开启脚本\n`pm2 start server.js`\n\n然后就可以看到\n```bash\n[PM2] Starting /home/pi/app.js in fork_mode (1 instance)\n[PM2] Done.\n┌──────────┬────┬─────────┬──────┬─────┬────────┬─────────┬────────┬─────┬───────────┬──────┬──────────┐\n│ App name │ id │ version │ mode │ pid │ status │ restart │ uptime │ cpu │ mem       │ user │ watching │\n├──────────┼────┼─────────┼──────┼─────┼────────┼─────────┼────────┼─────┼───────────┼──────┼──────────┤\n│ app      │ 0  │ N/A     │ fork │ 738 │ online │ 0       │ 0s     │ 0%  │ 21.8 MB   │ pi   │ disabled │\n└──────────┴────┴─────────┴──────┴─────┴────────┴─────────┴────────┴─────┴───────────┴──────┴──────────┘\n```\n\n这时，服务器已经运行起来了，如果想要查看某个脚本的运行状态，可以使用`pm2 show id`查看。\n\n### 开机启动\n`pm2 startup`指令会生成一个开机启动的脚本\n\n```\npm2 startup systemd\n```\n\n可以看到输入如下\n\n```\n[PM2] Init System found: systemd\n[PM2] To setup the Startup Script, copy/paste the following command:\nsudo env PATH=$PATH:/usr/bin /usr/lib/node_modules/pm2/bin/pm2 startup systemd -u pi --hp /home/pi\n```\n\n复制生成的脚本，并执行\n\n```\nsudo env PATH=$PATH:/usr/bin /usr/lib/node_modules/pm2/bin/pm2 startup systemd -u pi --hp /home/p\n```\n\n这条指令创建的系统单元会在系统启动的时候开始执行，当系统启动的时候，PM2 就会从这个转储系统的恢复过来，为了创建这个转储空间，运行以下命令：\n```\npm2 save\n```\n\n这条指令会存储 pm2 当前的状态（当前还在运行我们的服务器`server.js`）在转储系统中，当开机时，就会从系统中恢复。\n\n这样就实现了 Node 脚本的开机启动\n\n## 参考资料\n1. [Run your Node.js application on a headless Raspberry Pi](https://dev.to/bogdaaamn/run-your-nodejs-application-on-a-headless-raspberry-pi-4jnn)\n2. [create_ap](https://github.com/oblique/create_ap)","source":"_posts/year-03-23-树莓派创建热点与node脚本自动启动.md","raw":"---\ntitle: 树莓派创建热点与 node 脚本自动启动\ndate: 2019-03-23 15:00:10\ntags:\n    - Raspberry Pi\n    - Node 脚本自启动\n    - 创建热点\n---\n\n## 功能实现\n> 文中所有说到的功能，均已配置好，无需再进行操作，本文只做记录以供之后的调试。\n> 使用时：\n> 1. 开机，系统会自动创建热点：`PipeRobot`\n> 2. PC 或手机等终端连接热点（密码：SJTUROBOT）\n> 3. 打开浏览器，输入地址：`192.168.123.251:8081`\n\n树莓派在 PipeRobot 中作为服务器，需要具有创建 AP 热点的能力，供下位机建立连接和控制。\n\n为此，查阅了相关资料，项目使用 create_ap 插件实现快速创建热点。\n\n除此外，Node 脚本搭建的服务器需要能够实现开机启动，项目使用了 PM2 实现。\n\n---\n## 热点\n\n### create_ap 创建热点\n\n1. git clone 该项目 `git clonehttps://github.com/oblique/create_ap.git`\n2. 进入文件夹`cd create_ap`\n3. 编译 `sudo make install 就这样安装好了`\n4. 安装依赖 `sudo apt-get install util-linux procps hostapd iproute2 iw haveged dnsmasq`\n5. 此时就可以创建热点了，这里用的指令如下：\n\n`sudo create_ap wlan0 eth0 SSID PASSWRD`\n其中，SSID 是 WIFI 的名称，PASSWRD 是要设置的密码。\n\n### 开机时自动开启热点\n\n作为机器人控制系统一部分，需要在开机时自动创建热点。`create_ap`同样提供了这样的功能。\n\n可以使用`Systemd service`实现后台开启热点，比如\n\n`systemctl start create_ap` 就是开启热点，当然，我们需要对其配置文件进行编辑，开启我们需要的热点\n\n修改/etc/create_ap.conf\n`vim /etc/create_ap.conf`\n把其中的两句 SSID 和 PASSHRASE 修改为自己希望的用户名和密码。\n```\nSSID=PipeRobot\nPASSPHRASE=SJTUROBOT\n```\n**设置开机启动**\n`systemctl enable create_ap`\n\n至此，每次重启系统，就可以实现自动创建热点了。\n\n## Node 脚本开机启动\n\n因为对 Linux 脚本不是非常熟悉，Node 脚本的自动执行使用了 PM2 模块进行辅助。\n\n首先全局安装 PM2\n`sudo npm install -g pm2`\n\n### 使用 pm2 执行 node 脚本\n\n使用 PM2 运行脚本，首先进入脚本所在文件夹\n`cd Public/PipeRobot`\n\n调用 pm2 开启脚本\n`pm2 start server.js`\n\n然后就可以看到\n```bash\n[PM2] Starting /home/pi/app.js in fork_mode (1 instance)\n[PM2] Done.\n┌──────────┬────┬─────────┬──────┬─────┬────────┬─────────┬────────┬─────┬───────────┬──────┬──────────┐\n│ App name │ id │ version │ mode │ pid │ status │ restart │ uptime │ cpu │ mem       │ user │ watching │\n├──────────┼────┼─────────┼──────┼─────┼────────┼─────────┼────────┼─────┼───────────┼──────┼──────────┤\n│ app      │ 0  │ N/A     │ fork │ 738 │ online │ 0       │ 0s     │ 0%  │ 21.8 MB   │ pi   │ disabled │\n└──────────┴────┴─────────┴──────┴─────┴────────┴─────────┴────────┴─────┴───────────┴──────┴──────────┘\n```\n\n这时，服务器已经运行起来了，如果想要查看某个脚本的运行状态，可以使用`pm2 show id`查看。\n\n### 开机启动\n`pm2 startup`指令会生成一个开机启动的脚本\n\n```\npm2 startup systemd\n```\n\n可以看到输入如下\n\n```\n[PM2] Init System found: systemd\n[PM2] To setup the Startup Script, copy/paste the following command:\nsudo env PATH=$PATH:/usr/bin /usr/lib/node_modules/pm2/bin/pm2 startup systemd -u pi --hp /home/pi\n```\n\n复制生成的脚本，并执行\n\n```\nsudo env PATH=$PATH:/usr/bin /usr/lib/node_modules/pm2/bin/pm2 startup systemd -u pi --hp /home/p\n```\n\n这条指令创建的系统单元会在系统启动的时候开始执行，当系统启动的时候，PM2 就会从这个转储系统的恢复过来，为了创建这个转储空间，运行以下命令：\n```\npm2 save\n```\n\n这条指令会存储 pm2 当前的状态（当前还在运行我们的服务器`server.js`）在转储系统中，当开机时，就会从系统中恢复。\n\n这样就实现了 Node 脚本的开机启动\n\n## 参考资料\n1. [Run your Node.js application on a headless Raspberry Pi](https://dev.to/bogdaaamn/run-your-nodejs-application-on-a-headless-raspberry-pi-4jnn)\n2. [create_ap](https://github.com/oblique/create_ap)","slug":"树莓派创建热点与node脚本自动启动","published":1,"updated":"2022-08-17T07:53:21.232Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6xbhzke0018zk08y2tljxsl","content":"<h2 id=\"功能实现\"><a href=\"#功能实现\" class=\"headerlink\" title=\"功能实现\"></a>功能实现</h2><blockquote>\n<p>文中所有说到的功能，均已配置好，无需再进行操作，本文只做记录以供之后的调试。<br>使用时：</p>\n<ol>\n<li>开机，系统会自动创建热点：<code>PipeRobot</code></li>\n<li>PC 或手机等终端连接热点（密码：SJTUROBOT）</li>\n<li>打开浏览器，输入地址：<code>192.168.123.251:8081</code></li>\n</ol>\n</blockquote>\n<p>树莓派在 PipeRobot 中作为服务器，需要具有创建 AP 热点的能力，供下位机建立连接和控制。</p>\n<p>为此，查阅了相关资料，项目使用 create_ap 插件实现快速创建热点。</p>\n<p>除此外，Node 脚本搭建的服务器需要能够实现开机启动，项目使用了 PM2 实现。</p>\n<hr>\n<h2 id=\"热点\"><a href=\"#热点\" class=\"headerlink\" title=\"热点\"></a>热点</h2><h3 id=\"create-ap-创建热点\"><a href=\"#create-ap-创建热点\" class=\"headerlink\" title=\"create_ap 创建热点\"></a>create_ap 创建热点</h3><ol>\n<li>git clone 该项目 <code>git clonehttps://github.com/oblique/create_ap.git</code></li>\n<li>进入文件夹<code>cd create_ap</code></li>\n<li>编译 <code>sudo make install 就这样安装好了</code></li>\n<li>安装依赖 <code>sudo apt-get install util-linux procps hostapd iproute2 iw haveged dnsmasq</code></li>\n<li>此时就可以创建热点了，这里用的指令如下：</li>\n</ol>\n<p><code>sudo create_ap wlan0 eth0 SSID PASSWRD</code><br>其中，SSID 是 WIFI 的名称，PASSWRD 是要设置的密码。</p>\n<h3 id=\"开机时自动开启热点\"><a href=\"#开机时自动开启热点\" class=\"headerlink\" title=\"开机时自动开启热点\"></a>开机时自动开启热点</h3><p>作为机器人控制系统一部分，需要在开机时自动创建热点。<code>create_ap</code>同样提供了这样的功能。</p>\n<p>可以使用<code>Systemd service</code>实现后台开启热点，比如</p>\n<p><code>systemctl start create_ap</code> 就是开启热点，当然，我们需要对其配置文件进行编辑，开启我们需要的热点</p>\n<p>修改/etc/create_ap.conf<br><code>vim /etc/create_ap.conf</code><br>把其中的两句 SSID 和 PASSHRASE 修改为自己希望的用户名和密码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SSID=PipeRobot</span><br><span class=\"line\">PASSPHRASE=SJTUROBOT</span><br></pre></td></tr></table></figure></p>\n<p><strong>设置开机启动</strong><br><code>systemctl enable create_ap</code></p>\n<p>至此，每次重启系统，就可以实现自动创建热点了。</p>\n<h2 id=\"Node-脚本开机启动\"><a href=\"#Node-脚本开机启动\" class=\"headerlink\" title=\"Node 脚本开机启动\"></a>Node 脚本开机启动</h2><p>因为对 Linux 脚本不是非常熟悉，Node 脚本的自动执行使用了 PM2 模块进行辅助。</p>\n<p>首先全局安装 PM2<br><code>sudo npm install -g pm2</code></p>\n<h3 id=\"使用-pm2-执行-node-脚本\"><a href=\"#使用-pm2-执行-node-脚本\" class=\"headerlink\" title=\"使用 pm2 执行 node 脚本\"></a>使用 pm2 执行 node 脚本</h3><p>使用 PM2 运行脚本，首先进入脚本所在文件夹<br><code>cd Public/PipeRobot</code></p>\n<p>调用 pm2 开启脚本<br><code>pm2 start server.js</code></p>\n<p>然后就可以看到<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[PM2] Starting /home/pi/app.js <span class=\"keyword\">in</span> fork_mode (1 instance)</span><br><span class=\"line\">[PM2] Done.</span><br><span class=\"line\">┌──────────┬────┬─────────┬──────┬─────┬────────┬─────────┬────────┬─────┬───────────┬──────┬──────────┐</span><br><span class=\"line\">│ App name │ id │ version │ mode │ pid │ status │ restart │ uptime │ cpu │ mem       │ user │ watching │</span><br><span class=\"line\">├──────────┼────┼─────────┼──────┼─────┼────────┼─────────┼────────┼─────┼───────────┼──────┼──────────┤</span><br><span class=\"line\">│ app      │ 0  │ N/A     │ fork │ 738 │ online │ 0       │ 0s     │ 0%  │ 21.8 MB   │ pi   │ disabled │</span><br><span class=\"line\">└──────────┴────┴─────────┴──────┴─────┴────────┴─────────┴────────┴─────┴───────────┴──────┴──────────┘</span><br></pre></td></tr></table></figure></p>\n<p>这时，服务器已经运行起来了，如果想要查看某个脚本的运行状态，可以使用<code>pm2 show id</code>查看。</p>\n<h3 id=\"开机启动\"><a href=\"#开机启动\" class=\"headerlink\" title=\"开机启动\"></a>开机启动</h3><p><code>pm2 startup</code>指令会生成一个开机启动的脚本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm2 startup systemd</span><br></pre></td></tr></table></figure>\n<p>可以看到输入如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[PM2] Init System found: systemd</span><br><span class=\"line\">[PM2] To setup the Startup Script, copy/paste the following command:</span><br><span class=\"line\">sudo env PATH=$PATH:/usr/bin /usr/lib/node_modules/pm2/bin/pm2 startup systemd -u pi --hp /home/pi</span><br></pre></td></tr></table></figure>\n<p>复制生成的脚本，并执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo env PATH=$PATH:/usr/bin /usr/lib/node_modules/pm2/bin/pm2 startup systemd -u pi --hp /home/p</span><br></pre></td></tr></table></figure>\n<p>这条指令创建的系统单元会在系统启动的时候开始执行，当系统启动的时候，PM2 就会从这个转储系统的恢复过来，为了创建这个转储空间，运行以下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm2 save</span><br></pre></td></tr></table></figure></p>\n<p>这条指令会存储 pm2 当前的状态（当前还在运行我们的服务器<code>server.js</code>）在转储系统中，当开机时，就会从系统中恢复。</p>\n<p>这样就实现了 Node 脚本的开机启动</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ol>\n<li><a href=\"https://dev.to/bogdaaamn/run-your-nodejs-application-on-a-headless-raspberry-pi-4jnn\" target=\"_blank\" rel=\"noopener\">Run your Node.js application on a headless Raspberry Pi</a></li>\n<li><a href=\"https://github.com/oblique/create_ap\" target=\"_blank\" rel=\"noopener\">create_ap</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"功能实现\"><a href=\"#功能实现\" class=\"headerlink\" title=\"功能实现\"></a>功能实现</h2><blockquote>\n<p>文中所有说到的功能，均已配置好，无需再进行操作，本文只做记录以供之后的调试。<br>使用时：</p>\n<ol>\n<li>开机，系统会自动创建热点：<code>PipeRobot</code></li>\n<li>PC 或手机等终端连接热点（密码：SJTUROBOT）</li>\n<li>打开浏览器，输入地址：<code>192.168.123.251:8081</code></li>\n</ol>\n</blockquote>\n<p>树莓派在 PipeRobot 中作为服务器，需要具有创建 AP 热点的能力，供下位机建立连接和控制。</p>\n<p>为此，查阅了相关资料，项目使用 create_ap 插件实现快速创建热点。</p>\n<p>除此外，Node 脚本搭建的服务器需要能够实现开机启动，项目使用了 PM2 实现。</p>\n<hr>\n<h2 id=\"热点\"><a href=\"#热点\" class=\"headerlink\" title=\"热点\"></a>热点</h2><h3 id=\"create-ap-创建热点\"><a href=\"#create-ap-创建热点\" class=\"headerlink\" title=\"create_ap 创建热点\"></a>create_ap 创建热点</h3><ol>\n<li>git clone 该项目 <code>git clonehttps://github.com/oblique/create_ap.git</code></li>\n<li>进入文件夹<code>cd create_ap</code></li>\n<li>编译 <code>sudo make install 就这样安装好了</code></li>\n<li>安装依赖 <code>sudo apt-get install util-linux procps hostapd iproute2 iw haveged dnsmasq</code></li>\n<li>此时就可以创建热点了，这里用的指令如下：</li>\n</ol>\n<p><code>sudo create_ap wlan0 eth0 SSID PASSWRD</code><br>其中，SSID 是 WIFI 的名称，PASSWRD 是要设置的密码。</p>\n<h3 id=\"开机时自动开启热点\"><a href=\"#开机时自动开启热点\" class=\"headerlink\" title=\"开机时自动开启热点\"></a>开机时自动开启热点</h3><p>作为机器人控制系统一部分，需要在开机时自动创建热点。<code>create_ap</code>同样提供了这样的功能。</p>\n<p>可以使用<code>Systemd service</code>实现后台开启热点，比如</p>\n<p><code>systemctl start create_ap</code> 就是开启热点，当然，我们需要对其配置文件进行编辑，开启我们需要的热点</p>\n<p>修改/etc/create_ap.conf<br><code>vim /etc/create_ap.conf</code><br>把其中的两句 SSID 和 PASSHRASE 修改为自己希望的用户名和密码。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SSID=PipeRobot</span><br><span class=\"line\">PASSPHRASE=SJTUROBOT</span><br></pre></td></tr></table></figure></p>\n<p><strong>设置开机启动</strong><br><code>systemctl enable create_ap</code></p>\n<p>至此，每次重启系统，就可以实现自动创建热点了。</p>\n<h2 id=\"Node-脚本开机启动\"><a href=\"#Node-脚本开机启动\" class=\"headerlink\" title=\"Node 脚本开机启动\"></a>Node 脚本开机启动</h2><p>因为对 Linux 脚本不是非常熟悉，Node 脚本的自动执行使用了 PM2 模块进行辅助。</p>\n<p>首先全局安装 PM2<br><code>sudo npm install -g pm2</code></p>\n<h3 id=\"使用-pm2-执行-node-脚本\"><a href=\"#使用-pm2-执行-node-脚本\" class=\"headerlink\" title=\"使用 pm2 执行 node 脚本\"></a>使用 pm2 执行 node 脚本</h3><p>使用 PM2 运行脚本，首先进入脚本所在文件夹<br><code>cd Public/PipeRobot</code></p>\n<p>调用 pm2 开启脚本<br><code>pm2 start server.js</code></p>\n<p>然后就可以看到<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[PM2] Starting /home/pi/app.js <span class=\"keyword\">in</span> fork_mode (1 instance)</span><br><span class=\"line\">[PM2] Done.</span><br><span class=\"line\">┌──────────┬────┬─────────┬──────┬─────┬────────┬─────────┬────────┬─────┬───────────┬──────┬──────────┐</span><br><span class=\"line\">│ App name │ id │ version │ mode │ pid │ status │ restart │ uptime │ cpu │ mem       │ user │ watching │</span><br><span class=\"line\">├──────────┼────┼─────────┼──────┼─────┼────────┼─────────┼────────┼─────┼───────────┼──────┼──────────┤</span><br><span class=\"line\">│ app      │ 0  │ N/A     │ fork │ 738 │ online │ 0       │ 0s     │ 0%  │ 21.8 MB   │ pi   │ disabled │</span><br><span class=\"line\">└──────────┴────┴─────────┴──────┴─────┴────────┴─────────┴────────┴─────┴───────────┴──────┴──────────┘</span><br></pre></td></tr></table></figure></p>\n<p>这时，服务器已经运行起来了，如果想要查看某个脚本的运行状态，可以使用<code>pm2 show id</code>查看。</p>\n<h3 id=\"开机启动\"><a href=\"#开机启动\" class=\"headerlink\" title=\"开机启动\"></a>开机启动</h3><p><code>pm2 startup</code>指令会生成一个开机启动的脚本</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm2 startup systemd</span><br></pre></td></tr></table></figure>\n<p>可以看到输入如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[PM2] Init System found: systemd</span><br><span class=\"line\">[PM2] To setup the Startup Script, copy/paste the following command:</span><br><span class=\"line\">sudo env PATH=$PATH:/usr/bin /usr/lib/node_modules/pm2/bin/pm2 startup systemd -u pi --hp /home/pi</span><br></pre></td></tr></table></figure>\n<p>复制生成的脚本，并执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo env PATH=$PATH:/usr/bin /usr/lib/node_modules/pm2/bin/pm2 startup systemd -u pi --hp /home/p</span><br></pre></td></tr></table></figure>\n<p>这条指令创建的系统单元会在系统启动的时候开始执行，当系统启动的时候，PM2 就会从这个转储系统的恢复过来，为了创建这个转储空间，运行以下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm2 save</span><br></pre></td></tr></table></figure></p>\n<p>这条指令会存储 pm2 当前的状态（当前还在运行我们的服务器<code>server.js</code>）在转储系统中，当开机时，就会从系统中恢复。</p>\n<p>这样就实现了 Node 脚本的开机启动</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ol>\n<li><a href=\"https://dev.to/bogdaaamn/run-your-nodejs-application-on-a-headless-raspberry-pi-4jnn\" target=\"_blank\" rel=\"noopener\">Run your Node.js application on a headless Raspberry Pi</a></li>\n<li><a href=\"https://github.com/oblique/create_ap\" target=\"_blank\" rel=\"noopener\">create_ap</a></li>\n</ol>\n"},{"title":"D3可视化：（2）Bar Chart with D3js","date":"2019-03-20T08:17:29.000Z","_content":"\n**最终效果图**\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1g19c657jnqj20pw0djjrn.jpg)\n\n知识点：\n* d3数据绑定\n* 柱状图画法\n* 坐标轴\n* 比例尺\n\n---\n## 数据读入\n\n数据可视化的第一步还是数据读取，在d3中可以使用`d3.csv`非常方便的读取数据，它会返回一个`Promise`对象。\n\ncsv文件是以逗号`,`分隔的数据内容，本地使用的csv数据如下,文件名为`data.csv`：\n```csv\ncountry,population\nChina,1415046\nIndia,1354052\nUnited States,326767\nIndonesia,266795\nBrazil,210868\nPakistan,200814\nNigeria,195875\nBangladesh,166368\nRussia,143965\nMexico,130759\n```\n首先将数据读入，代码如下：\n```JavaScript\nconst data = d3.csv('data.csv').then(data => {\n    console.log(data))\n})\n```\n可以看到，控制台输出了一个数组，数组中的每条数据均是一个对象，类型为`{country:xx, population:xx}`\n\n当然，人数自然应该是`Number`类型的，同时，为了将人数转换为单位`个`，将所有数据都扩大一千倍，即：\n```JavaScript\nconst data = d3.csv('data.csv').then(data => {\n    data.forEach(element => {\n        element.population = +element.population * 1000\n    });  //处理完数据，就可以开始画图了\n    render(data)\n})\n```\n\n## 画柱状图\n\nHTML文件与上一节相同，都是仅包含了一个`<svg></svg>`标签，首先选择svg:\n```JavaScript\nconst svg = d3.select('svg');\nconst height = +svg.attr('height');\nconst width = +svg.attr('width');\n\nconst render = data => {\n\n} //根据已有数据，画图渲染的函数\n```\n### 数据绑定\n\n将数据绑定到DOM上，是D3最大的特色。`d3.select`与`d3.selectAll`返回选择集，但其本身是没有数据的，通过data()函数，可以将数据与之绑定。相关函数有两个：\n* `selection.datum([value])`\n  选择集上的每个元素都绑定相同的元素value\n* `selection.data(values[,key])`\n  选择集上每一个元素分别绑定数组values的每一项，key是一个键函数，用于指定绑定数组时的规则。\n\n`datum`用比较少，这里主要用到的是`data()`，将已处理好的数据绑定在dom上。\n\n### update、enter和exit\n\n在进行数据绑定的时候，不一定数据和元素个数就是相同的，这个时候就需要一个动态的处理，这就需要用到`updata`、`enter`、和`exit`了。\n* **update()    当对应的元素正好满足时 （ 绑定数据数量 = 对应元素 ）**\n 实际上并不存在这样一个函数，只是为了要与之后的 enter 和 exit 一起说明才想象有这样一个函数。但对应元素正好满足时，直接操作即可，后面直接跟 text ，style 等操作即可。\n* **enter()    当对应的元素不足时 （ 绑定数据数量 > 对应元素 ）**\n  当对应的元素不足时，通常要添加元素，使之与绑定数据的数量相等。后面通常先跟 append 操作。\n* **exit()     当对应的元素过多时 （ 绑定数据数量 < 对应元素 ）**\n  当对应的元素过多时，通常要删除元素，使之与绑定数据的数量相等。后面通常要跟 remove 操作。\n\n本项目主要用到了`enter`，因为页面中只有`svg`标签，我们需要做的是根据数据内容，在`svg`中画`<rect>`来表示柱状图。\n[理解 Update、Enter、Exit](http://wiki.jikexueyuan.com/project/d3wiki/enterexit.html)\n\n### render函数\n\n有了以上的概念，就可以开始画图了\n```JavaScript\nconst render = data => {\n    svg.selectAll('rect').data(data)  //选择`rect`并绑定数据data，但这个时候没有元素，因此使用enter\n        .enter().append('rect')\n        .attr('width',width)\n        .attr('height','30px')\n}\n```\n这样更新视图，就可以看到已经有图像出来了。但是只能看到一个黑色的长方形。因为目前图形并不能反映任何数据，只是单纯的固定'width'的长方形。为此，需要用上数据，但是因为数据可能很大或者很小，为了让其能够正好显示的视图中，需要使用到比例尺。\n\n## 比例尺\nD3中有很多比例尺，本例中主要使用到了线性比例尺(scaleLinear)和序数比例尺(scaleBand)\n\n**线性比例尺**可以将`domain`的内容线性映射到`range`的一个范围内，这样，就可以保证无论初始数值多大或多小，都能够很好的适应画当前视图。\n**映射关系**：\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1g19d8odvbej20by062aah.jpg)\n\n**序数比例尺**不是一个连续的比例尺，`domain()`中使用一个数组，`range()`是一个连续域。\n**映射关系**：\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1g19dbloeylj20rc0dzdio.jpg)\n\n因此，加上两个方向的比例尺，让柱状图的雏形开始慢慢出现吧：\n```JavaScript\nconst render = data => {\n    const xScale = d3.scaleLinear()\n        .domain([0,d3.max(data, d => d.population)])\n        .range([0,width]) //最大值将视图空间充满\n    const yScale = d3.scaleBand()\n        .domain(data.map(d => d.country))\n        .range([0,height])\n\n    svg.selectAll('rect').data(data)  //选择`rect`并绑定数据data，但这个时候没有元素，因此使用enter\n        .enter().append('rect')\n        .attr('y',d => yScale(d.country))\n        .attr('width',d => xScale(d.population)) //宽度根据数据\n        .attr('height',yScale.bandwidth()) //高度由比例尺自动生成\n}\n```\n这样子，就有一个雏形了，效果如下：\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1g1aafvtuhjj20k10anaa4.jpg)\n\n### 代码优化\n\n首先，重新审视下代码，发现其中`d => d.population`以及`d => d.country`在比例尺设置以及使用时出现了多次，如果需要修改，又是代码中多处的重复修改。为此，对其进行一个处理，如下：\n```JavaScript\nconst render = data => {\n    const xValue = d => d.population; //优化\n    const yValue = d => d.country;  //优化\n\n    const xScale = d3.scaleLinear()\n        .domain([0,d3.max(data,xValue)]) //优化\n        .range([0,width]) \n    const yScale = d3.scaleBand()\n        .domain(data.map(yValue))  //优化\n        .range([0,height])\n\n    svg.selectAll('rect').data(data) \n        .enter().append('rect')\n        .attr('y',d => yScale(yValue(d)))   //优化\n        .attr('width',d => xScale(xValue(d))) //优化\n        .attr('height',yScale.bandwidth()) \n```\n\n##  坐标轴\n### 使用margin来优化布局\n\n下图所示是`margin`的布局示意图，因为直接按照`svg`的`height`和`width`撑满画布将导致没有多余的位置放置坐标轴等，所以这里使用一个`margin`来对布局重新规划。\n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1g1aaroylbuj20oi0e40ub.jpg)\n\n代码如下：\n```JavaScript\nconst margin = {left:50,top:10,right:20,bottom:30};\nconst innerHeight = height - margin.top - margin.bottom;\nconst innerWidth = width - margin.left - margin.right;\n```\n其中innerHeight和innerWidth是柱状图的实际占有高度，因此，柱状图的代码可以修改为：\n```JavaScript\n    const xScale = d3.scaleLinear()\n        .domain([0, d3.max(data,xValue)])\n        .range([0, innerWidth]) //将 width 改为 innerWidth\n    const yScale = d3.scaleBand()\n        .domain(data.map(yValue))\n        .range([0, innerHeight]) //将height 改为 innerHeight\n    const g = svg.append('g')\n        .attr('transform', `translate(${margin.left},${margin.top})`) //加入新元素g,整体移动maring.left和margin.top\n    g.selectAll('rect').data(data)  \n        .enter().append('rect')\n        .attr('y',d => yScale(yValue(d)))\n        .attr('width', d => xScale(xValue(d)))\n        .attr('height',yScale.bandwidth())\n```\n\n### 增加坐标轴\n\n坐标轴的绘制，是d3通过`<svg>`中的`<path>` `<text>` `<line>`实现的，用到的函数如`axisLeft` `axisBottom`等，绘制一般分为一下几个步骤：\n* 创建坐标轴\n  `var axisX = d3.axisLeft(xScale) `根据比例尺创建坐标轴\n* 创建新的`<g>`组\n  `var gAxis = svg.append('g')`\n* 插入坐标轴\n  `axisX(gAxis)` 或者 在上一步直接`svg.append('g').call(axisX)`\n\n因此，本例中坐标轴添加可以这样：\n```JavaScript\n    g.append('g').call(d3.axisLeft(yScale)); //左边显示country\n    g.append('g').call(d3.axisBottom(xScale))\n        .attr('transform',`translate(0,${innerHeight})`) //虽然是bottom，但是默认位置并不在下，需要移动至下方\n```\n\n### 增加间隙\n\n现在柱状图还是很丑的状态，应该增加一点间隙，让它看起来更加美观，这就非常简单了，在`yScale`上使用`padding`属性。\n```JavaScript\n    const yScale = d3.scaleBand()\n        .domain(data.map(yValue))\n        .range([0, innerHeight])\n        .padding(0.15)   //增加了这个属性\n```\n\n### 修改样式\n\n为了让柱状图看起来更美观，增加一些css样式，样式如下：\n```css\nbody html{\n            margin:0;\n            overflow: hidden;\n        }\n        rect {\n            fill:steelblue;\n        }\n        text {\n            font-size: 1.1em;\n        }\n```\n\n\n\n### 注意\n\n由于chrome的安全原因限制，在本地使用`d3.csv`读取本地文件时是会遇到问题的，并不支持`file//:` 读取内容。 因此，代码在github中是可以正常运转，但是本地可能无法正常运作， 可以开一个本地服务器，将代码放置上。\n\n### 完整代码\n\n完整代码详见：[d3系列教程源码](https://github.com/forrany/Web-Project/tree/master/D3js%E5%8F%AF%E8%A7%86%E5%8C%96/2.Making%20a%20Bar%20Chat)","source":"_posts/year-03-20-D3数据可视化柱状图.md","raw":"---\ntitle: D3可视化：（2）Bar Chart with D3js\ndate: 2019-03-20 16:17:29\ntags:\n    - d3.js\n    - 可视化\n    - 柱状图\n---\n\n**最终效果图**\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1g19c657jnqj20pw0djjrn.jpg)\n\n知识点：\n* d3数据绑定\n* 柱状图画法\n* 坐标轴\n* 比例尺\n\n---\n## 数据读入\n\n数据可视化的第一步还是数据读取，在d3中可以使用`d3.csv`非常方便的读取数据，它会返回一个`Promise`对象。\n\ncsv文件是以逗号`,`分隔的数据内容，本地使用的csv数据如下,文件名为`data.csv`：\n```csv\ncountry,population\nChina,1415046\nIndia,1354052\nUnited States,326767\nIndonesia,266795\nBrazil,210868\nPakistan,200814\nNigeria,195875\nBangladesh,166368\nRussia,143965\nMexico,130759\n```\n首先将数据读入，代码如下：\n```JavaScript\nconst data = d3.csv('data.csv').then(data => {\n    console.log(data))\n})\n```\n可以看到，控制台输出了一个数组，数组中的每条数据均是一个对象，类型为`{country:xx, population:xx}`\n\n当然，人数自然应该是`Number`类型的，同时，为了将人数转换为单位`个`，将所有数据都扩大一千倍，即：\n```JavaScript\nconst data = d3.csv('data.csv').then(data => {\n    data.forEach(element => {\n        element.population = +element.population * 1000\n    });  //处理完数据，就可以开始画图了\n    render(data)\n})\n```\n\n## 画柱状图\n\nHTML文件与上一节相同，都是仅包含了一个`<svg></svg>`标签，首先选择svg:\n```JavaScript\nconst svg = d3.select('svg');\nconst height = +svg.attr('height');\nconst width = +svg.attr('width');\n\nconst render = data => {\n\n} //根据已有数据，画图渲染的函数\n```\n### 数据绑定\n\n将数据绑定到DOM上，是D3最大的特色。`d3.select`与`d3.selectAll`返回选择集，但其本身是没有数据的，通过data()函数，可以将数据与之绑定。相关函数有两个：\n* `selection.datum([value])`\n  选择集上的每个元素都绑定相同的元素value\n* `selection.data(values[,key])`\n  选择集上每一个元素分别绑定数组values的每一项，key是一个键函数，用于指定绑定数组时的规则。\n\n`datum`用比较少，这里主要用到的是`data()`，将已处理好的数据绑定在dom上。\n\n### update、enter和exit\n\n在进行数据绑定的时候，不一定数据和元素个数就是相同的，这个时候就需要一个动态的处理，这就需要用到`updata`、`enter`、和`exit`了。\n* **update()    当对应的元素正好满足时 （ 绑定数据数量 = 对应元素 ）**\n 实际上并不存在这样一个函数，只是为了要与之后的 enter 和 exit 一起说明才想象有这样一个函数。但对应元素正好满足时，直接操作即可，后面直接跟 text ，style 等操作即可。\n* **enter()    当对应的元素不足时 （ 绑定数据数量 > 对应元素 ）**\n  当对应的元素不足时，通常要添加元素，使之与绑定数据的数量相等。后面通常先跟 append 操作。\n* **exit()     当对应的元素过多时 （ 绑定数据数量 < 对应元素 ）**\n  当对应的元素过多时，通常要删除元素，使之与绑定数据的数量相等。后面通常要跟 remove 操作。\n\n本项目主要用到了`enter`，因为页面中只有`svg`标签，我们需要做的是根据数据内容，在`svg`中画`<rect>`来表示柱状图。\n[理解 Update、Enter、Exit](http://wiki.jikexueyuan.com/project/d3wiki/enterexit.html)\n\n### render函数\n\n有了以上的概念，就可以开始画图了\n```JavaScript\nconst render = data => {\n    svg.selectAll('rect').data(data)  //选择`rect`并绑定数据data，但这个时候没有元素，因此使用enter\n        .enter().append('rect')\n        .attr('width',width)\n        .attr('height','30px')\n}\n```\n这样更新视图，就可以看到已经有图像出来了。但是只能看到一个黑色的长方形。因为目前图形并不能反映任何数据，只是单纯的固定'width'的长方形。为此，需要用上数据，但是因为数据可能很大或者很小，为了让其能够正好显示的视图中，需要使用到比例尺。\n\n## 比例尺\nD3中有很多比例尺，本例中主要使用到了线性比例尺(scaleLinear)和序数比例尺(scaleBand)\n\n**线性比例尺**可以将`domain`的内容线性映射到`range`的一个范围内，这样，就可以保证无论初始数值多大或多小，都能够很好的适应画当前视图。\n**映射关系**：\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1g19d8odvbej20by062aah.jpg)\n\n**序数比例尺**不是一个连续的比例尺，`domain()`中使用一个数组，`range()`是一个连续域。\n**映射关系**：\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1g19dbloeylj20rc0dzdio.jpg)\n\n因此，加上两个方向的比例尺，让柱状图的雏形开始慢慢出现吧：\n```JavaScript\nconst render = data => {\n    const xScale = d3.scaleLinear()\n        .domain([0,d3.max(data, d => d.population)])\n        .range([0,width]) //最大值将视图空间充满\n    const yScale = d3.scaleBand()\n        .domain(data.map(d => d.country))\n        .range([0,height])\n\n    svg.selectAll('rect').data(data)  //选择`rect`并绑定数据data，但这个时候没有元素，因此使用enter\n        .enter().append('rect')\n        .attr('y',d => yScale(d.country))\n        .attr('width',d => xScale(d.population)) //宽度根据数据\n        .attr('height',yScale.bandwidth()) //高度由比例尺自动生成\n}\n```\n这样子，就有一个雏形了，效果如下：\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1g1aafvtuhjj20k10anaa4.jpg)\n\n### 代码优化\n\n首先，重新审视下代码，发现其中`d => d.population`以及`d => d.country`在比例尺设置以及使用时出现了多次，如果需要修改，又是代码中多处的重复修改。为此，对其进行一个处理，如下：\n```JavaScript\nconst render = data => {\n    const xValue = d => d.population; //优化\n    const yValue = d => d.country;  //优化\n\n    const xScale = d3.scaleLinear()\n        .domain([0,d3.max(data,xValue)]) //优化\n        .range([0,width]) \n    const yScale = d3.scaleBand()\n        .domain(data.map(yValue))  //优化\n        .range([0,height])\n\n    svg.selectAll('rect').data(data) \n        .enter().append('rect')\n        .attr('y',d => yScale(yValue(d)))   //优化\n        .attr('width',d => xScale(xValue(d))) //优化\n        .attr('height',yScale.bandwidth()) \n```\n\n##  坐标轴\n### 使用margin来优化布局\n\n下图所示是`margin`的布局示意图，因为直接按照`svg`的`height`和`width`撑满画布将导致没有多余的位置放置坐标轴等，所以这里使用一个`margin`来对布局重新规划。\n\n![](http://ww1.sinaimg.cn/large/6f9f3683ly1g1aaroylbuj20oi0e40ub.jpg)\n\n代码如下：\n```JavaScript\nconst margin = {left:50,top:10,right:20,bottom:30};\nconst innerHeight = height - margin.top - margin.bottom;\nconst innerWidth = width - margin.left - margin.right;\n```\n其中innerHeight和innerWidth是柱状图的实际占有高度，因此，柱状图的代码可以修改为：\n```JavaScript\n    const xScale = d3.scaleLinear()\n        .domain([0, d3.max(data,xValue)])\n        .range([0, innerWidth]) //将 width 改为 innerWidth\n    const yScale = d3.scaleBand()\n        .domain(data.map(yValue))\n        .range([0, innerHeight]) //将height 改为 innerHeight\n    const g = svg.append('g')\n        .attr('transform', `translate(${margin.left},${margin.top})`) //加入新元素g,整体移动maring.left和margin.top\n    g.selectAll('rect').data(data)  \n        .enter().append('rect')\n        .attr('y',d => yScale(yValue(d)))\n        .attr('width', d => xScale(xValue(d)))\n        .attr('height',yScale.bandwidth())\n```\n\n### 增加坐标轴\n\n坐标轴的绘制，是d3通过`<svg>`中的`<path>` `<text>` `<line>`实现的，用到的函数如`axisLeft` `axisBottom`等，绘制一般分为一下几个步骤：\n* 创建坐标轴\n  `var axisX = d3.axisLeft(xScale) `根据比例尺创建坐标轴\n* 创建新的`<g>`组\n  `var gAxis = svg.append('g')`\n* 插入坐标轴\n  `axisX(gAxis)` 或者 在上一步直接`svg.append('g').call(axisX)`\n\n因此，本例中坐标轴添加可以这样：\n```JavaScript\n    g.append('g').call(d3.axisLeft(yScale)); //左边显示country\n    g.append('g').call(d3.axisBottom(xScale))\n        .attr('transform',`translate(0,${innerHeight})`) //虽然是bottom，但是默认位置并不在下，需要移动至下方\n```\n\n### 增加间隙\n\n现在柱状图还是很丑的状态，应该增加一点间隙，让它看起来更加美观，这就非常简单了，在`yScale`上使用`padding`属性。\n```JavaScript\n    const yScale = d3.scaleBand()\n        .domain(data.map(yValue))\n        .range([0, innerHeight])\n        .padding(0.15)   //增加了这个属性\n```\n\n### 修改样式\n\n为了让柱状图看起来更美观，增加一些css样式，样式如下：\n```css\nbody html{\n            margin:0;\n            overflow: hidden;\n        }\n        rect {\n            fill:steelblue;\n        }\n        text {\n            font-size: 1.1em;\n        }\n```\n\n\n\n### 注意\n\n由于chrome的安全原因限制，在本地使用`d3.csv`读取本地文件时是会遇到问题的，并不支持`file//:` 读取内容。 因此，代码在github中是可以正常运转，但是本地可能无法正常运作， 可以开一个本地服务器，将代码放置上。\n\n### 完整代码\n\n完整代码详见：[d3系列教程源码](https://github.com/forrany/Web-Project/tree/master/D3js%E5%8F%AF%E8%A7%86%E5%8C%96/2.Making%20a%20Bar%20Chat)","slug":"D3数据可视化柱状图","published":1,"updated":"2022-08-17T07:53:21.232Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl6xbhzkf001azk08e4tsver7","content":"<p><strong>最终效果图</strong><br><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1g19c657jnqj20pw0djjrn.jpg\" alt=\"\"></p>\n<p>知识点：</p>\n<ul>\n<li>d3数据绑定</li>\n<li>柱状图画法</li>\n<li>坐标轴</li>\n<li>比例尺</li>\n</ul>\n<hr>\n<h2 id=\"数据读入\"><a href=\"#数据读入\" class=\"headerlink\" title=\"数据读入\"></a>数据读入</h2><p>数据可视化的第一步还是数据读取，在d3中可以使用<code>d3.csv</code>非常方便的读取数据，它会返回一个<code>Promise</code>对象。</p>\n<p>csv文件是以逗号<code>,</code>分隔的数据内容，本地使用的csv数据如下,文件名为<code>data.csv</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">country,population</span><br><span class=\"line\">China,1415046</span><br><span class=\"line\">India,1354052</span><br><span class=\"line\">United States,326767</span><br><span class=\"line\">Indonesia,266795</span><br><span class=\"line\">Brazil,210868</span><br><span class=\"line\">Pakistan,200814</span><br><span class=\"line\">Nigeria,195875</span><br><span class=\"line\">Bangladesh,166368</span><br><span class=\"line\">Russia,143965</span><br><span class=\"line\">Mexico,130759</span><br></pre></td></tr></table></figure></p>\n<p>首先将数据读入，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> data = d3.csv(<span class=\"string\">'data.csv'</span>).then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data))</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，控制台输出了一个数组，数组中的每条数据均是一个对象，类型为<code>{country:xx, population:xx}</code></p>\n<p>当然，人数自然应该是<code>Number</code>类型的，同时，为了将人数转换为单位<code>个</code>，将所有数据都扩大一千倍，即：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> data = d3.csv(<span class=\"string\">'data.csv'</span>).then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">    data.forEach(<span class=\"function\"><span class=\"params\">element</span> =&gt;</span> &#123;</span><br><span class=\"line\">        element.population = +element.population * <span class=\"number\">1000</span></span><br><span class=\"line\">    &#125;);  <span class=\"comment\">//处理完数据，就可以开始画图了</span></span><br><span class=\"line\">    render(data)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"画柱状图\"><a href=\"#画柱状图\" class=\"headerlink\" title=\"画柱状图\"></a>画柱状图</h2><p>HTML文件与上一节相同，都是仅包含了一个<code>&lt;svg&gt;&lt;/svg&gt;</code>标签，首先选择svg:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> svg = d3.select(<span class=\"string\">'svg'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> height = +svg.attr(<span class=\"string\">'height'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> width = +svg.attr(<span class=\"string\">'width'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> render = <span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"comment\">//根据已有数据，画图渲染的函数</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"数据绑定\"><a href=\"#数据绑定\" class=\"headerlink\" title=\"数据绑定\"></a>数据绑定</h3><p>将数据绑定到DOM上，是D3最大的特色。<code>d3.select</code>与<code>d3.selectAll</code>返回选择集，但其本身是没有数据的，通过data()函数，可以将数据与之绑定。相关函数有两个：</p>\n<ul>\n<li><code>selection.datum([value])</code><br>选择集上的每个元素都绑定相同的元素value</li>\n<li><code>selection.data(values[,key])</code><br>选择集上每一个元素分别绑定数组values的每一项，key是一个键函数，用于指定绑定数组时的规则。</li>\n</ul>\n<p><code>datum</code>用比较少，这里主要用到的是<code>data()</code>，将已处理好的数据绑定在dom上。</p>\n<h3 id=\"update、enter和exit\"><a href=\"#update、enter和exit\" class=\"headerlink\" title=\"update、enter和exit\"></a>update、enter和exit</h3><p>在进行数据绑定的时候，不一定数据和元素个数就是相同的，这个时候就需要一个动态的处理，这就需要用到<code>updata</code>、<code>enter</code>、和<code>exit</code>了。</p>\n<ul>\n<li><strong>update()    当对应的元素正好满足时 （ 绑定数据数量 = 对应元素 ）</strong><br>实际上并不存在这样一个函数，只是为了要与之后的 enter 和 exit 一起说明才想象有这样一个函数。但对应元素正好满足时，直接操作即可，后面直接跟 text ，style 等操作即可。</li>\n<li><strong>enter()    当对应的元素不足时 （ 绑定数据数量 &gt; 对应元素 ）</strong><br>当对应的元素不足时，通常要添加元素，使之与绑定数据的数量相等。后面通常先跟 append 操作。</li>\n<li><strong>exit()     当对应的元素过多时 （ 绑定数据数量 &lt; 对应元素 ）</strong><br>当对应的元素过多时，通常要删除元素，使之与绑定数据的数量相等。后面通常要跟 remove 操作。</li>\n</ul>\n<p>本项目主要用到了<code>enter</code>，因为页面中只有<code>svg</code>标签，我们需要做的是根据数据内容，在<code>svg</code>中画<code>&lt;rect&gt;</code>来表示柱状图。<br><a href=\"http://wiki.jikexueyuan.com/project/d3wiki/enterexit.html\" target=\"_blank\" rel=\"noopener\">理解 Update、Enter、Exit</a></p>\n<h3 id=\"render函数\"><a href=\"#render函数\" class=\"headerlink\" title=\"render函数\"></a>render函数</h3><p>有了以上的概念，就可以开始画图了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> render = <span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">    svg.selectAll(<span class=\"string\">'rect'</span>).data(data)  <span class=\"comment\">//选择`rect`并绑定数据data，但这个时候没有元素，因此使用enter</span></span><br><span class=\"line\">        .enter().append(<span class=\"string\">'rect'</span>)</span><br><span class=\"line\">        .attr(<span class=\"string\">'width'</span>,width)</span><br><span class=\"line\">        .attr(<span class=\"string\">'height'</span>,<span class=\"string\">'30px'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样更新视图，就可以看到已经有图像出来了。但是只能看到一个黑色的长方形。因为目前图形并不能反映任何数据，只是单纯的固定’width’的长方形。为此，需要用上数据，但是因为数据可能很大或者很小，为了让其能够正好显示的视图中，需要使用到比例尺。</p>\n<h2 id=\"比例尺\"><a href=\"#比例尺\" class=\"headerlink\" title=\"比例尺\"></a>比例尺</h2><p>D3中有很多比例尺，本例中主要使用到了线性比例尺(scaleLinear)和序数比例尺(scaleBand)</p>\n<p><strong>线性比例尺</strong>可以将<code>domain</code>的内容线性映射到<code>range</code>的一个范围内，这样，就可以保证无论初始数值多大或多小，都能够很好的适应画当前视图。<br><strong>映射关系</strong>：<br><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1g19d8odvbej20by062aah.jpg\" alt=\"\"></p>\n<p><strong>序数比例尺</strong>不是一个连续的比例尺，<code>domain()</code>中使用一个数组，<code>range()</code>是一个连续域。<br><strong>映射关系</strong>：<br><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1g19dbloeylj20rc0dzdio.jpg\" alt=\"\"></p>\n<p>因此，加上两个方向的比例尺，让柱状图的雏形开始慢慢出现吧：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> render = <span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> xScale = d3.scaleLinear()</span><br><span class=\"line\">        .domain([<span class=\"number\">0</span>,d3.max(data, d =&gt; d.population)])</span><br><span class=\"line\">        .range([<span class=\"number\">0</span>,width]) <span class=\"comment\">//最大值将视图空间充满</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> yScale = d3.scaleBand()</span><br><span class=\"line\">        .domain(data.map(<span class=\"function\"><span class=\"params\">d</span> =&gt;</span> d.country))</span><br><span class=\"line\">        .range([<span class=\"number\">0</span>,height])</span><br><span class=\"line\"></span><br><span class=\"line\">    svg.selectAll(<span class=\"string\">'rect'</span>).data(data)  <span class=\"comment\">//选择`rect`并绑定数据data，但这个时候没有元素，因此使用enter</span></span><br><span class=\"line\">        .enter().append(<span class=\"string\">'rect'</span>)</span><br><span class=\"line\">        .attr(<span class=\"string\">'y'</span>,d =&gt; yScale(d.country))</span><br><span class=\"line\">        .attr(<span class=\"string\">'width'</span>,d =&gt; xScale(d.population)) <span class=\"comment\">//宽度根据数据</span></span><br><span class=\"line\">        .attr(<span class=\"string\">'height'</span>,yScale.bandwidth()) <span class=\"comment\">//高度由比例尺自动生成</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样子，就有一个雏形了，效果如下：<br><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1g1aafvtuhjj20k10anaa4.jpg\" alt=\"\"></p>\n<h3 id=\"代码优化\"><a href=\"#代码优化\" class=\"headerlink\" title=\"代码优化\"></a>代码优化</h3><p>首先，重新审视下代码，发现其中<code>d =&gt; d.population</code>以及<code>d =&gt; d.country</code>在比例尺设置以及使用时出现了多次，如果需要修改，又是代码中多处的重复修改。为此，对其进行一个处理，如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> render = <span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> xValue = <span class=\"function\"><span class=\"params\">d</span> =&gt;</span> d.population; <span class=\"comment\">//优化</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> yValue = <span class=\"function\"><span class=\"params\">d</span> =&gt;</span> d.country;  <span class=\"comment\">//优化</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> xScale = d3.scaleLinear()</span><br><span class=\"line\">        .domain([<span class=\"number\">0</span>,d3.max(data,xValue)]) <span class=\"comment\">//优化</span></span><br><span class=\"line\">        .range([<span class=\"number\">0</span>,width]) </span><br><span class=\"line\">    <span class=\"keyword\">const</span> yScale = d3.scaleBand()</span><br><span class=\"line\">        .domain(data.map(yValue))  <span class=\"comment\">//优化</span></span><br><span class=\"line\">        .range([<span class=\"number\">0</span>,height])</span><br><span class=\"line\"></span><br><span class=\"line\">    svg.selectAll(<span class=\"string\">'rect'</span>).data(data) </span><br><span class=\"line\">        .enter().append(<span class=\"string\">'rect'</span>)</span><br><span class=\"line\">        .attr(<span class=\"string\">'y'</span>,d =&gt; yScale(yValue(d)))   <span class=\"comment\">//优化</span></span><br><span class=\"line\">        .attr(<span class=\"string\">'width'</span>,d =&gt; xScale(xValue(d))) <span class=\"comment\">//优化</span></span><br><span class=\"line\">        .attr(<span class=\"string\">'height'</span>,yScale.bandwidth())</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"坐标轴\"><a href=\"#坐标轴\" class=\"headerlink\" title=\"坐标轴\"></a>坐标轴</h2><h3 id=\"使用margin来优化布局\"><a href=\"#使用margin来优化布局\" class=\"headerlink\" title=\"使用margin来优化布局\"></a>使用margin来优化布局</h3><p>下图所示是<code>margin</code>的布局示意图，因为直接按照<code>svg</code>的<code>height</code>和<code>width</code>撑满画布将导致没有多余的位置放置坐标轴等，所以这里使用一个<code>margin</code>来对布局重新规划。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1g1aaroylbuj20oi0e40ub.jpg\" alt=\"\"></p>\n<p>代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> margin = &#123;<span class=\"attr\">left</span>:<span class=\"number\">50</span>,<span class=\"attr\">top</span>:<span class=\"number\">10</span>,<span class=\"attr\">right</span>:<span class=\"number\">20</span>,<span class=\"attr\">bottom</span>:<span class=\"number\">30</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> innerHeight = height - margin.top - margin.bottom;</span><br><span class=\"line\"><span class=\"keyword\">const</span> innerWidth = width - margin.left - margin.right;</span><br></pre></td></tr></table></figure></p>\n<p>其中innerHeight和innerWidth是柱状图的实际占有高度，因此，柱状图的代码可以修改为：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> xScale = d3.scaleLinear()</span><br><span class=\"line\">    .domain([<span class=\"number\">0</span>, d3.max(data,xValue)])</span><br><span class=\"line\">    .range([<span class=\"number\">0</span>, innerWidth]) <span class=\"comment\">//将 width 改为 innerWidth</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> yScale = d3.scaleBand()</span><br><span class=\"line\">    .domain(data.map(yValue))</span><br><span class=\"line\">    .range([<span class=\"number\">0</span>, innerHeight]) <span class=\"comment\">//将height 改为 innerHeight</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> g = svg.append(<span class=\"string\">'g'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'transform'</span>, <span class=\"string\">`translate(<span class=\"subst\">$&#123;margin.left&#125;</span>,<span class=\"subst\">$&#123;margin.top&#125;</span>)`</span>) <span class=\"comment\">//加入新元素g,整体移动maring.left和margin.top</span></span><br><span class=\"line\">g.selectAll(<span class=\"string\">'rect'</span>).data(data)  </span><br><span class=\"line\">    .enter().append(<span class=\"string\">'rect'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'y'</span>,d =&gt; yScale(yValue(d)))</span><br><span class=\"line\">    .attr(<span class=\"string\">'width'</span>, d =&gt; xScale(xValue(d)))</span><br><span class=\"line\">    .attr(<span class=\"string\">'height'</span>,yScale.bandwidth())</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"增加坐标轴\"><a href=\"#增加坐标轴\" class=\"headerlink\" title=\"增加坐标轴\"></a>增加坐标轴</h3><p>坐标轴的绘制，是d3通过<code>&lt;svg&gt;</code>中的<code>&lt;path&gt;</code> <code>&lt;text&gt;</code> <code>&lt;line&gt;</code>实现的，用到的函数如<code>axisLeft</code> <code>axisBottom</code>等，绘制一般分为一下几个步骤：</p>\n<ul>\n<li>创建坐标轴<br><code>var axisX = d3.axisLeft(xScale)</code>根据比例尺创建坐标轴</li>\n<li>创建新的<code>&lt;g&gt;</code>组<br><code>var gAxis = svg.append(&#39;g&#39;)</code></li>\n<li>插入坐标轴<br><code>axisX(gAxis)</code> 或者 在上一步直接<code>svg.append(&#39;g&#39;).call(axisX)</code></li>\n</ul>\n<p>因此，本例中坐标轴添加可以这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g.append(<span class=\"string\">'g'</span>).call(d3.axisLeft(yScale)); <span class=\"comment\">//左边显示country</span></span><br><span class=\"line\">g.append(<span class=\"string\">'g'</span>).call(d3.axisBottom(xScale))</span><br><span class=\"line\">    .attr(<span class=\"string\">'transform'</span>,<span class=\"string\">`translate(0,<span class=\"subst\">$&#123;innerHeight&#125;</span>)`</span>) <span class=\"comment\">//虽然是bottom，但是默认位置并不在下，需要移动至下方</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"增加间隙\"><a href=\"#增加间隙\" class=\"headerlink\" title=\"增加间隙\"></a>增加间隙</h3><p>现在柱状图还是很丑的状态，应该增加一点间隙，让它看起来更加美观，这就非常简单了，在<code>yScale</code>上使用<code>padding</code>属性。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> yScale = d3.scaleBand()</span><br><span class=\"line\">    .domain(data.map(yValue))</span><br><span class=\"line\">    .range([<span class=\"number\">0</span>, innerHeight])</span><br><span class=\"line\">    .padding(<span class=\"number\">0.15</span>)   <span class=\"comment\">//增加了这个属性</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"修改样式\"><a href=\"#修改样式\" class=\"headerlink\" title=\"修改样式\"></a>修改样式</h3><p>为了让柱状图看起来更美观，增加一些css样式，样式如下：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> <span class=\"selector-tag\">html</span>&#123;</span><br><span class=\"line\">            <span class=\"attribute\">margin</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"selector-tag\">rect</span> &#123;</span><br><span class=\"line\">            <span class=\"attribute\">fill</span>:steelblue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"selector-tag\">text</span> &#123;</span><br><span class=\"line\">            <span class=\"attribute\">font-size</span>: <span class=\"number\">1.1em</span>;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>由于chrome的安全原因限制，在本地使用<code>d3.csv</code>读取本地文件时是会遇到问题的，并不支持<code>file//:</code> 读取内容。 因此，代码在github中是可以正常运转，但是本地可能无法正常运作， 可以开一个本地服务器，将代码放置上。</p>\n<h3 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h3><p>完整代码详见：<a href=\"https://github.com/forrany/Web-Project/tree/master/D3js%E5%8F%AF%E8%A7%86%E5%8C%96/2.Making%20a%20Bar%20Chat\" target=\"_blank\" rel=\"noopener\">d3系列教程源码</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>最终效果图</strong><br><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1g19c657jnqj20pw0djjrn.jpg\" alt=\"\"></p>\n<p>知识点：</p>\n<ul>\n<li>d3数据绑定</li>\n<li>柱状图画法</li>\n<li>坐标轴</li>\n<li>比例尺</li>\n</ul>\n<hr>\n<h2 id=\"数据读入\"><a href=\"#数据读入\" class=\"headerlink\" title=\"数据读入\"></a>数据读入</h2><p>数据可视化的第一步还是数据读取，在d3中可以使用<code>d3.csv</code>非常方便的读取数据，它会返回一个<code>Promise</code>对象。</p>\n<p>csv文件是以逗号<code>,</code>分隔的数据内容，本地使用的csv数据如下,文件名为<code>data.csv</code>：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">country,population</span><br><span class=\"line\">China,1415046</span><br><span class=\"line\">India,1354052</span><br><span class=\"line\">United States,326767</span><br><span class=\"line\">Indonesia,266795</span><br><span class=\"line\">Brazil,210868</span><br><span class=\"line\">Pakistan,200814</span><br><span class=\"line\">Nigeria,195875</span><br><span class=\"line\">Bangladesh,166368</span><br><span class=\"line\">Russia,143965</span><br><span class=\"line\">Mexico,130759</span><br></pre></td></tr></table></figure></p>\n<p>首先将数据读入，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> data = d3.csv(<span class=\"string\">'data.csv'</span>).then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data))</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，控制台输出了一个数组，数组中的每条数据均是一个对象，类型为<code>{country:xx, population:xx}</code></p>\n<p>当然，人数自然应该是<code>Number</code>类型的，同时，为了将人数转换为单位<code>个</code>，将所有数据都扩大一千倍，即：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> data = d3.csv(<span class=\"string\">'data.csv'</span>).then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">    data.forEach(<span class=\"function\"><span class=\"params\">element</span> =&gt;</span> &#123;</span><br><span class=\"line\">        element.population = +element.population * <span class=\"number\">1000</span></span><br><span class=\"line\">    &#125;);  <span class=\"comment\">//处理完数据，就可以开始画图了</span></span><br><span class=\"line\">    render(data)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"画柱状图\"><a href=\"#画柱状图\" class=\"headerlink\" title=\"画柱状图\"></a>画柱状图</h2><p>HTML文件与上一节相同，都是仅包含了一个<code>&lt;svg&gt;&lt;/svg&gt;</code>标签，首先选择svg:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> svg = d3.select(<span class=\"string\">'svg'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> height = +svg.attr(<span class=\"string\">'height'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> width = +svg.attr(<span class=\"string\">'width'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> render = <span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125; <span class=\"comment\">//根据已有数据，画图渲染的函数</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"数据绑定\"><a href=\"#数据绑定\" class=\"headerlink\" title=\"数据绑定\"></a>数据绑定</h3><p>将数据绑定到DOM上，是D3最大的特色。<code>d3.select</code>与<code>d3.selectAll</code>返回选择集，但其本身是没有数据的，通过data()函数，可以将数据与之绑定。相关函数有两个：</p>\n<ul>\n<li><code>selection.datum([value])</code><br>选择集上的每个元素都绑定相同的元素value</li>\n<li><code>selection.data(values[,key])</code><br>选择集上每一个元素分别绑定数组values的每一项，key是一个键函数，用于指定绑定数组时的规则。</li>\n</ul>\n<p><code>datum</code>用比较少，这里主要用到的是<code>data()</code>，将已处理好的数据绑定在dom上。</p>\n<h3 id=\"update、enter和exit\"><a href=\"#update、enter和exit\" class=\"headerlink\" title=\"update、enter和exit\"></a>update、enter和exit</h3><p>在进行数据绑定的时候，不一定数据和元素个数就是相同的，这个时候就需要一个动态的处理，这就需要用到<code>updata</code>、<code>enter</code>、和<code>exit</code>了。</p>\n<ul>\n<li><strong>update()    当对应的元素正好满足时 （ 绑定数据数量 = 对应元素 ）</strong><br>实际上并不存在这样一个函数，只是为了要与之后的 enter 和 exit 一起说明才想象有这样一个函数。但对应元素正好满足时，直接操作即可，后面直接跟 text ，style 等操作即可。</li>\n<li><strong>enter()    当对应的元素不足时 （ 绑定数据数量 &gt; 对应元素 ）</strong><br>当对应的元素不足时，通常要添加元素，使之与绑定数据的数量相等。后面通常先跟 append 操作。</li>\n<li><strong>exit()     当对应的元素过多时 （ 绑定数据数量 &lt; 对应元素 ）</strong><br>当对应的元素过多时，通常要删除元素，使之与绑定数据的数量相等。后面通常要跟 remove 操作。</li>\n</ul>\n<p>本项目主要用到了<code>enter</code>，因为页面中只有<code>svg</code>标签，我们需要做的是根据数据内容，在<code>svg</code>中画<code>&lt;rect&gt;</code>来表示柱状图。<br><a href=\"http://wiki.jikexueyuan.com/project/d3wiki/enterexit.html\" target=\"_blank\" rel=\"noopener\">理解 Update、Enter、Exit</a></p>\n<h3 id=\"render函数\"><a href=\"#render函数\" class=\"headerlink\" title=\"render函数\"></a>render函数</h3><p>有了以上的概念，就可以开始画图了<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> render = <span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">    svg.selectAll(<span class=\"string\">'rect'</span>).data(data)  <span class=\"comment\">//选择`rect`并绑定数据data，但这个时候没有元素，因此使用enter</span></span><br><span class=\"line\">        .enter().append(<span class=\"string\">'rect'</span>)</span><br><span class=\"line\">        .attr(<span class=\"string\">'width'</span>,width)</span><br><span class=\"line\">        .attr(<span class=\"string\">'height'</span>,<span class=\"string\">'30px'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样更新视图，就可以看到已经有图像出来了。但是只能看到一个黑色的长方形。因为目前图形并不能反映任何数据，只是单纯的固定’width’的长方形。为此，需要用上数据，但是因为数据可能很大或者很小，为了让其能够正好显示的视图中，需要使用到比例尺。</p>\n<h2 id=\"比例尺\"><a href=\"#比例尺\" class=\"headerlink\" title=\"比例尺\"></a>比例尺</h2><p>D3中有很多比例尺，本例中主要使用到了线性比例尺(scaleLinear)和序数比例尺(scaleBand)</p>\n<p><strong>线性比例尺</strong>可以将<code>domain</code>的内容线性映射到<code>range</code>的一个范围内，这样，就可以保证无论初始数值多大或多小，都能够很好的适应画当前视图。<br><strong>映射关系</strong>：<br><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1g19d8odvbej20by062aah.jpg\" alt=\"\"></p>\n<p><strong>序数比例尺</strong>不是一个连续的比例尺，<code>domain()</code>中使用一个数组，<code>range()</code>是一个连续域。<br><strong>映射关系</strong>：<br><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1g19dbloeylj20rc0dzdio.jpg\" alt=\"\"></p>\n<p>因此，加上两个方向的比例尺，让柱状图的雏形开始慢慢出现吧：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> render = <span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> xScale = d3.scaleLinear()</span><br><span class=\"line\">        .domain([<span class=\"number\">0</span>,d3.max(data, d =&gt; d.population)])</span><br><span class=\"line\">        .range([<span class=\"number\">0</span>,width]) <span class=\"comment\">//最大值将视图空间充满</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> yScale = d3.scaleBand()</span><br><span class=\"line\">        .domain(data.map(<span class=\"function\"><span class=\"params\">d</span> =&gt;</span> d.country))</span><br><span class=\"line\">        .range([<span class=\"number\">0</span>,height])</span><br><span class=\"line\"></span><br><span class=\"line\">    svg.selectAll(<span class=\"string\">'rect'</span>).data(data)  <span class=\"comment\">//选择`rect`并绑定数据data，但这个时候没有元素，因此使用enter</span></span><br><span class=\"line\">        .enter().append(<span class=\"string\">'rect'</span>)</span><br><span class=\"line\">        .attr(<span class=\"string\">'y'</span>,d =&gt; yScale(d.country))</span><br><span class=\"line\">        .attr(<span class=\"string\">'width'</span>,d =&gt; xScale(d.population)) <span class=\"comment\">//宽度根据数据</span></span><br><span class=\"line\">        .attr(<span class=\"string\">'height'</span>,yScale.bandwidth()) <span class=\"comment\">//高度由比例尺自动生成</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样子，就有一个雏形了，效果如下：<br><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1g1aafvtuhjj20k10anaa4.jpg\" alt=\"\"></p>\n<h3 id=\"代码优化\"><a href=\"#代码优化\" class=\"headerlink\" title=\"代码优化\"></a>代码优化</h3><p>首先，重新审视下代码，发现其中<code>d =&gt; d.population</code>以及<code>d =&gt; d.country</code>在比例尺设置以及使用时出现了多次，如果需要修改，又是代码中多处的重复修改。为此，对其进行一个处理，如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> render = <span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> xValue = <span class=\"function\"><span class=\"params\">d</span> =&gt;</span> d.population; <span class=\"comment\">//优化</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> yValue = <span class=\"function\"><span class=\"params\">d</span> =&gt;</span> d.country;  <span class=\"comment\">//优化</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> xScale = d3.scaleLinear()</span><br><span class=\"line\">        .domain([<span class=\"number\">0</span>,d3.max(data,xValue)]) <span class=\"comment\">//优化</span></span><br><span class=\"line\">        .range([<span class=\"number\">0</span>,width]) </span><br><span class=\"line\">    <span class=\"keyword\">const</span> yScale = d3.scaleBand()</span><br><span class=\"line\">        .domain(data.map(yValue))  <span class=\"comment\">//优化</span></span><br><span class=\"line\">        .range([<span class=\"number\">0</span>,height])</span><br><span class=\"line\"></span><br><span class=\"line\">    svg.selectAll(<span class=\"string\">'rect'</span>).data(data) </span><br><span class=\"line\">        .enter().append(<span class=\"string\">'rect'</span>)</span><br><span class=\"line\">        .attr(<span class=\"string\">'y'</span>,d =&gt; yScale(yValue(d)))   <span class=\"comment\">//优化</span></span><br><span class=\"line\">        .attr(<span class=\"string\">'width'</span>,d =&gt; xScale(xValue(d))) <span class=\"comment\">//优化</span></span><br><span class=\"line\">        .attr(<span class=\"string\">'height'</span>,yScale.bandwidth())</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"坐标轴\"><a href=\"#坐标轴\" class=\"headerlink\" title=\"坐标轴\"></a>坐标轴</h2><h3 id=\"使用margin来优化布局\"><a href=\"#使用margin来优化布局\" class=\"headerlink\" title=\"使用margin来优化布局\"></a>使用margin来优化布局</h3><p>下图所示是<code>margin</code>的布局示意图，因为直接按照<code>svg</code>的<code>height</code>和<code>width</code>撑满画布将导致没有多余的位置放置坐标轴等，所以这里使用一个<code>margin</code>来对布局重新规划。</p>\n<p><img src=\"http://ww1.sinaimg.cn/large/6f9f3683ly1g1aaroylbuj20oi0e40ub.jpg\" alt=\"\"></p>\n<p>代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> margin = &#123;<span class=\"attr\">left</span>:<span class=\"number\">50</span>,<span class=\"attr\">top</span>:<span class=\"number\">10</span>,<span class=\"attr\">right</span>:<span class=\"number\">20</span>,<span class=\"attr\">bottom</span>:<span class=\"number\">30</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> innerHeight = height - margin.top - margin.bottom;</span><br><span class=\"line\"><span class=\"keyword\">const</span> innerWidth = width - margin.left - margin.right;</span><br></pre></td></tr></table></figure></p>\n<p>其中innerHeight和innerWidth是柱状图的实际占有高度，因此，柱状图的代码可以修改为：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> xScale = d3.scaleLinear()</span><br><span class=\"line\">    .domain([<span class=\"number\">0</span>, d3.max(data,xValue)])</span><br><span class=\"line\">    .range([<span class=\"number\">0</span>, innerWidth]) <span class=\"comment\">//将 width 改为 innerWidth</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> yScale = d3.scaleBand()</span><br><span class=\"line\">    .domain(data.map(yValue))</span><br><span class=\"line\">    .range([<span class=\"number\">0</span>, innerHeight]) <span class=\"comment\">//将height 改为 innerHeight</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> g = svg.append(<span class=\"string\">'g'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'transform'</span>, <span class=\"string\">`translate(<span class=\"subst\">$&#123;margin.left&#125;</span>,<span class=\"subst\">$&#123;margin.top&#125;</span>)`</span>) <span class=\"comment\">//加入新元素g,整体移动maring.left和margin.top</span></span><br><span class=\"line\">g.selectAll(<span class=\"string\">'rect'</span>).data(data)  </span><br><span class=\"line\">    .enter().append(<span class=\"string\">'rect'</span>)</span><br><span class=\"line\">    .attr(<span class=\"string\">'y'</span>,d =&gt; yScale(yValue(d)))</span><br><span class=\"line\">    .attr(<span class=\"string\">'width'</span>, d =&gt; xScale(xValue(d)))</span><br><span class=\"line\">    .attr(<span class=\"string\">'height'</span>,yScale.bandwidth())</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"增加坐标轴\"><a href=\"#增加坐标轴\" class=\"headerlink\" title=\"增加坐标轴\"></a>增加坐标轴</h3><p>坐标轴的绘制，是d3通过<code>&lt;svg&gt;</code>中的<code>&lt;path&gt;</code> <code>&lt;text&gt;</code> <code>&lt;line&gt;</code>实现的，用到的函数如<code>axisLeft</code> <code>axisBottom</code>等，绘制一般分为一下几个步骤：</p>\n<ul>\n<li>创建坐标轴<br><code>var axisX = d3.axisLeft(xScale)</code>根据比例尺创建坐标轴</li>\n<li>创建新的<code>&lt;g&gt;</code>组<br><code>var gAxis = svg.append(&#39;g&#39;)</code></li>\n<li>插入坐标轴<br><code>axisX(gAxis)</code> 或者 在上一步直接<code>svg.append(&#39;g&#39;).call(axisX)</code></li>\n</ul>\n<p>因此，本例中坐标轴添加可以这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g.append(<span class=\"string\">'g'</span>).call(d3.axisLeft(yScale)); <span class=\"comment\">//左边显示country</span></span><br><span class=\"line\">g.append(<span class=\"string\">'g'</span>).call(d3.axisBottom(xScale))</span><br><span class=\"line\">    .attr(<span class=\"string\">'transform'</span>,<span class=\"string\">`translate(0,<span class=\"subst\">$&#123;innerHeight&#125;</span>)`</span>) <span class=\"comment\">//虽然是bottom，但是默认位置并不在下，需要移动至下方</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"增加间隙\"><a href=\"#增加间隙\" class=\"headerlink\" title=\"增加间隙\"></a>增加间隙</h3><p>现在柱状图还是很丑的状态，应该增加一点间隙，让它看起来更加美观，这就非常简单了，在<code>yScale</code>上使用<code>padding</code>属性。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> yScale = d3.scaleBand()</span><br><span class=\"line\">    .domain(data.map(yValue))</span><br><span class=\"line\">    .range([<span class=\"number\">0</span>, innerHeight])</span><br><span class=\"line\">    .padding(<span class=\"number\">0.15</span>)   <span class=\"comment\">//增加了这个属性</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"修改样式\"><a href=\"#修改样式\" class=\"headerlink\" title=\"修改样式\"></a>修改样式</h3><p>为了让柱状图看起来更美观，增加一些css样式，样式如下：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">body</span> <span class=\"selector-tag\">html</span>&#123;</span><br><span class=\"line\">            <span class=\"attribute\">margin</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"selector-tag\">rect</span> &#123;</span><br><span class=\"line\">            <span class=\"attribute\">fill</span>:steelblue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"selector-tag\">text</span> &#123;</span><br><span class=\"line\">            <span class=\"attribute\">font-size</span>: <span class=\"number\">1.1em</span>;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h3><p>由于chrome的安全原因限制，在本地使用<code>d3.csv</code>读取本地文件时是会遇到问题的，并不支持<code>file//:</code> 读取内容。 因此，代码在github中是可以正常运转，但是本地可能无法正常运作， 可以开一个本地服务器，将代码放置上。</p>\n<h3 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h3><p>完整代码详见：<a href=\"https://github.com/forrany/Web-Project/tree/master/D3js%E5%8F%AF%E8%A7%86%E5%8C%96/2.Making%20a%20Bar%20Chat\" target=\"_blank\" rel=\"noopener\">d3系列教程源码</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cl6xbhzjh0001zk08evpqbpx5","tag_id":"cl6xbhzjo0005zk08xqdnssm7","_id":"cl6xbhzk1000izk08cd47ejck"},{"post_id":"cl6xbhzjh0001zk08evpqbpx5","tag_id":"cl6xbhzju000azk08j07cfk69","_id":"cl6xbhzk3000kzk08zndb0xme"},{"post_id":"cl6xbhzjh0001zk08evpqbpx5","tag_id":"cl6xbhzjx000dzk08ofuqvdxe","_id":"cl6xbhzk4000nzk08p4zssvut"},{"post_id":"cl6xbhzk1000hzk08wqje27an","tag_id":"cl6xbhzjo0005zk08xqdnssm7","_id":"cl6xbhzk5000pzk08yxj0znpc"},{"post_id":"cl6xbhzk1000hzk08wqje27an","tag_id":"cl6xbhzju000azk08j07cfk69","_id":"cl6xbhzk6000szk083i8jj7yc"},{"post_id":"cl6xbhzk1000hzk08wqje27an","tag_id":"cl6xbhzjx000dzk08ofuqvdxe","_id":"cl6xbhzk7000uzk08w8ea5vgi"},{"post_id":"cl6xbhzjm0003zk080e8tjluu","tag_id":"cl6xbhzjo0005zk08xqdnssm7","_id":"cl6xbhzk8000xzk081nyejejd"},{"post_id":"cl6xbhzjm0003zk080e8tjluu","tag_id":"cl6xbhzju000azk08j07cfk69","_id":"cl6xbhzk9000zzk08mrztwml9"},{"post_id":"cl6xbhzjm0003zk080e8tjluu","tag_id":"cl6xbhzjx000dzk08ofuqvdxe","_id":"cl6xbhzka0012zk08iv7nsk42"},{"post_id":"cl6xbhzjq0006zk081dc5wsaw","tag_id":"cl6xbhzjo0005zk08xqdnssm7","_id":"cl6xbhzkf0019zk08qaxsqwh6"},{"post_id":"cl6xbhzjq0006zk081dc5wsaw","tag_id":"cl6xbhzju000azk08j07cfk69","_id":"cl6xbhzkg001bzk08h604fvmp"},{"post_id":"cl6xbhzjq0006zk081dc5wsaw","tag_id":"cl6xbhzjx000dzk08ofuqvdxe","_id":"cl6xbhzkg001dzk08m9477qnq"},{"post_id":"cl6xbhzjs0008zk08558nvijl","tag_id":"cl6xbhzkd0017zk08tluvnmqd","_id":"cl6xbhzkh001fzk08a18no9ks"},{"post_id":"cl6xbhzjs0008zk08558nvijl","tag_id":"cl6xbhzju000azk08j07cfk69","_id":"cl6xbhzkh001gzk08k7qkxhr8"},{"post_id":"cl6xbhzjt0009zk08uor5zze0","tag_id":"cl6xbhzkg001ezk08mskb7ddx","_id":"cl6xbhzki001kzk08yut32d1i"},{"post_id":"cl6xbhzjt0009zk08uor5zze0","tag_id":"cl6xbhzju000azk08j07cfk69","_id":"cl6xbhzki001lzk08zjbog50j"},{"post_id":"cl6xbhzjt0009zk08uor5zze0","tag_id":"cl6xbhzki001izk08flpydxda","_id":"cl6xbhzkj001nzk088ckfgyqp"},{"post_id":"cl6xbhzjv000bzk08dnm1w7mh","tag_id":"cl6xbhzjo0005zk08xqdnssm7","_id":"cl6xbhzkj001pzk0846u2g5pg"},{"post_id":"cl6xbhzjv000bzk08dnm1w7mh","tag_id":"cl6xbhzju000azk08j07cfk69","_id":"cl6xbhzkj001qzk08s2c0vcwk"},{"post_id":"cl6xbhzjv000bzk08dnm1w7mh","tag_id":"cl6xbhzki001jzk08g16e36ug","_id":"cl6xbhzkk001szk0820hqov2r"},{"post_id":"cl6xbhzjv000bzk08dnm1w7mh","tag_id":"cl6xbhzki001mzk08trqgs5zg","_id":"cl6xbhzkk001tzk08430juoal"},{"post_id":"cl6xbhzjw000czk08iczk8ka6","tag_id":"cl6xbhzjo0005zk08xqdnssm7","_id":"cl6xbhzkk001vzk087rqw3q2i"},{"post_id":"cl6xbhzjw000czk08iczk8ka6","tag_id":"cl6xbhzju000azk08j07cfk69","_id":"cl6xbhzkk001wzk08iieokdyf"},{"post_id":"cl6xbhzjw000czk08iczk8ka6","tag_id":"cl6xbhzkj001ozk08ub24rgjq","_id":"cl6xbhzkn001yzk084bw6h01k"},{"post_id":"cl6xbhzjx000ezk08887qfgp4","tag_id":"cl6xbhzkj001rzk08hca7wmj2","_id":"cl6xbhzkn001zzk08owryrb5j"},{"post_id":"cl6xbhzjx000ezk08887qfgp4","tag_id":"cl6xbhzkk001uzk08bbozc2yb","_id":"cl6xbhzkp0020zk087qyhy5n9"},{"post_id":"cl6xbhzjy000fzk08zqid2e2d","tag_id":"cl6xbhzkn001xzk08t87yten2","_id":"cl6xbhzkq0023zk08uzdhuggo"},{"post_id":"cl6xbhzjy000fzk08zqid2e2d","tag_id":"cl6xbhzju000azk08j07cfk69","_id":"cl6xbhzkq0024zk083a6pn3ul"},{"post_id":"cl6xbhzjy000fzk08zqid2e2d","tag_id":"cl6xbhzkp0021zk08eszgx7vo","_id":"cl6xbhzkr0026zk08jgaq5wif"},{"post_id":"cl6xbhzk2000jzk084v3qh5nr","tag_id":"cl6xbhzjo0005zk08xqdnssm7","_id":"cl6xbhzkr0027zk08xjeaxmov"},{"post_id":"cl6xbhzk2000jzk084v3qh5nr","tag_id":"cl6xbhzju000azk08j07cfk69","_id":"cl6xbhzkr0029zk08t4a4c7yj"},{"post_id":"cl6xbhzk2000jzk084v3qh5nr","tag_id":"cl6xbhzkp0022zk08w8362h80","_id":"cl6xbhzkr002azk08vkyoy2si"},{"post_id":"cl6xbhzk3000mzk08a5fcr8xd","tag_id":"cl6xbhzkg001ezk08mskb7ddx","_id":"cl6xbhzkr002czk08luq8fbnt"},{"post_id":"cl6xbhzk3000mzk08a5fcr8xd","tag_id":"cl6xbhzju000azk08j07cfk69","_id":"cl6xbhzkr002dzk08k3ki7gn8"},{"post_id":"cl6xbhzk3000mzk08a5fcr8xd","tag_id":"cl6xbhzkr0028zk08toeqb6ya","_id":"cl6xbhzks002fzk08ig6m6jlr"},{"post_id":"cl6xbhzk4000ozk0888uzrm1f","tag_id":"cl6xbhzkr002bzk08p5aa9q9a","_id":"cl6xbhzks002gzk085ikgmsgf"},{"post_id":"cl6xbhzk5000rzk08jodb0vr1","tag_id":"cl6xbhzkg001ezk08mskb7ddx","_id":"cl6xbhzkt002kzk08044ybdtt"},{"post_id":"cl6xbhzk5000rzk08jodb0vr1","tag_id":"cl6xbhzks002hzk08qe9y3y4k","_id":"cl6xbhzkt002lzk08qspfx3tq"},{"post_id":"cl6xbhzk5000rzk08jodb0vr1","tag_id":"cl6xbhzju000azk08j07cfk69","_id":"cl6xbhzkt002nzk080xyt1cc6"},{"post_id":"cl6xbhzk5000rzk08jodb0vr1","tag_id":"cl6xbhzks002izk08otsqahln","_id":"cl6xbhzkt002ozk08gvs5zdoh"},{"post_id":"cl6xbhzk6000tzk085nypm9rd","tag_id":"cl6xbhzkt002jzk08vd8x33zu","_id":"cl6xbhzku002rzk0898233jo7"},{"post_id":"cl6xbhzk6000tzk085nypm9rd","tag_id":"cl6xbhzkt002mzk08x7y238kw","_id":"cl6xbhzku002szk08o7hlgxyj"},{"post_id":"cl6xbhzk6000tzk085nypm9rd","tag_id":"cl6xbhzkt002pzk08r23zyhlm","_id":"cl6xbhzku002uzk08saru9cnb"},{"post_id":"cl6xbhzk8000wzk08dt92ewkv","tag_id":"cl6xbhzku002qzk087b5rqu8n","_id":"cl6xbhzku002vzk08p2r8m5re"},{"post_id":"cl6xbhzk9000yzk08epu0ruq0","tag_id":"cl6xbhzku002tzk08lsnl82c1","_id":"cl6xbhzkv002zzk08phf8h253"},{"post_id":"cl6xbhzk9000yzk08epu0ruq0","tag_id":"cl6xbhzku002wzk08a6uhpbw2","_id":"cl6xbhzkv0030zk083667nbh8"},{"post_id":"cl6xbhzk9000yzk08epu0ruq0","tag_id":"cl6xbhzku002xzk085p9l5opm","_id":"cl6xbhzkv0032zk0885j8cwcp"},{"post_id":"cl6xbhzka0011zk08ei5iidhu","tag_id":"cl6xbhzkv002yzk08yb76hgr8","_id":"cl6xbhzkv0033zk08bk9pg0j7"},{"post_id":"cl6xbhzkb0013zk08e2bg2tf1","tag_id":"cl6xbhzkv0031zk089tcfj1ip","_id":"cl6xbhzkw0036zk08hd2zpami"},{"post_id":"cl6xbhzkb0013zk08e2bg2tf1","tag_id":"cl6xbhzku002wzk08a6uhpbw2","_id":"cl6xbhzkw0037zk08bdr1380j"},{"post_id":"cl6xbhzkc0015zk08dou3rm37","tag_id":"cl6xbhzkw0035zk086y1884mn","_id":"cl6xbhzkx003bzk08vbzjd18x"},{"post_id":"cl6xbhzkc0015zk08dou3rm37","tag_id":"cl6xbhzku002qzk087b5rqu8n","_id":"cl6xbhzkx003czk08ajebb66k"},{"post_id":"cl6xbhzkc0015zk08dou3rm37","tag_id":"cl6xbhzkx0039zk0841xs6kbg","_id":"cl6xbhzkx003ezk08h14xacz2"},{"post_id":"cl6xbhzkd0016zk083ejqn17j","tag_id":"cl6xbhzju000azk08j07cfk69","_id":"cl6xbhzky003gzk08q8prgyfq"},{"post_id":"cl6xbhzkd0016zk083ejqn17j","tag_id":"cl6xbhzkx003azk08ulfz2xux","_id":"cl6xbhzky003hzk08npc00m14"},{"post_id":"cl6xbhzkd0016zk083ejqn17j","tag_id":"cl6xbhzkx003dzk0818hw7oae","_id":"cl6xbhzky003jzk08tw3c55fx"},{"post_id":"cl6xbhzke0018zk08y2tljxsl","tag_id":"cl6xbhzkx003dzk0818hw7oae","_id":"cl6xbhzkz003mzk08yzdy6b21"},{"post_id":"cl6xbhzke0018zk08y2tljxsl","tag_id":"cl6xbhzky003izk08stcnaleg","_id":"cl6xbhzkz003nzk08phdldazi"},{"post_id":"cl6xbhzke0018zk08y2tljxsl","tag_id":"cl6xbhzky003kzk085zduog29","_id":"cl6xbhzl0003pzk08m2ihe5oy"},{"post_id":"cl6xbhzkf001azk08e4tsver7","tag_id":"cl6xbhzku002tzk08lsnl82c1","_id":"cl6xbhzl0003rzk08l15ecgz1"},{"post_id":"cl6xbhzkf001azk08e4tsver7","tag_id":"cl6xbhzku002wzk08a6uhpbw2","_id":"cl6xbhzl0003szk089z2o26ct"},{"post_id":"cl6xbhzkf001azk08e4tsver7","tag_id":"cl6xbhzl0003qzk08opjwnnf6","_id":"cl6xbhzl0003tzk08ysir0aa1"}],"Tag":[{"name":"前端面试","_id":"cl6xbhzjo0005zk08xqdnssm7"},{"name":"JavaScript","_id":"cl6xbhzju000azk08j07cfk69"},{"name":"前端笔试","_id":"cl6xbhzjx000dzk08ofuqvdxe"},{"name":"正则表达式","_id":"cl6xbhzkd0017zk08tluvnmqd"},{"name":"前端开发","_id":"cl6xbhzkg001ezk08mskb7ddx"},{"name":"React","_id":"cl6xbhzki001izk08flpydxda"},{"name":"异步原理","_id":"cl6xbhzki001jzk08g16e36ug"},{"name":"Generator","_id":"cl6xbhzki001mzk08trqgs5zg"},{"name":"JS Event","_id":"cl6xbhzkj001ozk08ub24rgjq"},{"name":"感悟","_id":"cl6xbhzkj001rzk08hca7wmj2"},{"name":"随笔","_id":"cl6xbhzkk001uzk08bbozc2yb"},{"name":"转载","_id":"cl6xbhzkn001xzk08t87yten2"},{"name":"ES6","_id":"cl6xbhzkp0021zk08eszgx7vo"},{"name":"算法","_id":"cl6xbhzkp0022zk08w8362h80"},{"name":"设计模式","_id":"cl6xbhzkr0028zk08toeqb6ya"},{"name":"git","_id":"cl6xbhzkr002bzk08p5aa9q9a"},{"name":"Node.js","_id":"cl6xbhzks002hzk08qe9y3y4k"},{"name":"译文","_id":"cl6xbhzks002izk08otsqahln"},{"name":"jupyter notebook","_id":"cl6xbhzkt002jzk08vd8x33zu"},{"name":"前端","_id":"cl6xbhzkt002mzk08x7y238kw"},{"name":"二次开发","_id":"cl6xbhzkt002pzk08r23zyhlm"},{"name":"路由器","_id":"cl6xbhzku002qzk087b5rqu8n"},{"name":"d3.js","_id":"cl6xbhzku002tzk08lsnl82c1"},{"name":"可视化","_id":"cl6xbhzku002wzk08a6uhpbw2"},{"name":"SVG","_id":"cl6xbhzku002xzk085p9l5opm"},{"name":"串口协议说明","_id":"cl6xbhzkv002yzk08yb76hgr8"},{"name":"d3","_id":"cl6xbhzkv0031zk089tcfj1ip"},{"name":"黑科技","_id":"cl6xbhzkw0035zk086y1884mn"},{"name":"刷机","_id":"cl6xbhzkx0039zk0841xs6kbg"},{"name":"Mjpg-Streamer","_id":"cl6xbhzkx003azk08ulfz2xux"},{"name":"Raspberry Pi","_id":"cl6xbhzkx003dzk0818hw7oae"},{"name":"Node 脚本自启动","_id":"cl6xbhzky003izk08stcnaleg"},{"name":"创建热点","_id":"cl6xbhzky003kzk085zduog29"},{"name":"柱状图","_id":"cl6xbhzl0003qzk08opjwnnf6"}]}}