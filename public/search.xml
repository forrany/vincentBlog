<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[常用git命令总结]]></title>
    <url>%2F2019%2F11%2F25%2FMost-useful-git-commands%2F</url>
    <content type="text"><![CDATA[记录在日常使用git时遇到的问题和解决方案 除了最频繁的git pull 、 git push 等操作，在工作和日常使用中，还会遇到各种各样的问题和情景，在这里做一些记录，方便总结、查看 1. Your branch is ahead of ‘origin/master’ by 3 commitsI am getting the following when running git status 1Your branch is ahead of &apos;origin/master&apos; by 3 commits. I have read on some other post the way to fix this is run git pull --rebase but what exactly is rebase, will I lose data or is this simple way to sync with master? answers You get that message because you made changes in your local master and you didn’t push them to remote. You have several ways to “solve” it and it normally depends on how your workflow looks like: In a good workflow your remote copy of master should be the good one while your local copy of master is just a copy of the one in remote. Using this workflow you’ll never get this message again. If you work in another way and your local changes should be pushed then just git push originassuming origin is your remote If your local changes are bad then just remove them or reset your local master to the state on remote git reset –hard origin/master 2. git修改远程仓库地址方法有三种： 修改命令 1git remote set-url origin [url] 先删后加 12git remote rm origingit remote add origin [url] 直接修改config文件 3. git放弃修改&amp;放弃增加文件 本地修改了一堆文件(并没有使用git add到暂存区)，想放弃修改。单个文件/文件夹： 1$ git checkout -- filename ​ 所有文件/文件夹： 1$ git checkout . 本地新增了一堆文件(并没有git add到暂存区)，想放弃修改。单个文件/文件夹： 1$ rm filename / rm dir -rf 所有文件/文件夹： 12$ git clean -xdf// 删除新增的文件，如果文件已经已经git add到暂存区，并不会删除！ 本地修改/新增了一堆文件，已经git add到暂存区，想放弃修改。单个文件/文件夹： 1$ git reset HEAD filename ​ 所有文件/文件夹： 1$ git reset HEAD . 本地通过git add &amp; git commit 之后，想要撤销此次commit 123$ git reset commit_id//这个id是你想要回到的那个节点，可以通过git log查看，可以只选前6位 // 撤销之后，你所做的已经commit的修改还在工作区！ 123$ git reset --hard commit_id//这个id是你想要回到的那个节点，可以通过git log查看，可以只选前6位 // 撤销之后，你所做的已经commit的修改将会清除，仍在工作区/暂存区的代码不会清除！ 4. 删除分支首先查看项目的分支（包括本地和远程） 1$ git branch -a 删除本地分支 1$ git branch -d &lt;branchname&gt; 删除远程分支 1$ git push origin --delete &lt;branchname&gt; 5.删除远程文件 项目开发初期由于.gitignore 文件配置不正确很有可能导致某些不需要的目录上传到 git 远程仓库上了，这样会导致每个开发者提交的时候这些文件每次都会不同。除了一开始提交的时候注意配置好 .gitignore 文件外，我们也需要了解下出现这种问题后的解决办法 具体操作步骤如下： 预览将要删除的文件 123git rm -r -n --cached 文件/文件夹名称 加上 -n 这个参数，执行命令时，是不会删除任何文件，而是展示此命令要删除的文件列表预览。 确定无误后删除文件 1git rm -r --cached 文件/文件夹名称 提交到本地并推送到远程服务器 12git commit -m &quot;提交说明&quot;git push origin master 修改本地 .gitignore 文件 并提交 12git commit -m &quot;提交说明&quot;git push origin master 6. gitlab或github下fork后如何同步源的新更新内容？ gitlab或github下，a开发者fork了b开发者的项目后，如果b开发人员更新代码后，a开发者如何获得更新？ 具体步骤如下: 给fork配置远程库 1gir remote -v 查看远程状态 确定一个将被同步给 fork 远程的上游仓库 1git remote add upstream URL 同步fork 从上游仓库 fetch 分支和提交点，提交给本地 master，并会被存储在一个本地分支upstream/master 1git fetch upstream 切换到本地主分支 1git checkout master 把 upstream/master 分支合并到本地 master 上，这样就完成了同步，并且不会丢掉本地修的内容 1git merge upstream/master 7. 对本地commit进行还原1git reset --soft HEAD~1 注：reset命令基于最近一次提交，多次执行会回到更早以前，这可能会超出预期。 8. 放弃修改，远程覆盖本地代码与问题1一样，本地超前远程分支，但同时不想要本地的修改，在复习下 在使用Git的过程中，有些时候我们只想要git服务器中的最新版本的项目，对于本地的项目中修改不做任何理会 123git fetch --allgit reset --hard origin/mastergit pull]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PipeRobot 串口传输协议说明]]></title>
    <url>%2F2019%2F03%2F23%2FPipeRobot-%E4%B8%B2%E5%8F%A3%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[树莓派作为服务器，接收手机/PC端发送的控制指令后，通过UART串口将控制指令进行转发，这里对指令协议进行说明 通讯协议 数据编号 数据内容 含义 0 0x55 包头 1 command 控制指令 2 speed 速度 每帧数据都包含了3个字节的数据，分别为包头、控制指令和速度，其中包头均以0x55开头，可以在接收数据时做简单的校验。 控制指令第二个字节控制指令主要包括了： 前进 0x01 后退 0x02 伸张 0x03 收缩 0x04 停止 0x05 下位机在接受数据时，根据第二字节数据判断指令内容 速度第三个字节是速度，范围是[0x00,0x64](即十进制的0~100)。 下位机在接收到数据时，可以根据速度对电机的转速进行相应的控制 下位机程序参考下位机使用ARM系列芯片，实现对机器人的控制，这里主要对串口协议部分给出程序参考 中断部分12345678910111213141516unsigned char Re_buf[11],counter=0;unsigned char sign;void USART2_IRQHandler(void) //串口2全局中断服务函数&#123; if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET) //接收中断有效,若接收数据寄存器满 &#123; Re_buf[counter] = USART_ReceiveData(USART2); //接收数据 if(counter == 0 &amp;&amp; Re_buf[0] != 0x55) return; //第 0 号数据不是帧头，跳过 counter++; if(counter==3) //接收到 11 个数据 &#123; counter=0; //重新赋值，准备下一帧数据的接收 sign=1; //sign作为标志，表示收到数据，可以在主程序中检测该状态，以进行相应的内容 &#125; &#125;&#125; 主程序在主程序中，根据指令的内容，进行不同的控制1234567891011121314151617181920212223242526272829303132u16 speed;extern unsigned char Re_buf[11],counter;extern unsigned char sign; while (1) &#123; if(sign) &#123; sign = 0; if(Re_buf[0]==0x55) //检查帧头 &#123; speed = speedMap(Re_buf[2]); //写一个函数，将0~100映射到0~999 switch(Re_buf[1]) &#123; case 0x01: //标识前进 Motor1_control(0,speed) //前进 break; case 0x02: //标识后退 Motor1_control(speed,0) //前进 break; case 0x53: //标识伸长 Motor2_control(900,0); //直接900的速度伸长，忽略速度 break; case 0x54: //标识收缩 Motor2_control(0,900);直接900的速度收缩，忽略速度 break; case 0x55: //标识停止 GPIO_ResetBits(GPIOC,GPIO_Pin_7); //拉低使能端 break; default: break; &#125; &#125; &#125; 注意点收缩和伸展均以较高的速度进行，原因在于原程序中使用了编码器检测速度变化的方式，来自动停止伸缩和伸长。 当速度较低的时，会影响其正常工作，且一般伸长、收缩需要尽快完成。]]></content>
      <tags>
        <tag>串口协议说明</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派创建热点与 node 脚本自动启动]]></title>
    <url>%2F2019%2F03%2F23%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9B%E5%BB%BA%E7%83%AD%E7%82%B9%E4%B8%8Enode%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[功能实现 文中所有说到的功能，均已配置好，无需再进行操作，本文只做记录以供之后的调试。使用时： 开机，系统会自动创建热点：PipeRobot PC 或手机等终端连接热点（密码：SJTUROBOT） 打开浏览器，输入地址：192.168.123.251:8081 树莓派在 PipeRobot 中作为服务器，需要具有创建 AP 热点的能力，供下位机建立连接和控制。 为此，查阅了相关资料，项目使用 create_ap 插件实现快速创建热点。 除此外，Node 脚本搭建的服务器需要能够实现开机启动，项目使用了 PM2 实现。 热点create_ap 创建热点 git clone 该项目 git clonehttps://github.com/oblique/create_ap.git 进入文件夹cd create_ap 编译 sudo make install 就这样安装好了 安装依赖 sudo apt-get install util-linux procps hostapd iproute2 iw haveged dnsmasq 此时就可以创建热点了，这里用的指令如下： sudo create_ap wlan0 eth0 SSID PASSWRD其中，SSID 是 WIFI 的名称，PASSWRD 是要设置的密码。 开机时自动开启热点作为机器人控制系统一部分，需要在开机时自动创建热点。create_ap同样提供了这样的功能。 可以使用Systemd service实现后台开启热点，比如 systemctl start create_ap 就是开启热点，当然，我们需要对其配置文件进行编辑，开启我们需要的热点 修改/etc/create_ap.confvim /etc/create_ap.conf把其中的两句 SSID 和 PASSHRASE 修改为自己希望的用户名和密码。12SSID=PipeRobotPASSPHRASE=SJTUROBOT 设置开机启动systemctl enable create_ap 至此，每次重启系统，就可以实现自动创建热点了。 Node 脚本开机启动因为对 Linux 脚本不是非常熟悉，Node 脚本的自动执行使用了 PM2 模块进行辅助。 首先全局安装 PM2sudo npm install -g pm2 使用 pm2 执行 node 脚本使用 PM2 运行脚本，首先进入脚本所在文件夹cd Public/PipeRobot 调用 pm2 开启脚本pm2 start server.js 然后就可以看到1234567[PM2] Starting /home/pi/app.js in fork_mode (1 instance)[PM2] Done.┌──────────┬────┬─────────┬──────┬─────┬────────┬─────────┬────────┬─────┬───────────┬──────┬──────────┐│ App name │ id │ version │ mode │ pid │ status │ restart │ uptime │ cpu │ mem │ user │ watching │├──────────┼────┼─────────┼──────┼─────┼────────┼─────────┼────────┼─────┼───────────┼──────┼──────────┤│ app │ 0 │ N/A │ fork │ 738 │ online │ 0 │ 0s │ 0% │ 21.8 MB │ pi │ disabled │└──────────┴────┴─────────┴──────┴─────┴────────┴─────────┴────────┴─────┴───────────┴──────┴──────────┘ 这时，服务器已经运行起来了，如果想要查看某个脚本的运行状态，可以使用pm2 show id查看。 开机启动pm2 startup指令会生成一个开机启动的脚本 1pm2 startup systemd 可以看到输入如下 123[PM2] Init System found: systemd[PM2] To setup the Startup Script, copy/paste the following command:sudo env PATH=$PATH:/usr/bin /usr/lib/node_modules/pm2/bin/pm2 startup systemd -u pi --hp /home/pi 复制生成的脚本，并执行 1sudo env PATH=$PATH:/usr/bin /usr/lib/node_modules/pm2/bin/pm2 startup systemd -u pi --hp /home/p 这条指令创建的系统单元会在系统启动的时候开始执行，当系统启动的时候，PM2 就会从这个转储系统的恢复过来，为了创建这个转储空间，运行以下命令：1pm2 save 这条指令会存储 pm2 当前的状态（当前还在运行我们的服务器server.js）在转储系统中，当开机时，就会从系统中恢复。 这样就实现了 Node 脚本的开机启动 参考资料 Run your Node.js application on a headless Raspberry Pi create_ap]]></content>
      <tags>
        <tag>Raspberry Pi</tag>
        <tag>Node 脚本自启动</tag>
        <tag>创建热点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[D3可视化：（2）Bar Chart with D3js]]></title>
    <url>%2F2019%2F03%2F20%2FD3%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E6%9F%B1%E7%8A%B6%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[最终效果图 知识点： d3数据绑定 柱状图画法 坐标轴 比例尺 数据读入数据可视化的第一步还是数据读取，在d3中可以使用d3.csv非常方便的读取数据，它会返回一个Promise对象。 csv文件是以逗号,分隔的数据内容，本地使用的csv数据如下,文件名为data.csv：1234567891011country,populationChina,1415046India,1354052United States,326767Indonesia,266795Brazil,210868Pakistan,200814Nigeria,195875Bangladesh,166368Russia,143965Mexico,130759 首先将数据读入，代码如下：123const data = d3.csv('data.csv').then(data =&gt; &#123; console.log(data))&#125;) 可以看到，控制台输出了一个数组，数组中的每条数据均是一个对象，类型为{country:xx, population:xx} 当然，人数自然应该是Number类型的，同时，为了将人数转换为单位个，将所有数据都扩大一千倍，即：123456const data = d3.csv('data.csv').then(data =&gt; &#123; data.forEach(element =&gt; &#123; element.population = +element.population * 1000 &#125;); //处理完数据，就可以开始画图了 render(data)&#125;) 画柱状图HTML文件与上一节相同，都是仅包含了一个&lt;svg&gt;&lt;/svg&gt;标签，首先选择svg:1234567const svg = d3.select('svg');const height = +svg.attr('height');const width = +svg.attr('width');const render = data =&gt; &#123;&#125; //根据已有数据，画图渲染的函数 数据绑定将数据绑定到DOM上，是D3最大的特色。d3.select与d3.selectAll返回选择集，但其本身是没有数据的，通过data()函数，可以将数据与之绑定。相关函数有两个： selection.datum([value])选择集上的每个元素都绑定相同的元素value selection.data(values[,key])选择集上每一个元素分别绑定数组values的每一项，key是一个键函数，用于指定绑定数组时的规则。 datum用比较少，这里主要用到的是data()，将已处理好的数据绑定在dom上。 update、enter和exit在进行数据绑定的时候，不一定数据和元素个数就是相同的，这个时候就需要一个动态的处理，这就需要用到updata、enter、和exit了。 update() 当对应的元素正好满足时 （ 绑定数据数量 = 对应元素 ）实际上并不存在这样一个函数，只是为了要与之后的 enter 和 exit 一起说明才想象有这样一个函数。但对应元素正好满足时，直接操作即可，后面直接跟 text ，style 等操作即可。 enter() 当对应的元素不足时 （ 绑定数据数量 &gt; 对应元素 ）当对应的元素不足时，通常要添加元素，使之与绑定数据的数量相等。后面通常先跟 append 操作。 exit() 当对应的元素过多时 （ 绑定数据数量 &lt; 对应元素 ）当对应的元素过多时，通常要删除元素，使之与绑定数据的数量相等。后面通常要跟 remove 操作。 本项目主要用到了enter，因为页面中只有svg标签，我们需要做的是根据数据内容，在svg中画&lt;rect&gt;来表示柱状图。理解 Update、Enter、Exit render函数有了以上的概念，就可以开始画图了123456const render = data =&gt; &#123; svg.selectAll('rect').data(data) //选择`rect`并绑定数据data，但这个时候没有元素，因此使用enter .enter().append('rect') .attr('width',width) .attr('height','30px')&#125; 这样更新视图，就可以看到已经有图像出来了。但是只能看到一个黑色的长方形。因为目前图形并不能反映任何数据，只是单纯的固定’width’的长方形。为此，需要用上数据，但是因为数据可能很大或者很小，为了让其能够正好显示的视图中，需要使用到比例尺。 比例尺D3中有很多比例尺，本例中主要使用到了线性比例尺(scaleLinear)和序数比例尺(scaleBand) 线性比例尺可以将domain的内容线性映射到range的一个范围内，这样，就可以保证无论初始数值多大或多小，都能够很好的适应画当前视图。映射关系： 序数比例尺不是一个连续的比例尺，domain()中使用一个数组，range()是一个连续域。映射关系： 因此，加上两个方向的比例尺，让柱状图的雏形开始慢慢出现吧：1234567891011121314const render = data =&gt; &#123; const xScale = d3.scaleLinear() .domain([0,d3.max(data, d =&gt; d.population)]) .range([0,width]) //最大值将视图空间充满 const yScale = d3.scaleBand() .domain(data.map(d =&gt; d.country)) .range([0,height]) svg.selectAll('rect').data(data) //选择`rect`并绑定数据data，但这个时候没有元素，因此使用enter .enter().append('rect') .attr('y',d =&gt; yScale(d.country)) .attr('width',d =&gt; xScale(d.population)) //宽度根据数据 .attr('height',yScale.bandwidth()) //高度由比例尺自动生成&#125; 这样子，就有一个雏形了，效果如下： 代码优化首先，重新审视下代码，发现其中d =&gt; d.population以及d =&gt; d.country在比例尺设置以及使用时出现了多次，如果需要修改，又是代码中多处的重复修改。为此，对其进行一个处理，如下：12345678910111213141516const render = data =&gt; &#123; const xValue = d =&gt; d.population; //优化 const yValue = d =&gt; d.country; //优化 const xScale = d3.scaleLinear() .domain([0,d3.max(data,xValue)]) //优化 .range([0,width]) const yScale = d3.scaleBand() .domain(data.map(yValue)) //优化 .range([0,height]) svg.selectAll('rect').data(data) .enter().append('rect') .attr('y',d =&gt; yScale(yValue(d))) //优化 .attr('width',d =&gt; xScale(xValue(d))) //优化 .attr('height',yScale.bandwidth()) 坐标轴使用margin来优化布局下图所示是margin的布局示意图，因为直接按照svg的height和width撑满画布将导致没有多余的位置放置坐标轴等，所以这里使用一个margin来对布局重新规划。 代码如下：123const margin = &#123;left:50,top:10,right:20,bottom:30&#125;;const innerHeight = height - margin.top - margin.bottom;const innerWidth = width - margin.left - margin.right; 其中innerHeight和innerWidth是柱状图的实际占有高度，因此，柱状图的代码可以修改为：12345678910111213const xScale = d3.scaleLinear() .domain([0, d3.max(data,xValue)]) .range([0, innerWidth]) //将 width 改为 innerWidthconst yScale = d3.scaleBand() .domain(data.map(yValue)) .range([0, innerHeight]) //将height 改为 innerHeightconst g = svg.append('g') .attr('transform', `translate($&#123;margin.left&#125;,$&#123;margin.top&#125;)`) //加入新元素g,整体移动maring.left和margin.topg.selectAll('rect').data(data) .enter().append('rect') .attr('y',d =&gt; yScale(yValue(d))) .attr('width', d =&gt; xScale(xValue(d))) .attr('height',yScale.bandwidth()) 增加坐标轴坐标轴的绘制，是d3通过&lt;svg&gt;中的&lt;path&gt; &lt;text&gt; &lt;line&gt;实现的，用到的函数如axisLeft axisBottom等，绘制一般分为一下几个步骤： 创建坐标轴var axisX = d3.axisLeft(xScale)根据比例尺创建坐标轴 创建新的&lt;g&gt;组var gAxis = svg.append(&#39;g&#39;) 插入坐标轴axisX(gAxis) 或者 在上一步直接svg.append(&#39;g&#39;).call(axisX) 因此，本例中坐标轴添加可以这样：123g.append('g').call(d3.axisLeft(yScale)); //左边显示countryg.append('g').call(d3.axisBottom(xScale)) .attr('transform',`translate(0,$&#123;innerHeight&#125;)`) //虽然是bottom，但是默认位置并不在下，需要移动至下方 增加间隙现在柱状图还是很丑的状态，应该增加一点间隙，让它看起来更加美观，这就非常简单了，在yScale上使用padding属性。1234const yScale = d3.scaleBand() .domain(data.map(yValue)) .range([0, innerHeight]) .padding(0.15) //增加了这个属性 修改样式为了让柱状图看起来更美观，增加一些css样式，样式如下：12345678910body html&#123; margin:0; overflow: hidden; &#125; rect &#123; fill:steelblue; &#125; text &#123; font-size: 1.1em; &#125; 注意由于chrome的安全原因限制，在本地使用d3.csv读取本地文件时是会遇到问题的，并不支持file//: 读取内容。 因此，代码在github中是可以正常运转，但是本地可能无法正常运作， 可以开一个本地服务器，将代码放置上。 完整代码完整代码详见：d3系列教程源码]]></content>
      <tags>
        <tag>d3.js</tag>
        <tag>可视化</tag>
        <tag>柱状图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mjpg-Streamer+Node.js实现在树莓派上的监控与拍照]]></title>
    <url>%2F2019%2F03%2F09%2F%E5%9F%BA%E4%BA%8EMjpg-Streamer%E4%B8%8E%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%8B%8D%E7%85%A7%2F</url>
    <content type="text"><![CDATA[最近在做一个机器人项目，需要将试试捕获安装于机器人身上的视频图像，并能够对机器人进行无线运动控制。作为前端工程师的我，很自然的想到了使用Node作为服务器和机器人的控制中心，通过前端页面实现对机器人控制和视频图像的捕捉。 本文主要对项目中的一个单元：视频图像的捕捉和拍照功能进行开发记录和解析。 实现功能一： 远程视频图像获取二： 视频图像清晰度调节三： 拍照功能 基于Express的服务器环境搭建Express是基于Node的一个快速搭建服务器的框架，项目使用Express快速搭建服务器。 node的安装首先，更新所有安装列表到最新的状态：1pi@raspberrypi:~$ sudo apt-get update 升级所有安装包到最新版本： 1pi@raspberrypi:~$ sudo apt-get dist-upgrade 接下来，下载和安装node(注意版本号使用_8.x) 1pi@raspberrypi:~$ curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash - 现在可以安装了： 1pi@raspberrypi:~$ sudo apt-get install -y nodejs 测试是否安装成功： 1pi@raspberrypi:~$ node -v Express安装使用Node的包管理工具npm来新建项目和安装框架 首先，进入项目目录，并新建工程:12$ cd Public/WebProject/FisrtPage/$ npm init -y 安装 Express 并将其保存到依赖列表中：以下命令会将 Express 框架安装在当前目录的 node_modules 目录中1$ npm install express --save 然后，在该项目文件下新建server.js文件，引入Express就可以很方便的搭建起一个服务器。具体的内容在后面进行分析。 Mjpg-Streamer项目使用的是一个USB摄像头，为了能将图像捕获并通过HTTP转发，项目使用Mjpg-Streamer实现这一功能。 安装必要的库 12345sudo apt-get updatesudo apt-get install libjpeg8-devsudo apt-get install imagemagicksudo apt-get install libv4l-dev //sudo apt-get install cmake //编译工具 为了向后兼容，链接videodev2.h和videodev.h1sudo ln -s /usr/include/linux/videodev2.h /usr/include/linux/videodev/h 注意，这里的sudo ln -s是非常重要的操作命令，类似于为a做一个超链接 git开源代码到本地，编译进入到home目录，然后开始克隆 123cd ~sudo git clone https://github.com/jacksonliam/mjpg-streamer.gitcd mjpg-streamer/mjpg-streamer-experimental 编译和安装 12sudo makesudo make install 测试和使用 完成以上步骤之后，可以开始测试一下。 插入摄像头，执行以下命令，分别在两个窗口打开1sudo mjpg_streamer -i "./input_uvc.so -r 640x480 -q 70 -f 15 -d /dev/video1 -n" -o "./output_http.so -p 8080 -w /usr/local/www" 出现一下的内容，表明安装成功这样，打开浏览器输入http://localhost:8080/?action=stream就可以看到视频图像，其中localhost在实际使用中，换成了树莓派的IP地址，树莓派已经提前设置了静态地址，我使用的是192.168.123.251，因此，视频的地址就顾定成了： http://192.168.123.251:8080/?action=stream 依赖模块shelljs上面使用的Mjpg-Streamer可以通过改变参数实现对清晰度、帧率的调整，比如将上面的图像修改为720P、15帧的指令为：1mjpg_streamer -i "input_uvc.so -r 1280x720 -f 15 -n" -o "output_http.so " 但是这个是在终端中执行的命令，而服务器是使用Node，因此这里使用了shelljs实现在Node运行shell指令。 首先安装shelljs1npm install shelljs -S 有关该模块的具体使用及相关API可以查阅官网,本项目中主要使用了两个指令是： shell.exec() 执行某个指令 shell.cd() 进入某个目录 为了在后台实现不同分辨率图像的转换，专门写一个函数来实现切换，并通过变量videoStatus的状态来表示不同的分辨率，与前端相对应的: videoStatus: 1-流畅 videoStatus: 2-清晰 videoStatus: 3-高清 清晰度切换的函数实现如下:1234567891011121314151617181920212223var videoStatus = 0; // 1-流畅； 2-清晰； 3-高清， 默认清晰const videoCommand = [ 'mjpg_streamer -i "./input_uvc.so -r 640x480 -q 70 -f 30 -d /dev/video0 -n" -o "./output_http.so -p 8082 -w /usr/local/www"', 'mjpg_streamer -i "./input_uvc.so -r 1280x720 -q 70 -f 15 -d /dev/video0 -n" -o "./output_http.so -p 8082 -w /usr/local/www"', 'mjpg_streamer -i "./input_uvc.so -r 1920x1080 -q 70 -f 15 -d /dev/video0 -n" -o "./output_http.so -p 8082 -w /usr/local/www"']function openVideo(qulity) &#123; return new Promise((resolve,reject) =&gt; &#123; if (shell.exec('pgrep mjpg_streamer').stdout !== '') &#123; shell.exec('killall mjpg_streamer'); &#125; let command = videoCommand[qulity]; shell.cd('~'); shell.cd('mjpg-streamer/mjpg-streamer-experimental/') shell.exec(command, (code, std, err) =&gt; &#123; console.log('Exit code:', code); console.log('Program output:', std); console.log('Program stderr:', err); &#125;) videoStatus = +qulity + 1; resolve('Success'); &#125;)&#125; 对关键的几条指令进行一下说明： shell.exec(&#39;pgrep mjpg_streamer&#39;).stdout !== &#39;&#39; pgrep以名称为依据从运行进程队列中查找进程,并显示查找到进程的id。在shelljs中，stdout是指令的输出，如果不存在进程，则返回为空； 这里加判断的意思主要在于如果mjpg已经在运行，则要杀死该进程（清晰度更换通过重启mjpg实现） let command = videoCommand[qulity] 具体的程序执行取决于前端的请求，根据qulity来开启不同清晰度的摄像头。 接下里，对设置清晰度的请求，设置服务器响应,并开启服务器:12345678910111213141516171819202122232425262728var express = require('express');var app = express();var bodyParse = require("body-parser");app.post('/VideoSet',(req,res) =&gt; &#123; if(+req.body.Video === videoStatus) &#123; res.end('Same Video Set'); return; &#125; switch (req.body.Video) &#123; case "1": openVideo(0); res.end('Success'); break; case "2": openVideo(1); res.end('Success'); break; case "3": openVideo(2); res.end('Success'); break; &#125;&#125;)var server = app.listen(8081,function()&#123; console.log("Server is running at 8081 port...");&#125;); serialport项目除了传统前端的内容，还涉及了对机器人的控制，而机器人控制主要通过基于STM系列的下位机实现。所以RaspberryPi在作为服务器接收到前端控制请求后，需要将控制请求发送至下位机，实现控制，项目中使用了UART串口进行相互连接。 打开RaspberryPi 3B的串口通讯能力之前项目中，使用了USB转串口模块直接插在RaspberryPI的USB接口上，然后通过serialport打开相应的串口实现串口通讯。 本项目中，为了节约USB资源和空间，要使用GPIO口的TX/RX进行UART通讯。RaspberryPi 3B与之前的版本不同，它带了两个串口，分别是： /dev/ttyAMA0：RPI3配备了蓝牙，为了保证蓝牙的正确使用，/dev/ttyAMA0则不再为GPIO串口服务，而是为蓝牙模块服务。 /dev/ttyS0：被称为”mini uart”，此串口代表了”Physical pin 8|10 BCM pin 14|15Wiring Pi pin 15|16”.但是由于次串口波特率收到cpu频率影响，并不稳定，所以实际上无法被用来串口通信。 正因如此，网络上大部分教程，直接使用/dev/ttyAMA0作为串口的方法就无法使用RPI3了，查了相关资料，通过以下方法解决(参考自简书R4L)： 将ttyAMA0和ttyS0互换，那么gpio tx\rx串口映射给ttyAMA0，ttyS0则映射给蓝牙设备。这样gpio 14、15串口就拥有了稳定，强大的通信功能,而蓝牙串口则无法正常使用。 1) 激活串口1$ sudo nano /boot/config.txt 改变使得：enable_uart=1.若无此参数，则在最后一行添加：enable_uart=1.重启设备。 2)查看串口别名1ls -l /dev 会发现:lrwxrwxrwx 1 root root 7 Aug 28 07:41 serial0 -&gt; ttyS0lrwxrwxrwx 1 root root 5 Aug 28 07:41 serial1 -&gt; ttyAMA0 3)禁用/dev/ttyS0的console功能12$ sudo systemctl stop serial-getty@ttyS0.service$ sudo systemctl disable serial-getty@ttyS0.service 并且修改cmdline.txt文件1$ sudo nano /boot/cmdline.txt 删除“console=serial0,115200”，保存并重启 4) 交换串口1$ sudo nano /boot/config.txt 在最下面添加：dtoverlay=pi3-miniuart-bt保存并重启。此时查看串口别名则发现：lrwxrwxrwx 1 root root 7 Aug 28 07:41 serial0 -&gt; ttyAMA0lrwxrwxrwx 1 root root 5 Aug 28 07:41 serial1 -&gt; ttyS0此时，ttyAMA0串口可以正常用于串口通信，ttyS0则无法被用于串口通信，蓝牙功能失效。 使用serialport打开通讯1) 安装serialport1npm install serialport -S 2) 引入serialport，并开启串口1234var SerialPort = require(&apos;serialport&apos;);const port = new SerialPort(&apos;/dev/ttyAMA0&apos;, &#123; baudRate: 9600&#125;) //使用串口，与下位机机型通讯 3) 串口通讯 serialport的api非常简单，使用相关进行通讯即可12345678910111213141516port.write(&apos;main screen turn on&apos;, function (err) &#123; if (err) &#123; return console.log(&apos;Error on write: &apos;, err.message) &#125; console.log(&apos;message written&apos;) //打开串口&#125;)// Open errors will be emitted as an error eventport.on(&apos;error&apos;, function (err) &#123; console.log(&apos;Error: &apos;, err.message)&#125;)// Switches the port into &quot;flowing mode&quot;port.on(&apos;data&apos;, function (data) &#123; console.log(&apos;Data:&apos;, data.toString()) //接收到数据，打印出来&#125;) 拍照与保存功能MJPG-STREAMER支持保存当前帧，只需要将视频画面地址http://192.168.123.251:8082/?action=stream中的最后一个stream改为snapshot即可。 一开始初步的想法是完全同通前端实现，通过&lt;img src=&quot;http://192.168.123.251:8080/?action=action&quot; /&gt;标签来实现拍照功能，但是这种放有两个问题： 所见非所得，假如在t0时刻拍照为img1，接着点击保存到本地的时候，下载和保存的图片是t1时刻的另一张照片，这是不满足需求的； 图片下载功能通过&lt;a&gt;标签＋download属性实现，但是chrome浏览器对与跨域的图像无法实现保存，只能在新页面打开。 因此拍照与保存功能设计成如下的流程： 服务器端配置1） 获取图片地址 服务器端要实现保存图片到本地，首先需要获取图片的地址。图片地址为http://IP:PORT/?action=action 项目中，将视频画面的地址端口设置为8082，即PORT=8082，IP地址则是RaspberryPi本机的地址，在NODE中获取本机地址的方法如下：123456789101112function getIPAdress() &#123; var interfaces = require(&apos;os&apos;).networkInterfaces(); for (var devName in interfaces) &#123; var iface = interfaces[devName]; for (var i = 0; i &lt; iface.length; i++) &#123; var alias = iface[i]; if (alias.family === &apos;IPv4&apos; &amp;&amp; alias.address !== &apos;127.0.0.1&apos; &amp;&amp; !alias.internal) &#123; return alias.address; &#125; &#125; &#125;&#125; 2） 下载图片 图片下载，使用到了request这个模块，首先在项目中安装该模块1npm install request -S 接下来，写一个下载图片的函数，创建一个文件downIMG.js1$ vim downIMG.js 写下载图片的函数，并将函数导出12345678910const fs = require(&apos;fs&apos;);const request = require(&apos;request&apos;);const download = function(uri, filename, callback) &#123; request.head(uri, function(err, res, body) &#123; request(uri).pipe(fs.createWriteStream(__dirname +&apos;/public/SnapShoot/&apos; + filename)).on(&apos;close&apos;, callback); &#125;);&#125;;module.exports = download 在项目所在文件夹下，新建一个SnapShoot的文件夹。 3） 引入图片下载函数，服务器实现响应 在主文件server.js中，实现服务器的响应1234567891011var download = require(&apos;./downIMG&apos;);app.use(express.static(path.join(__dirname, &apos;public&apos;))); //将public设置为静态资源，这样保存的截图才可以被访问得到app.use(bodyParse.json(&#123; limit: &apos;1mb&apos; &#125;)); //body-parser 解析json格式数据app.use(bodyParse.urlencoded(&#123;extended:false&#125;));app.get(&apos;/capture&apos;, function (req, res) &#123; download(snapAddress,&apos;current.png&apos;,function()&#123; res.send(&apos;Capture Sussess&apos;); &#125;)&#125;) //拍照请求 至此，前端只需要通过&lt;a&gt;标签配合download属性，就可以实现拍照和下载的功能了，样例：1&lt;a target="_blank" id="down" :href="snapAdd" :download="currentDate"&gt;点击下载&lt;/a&gt; 完整代码服务器端包括了 server.js + downIMG.js，以及前端的页面及静态资源。 downIMG.js 12345678910var fs = require(&apos;fs&apos;), request = require(&apos;request&apos;);var download = function(uri, filename, callback) &#123; request.head(uri, function(err, res, body) &#123; request(uri).pipe(fs.createWriteStream(__dirname +&apos;/public/SnapShoot/&apos; + filename)).on(&apos;close&apos;, callback); &#125;);&#125;;module.exports = download server.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149const express = require(&apos;express&apos;);const app = express();const bodyParse = require(&quot;body-parser&quot;);const shell = require(&apos;shelljs&apos;);const download = require(&apos;./downIMG&apos;);const path = require(&apos;path&apos;);const SerialPort = require(&apos;serialport&apos;);const IP = getIPAdress();const PORT = &apos;8082&apos;;const videoCommand = [ &apos;mjpg_streamer -i &quot;./input_uvc.so -r 640x480 -q 70 -f 30 -d /dev/video0 -n&quot; -o &quot;./output_http.so -p 8082 -w /usr/local/www&quot;&apos;, &apos;mjpg_streamer -i &quot;./input_uvc.so -r 1280x720 -q 70 -f 15 -d /dev/video0 -n&quot; -o &quot;./output_http.so -p 8082 -w /usr/local/www&quot;&apos;, &apos;mjpg_streamer -i &quot;./input_uvc.so -r 1920x1080 -q 70 -f 15 -d /dev/video0 -n&quot; -o &quot;./output_http.so -p 8082 -w /usr/local/www&quot;&apos;]const snapAddress = `http://$&#123;IP&#125;:$&#123;PORT&#125;/?action=snapshot`;var speed = 50; //运动速度var videoStatus = 0; // 1-流畅； 2-清晰； 3-高清， 默认清晰const port = new SerialPort(&apos;/dev/ttyAMA0&apos;, &#123; baudRate: 9600&#125;) //使用串口，与下位机机型通讯port.write(&apos;main screen turn on&apos;, function (err) &#123; if (err) &#123; return console.log(&apos;Error on write: &apos;, err.message) &#125; console.log(&apos;message written&apos;)&#125;)// Open errors will be emitted as an error eventport.on(&apos;error&apos;, function (err) &#123; console.log(&apos;Error: &apos;, err.message)&#125;)// Switches the port into &quot;flowing mode&quot;port.on(&apos;data&apos;, function (data) &#123; console.log(&apos;Data:&apos;, data.toString())&#125;) const buf1 = Buffer.alloc(1,1), //前进 buf2 = Buffer.alloc(1,2), //后退 buf3 = Buffer.alloc(1,3), //伸张 buf4 = Buffer.alloc(1,4), //收缩 buf5 = Buffer.alloc(1,5); //停止app.use(express.static(path.join(__dirname, &apos;public&apos;)));app.use(bodyParse.json(&#123; limit: &apos;1mb&apos; &#125;)); //body-parser 解析json格式数据app.use(bodyParse.urlencoded(&#123;extended:false&#125;));app.post(&apos;/VideoSet&apos;,(req,res) =&gt; &#123; if(+req.body.Video === videoStatus) &#123; res.end(&apos;Same Video Set&apos;); return; &#125; switch (req.body.Video) &#123; case &quot;1&quot;: openVideo(0); res.end(&apos;Success&apos;); break; case &quot;2&quot;: openVideo(1); res.end(&apos;Success&apos;); break; case &quot;3&quot;: openVideo(2); res.end(&apos;Success&apos;); break; &#125;&#125;)app.get(&apos;/capture&apos;, function (req, res) &#123; download(snapAddress,&apos;current.png&apos;,function()&#123; res.send(&apos;Capture Sussess&apos;); &#125;)&#125;) app.get(&apos;/speed&apos;,function(req,res) &#123; res.send(&#123;&apos;speed&apos;:speed&#125;);&#125;) app.post(&apos;/speedSet&apos;,(req,res) =&gt; &#123; speed = req.body.speed; res.end(&apos;Speed Set Success&apos;);&#125;)app.get(&apos;/VideoStatus&apos;, function(req, res)&#123; res.send(videoStatus.toString());&#125;)app.get(&apos;/&apos;,function(req,res)&#123; res.sendFile(__dirname + &apos;/&apos; + &quot;index.html&quot;);&#125;)app.get(&apos;/up&apos;,function(req,res)&#123; console.log(&quot;up recieve&quot;); res.send(&apos;ok&apos;); port.write(buf1,&apos;hex&apos;);&#125;)app.get(&apos;/down&apos;,function(req,res)&#123; console.log(&apos;down recieve&apos;); res.send(&apos;ok&apos;); port.write(buf2,&apos;hex&apos;); &#125;)app.get(&apos;/stretch&apos;, function (req, res) &#123; console.log(&apos;stretch&apos;); res.send(&apos;ok&apos;); port.write(buf3,&apos;hex&apos;);&#125;)app.get(&apos;/shrink&apos;,function(req,res)&#123; console.log(&apos;shrink recieve&apos;); res.send(&apos;ok&apos;); port.write(buf4);&#125;)app.get(&apos;/stop&apos;,function(req,res)&#123; console.log(&apos;stop!!!&apos;); res.send(&apos;ok&apos;); port.write(buf5);&#125;)var server = app.listen(8081,function()&#123; console.log(&quot;Server is running at 8081 port...&quot;);&#125;);function openVideo(qulity) &#123; return new Promise((resolve,reject) =&gt; &#123; if (shell.exec(&apos;pgrep mjpg_streamer&apos;).stdout !== &apos;&apos;) &#123; shell.exec(&apos;killall mjpg_streamer&apos;); &#125; let command = videoCommand[qulity]; shell.cd(&apos;~&apos;); shell.cd(&apos;mjpg-streamer/mjpg-streamer-experimental/&apos;) shell.exec(command, (code, std, err) =&gt; &#123; console.log(&apos;Exit code:&apos;, code); console.log(&apos;Program output:&apos;, std); console.log(&apos;Program stderr:&apos;, err); &#125;) videoStatus = +qulity + 1; resolve(&apos;Success&apos;); &#125;)&#125;function getIPAdress() &#123; var interfaces = require(&apos;os&apos;).networkInterfaces(); for (var devName in interfaces) &#123; var iface = interfaces[devName]; for (var i = 0; i &lt; iface.length; i++) &#123; var alias = iface[i]; if (alias.family === &apos;IPv4&apos; &amp;&amp; alias.address !== &apos;127.0.0.1&apos; &amp;&amp; !alias.internal) &#123; return alias.address; &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>Raspberry Pi</tag>
        <tag>Mjpg-Streamer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[D3可视化：（1）初次见面，SVG与D3的魅力]]></title>
    <url>%2F2019%2F02%2F16%2FD3%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B9%8B%E5%88%9D%E5%8D%B0%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[D3.js是一个基于HTML/SVG/CSS的数据可视化库，是领域内非常强大的存在了。 今后会在工作使用，也因此开始了自学之旅。学习过程中，我主要通过Curran Kelleher老师的系列教程进行学习，这个笔记用于学习、整理和分享，陆续学习、更新和记录中…. 学习目的： 熟悉和认识D3.js 练习使用SVG画图，熟悉操作 练习D3.js的基本函数和操作 完成效果图：在线demo D3初印象选择集D3是实现数据可视化，仍然离不开传统DOM的选择和操作，也因此，D3提供了类似Jquery的DOM操作指令： d3.select：选择第一个指定元素 d3.selectAll ： 选择所有的元素 12const svg = d3.select('svg') //选择svgconst p = svg.selectAll('p') //选择svg下所有的p标签 当然，可以使用#id 以及 .class 对id和类进行选择 查看状态d3.select和d3.selectAll返回的都是选择集，添加、删除以及修改都需要用到选择集，查看状态有三个函数可以使用： selection.empty() 选择集为空，返回true，否则返回false selection.node() 返回第一个非空元素，如果选择集为空，返回null selection.size() 返回选择集中的元素个数 设定和获取属性使用select或selectAll选择后，可以通过attr获取和设定属性，可以使用append方法添加元素123const svg = select('svg');svg.append('circle') .attr('r','30') 使用D3和SVG画图html文件12345678910&lt;html lang="en"&gt;&lt;head&gt; &lt;title&gt;Smile face with d3&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;svg width="960" height="500"&gt;&lt;/svg&gt; &lt;script src="https://d3js.org/d3.v5.min.js"&gt;&lt;/script&gt; &lt;script src="index.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 主要内容通过index.js实现: 第一步：通过d3选择SVG，使用circle构建轮廓 123456789101112131415161718192021const svg = d3.select('svg');const height = +svg.attr('height');const width = +svg.attr('width');svg.append('circle') .attr('r',height / 2) .attr('cx', width / 2) .attr('cy', height / 2) .attr('fill', 'yellow') .attr('stroke','black')const leftEye = svg.append('circle') .attr('r', 30) .attr('cx', width / 2 - 100) .attr('cy', height / 2 - 80) .attr('fill', 'black')const rightEye = svg.append('circle') .attr('r', 30) .attr('cx', width / 2 + 100) .attr('cy', height / 2 - 80) .attr('fill', 'black') 要点： 通过attr获取的属性是string类型的，通过parseFloat或者+转换为number类型 对圆形circle的属性cx cy等，使用变量作为其大小设置的值，而不用一个数字，方便日后的维护 leftEye和RightEye用类似的方法，创造出来，并将眼睛放置在合适的位置。 代码优化1）可以发现，对三个圆圆心的操作cx和cy出现了多次，而作用也仅仅是为了将圆放在中心。因此，可以通过SVG中的&lt;g&gt;来分组来实现一次性操作。 12345678const g = svg.append('g') .attr('transform',`translate($&#123; width / 2&#125;, $&#123; height / 2&#125;)`)//这样，在画圆的时候，就可以去掉对其圆心的操作，因为默认的位置就在中心了const circle = g.append('circle') .attr('r',height / 2) .attr('fill', 'yellow') .attr('stroke','black') 2）同样的，对于眼睛的操作，也有点繁琐，可以通过变量和分组，提高代码的可维护性能。1234567891011121314const eyeSpacing = 100;const eyeYoffset = -80const eyeRadius = 30;const eyesG = g.append('g') .attr('transform', `translate(0, $&#123;eyeYoffset&#125;)`);const leftEye = eyesG.append('circle') .attr('r', eyeRadius) .attr('cx', - eyeSpacing)const rightEye = eyesG.append('circle') .attr('r', eyeRadius) .attr('cx', + eyeSpacing) 第二步 嘴巴 嘴巴实际上是一个弧线，使用SVG中的path进行绘制。熟悉path的，当然可以直接给参数进行绘制，但是d3对圆弧有更好的支持，可以使用d3.arc函数，方便的绘制圆弧。 arc函数根据官方的API手册，函数的使用方法如下：12345678var arc = d3.arc();arc(&#123; innerRadius: 0, outerRadius: 100, startAngle: 0, endAngle: Math.PI / 2&#125;); // "M0,-100A100,100,0,0,1,100,0L0,0Z" 其中，innerRadius是内圆半径，outerRadius是外圆半径，startAngle和endAngle分别是开始和结束的弧度（完整的圆是0~2PI） 笑脸的实现根据以上内容，代码如下：1234567const mouth = g.append('path') .attr('d',d3.arc()(&#123; innerRadius: 150, outerRadius: 170, startAngle: Math.PI /2, endAngle: Math.PI * 3 / 2 &#125;)) 眉毛眉毛用简单的长方形来代替，也就是svg中的&lt;rect&gt;，使用前文的编程风格，将眉毛归为一个group，并将位置设定。123456789101112131415const eyebrowWidth = 50;const eyebrowHeight = 10;const eyebrowYoffset = -150;const BrowG = g.append('g') .attr('transform',`translate($&#123;-eyebrowWidth / 2&#125;,$&#123;eyebrowYoffset&#125;)`);const leftEyebrow = BrowG.append('rect') .attr('width',eyebrowWidth) .attr('height',eyebrowHeight) .attr('x',-eyeSpacing)const rightEyebrow = BrowG.append('rect') .attr('width', eyebrowWidth) .attr('height', eyebrowHeight) .attr('x', eyeSpacing) 加入动画使用transition函数设置眉毛的动画，让笑脸动起来123456const BrowG = g.append('g') .attr('transform',`translate($&#123;-eyebrowWidth / 2&#125;,$&#123;eyebrowYoffset&#125;)`);BrowG.transition().duration(2000) .attr('transform', `translate($&#123;-eyebrowWidth / 2&#125;,$&#123;eyebrowYoffset - 50&#125;)`) .transition().duration(2000) .attr('transform', `translate($&#123;-eyebrowWidth / 2&#125;,$&#123;eyebrowYoffset&#125;)`).duration(2000) 注意点： transition函数要对号入座，即如果加在了&lt;g&gt;上，对应的增加的属性动画应该在transform上； 如果动画在&lt;rect&gt;上，动画应该在y属性上。 添加动画不能在append函数之后连接，比如BrowG.append(&#39;g&#39;).attr(...).transition()是不行的。因为过度动画无法绑定在append的元素上，需要分别操作。 完整代码code downlaod here 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const svg = d3.select('svg');const height = +svg.attr('height');const width = +svg.attr('width');const g = svg.append('g') .attr('transform',`translate($&#123; width / 2&#125;, $&#123; height / 2&#125;)`)const circle = g.append('circle') .attr('r',height / 2) .attr('fill', 'yellow') .attr('stroke','black')const eyeSpacing = 100;const eyeYoffset = -80const eyeRadius = 30;const eyebrowWidth = 50;const eyebrowHeight = 10;const eyebrowYoffset = -150;const eyesG = g.append('g') .attr('transform', `translate(0, $&#123;eyeYoffset&#125;)`);const leftEye = eyesG.append('circle') .attr('r', eyeRadius) .attr('cx', - eyeSpacing)const rightEye = eyesG.append('circle') .attr('r', eyeRadius) .attr('cx', + eyeSpacing)const mouth = g.append('path') .attr('d',d3.arc()(&#123; innerRadius: 150, outerRadius: 170, startAngle: Math.PI /2, endAngle: Math.PI * 3 / 2 &#125;))const BrowG = g.append('g') .attr('transform',`translate($&#123;-eyebrowWidth / 2&#125;,$&#123;eyebrowYoffset&#125;)`);BrowG.transition().duration(2000) .attr('transform', `translate($&#123;-eyebrowWidth / 2&#125;,$&#123;eyebrowYoffset - 50&#125;)`) .transition().duration(2000) .attr('transform', `translate($&#123;-eyebrowWidth / 2&#125;,$&#123;eyebrowYoffset&#125;)`).duration(2000)const leftEyebrow = BrowG.append('rect') .attr('width',eyebrowWidth) .attr('height',eyebrowHeight) .attr('x',-eyeSpacing)const rightEyebrow = BrowG.append('rect') .attr('width', eyebrowWidth) .attr('height', eyebrowHeight) .attr('x', eyeSpacing)]]></content>
      <tags>
        <tag>d3.js</tag>
        <tag>可视化</tag>
        <tag>SVG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾路由--Padavan私有云]]></title>
    <url>%2F2019%2F01%2F14%2F%E6%8A%98%E8%85%BE%E8%B7%AF%E7%94%B1-Padavan%E7%A7%81%E6%9C%89%E4%BA%91%2F</url>
    <content type="text"><![CDATA[经历了网盘的各种关闭、数据迁移和限速，国内基本只有百度网盘一家独大了。然而百度网盘推出会员、进而超级会员一波骚操作后，实在让人累觉不爱。 最近正好在折腾路由器，上一篇已经把刚买的小米路由器刷成了Padavan固件，就其本身而言，已经很具可玩性了。这次把搭建私有云的过程写下来，也只是防止日后忘记而已，并没有太多的技术含量。 在实验室、家庭中，有一个内网范围的共享平台是非常方便的，这也是觉得比较使用，有必要记录和分享的原因吧，下面进入正题。 准备阶段 已刷Padavan固件的路由器，这个已经在上一篇记录，有需要的可以参考小米路由器刷机指南 移动硬盘 KodExplorer可道云KodExplorer可道云和智能路由器真的是绝配，刷Padavan是因为固件本身已经继承了KodExplorer，以及很多其他工具。 这里是KodExplorer的一个在线Demo，有桌面和文件夹两种管理模式，非常Nice。可道云在线Demo 配置可道云登陆路由器管理页面，默认地址:192.168.123.1,账号密码:admin 固件中已经集成可道云，点击左侧搭建Web环境 点入以后，按照以下显示操作。按如下操作就可以打开WEB服务器功能和可道云，因为可道云不使用数据库，所以还是很方便的，这个时候就可以直接通过IP+端口的方式访问可道云了，因为集成的是早些版本的可道云，所以建议在升级以后使用。 通过以上的步骤，已经可以实现内网的可道云了，只需要IP地址加端口号即可访问。 当然，如果想要外网访问，还需要做一下其他工作,主要有4中方法： 1、方法一：跟电信商要一个公网的IP在路由器中开启端口映射功能2、方法二：注册花生壳免费账号，通过绑定花生壳来做访问3、方法三：ngrok内网转发等方式来实现访问4、更多方法：百度搜索“内网穿透” 这里就在暂时不讨论了。 最后，简单上一下效果吧： opt挂载空间占用100%问题在使用kod云进行大文件传输的时候，会遇到资源空间用完的问题，这是非常坑的，提示如下1【LNMP】: /opt 已用节点空间100%/100% 为了解决这个问题，需要将opt挂载到U盘。 这里主要涉及两个点： ext4格式U盘 挂载opt 一般U盘不是ext4格式的，Windows格式化ext4需要一些软件，其实可以在Linux进行格式化，这里介绍对方法进行总结。 如何在路由器上格式化 U 盘为 ext4一、安装fdisk一般梅林固件都会自带的，不用安装1234$ opkg update$ opkg install fdisk# 输出Configuring fdisk. 并且没有错误# fdisk就安装好了 二、查看设备1234567$ fdisk -l # 这里先输出系统分区之类的不用管，外置设备一般在最后Disk /dev/sda: 30.7 GB, 30752000000 bytes64 heads, 32 sectors/track, 29327 cylindersUnits = cylinders of 2048 * 512 = 1048576 bytesDevice Boot Start End Blocks Id System/dev/sda1 2 29327 30029824 83 Linux 上面的信息注意看到和你的存储大小一样的设备，我的是/dev/sda，在它里面有个/dev/sda1的分区 三、删除分区、新建分区12345678910111213141516171819202122232425$ fdisk /dev/sda # 这是你的设备別打成分区Welcome to fdisk (util-linux 2.29.2).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Command (m for help): d # 输入d回车，我只有一个分区，它自动选择了，如果你有多个分区，可以多次使用dSelected partition 1Partition 1 has been deleted.Command (m for help): n # 输入n会车，创建分区Partition typep primary (0 primary, 0 extended, 4 free)e extended (container for logical partitions)Select (default p): p # 选择pPartition number (1-4, default 1): # 回车First sector (2048-2065023, default 2048): #回车Last sector, +sectors or +size&#123;K,M,G,T,P&#125; (2048-2065023, default 2065023): # 回车Created a new partition 1 of type 'Linux' and of size 1007.3 MiB.Command (m for help): w # 输入w回车，保存并退出The partition table has been altered.Calling ioctl() to re-read partition table.Syncing disks. 经过以上的操作，你可以用fdisk -l命令查看U盘上是否只有一个Linux分区 1234567$ fdisk -l # 找到你的设备 可以看到ID为83就对了Disk /dev/sda: 30.7 GB, 30752000000 bytes64 heads, 32 sectors/track, 29327 cylindersUnits = cylinders of 2048 * 512 = 1048576 bytesDevice Boot Start End Blocks Id System/dev/sda1 2 29327 30029824 83 Linux 四、格式化分区分区已经有了，现在开始格式化，其实现在的分区已经是ext4格式的了，不过我们还是对它进行一下格式化，算是熟悉一下命令，以后直接这样格式化吧123456789$ mkfs.ext4 /dev/sda1 # 如果你的硬盘比较大，256G以上的话，是这个命令：mkfs.ext4 -T largefile /dev/sda1mke2fs 1.43.3 (04-Sep-2016)/dev/sda1 contains a ext4 file system labelled 'ONMP'last mounted on Sun Nov 12 09:21:22 2017Proceed anyway? (y,n) y # 输入y回车$ umount /dev/sda1 # 如果出错，可能是因为已经被挂载了，先执行这个卸载 这样，U盘就被格式化完了 修改opt挂载当出现opt资源空间不足问题时，服务是无法正常启动的。 我们先查看下空间使用情况，两个指令，分别是:1234567891011121314151617181920212223242526df -h #查看空间df -i #这个命令的节点空间查看``` ![](http://ww1.sinaimg.cn/large/6f9f3683ly1fz8uovlawtj20k907pq33.jpg)原来的是100%，是在内存卡上的ada1 这个是我的u盘我吧这个opt文件挂载到u盘上mount /dev/sda1 /opt然后重启，就可以了现在你继续用LNMP就 可以了## opt下载失败/解压失败曾经遇到这个问题，当出现时，可以手动下载来解决，过程如下。1、首先在U盘或者SD卡的分区一上建立一个opt 目录：例如 ```bashmkdir /media/AiCard_01/opt -p 这里的目录可能和你的存储设备不同。 2、重启路由，确定你的opt目录已经正确mount了。输入 mount ，看到有如下字样1/dev/mmcblk0p1 on /opt type ext4 (rw,noatime,data=ordered) 说明成功了。 3、然后手动下载 opt.tgz 文件，目前有两个下载地址：12cd /optwget https://bitbucket.org/hiboyhiboy ... aster/optupang7.tgz -O opt.tgz 或者12wget https://raw.githubusercontent.co ... aster/optupang7.tgz -O opt.tgz 也可以使用 curl1curl https://bitbucket.org/hiboyhiboy ... aster/optupang7.tgz -o opt.tgz -k 或者1curl https://raw.githubusercontent.co ... aster/optupang7.tgz -o opt.tgz -k 这个时候可以看到下载进度条开始慢慢跑了，是的，两个都很慢。 当下载进度条到了100%以后，再把opt 功能打开， 参考资料1.如何在路由器上格式化 U 盘为 ext42.【LNMP】: /opt 已用节点空间100%/100%]]></content>
      <tags>
        <tag>路由器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小米路由器R3G刷机指南]]></title>
    <url>%2F2018%2F12%2F20%2F%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A8R3G%E5%88%B7%E6%9C%BA%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[小米路由刷机指南1. 开箱并刷机至开发板为了能够获得更高权限，开箱后必须要刷开发板，这个是官方支持的，没有什么风险，步骤如下： 在miwifi.com官网下载路由器对应的开发版ROM包，并将其放在U盘的根目录下，命名为miwifi.bin 断开小米路由器的电源，将U盘插入路由器的USB接口 按下reset按钮后重新接入电源，待指示灯变为黄色闪烁状态后松开reset键 等待5~8分钟，刷机完成之后系统会自动重启并进入正常的启动状态（指示灯由黄灯常亮变为蓝灯常亮），此时，说明刷机成功完成 2. 开启SSH权限与一般的OPENWRT的路由器不太相同，开启SSH权限需要小米账号以及官方文件的支持。主要有以下步骤: 使用小米路由APP登陆管理界面，绑定小米账号 到小米路由官网下载SSH工具，如下图 根据官网提示，将SSH工具下载到U盘，开启SSH权限 3. 刷入BreedBreed就是一个不死UBOOT，有了它，不用担心刷机成砖的问题，因此首先刷入该文件，为了方便，将之后用的文件全部下载好 breed 链接：https://pan.baidu.com/s/1zI0e_R6qySDj-TpjqracUw提取码：n41w复制这段内容后打开百度网盘手机App，操作更方便哦 padavan固件：链接：https://pan.baidu.com/s/14DYiNJWjpN3_S6eCoRHT_Q提取码：9gpj复制这段内容后打开百度网盘手机App，操作更方便哦 首先刷入breed，通过WINSCP与路由连接，小米官方固件下，地址为196.168.31.1，登录名root，密码为刚才ssh工具官网中所给的密码。 登陆后，将breed.bin文件拖入根目录下的tmp文件夹，打开终端，输入指令mtd -r write /tmp/breed.bin Bootloader 刷入后，机器会重新启动，手动设置电脑有线网卡的IP为192.168.1.3 电脑与路由器WAN口连接 用牙签顶住路由的reset键再开机，等到路由的灯狂闪的时候，松开reset键， 电脑上在浏览器中输入192.168.1.1，就进入不死breed的控制台了 4. 进入Breed，备份原来的固件 进入Breed，选择固件备份，然后将原来的内容进行备份，有备无患。 备份 提取码：k2x7 5. 刷入固件刷入刚才下载的padavan固件 刷入后，路由管理地址变为: 192.168.123.1 管理账号和密码均为admin 6. 补充gl-inet 6404路由的管理页面为192.168.8.1]]></content>
      <tags>
        <tag>路由器</tag>
        <tag>黑科技</tag>
        <tag>刷机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的几种设计模式]]></title>
    <url>%2F2018%2F12%2F16%2F2018-12-16-inherit-in-javascript%2F</url>
    <content type="text"><![CDATA[单例模式12345678910 var person = &#123; name : "Tom", age: 12&#125;var person1 = &#123; name : "toony", age : "11"&#125; 这就是单例模式 作用： 实现分组，把描述同一个事物的属性和方法放在了同一个空间中，起到了分组的作用，避免了相同变量名之间的干扰 在单例模式中，我们把对象名叫命名空间 单例模式是我们项目中常用的模式，因为可以利用它进行模块化开发。 12345678//同样都用change方法，为了避免污染var sideBar = &#123; change : function ()&#123;&#125;&#125;var headBar = &#123; change : function ()&#123;&#125;&#125; 工厂模式为了实现”低冗余，高聚合“的方式，为了批量生产，于是有了工厂模式。 12345678910function creatPerson(name,age)&#123; var obj = &#123;&#125;; obj.name = name; obj.age = age; obj.writeJs = function () &#123; console.log('ha' + obj.name + 'can write JS'); &#125; return obj;&#125; 于是，不用像单例模式那样，进行多次的重复的写内容了 12var person1 = creatPerson("tom",15);var person2 = creatPerson("tony",22); 特点： 把实现相同功能的代码放到一个函数中，以后再想实现这个功能，不需要重新编写代码，只要运行代码即可 &gt;&gt;&gt;我们把这个叫函数的封装 ==低耦合，高内聚== 面向对象的编程语言 封装 封装已经实现，就是函数 继承 通过原型链实现 多态 当前方法和类的多种姿态，包括 重载和重写 多态之重载方法名相同，参数类型、个数不同。但是，JS中没有重载，因为当重复写的时候，会被覆盖 12function sum (num,num)&#123;&#125;function sum (num) &#123;&#125; 这是不行的，因此JS是没有重载的(overload)！！但是可以通过if语句判断，来模拟实现重载(overload)但是JS有多态，因为有重写 构造函数模式12345678910function CreatPerson (name,age) &#123; this.name = name; this.age = age; this.writeJs = function ()&#123; console.log("my name is " + this.name + "I can write JS"); &#125;&#125;var tom = CreatPerson("tom",12); 这就是构造函数设计模式，注意方面里面的this是在调用的时候，才知道指向谁； 而前面的属性上的this，则是在构造函数时，指向实例。 因为构造函数，遇到new 的时候，会自己创建一个this对象，最后再自动返回this对象。 这种，在内建对象中，也有类似的模式，比如创建数组：12var arr = [];var arr1 = new Array(); 不管哪组方式，arr都是 Array的实例。但是注意： 不同实例的方法虽然名称相同，但是是不同的东西，那是各自实例的私有属性，单独的个体。 这个不是单例模式，而是构造函数模式有的时候，面试官认为这个是单例模式，实际上，这并不是，这个是构造函数模式，也创造了单独的对象，但是在W3C中是可以查询的！ JS中，所有类都是函数数据类型的，它与函数没有很大的区别。只不过在new的时候，会自动创建一个this对象，最后再自动返回。 (注意，实例都是object类型) 构造函数中，this.xxx中的this都是指向实例本身。 在方法中，this需要等待调用才有所指代 p1和p2中都是同一个类的实力，都有相同的方法，但是那是私有属性，是单独个体，不相等。 还有一些特点(扩展) var p1 = new CreatPerson 在构造函数中，如果没有参数，括号可以省略. 但是函数执行是不可以省略的 如果提前return了一个对象，则会返回新的对象；如果返回一个基本数据类型，则没有任何影响 测一个实例是否是一个类的实力 instanceof 1234console.log(p1 instanceof CreatPerson); //trueconsole.log(p1 instanceof(CreatPerson)); //trueconsole.log(p1 instanceof Array) ; //falseconsole.log(p1 instanceof Object) ; //true 检测数据类型来说，typeof不能准确检测Array的具体类型(只能返回object)。 可以使用istanceof 1234var arr = [];console.log(arr istanceof Array); //true//也可以使用Object下的console.log(Object.prototype.toString(arr)) //返回[object Array] 检测某一个实例是否有某个属性 in 12345var obj = &#123; name : "tom", age : 12&#125;console.log("age" in obj) //true; 注意in无论是共有(prototype)还是私有的，都会返回。 因此，为了检测私有属性，有hasOwnProperty 检测某一个属性是否是私有属性 hasOwnProperty 1console.log(obj.hasOwnProperty('age')) //true; 检测某一个实例是否有某个属性 in 123function hasPubProperty (obj,property) &#123; return property in obj &amp;&amp; !obj.hasOwnProperty(property);&#125; 原型链模式 数组去重,链式写法 1234567891011121314Array.prototype.myUnique = function () &#123; var obj = &#123;&#125;; for(var i = 0; i &lt; this.length; i++ )&#123; var cur = this[i]; if(obj[cur] == cur)&#123; this[i] = this[this.length -1]; this.length--; i--; continue; &#125; obj[cur] = cur; &#125; return this; //实现链式写法&#125; 写一个mySlice方法 12345678910111213141516Array.prototype.mySlice = function (start,end) &#123; var arr = [], rArr = []; start &lt; 0? start += this.length : start; end &lt; 0? end += this.length : end; end &gt;= this.length? end = this.length : end; for(var i = 0; i&lt; this.length - 1 ; i++)&#123; if(start &lt;= i)&#123; arr[arr.length] = this[i]; &#125; if(end == i-1)&#123; break; &#125; &#125; return arr; &#125; 原型链批量设置共有属性的小问题当有多项属性、方法需要在原型链上配置的时候，可以使用批量设置，但是注意，一定要设置好constuctor 12345678Myfun.prototype = &#123; constructor: Myfun, this.show: function () &#123; console.log(this.name); &#125;, ...&#125; 记住这张图中的内容，这种设置方式相当于新开辟的一个内存地址来保存prototype，如果没有设置contructor，这个时候，constructor 就会指向Object。 另一方面，如果直接内置的类上批量添加，因为会覆盖原有的很多方法，因此浏览器会屏蔽这种设置方法 12Array.prototype = &#123;&#125;//这种方法无效 原型继承 最常用的方法； 子类B想要继承父类A中所有的属性和方法（私有+共有)，让B的prototype = A的实例。B.prototype = new A 原型继承特点，父类私有和共有的都变成了子类私有的方法和属性。圣杯模式 123456789var inherit = (function () &#123; var function F() &#123;&#125; return function (Origin,Target)&#123; F.prototype = Origin.prototype; Target.prototype = new F； Target.prototype.constructor = Target; Target.prototype.uber = Origin;&#125;&#125; ()) 中间类继承这个比较特殊，主要用在一个问题上: 当遇到argument[]这种类数组时，无法使用数组的方法，很蛋疼。比如想封装一个平均值的方法 12345678910function avgFn() &#123; var sum; Array.prototype.sort.call(arguments,function (a,b) &#123;return a-b&#125;); //升序排列，扔掉一个最大，一个最小 Array.prototype.pop().call(arguments); Array.prototype.shift().call(arguments); for(var i = 0; i &lt; arguments.length; i++)&#123; sum += arr[i] &#125; return sum/arguments.length;&#125; 显得很麻烦，因为要通过调用Array的方法。所以，这里可以直接修改类数组(同样也是对象)的__proto__ 属性12arguments.__proto__ = Array.prototype;...]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端开发</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一篇帮你彻底弄懂NodeJs中的Buffer]]></title>
    <url>%2F2018%2F10%2F09%2F2018-10-09-Better-understand-Buffer-in-Node-js%2F</url>
    <content type="text"><![CDATA[原文链接 你是不是和我一样，对Node.js中的Buffer, Stream, 和 二进制数据一直都是很模糊的印象? 或者有的时候觉得，哎，我会用就行了，这些原理、底层的东西，应该交给Node.js的工程师们去理解。 的确，这些名词可能会比较初学者感到恐惧和陌生，特别是那些刚从前端转全栈，做Node.js，却没有计算机基础的同学来说。 但是很遗憾，很多教程或者书籍都会直接跳过这些原理和解释的部分，直接教你怎么使用Node.js的一些库、工具或者API，但是对于核心的部分、为什么这样处理和使用，却只字未提。甚至有些直接告诉你：“你根本不需要理解这些，因为你在工作中可能永远不会直接使用它” 是的，如果你想一辈子做一个平庸的程序员，的确可以在工作中不直接使用。 然而，如果那些迷惑和模糊的概念，能引起你的好奇，并不断保持这种好奇心去学习和探索，那么你对Node.js的理解就会更上一层楼，然后你就会更愿意去学习和了解Node.js一些核心的、原理性的东西，比如Buffer, Stream。 这也就是我写这篇文章的原因–去帮助你更好的、更深入的去理解Node.js。 当说到Buffer，官方是这么说的： …JavaScript 语言没有读取或操作二进制数据流的机制。 Buffer 类被引入作为 Node.js API 的一部分，使其可以在 TCP 流或文件系统操作等场景中处理二进制数据流。 嗯..尴尬，除非你已经有一些计算机基础，否则上面这句话说了只能让你脑袋更大。我们尝试简化一下，把主要含义提炼一下，可以这么说： Buffer类被引入到Node.js的API中，让其与二进制数据流的操作和交互成为可能 这样是不是简单的多了？ 但是…Buffer，streams和二进制数据又是什么东西呢？我们从后向前，一个一个解释下。 二进制数据是什么鬼？你应该已经知道，计算机存储和表示数据使用二进制的。比如，下面这些是5个二进制数，5个不同的1和0序列： 10, 01, 001, 1110, 00101011 二进制中的每个数字，0或1叫做位(bit)，也就是Binary digIT的缩写。 为了能够存储和表示这些数据，计算机需要将数据转换为二进制形式。比如，要存储数字12，计算机需要将12转化为二进制1100 计算机怎么知道要如何去转换？这就完全是一个数学问题了。计算机是知道怎么去处理的，有兴趣的可以自己查阅。 但是，我们日常工作的数据类型不仅仅是数字。我们还有字符、图片甚至视频。计算机是知道如何将这些表示为二进制的。就拿字符来说，比如计算机如何用二进制来表示”L“这个字母。为了将数据存储为二进制形式，无论任何类型的数据都会先被转换为数字，然后将数字转为二进制形式。所以为了表示”L“，计算机首先将L转换为数字表示，我们看下怎么做到这一点。 打开你的浏览器控制台，然后粘贴下面的代码：&quot;L&quot;.charCodeAt(0)。你看到了什么？数字76？这就是字母L的数字编码。但是计算机怎么知道具体哪个数字代表那个字母呢？ 字符集字符集就是定义数字所代表的字符的一个规则表，同样定义了怎样用二进制存储和表示。那么，用多少位来表示一个数字，这个就叫字符编码(Character Encoding) 有一种字符编码叫做UTF-8。它规定了，字符应该以字节为单位来表示。一个字节是8位(bit)。所以8个1和0组成的序列，应该用二进制来存储和表示任意一个字符。 为了更好的理解，举个例子： 比如之前提到的12的二进制表示是1100。 所以，使用UTF-8的格式来表示，应该使用一个字节，也就是8位来完整表示，也即00001100， 没有错吧？ 因此，76在计算机中的存储形式应该是01001100。 这就是计算机将字符存储成二进制的方式。当然，计算机也有一些特殊规则，将图片、视频等存储为二进制的，总之，计算机会将无论图片、视频或其他数据都转换为二进制并存储，这就是我们说的二进制数据。 如果你对字符编码非常感兴趣，那你可以参考一下这篇文章 现在我们了解了什么是二进制数据，但是我们介绍buffer的时候，说的二进制数据流(streams of binary data)又是什么呢？ Stream在Node.js中，流(stream)就是一系列从A点到B点移动的数据。完整点的说，就是当你有一个很大的数据需要传输、搬运时，你不需要等待所有数据都传输完成才开始下一步工作。 实际上，巨型数据会被分割成小块(chunks)进行传输。所以，buffer的原始定义中所说的(“streams of binary data… in the context of… file system”)意思就是说二进制数据在文件系统中的传输。比如，将file1.txt的文字存储到file2.txt中。 但是，buffer到底在流(stream)中，是如何操作二进制数据的？buffer到底是个什么呢？ Buffer我们已经知道数据流(stream of data)是从一个地方向另一个地方传输数据的过程，但是这个具体是怎么样的一个过程？ 通常情况下，我们传输数据往往是为了处理它，或者读它，或者基于这些数据做处理等。但是，在每次传输过程中，有一个数据量的问题。因此当数据到达的时间比数据理出的时间快的时候，这个时候我们处理数据就需要等待了。 领域覅那个面，如果处理数据的时间比到达的时间快，这一时刻仅仅到达了一小部分数据，那这小部分数据需要等待剩下的数据填满，然后再送过去统一处理。 这个”等待区域”就是buffer! 它是你电脑上的一个很小的物理地址，一般在RAM中，在这里数据暂时的存储、等待，最后在流(stream)中，发送过去并处理。 我们可以把整个流(stream)和buffer的配合过程看作公交站。在一些公交站，公车在没有装满乘客前是不会发车的，或者在特定的时刻才会发车。当然，乘客也可能在不同的时间，人流量大小也会有所不同，有人多的时候，有人少的时候，乘客或公交站都无法控制人流量。 不论何时，早到的乘客都必须等待，直到公车接到指令可以发车。当乘客到站，发现公车已经装满，或者已经开走，他就必须等待下一班车次。 总之，这里总会有一个等待的地方，这个等待的区域就是Node.js中的Buffer Node.js不能控制数据什么时候传输过来，传输速度，就好像公交车站无法控制人流量一样。他只能决定什么时候发送数据。如果时间还不到，那么Node.js就会把数据放入buffer–”等待区域”中，一个在RAM中的地址，直到把他们发送出去进行处理。 一个关于buffer很典型的例子，就是你在线看视频的时候。如果你的网络足够快，数据流(stream)就可以足够快，可以让buffer迅速填满然后发送和处理，然后处理另一个，再发送，再另一个，再发送，然后整个stream完成。 但是当你网络连接很慢，当处理完当前的数据后，你的播放器就会暂停，或出现”缓冲”(buffer)字样，意思是正在收集更多的数据，或者等待更多的数据到来，才能下一步处理。当buffer装满并处理好，播放器就会显示数据，也就是播放视频了。在播放当前内容的时候，更多的数据也会源源不断的传输、到达和在buffer等待。 如果播放器已经处理完或播放完前一个数据，buffer仍然没有填满，”buffering”(缓冲)字符就会再次出现，等待和收集更多的数据。 这就是Buffer！ 从原始的定义，我们知道，buffer可以在stream中与二进制数据进行交互和操作。那么到底可以进行什么样的操作呢？在Node.js中又应该如何进行刚才所描述的一些东西呢？我们来瞧一瞧。 与Buffer共舞你甚至可以做你自己的buffer！ 在stream中，Node.js会自动帮你创建buffer之外，你可以创建自己的buffer并操作它，是不是很有趣？ 我们来搞一个！ 根据你的需求，这里有不同的创建方式，我们一起看一下吧： 12345678// 创建一个大小为10的空buffer// 这个buffer只能承载10个字节的内容const buf1 = Buffer.alloc(10);// 根据内容直接创建bufferconst buf2 = Buffer.from("hello buffer"); 创建了之后，你就可以操作buffer了 1234567891011121314151617181920212223242526// 检查下buffer的结构buf1.toJSON()// &#123; type: 'Buffer', data: [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] &#125;// 一个空的bufferbuf2.toJSON()// &#123; type: 'Buffer',data: [ 104, 101, 108, 108, 111, 32, 98, 117, 102, 102, 101, 114 ] &#125;// the toJSON() 方法可以将数据进行Unicode编码并展示 // 检查buffer的大小buf1.length // 10buf2.length //12 根据数据自动盛满并创建//写入数据到bufferbuf1.write("Buffer really rocks!")//解码bufferbuf1.toString() // 'Buffer rea'//哦豁，因为buf1只能承载10个字节的内容，所有多处的东西会被截断//比较两个buffers 当然，在Node.js中，还有更多更丰富的方法来操作buffer，你可以参考这里，然后去尝试更多的方法。 最后，我想给你一个小小的挑战：去阅读zlib.js的源码，一个Node.js的核心库，去看一下它是如何利用buffer这个神器去操作二进制数据流的。处理后，最后变成gziped文件。 当你在阅读的时候，记录下你的学习经历并在评论中分享下来吧。 我希望这个介绍可以帮你更好的理解Node.js中的Buffer。 如果你觉得我这篇文章还不错，为了能让更多人看到，请点个赞吧，可以让这篇文章更好的传播，让更多人看到。 如果你有任何问题，或者有不同的理解，请尽情的评论提出或者通过twitter找我哦。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端开发</tag>
        <tag>Node.js</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学生时代的最后一个教师节]]></title>
    <url>%2F2018%2F09%2F10%2F2018-09-10-Teachers-day%2F</url>
    <content type="text"><![CDATA[我一直都在扮演着别人口中的角色，一路上我遇到的每个恩师，似乎都能看出我这种“虚伪”, 于是他们每次把我说的异常优秀：”成绩好、自我约束力强、管理能力强、能成大器”，然后我就不自觉地尝试出演他们口中所说的高闻灿，一直到今天…. 终得贵人助一月，在重庆璧山的一个古巷中，偶得一签，签曰：“……… 终得贵人助” 前面的话我已经记不清楚了，于是在本该充满欢声笑语中新年氛围中，我也不禁皱眉，心想: 今年找工作会一帆风顺吗？ 我一直都不自信，唯一自信的来源是别人对我的描述和信任，我会为了不辜负这份信任，不惜拼尽一切去维护好这份信任。于是我一直都在扮演着别人口中的角色，一路上我遇到的每个恩师，似乎都能看出我这种“虚伪”, 于是他们每次把我说的异常优秀：”成绩好、自我约束力强、管理能力强、能成大器”，然后我就不自觉地尝试出演他们口中所说的高闻灿，一直到今天…. 暑假今年暑假，不算酷暑，却丝毫没有凉意 实习从未间断，每天挤地铁、晚回家，在后半阶段，实习的同时还得时时关注秋招进展，确实是人困马乏。 未能见亲人一眼，可至少结局不负有心人 8月底，看着手上的几个Offer，会心一笑，当初的焦虑也减轻了不少，心想：”终于可以继续维护了那些人对我的期望和信任…“ 教师节有那么一瞬间，自己心里也会恍惚一下：“ 那么久了，第一时间想到的竟然还是别人的评价、信任和责任 ” 但是这些却都是潜意识的，因为这个高闻灿，是父母教育、恩师指导和贵人帮助所共同“创造”出来的。 初中的郭老师、谢老师、王老师成功的让一个调皮的学生变得有追求、有理想； 高中的黄老师则是给予该学生自信、理念和赋予价值观的第一人，熊爷、池哥、陆哥、加强哥、帆哥等育才精英共同让他成长为一个完整的人； 大学，川大测控系老师，则表现出”海纳百川、有容乃大“的情怀，让学生初探象牙塔内的光环； 而现在，若不是导师在4月份提前放行实习，学生也没机会在7、8月份顺利的找工作 …… 总遇贵人时间匆匆的溜到了在校时期的最后一个教师节 回想过往，感想颇多 现在很少矫情的去写日志或什么 但是总觉得走到今天，是我一路总遇贵人 矫情也好、肉麻也罢 在此，感谢所有的老师，谢谢 没能像往日朝夕相处，但能每年一念，望保重身体，来日一聚！ 这些恩师，是贵人中的贵人]]></content>
      <tags>
        <tag>感悟</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转载]Class vs Factory function: exploring the way forward]]></title>
    <url>%2F2018%2F09%2F06%2F2018-09-06-Class-vs-Factory-function%2F</url>
    <content type="text"><![CDATA[一直以为ES6出了后，新特性都是值得推广、使用的，直到看了这篇文章，甚有醍醐灌顶之感，来不及翻译，直接转载过来（原文需要翻墙查看） 原文地址：Class vs Factory function: exploring the way forward ECMAScript 2015 (aka ES6) comes with the class syntax, so now we have two competing patterns for creating objects. In order to compare them, I’ll create the same object definition (TodoModel) as a class, and then as a factory function. TodoModel as a Class 123456789101112class TodoModel &#123; constructor()&#123; this.todos = []; this.lastChange = null; &#125; addToPrivateList()&#123; console.log(&quot;addToPrivateList&quot;); &#125; add() &#123; console.log(&quot;add&quot;); &#125; reload()&#123;&#125;&#125; TodoModel as a Factory Function 123456789101112131415function TodoModel()&#123; var todos = []; var lastChange = null; function addToPrivateList()&#123; console.log(&quot;addToPrivateList&quot;); &#125; function add() &#123; console.log(&quot;add&quot;); &#125; function reload()&#123;&#125; return Object.freeze(&#123; add, reload &#125;);&#125; EncapsulationThe first thing we notice is that all members, fields, and methods of a class object are public. 1234var todoModel = new TodoModel();console.log(todoModel.todos); //[]console.log(todoModel.lastChange) //nulltodoModel.addToPrivateList(); //addToPrivateList The lack of encapsulation may create security problems. Take the example of a global object that can be modified directly from the Developer Console. When using factory function, only the methods we expose are public, everything else is encapsulated. 12345var todoModel = TodoModel();console.log(todoModel.todos); //undefinedconsole.log(todoModel.lastChange) //undefinedtodoModel.addToPrivateList(); //taskModel.addToPrivateList is not a function thisthis losing context problems are still there when using class. For example, this is losing context in nested functions. It is not only annoying during coding, but it’s also a constant source of bugs. 123456789101112class TodoModel &#123; constructor()&#123; this.todos = []; &#125; reload()&#123; setTimeout(function log() &#123; console.log(this.todos); //undefined &#125;, 0); &#125;&#125;todoModel.reload(); //undefined or this is losing context when the method is used as a callback, like on a DOM event. 1$(&quot;#btn&quot;).click(todoModel.reload); //undefined There are no such problems when using a factory function, as it doesn’t use this at all. 1234567891011function TodoModel()&#123; var todos = []; function reload()&#123; setTimeout(function log() &#123; console.log(todos); //[] &#125;, 0); &#125;&#125;todoModel.reload(); //[]$(&quot;#btn&quot;).click(todoModel.reload); //[] this and arrow functionThe arrow function partially solves the this loosing context issues in classes, but at the same time creates a new problem: this is no longer loosing context in nested functions this is loosing context when the method is used as a callback arrow function promotes the use of anonymous functions I refactored the TodoModel using the arrow function. It’s important to note that in the process of refactoring to the arrow function we can loose something very important for readability, the function name. Look for example at: 12345678//using function name to express intentsetTimeout(function renderTodosForReview() &#123; /* code */ &#125;, 0);//versus using an anonymous functionsetTimeout(() =&gt; &#123; /* code */ &#125;, 0); Immutable APIOnce the object is created, I’m expecting its API to be immutable. I can easily change the implementation of a public method to do something else when it was created using a class. 12todoModel.reload = function() &#123; console.log(&quot;a new reload&quot;); &#125;todoModel.reload(); //a new reload This problem can be solved by calling Object.freeze(TodoModel.prototype)after the class definition. The API of the object created using a factory function is immutable. Notice the use of Object.freeze() on the returned object containing only the public methods. The private data of the object can be modified, but only through these public methods. 12todoModel.reload = function() &#123; console.log(&quot;a new reload&quot;); &#125;todoModel.reload(); //reload newnew should be used when creating objects using classes. new is not required when creating objects with factory functions, but if that makes it more readable, you can go for it, there is no harm. 1var todoModel= new TodoModel(); Using new with a factory function will just return the object created by the factory. Composition over inheritanceClasses support both inheritance and composition. Below is an example of inheritance where SpecialService class inherits from Service class: 123456789class Service &#123; doSomething()&#123; console.log(&quot;doSomething&quot;); &#125;&#125;class SpecialService extends Service &#123; doSomethingElse()&#123; console.log(&quot;doSomethingElse&quot;); &#125; &#125;var specialService = new SpecialService();specialService.doSomething();specialService.doSomethingElse(); Here is another example where SpecialService reuses member of Serviceusing composition: 12345678910111213141516class Service &#123; doSomething()&#123; console.log(&quot;doSomething&quot;); &#125;&#125;class SpecialService&#123; constructor(args)&#123; this.service = args.service; &#125; doSomething() &#123; this.service.doSomething(); &#125; doSomethingElse()&#123; console.log(&quot;doSomethingElse&quot;); &#125;&#125;var specialService = new SpecialService(&#123; service : new Service()&#125;);specialService.doSomething();specialService.doSomethingElse(); Factory functions promote composition over inheritance. Take a look at the next example where SpecialService reuses members of Service : 12345678910111213141516171819function Service() &#123; function doSomething()&#123; console.log(&quot;doSomething&quot;); &#125; return Object.freeze(&#123; doSomething &#125;);&#125;function SpecialService(args)&#123; var service = args.service; function doSomethingElse()&#123; console.log(&quot;doSomethingElse&quot;); &#125; return Object.freeze(&#123; doSomething : service.doSomething, doSomethingElse &#125;);&#125;var specialService = SpecialService(&#123; service : Service()&#125;);specialService.doSomething();specialService.doSomethingElse(); MemoryClasses are better at memory conservation, as they are implemented over the prototype system. All methods will be created only once in the prototype object and shared by all instances. The memory cost of the factory function is noticeable when creating thousands of the same object. Here is the page used for testing the memory cost when using factory function. 123456789The memory cost (in Chrome)+-----------+------------+------------+| Instances | 10 methods | 20 methods |+-----------+---------------+---------+| 10 | 0 | 0 || 100 | 0.1Mb | 0.1Mb || 1000 | 0.7Mb | 1.4Mb || 10000 | 7.3Mb | 14.2Mb |+-----------+------------+------------+ Objects vs Data StructuresBefore analyzing the memory cost any further, a distinction should be made between two kinds of objects: OOP Objects Data Objects (aka Data Structures) Objects expose behavior and hide data. Data Structures expose data and have no significant behavior. — Robert Martin “Clean Code” I’ll take a look again at the TodoModel example and explain these two kinds of objects. 1234567891011function TodoModel()&#123; var todos = []; function add() &#123; &#125; function reload()&#123; &#125; return Object.freeze(&#123; add, reload &#125;);&#125; TodoModel is responsible for storing and managing the list of todos. TodoModel is the OOP Object, the one exposing behavior and hiding data. There will be only one instance of it in the application, so there’s no extra memory cost when using the factory function. The todos objects represent the Data Structures. There may be a lot of these objects, but they are just plain JavaScript objects. We are not interested in keeping their methods private — rather we actually want to expose all their data and methods. So all these objects will be built over the prototype system, and they will benefit from the memory conservation. They can be built using a simple object literal or Object.create() . UI ComponentsIn the application, there may be hundreds or thousands of instances of a UI component. This is a situation where we need to make a trade-off between encapsulation and memory conservation. Components will be built according to the component framework practice. For example, object literals will be used for Vue, or classes for React. Each component’s members will be public, but they will benefit from the memory conservation of the prototype system. ConclusionThe strong points of class are its familiarity for people coming from a class-based background and its nicer syntax over the prototype system. However, its security problems and the usage of this, a continuous source of losing context bugs, makes it a second option. As an exception, classes will be used if required by the component’s framework, as in the case of React. Factory function is not only the better option for creating secured, encapsulated, and flexible OOP Objects but also opens the door for a new, unique to JavaScript, programming paradigm. I think Class Free Object Oriented Programming is JavaScript’s gift to humanity. — Douglas Crockford “The Better Parts”]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>转载</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VK的秋招前端奇遇记(四)]]></title>
    <url>%2F2018%2F09%2F04%2F2018-09-04-VK-mistake-4%2F</url>
    <content type="text"><![CDATA[嗯，上次写blog已经是几周前的事情了，其实已经积攒了很多小问题需要记录和分享了。但是在8月底，VK我一次经历了了携程、拼多多、腾讯、网易等多轮面试轰炸，忙得不可开交，有喜有忧的同时，还是赶快记录了不足，把一些充满迷惑性的问题继续记录和学习。 JavaScript总是给人以惊喜，学习不止，进步不断，今天继续补充JS容易搞错的几道笔试/面试题，为了秋招继续努力，欢迎一起为秋招努力的小伙伴共勉 系列笔记： 1.VK的秋招前端奇遇记(一)/) 2.VK的秋招前端奇遇记(二)/) 3.VK的秋招前端奇遇记(三)/) 4.VK的秋招前端奇遇记(四)/) 5.番外篇：前端面试&amp;笔试算法 Algorithm 面试&amp;常识题Q1. forEach 与 map的区别？ forEach不支持中断循环？这是一道巨坑的题目 先看下很多博客、文章总结的一个关于循环的区别是怎么说的 map可以做链式操作、forEach不可以 map有返回值,return、 forEach没有返回值 for循环不用担心兼容性问题，可以break跳出循环，是基础循环 forEach不支持continue和break，是不能退出循环本身的。 上面这些比较，本身没有什么问题，但是当第三点和第四点结合的时候，就很容易让人有个推论： map是可以跳出循环的，可以提前中断 然而，也的确有些面试官，认为forEach不能break，map是可以的跳出的。 真的是这样的？ 首先，众所周知，forEach是不能用break提前中断循环的，如果使用了，会直接报错。比如以下： 123456var list = [1,2,3,4];list.forEach(item =&gt; &#123; if(item === 2) &#123; break; &#125;&#125; ) 但是，如果真的想要中止？ 因为会报错，这也提供给我们一个思路，那就是用try..catch把它保住，捕获错误。 但是，个人认为真是多此一举，应该没人会这么用。就不多做讨论了。 那么map可以用break吗？ 很显然，它也不行。所以如果有面试官问你，甚至告诉你”forEach和map的不同，forEach不可以中止”时，你真的可以大胆回击： 想要用Array.prototype.map实现break,也是完全不可能的 map中文翻译为映射，所谓映射，当然是把数组中每个值进行映射处理，有何理由中断循环，特殊处理？ Q2. 对象与继承请问以下程序中，person1和person2哪个是Person的实例？其__proto__分别指向谁? 123456function Person(name) &#123; this.name = name; return &#123;name: name&#125;&#125;var person1 = new Person('sam');var person2 = Person('Lily') Ans12person1和person2都不是Person的实例它们的'__proto__'指向Object 这题题目的关键就是理解new的过程，这也是常见的面试题之一了。如果遇到关键字new，那么，函数就不单单是一个函数了： 函数执行，首先隐式建立对象this 执行，绑定this相关的属性,本例中this.name = name 函数最后，隐式的returnthis 当然，这里简化了这个过程，但是核心是这几步。 但是如果在隐式返回this之前，提前返回了一个对象，那么就会退出函数了。 要知道，只有这个this才是实例本身，它的__proto__才指向构造函数，如果不能把this返回出去，那么一切都是徒劳的。因此，这里无论是否new，都返回的是一个新对象{}。 Q3. 垃圾回收机制方式及内存管理（爱奇艺2018提前批二面）这里，自己当时回答的不好，就引用别人博客整理的内容啦. 回收机制方式 定义和用法：垃圾回收机制(GC:Garbage Collection),执行环境负责管理代码执行过程中使用的内存。 原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。 实例如下： 123456789function fn1() &#123; var obj = &#123;name: 'hanzichi', age: 10&#125;;&#125;function fn2() &#123; var obj = &#123;name:'hanzichi', age: 10&#125;; return obj;&#125;var a = fn1();var b = fn2(); fn1中定义的obj为局部变量，而当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放；在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放。 垃圾回收策略：标记清除(较为常用)和引用计数。 标记清除： 定义和用法：当变量进入环境时，将变量标记”进入环境”，当变量离开环境时，标记为：”离开环境”。某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量。 到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。 引用计数： 定义和用法：引用计数是跟踪记录每个值被引用的次数。 基本原理：就是变量的引用次数，被引用一次则加1，当这个引用计数为0时，被视为准备回收的对象。 内存管理 什么时候触发垃圾回收？ 垃圾回收器周期性运行，如果分配的内存非常多，那么回收工作也会很艰巨，确定垃圾回收时间间隔就变成了一个值得思考的问题。 IE6的垃圾回收是根据内存分配量运行的，当环境中的变量，对象，字符串达到一定数量时触发垃圾回收。垃圾回收器一直处于工作状态，严重影响浏览器性能。 IE7中，垃圾回收器会根据内存分配量与程序占用内存的比例进行动态调整，开始回收工作。 合理的GC方案：(1)、遍历所有可访问的对象; (2)、回收已不可访问的对象。 GC缺陷：(1)、停止响应其他操作； GC优化策略：(1)、分代回收（Generation GC）;(2)、增量GC 说实话，这一块，自己没有很好的整理，但是目前准备秋招和毕设，没有更多的经历，只能待有空再深入学习研究了。 编程题Q1. 表格排序请将以下表格，按年龄进行排序，使用原生JS，不允许使用任何第三方工具。 123456789101112131415161718192021222324252627282930&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;name&lt;/th&gt; &lt;th&gt;age&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;张三&lt;/td&gt; &lt;td&gt;17&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李四&lt;/td&gt; &lt;td&gt;43&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;王五&lt;/td&gt; &lt;td&gt;22&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小刘&lt;/td&gt; &lt;td&gt;9&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;黄三&lt;/td&gt; &lt;td&gt;20&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; Ans:这个其实很easy了，只是我在写的时候，还是调试了好几次，这里主要两点： 通过document.getElementsBytagNames选择的对象，在dom的映射机制下，是双双绑定的； 使用dom.appendChild()方法，要保证参数是node节点。 Array.sort()方法，注意，只能用在Array上。 1234567891011121314var sortByAge = function () &#123; var tbody = document.getElementsByTagName('tbody')[0]; var items = tbody.getElementsByTagName('tr'); let arrayI = Array(...items); //将类数组转化为数组，使用sort方法 arrayI.sort((a,b)=&gt; &#123; let ageA = a.getElementsByTagName('td')[1].innerText; let ageB = b.getElementsByTagName('td')[1].innerText; return ageA - ageB; &#125;) for(let i = 0; i&lt;items.length; i++) &#123; tbody.appendChild(arrayI[i]); //依次插入，这里arrayI的每一个元素都是原来的dom映射过来的实例。所以并不是“创造”出了复制品，而是重新排序了 &#125; &#125;sortByAge(); Q2.时间’0101’转换为正常时间值(杭州有赞2018秋招二面在线编程)一天24小时，我们将其折为每30分钟为一段，这样一天共有48段。我们用1表示这段时间有效，0表示无效，比如10... 表示开始时间为00:00 持续了半个小时,技术时间为00:30。111001.. 则表示00:00~01:30 02:30~03:00两个时间段。 要求写一个函数，对时间码进行转换： 输入：110100000000000000000000000000000000000000000000 输出： [&quot;00:30~01:30&quot;, &quot;01:00~02:00&quot;] Ans这个是我视频面试时的一道编程题，由于时间紧，面对面试官有点小压力，所以就用了比较笨的方法实现了，后来也没有重新思考和优化，有好的思路和简单的方法的小伙伴欢迎交流。 以下思路： 遍历输入字符串 当为1，判断是否为第一次，如果是第一次，根据index，记录startTime；如果不是第一次，进行time累加 当为0，判断之前是否为1，如果之前是1，则根据time值进行累加，计算endTime，并将时间段push到数组 判断是否为第一次、判断之前是否为1，主要通过一个flag进行记录。 根据上面思路，代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940function timeTransfer(str) &#123; var flag = false, //flag，判断是否第一次为1 time = 0, //时间记录值 n = str.length, startTime, //开始时间 startHour, //开始的小时 startMin, //开始的分钟 endTime, //结束时间 endHour, //结束的小时 endMin, //结束的分钟 retTime = []; //最终返回的数组 for(let i = 0 ; i &lt; n; i++) &#123; if(str[i] === '1') &#123; if(flag === false) &#123; //判断是否为第一个1，如果是，根据i设定开始时间 startHour = parseInt(i/2); startMin = i % 2 ? 0:30; startTime = `$&#123;startHour &gt; 9? startHour: '0' + startHour&#125;:$&#123;startMin &gt; 9 ? startMin : '0' + startMin&#125;`; flag = true; //置位 flag &#125; time += 0.5; //时间累加 if(i === n-1) &#123; //如果已经遍历到最后，那么计算结束时间(当str的末尾为1时，需要处理) endHour = startHour + parseInt(time); endMin = startMin + (time % 2 ? 0 : 30); endTime = `$&#123;endHour &gt; 9 ? endHour : '0' + endHour&#125;:$&#123;endMin &gt; 9 ? endMin : '0' + endMin&#125;`; retTime.push(`$&#123;startTime&#125;~$&#123;endTime&#125;`); &#125; &#125; else if (str[i] === '0') &#123; if(flag === false) &#123; //如果为flase，代表前面不是1，继续下次循环 continue; &#125; else &#123; //否则，计算结束时间 flag = false; endHour = startHour + parseInt(time); endMin = startMin + (time % 2 ? 0 : 30); endTime = `$&#123;endHour &gt; 9 ? endHour : '0' + endHour&#125;:$&#123;endMin &gt; 9 ? endMin : '0' + endMin&#125;`; retTime.push(`$&#123;startTime&#125;~$&#123;endTime&#125;`); &#125; &#125; &#125; return retTime; &#125; 以上程序，是跑通了的，虽然有点笨，但是勉强满足要求。 参考资料 csdn wdlhao的博客]]></content>
      <tags>
        <tag>前端面试</tag>
        <tag>JavaScript</tag>
        <tag>前端笔试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS事件机制之Microtasks & Tasks & Queues]]></title>
    <url>%2F2018%2F09%2F04%2F2018-09-04-Tasks-microtasks-queues-and-schedules%2F</url>
    <content type="text"><![CDATA[面试和笔试题目中，经常会出现’promise’,’setTimeout’等函数混合出现时候的运行顺序问题。 我们都知道这些异步的方法会在当前任务执行结束之后调用，但为什么’promise’会在’setTimeout’之前执行？ 具体的实现原理是什么？ 问题的提出上面问题的答案，都在文章《Tasks, microtasks, queues and schedules》讲的非常透彻。 建议英文可以的同学直接看这篇文章，就不要看我这个“笔记”了。( 之所以叫笔记，因为大部分内容出自文章，但是又不是按字翻译 ) 以下的题目是我们刷题可以经常看到的一个常规题目：12345678910111213console.log('script start');setTimeout(function() &#123; console.log('setTimeout');&#125;, 0);Promise.resolve().then(function() &#123; console.log('promise1');&#125;).then(function() &#123; console.log('promise2');&#125;);console.log('script end'); 几乎每个前端er都可以毫不犹豫的给出答案:12345script startscript endpromise1promise2setTimeout 问题来了，为什么promise的异步执行会在setTimeout之前，甚至setTimeout设置的延时是0都不行。 还有在Vue中，我们常用的nextTick()函数原理中，说的microtasks是什么东西？ 一切的解释都在开头给的文章中。 ps： 再次再次声明，这篇文章仍然是我记得笔记，原文比我写的好得多，英文可以的小伙伴强烈推荐看原文。 js异步实现原理我们多多少少都应该听说过event loop，js是单线程的，通过异步它变得非常强大，而实现异步主要就是通过将异步的内容压入tasks，当前任务执行结束之后，再执行tasks中的callback。 Tasks，是一个任务队列，Js在执行同步任务的时候，只要遇到了异步执行和函数，都会把这个内容压入Tasks中，然后在当前同步任务完成后，再去Tasks中执行相应的回调。 举个例子，比如刚才代码中的setTimeout，当遇到这个函数，总会跟一个异步执行的任务(callback)，那么这个时候，Tasks队列里，除了当前正在执行的script之外，会在后面压入一个setTimeout callback， 而这个callback的调用时机，就是在当前同步任务完成之后，才会调用。这就是为什么,’setTimeout’ 会出现在’script end’之后了。 MicroTasks，说一些这个，这个和setTimeout不同，因为它是在当前Task完成后，就立即执行的，或者可以理解成，’microTasks总是在当前任务的最后执行’。 另外，还有一个非常重要的特性是： 如果当前JS stack如果为空的时候(比如我们绑定了click事件后，等待和监听click时间的时候，JS stack就是空的),一会立即执行。 关于这一点，之后有个例子会具体说明，先往下看。 那么MicroTasks队列主要是promise和mutation observer 的回掉函数生成 用新的理论来解释下好了，刚才大概说了几个概念，那么一开始的例子，到底发生了什么？ talk is cheap, show me a animation!!—我自己说的 下面的动画说明对整个过程进行了说明: 1、 程序执行 log: script start Tasks: Run script JS stack: script 2、 遇到setTimeout log: script start Tasks： Run script | setTimeout callback JS stack: script 3、 遇到Promise Tasks: Run script | setTimeout callback Microtasks: promise then JS stack: script 4、 执行最后一行 log: script start | script end Tasks: Run script | setTimeout callback Microtasks: promise then JS stack: script 4、 同步任务执行完毕，弹出相应的stack log: script start | script end Tasks: Run script | setTimeout callback Microtasks: promise then JS stack: 5、 同步任务最后是microTasks，JS stack压入callback log: script start | script end | promise1 Tasks: Run script | setTimeout callback Microtasks: promise then | promise then JS stack: promise1 calback6、 promise返回新的promise，压入microTasks，继续执行 log: script start | script end | promise1 | promise2 Tasks: Run script | setTimeout callback Microtasks: promise then JS stack: promise2 calback 8、 第一个Tasks结束,弹出 log: script start | script end | promise1 | promise2 Tasks: setTimeout callback Microtasks: JS stack: 9、 下一个Tasks log: script start | script end | promise1 | promise2 | setTimeout Tasks: setTimeout callback Microtasks: JS stack: setTimeout callback 好了，结束了，这就比之前的理解”promise比setTimeout快，异步先执行promise，再执行setTimeout”就深刻的多。 因为promise所建立的回掉函数是压入了mircroTasks队列中，它仍然属于当前的Task，而setTimeout则是相当于在Task序列中添加了新的任务 一个更复杂的例子好了，有了刚才的认识和铺垫，接下来通过一个更加复杂的例子来熟悉JS事件处理的一个过程。 现在有这样一个页面结构：123&lt;div class="outer"&gt; &lt;div class="inner"&gt;&lt;/div&gt;&lt;/div&gt; js代码如下,现在如果点击里面的方块，控制台会输出什么呢？在线实例123456789101112131415161718192021222324252627282930// Let's get hold of those elementsvar outer = document.querySelector('.outer');var inner = document.querySelector('.inner');// Let's listen for attribute changes on the// outer elementnew MutationObserver(function() &#123; console.log('mutate');&#125;).observe(outer, &#123; attributes: true&#125;);// Here's a click listener…function onClick() &#123; console.log('click'); setTimeout(function() &#123; console.log('timeout'); &#125;, 0); Promise.resolve().then(function() &#123; console.log('promise'); &#125;); outer.setAttribute('data-random', Math.random());&#125;// …which we'll attach to both elementsinner.addEventListener('click', onClick);outer.addEventListener('click', onClick); 这里先把正确答案公布，按照之前的理论，正确答案应该是：12345678clickpromisemutateclickpromisemutatetimeouttimeout 当然，不同浏览器，对于event loop的实现会稍有不同，这个是chrome下打印出来的结果，具体的其他形式还是推荐大家看原文了。 下面分析下，为什么是上面的顺序呢？ 代码分析按照刚才的结论： click事件显然是一个Task，Mutation observer和Promise是在microTasks队列中的，而setTimeout会被安排在Tasks之中。 因此 1、点击事件触发 Tasks: Dispatch click Microtasks: JS stack: 2、触发点击事件的函数，函数执行，压入JS stack Tasks: Dispatch click Microtasks: JS stack: onClick Log: ‘click’ 3、遇到setTimeout，压入Tasks队列 Tasks: Dispatch click | setTimeout callBack Microtasks: JS stack: onClick Log: ‘click’ 4、遇到promise，压入Microtasks Tasks: Dispatch click | setTimeout callBack Microtasks: Promise.then JS stack: onClick Log: ‘click’ 5、遇到 outer.setAttribute，触发mutation Tasks: Dispatch click | setTimeout callBack Microtasks: Promise.then | Mutation observers JS stack: onClick Log: ‘click’ 6、onclick函数执行完毕，出JS stack Tasks: Dispatch click | setTimeout callBack Microtasks: Promise.then | Mutation observers JS stack: Log: ‘click’ 7、这个时候，JS stack为空，执行Microtasks Tasks: Dispatch click | setTimeout callBack Microtasks: Promise.then | Mutation observers JS stack: PromiseCallback Log: ‘click’ ‘promise’ 8、microtasks顺序执行 Tasks: Dispatch click | setTimeout callBack Microtasks: Mutation observers JS stack: Mutation callback Log: ‘click’ ‘promise’ ‘mutate’ 接下来是重点，当microtasks为空，该执行下一个Tasks(setTimeout)了吗？并没有，因为js事件流中的冒泡被触发，也就是在外面的一层Div也会触发click函数，因此我们把刚才的步骤再走一遍。 过程省略，结果为9、冒泡走一遍的结果为 Tasks: Dispatch click | setTimeout callBack | setTmeout callback(outer) Microtasks: Mutation observers JS stack: Mutation callback Log: click promise mutate click promise mutate 10、 第一个Tasks完成，出栈 Tasks: setTimeout callBack | setTmeout callback(outer) Microtasks: JS stack: setTimeout callback Log: click promise mutate click promise mutate timeout 11、 第二个Tasks完成，出栈 Tasks: setTmeout callback(outer) Microtasks: JS stack: setTimeout(outer) callback Log: click promise mutate click promise mutate timeout timeout 结束了 所以这里的重点是什么？ 是MicroTasks的执行时机： 见缝插针，它不一定就必须在Tasks的最后，只要JS stack为空，就可以执行 这条规则出处在 If the stack of script settings objects is now empty, perform a microtask checkpoint— HTML: Cleaning up after a callback step 3 另一方面，ECMA也对此有过说明 Execution of a Job can be initiated only when there is no running execution context and the execution context stack is empty… — ECMAScript: Jobs and Job Queues 但是对于其他浏览器(firefox safari ie)同样的代码，得出的结果是不同的哦。关键在于，对与 job和microTasks之间的一个联系是很模糊的。 但是我们就按照Chrome的实现来理解吧。 最后一关 还是刚才那道题，只不过，我不用鼠标点击了，而是直接执行函数 1inner.click() 如果这样，结果会一样吗？ 答案是: 1234567clickclickpromisemutatepromisetimeout timeout What！！？？我怎么感觉我白学了？ 不着急，看下这次的过程是这样的，首先最大的不同在于，我们在函数最底部加了一个执行inner.click()，这样子，这个函数执行的过程，都是同步序列里的，所以这次的task的起点就在Run scripts: 1、不同与鼠标点击，我们执行函数后，进入函数内部执行 Tasks: Run scripts Microtasks: JS stack: script | onClick Log: click 2、遇到setTimeout和promise&amp;mutation Tasks: Run scripts | setTimeout callback Microtasks: Promise.then | Mutation Observers JS stack: script | onClick Log: click 3、接下来关键，冒泡的时候，因为我们并没有执行完当前的script,还在inner.click()这个函数执行之中，因此当onclick结束，开始冒泡时，script并没有结束 Tasks: Run scripts | setTimeout callback Microtasks: Promise.then | Mutation Observers JS stack: script | onClick(这是冒泡的click，第一次click已经结束) Log: click click 4、冒泡阶段重复之前内容 Tasks: Run scripts | setTimeout callback |setTimeout callback(outer) Microtasks: Promise.then | Mutation Observers |promise.then JS stack: script | onClick(这是冒泡的click，第一次click已经结束) Log: click click 注意第二次没有增加mutation，因为已经有一个在渲染的了 5、inner.click()执行完毕,执行Microtasks Tasks: Run scripts | setTimeout callback |setTimeout callback(outer) Microtasks: Promise.then | Mutation Observers |promise.then JS stack: Log: click click promise 6、按理论执行 Tasks: Run scripts | setTimeout callback |setTimeout callback(outer) Microtasks: Mutation Observers |promise.then JS stack: Log: click click promise mutate…. 后面的就不解释了，Microtasks依次出栈，接着Tasks顺序执行。 总结Jake老师的文章，对这个的解析和深入实在令人佩服，我也在面试中因把event loop解释的较为详尽而被面试官肯定，所以如果对异步以及event loop有疑惑的，可以好好的消化下这个内容，一起进步!]]></content>
      <tags>
        <tag>前端面试</tag>
        <tag>JavaScript</tag>
        <tag>JS Event</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Generator 异步原理]]></title>
    <url>%2F2018%2F08%2F28%2F2018-08-28-How-generator-works%2F</url>
    <content type="text"><![CDATA[从实际应用场景开始假设我们有一个异步的请求，想要去通过api获取一些数据。这里借助node-fetch库来获取数据。fetch可以异步的获取数据，并返回一个promise，所以常规的异步操作和写法，大致如下12345var fetch = require('node-fetch');fetch('http://jasonplacerholder.typecoder.com/posts/1') .then( res =&gt; res.json() ) .then( post =&gt; post.title ) .then( x =&gt; console.log('Title: ',x)) 好了，以上的代码就是一个获取api，并拿到api中的title内容。 关于promise这里不多说，fetch返回的就是一个promise。 genetor实现那么如果使用generator会如何实现实现同样的一个异步操作呢？ 这里先给结果，再来分析实现原理。这里记住co，这个co是干嘛的，一会分析并实现一个我们自己的co函数。 co接收一个genetor，所以我们可以认为co就是一个generator的发动机，或者自动执行器。12345678const co = require('co');co(function *() &#123; const url = 'http://jasonplacerholder.typecoder.com/posts/1'; const response = yield fetch(url); const post = yield response.json(); const title = post.title; console.log('Title: ',title);&#125;) 好了，结束，执行后，会输出同样的结果，似乎和promise没有两样。下面先简单的逐行分析，来看看在genetor中，做了什么。12345//从genetor的第一行开始第一行： 定义了url第二行： 声明response，并将fetch(url)的结果.....yieldstop...What is yield??? 嗯，所以，这个genetor的yield是干什么的？这是genetor和普通函数的不同之处，也是它可以做异步的基础。不同与普通函数，genetor遇到了yield之后，会将yield后面的处理内容抛出。 genetor: 运行呀—运行呀—运行呀–yield？ What？这是什么鬼，我搞不定，老大你帮我搞定后再加我—out.. outer(执行器co）: 收到yield返回的结果，处理—-返回给genetor genetor: 收到处理结果—运行—yeild？这又是什么？你帮我搞定，out… outer(执行器co)： 收到yield返回的promise，处理—返回给genetor 这就是异步的原理了，genetor遇到yield会把任务丢出去，它就暂时不运行了。 我们知道，yield丢出去的是一个iterator，当调用next()的时候，会返回genetor中。 所以其实co就是一个自动触发和调度next()的函数。 实现co知道了原理，我们自己来实现这个过程。然后就会比较清除整个过程了。 我们把函数改一下12345678910111213run(function *() &#123; const url = 'http://jasonplacerholder.typecoder.com/posts/1'; const response = yield fetch(url); const post = yield response.json(); const title = post.title; console.log('Title: ',title);&#125;)function run(generator) &#123; const iterator = generator(); //genetor执行会返回一个iterator，然后调用next()才会执行到下一个yield iterator.next(); //这里打印出来的结果看一下是&#123;value: Promise &#123;&lt;pending&gt;&#125;,done:false&#125;&#125; 解释： 就如上面genetor和outer的对话，遇到yield，genetor会说:”我不知道怎么搞这个promise,你来搞吧，给你..“ 于是，外面的就会接住这个promise 我们继续写1234567function run(generator) &#123; const iterator = generator(); //genetor执行会返回一个iterator，然后调用next()才会执行到下一个yield const iteration = iterator.next(); //这里打印出来的结果看一下是&#123;value: Promise &#123;&lt;pending&gt;&#125;,done:false&#125; const promise = iteration.value; promise.then(x =&gt; iterator.next(x)) //ok，外部帮忙处理了promise，然后处理的结果，我们需要返回genetor，使其继续运行 //这个时候，genetor中的response拿到了值，就等于这里的x&#125; 分析到这里，程序已经得到了response。 但是，下一句，立马又遇到了response.json()，同样又会丢出去一个内容，因此，我们这里再处理一下，如下：1234567891011function run(generator) &#123; const iterator = generator(); //genetor执行会返回一个iterator，然后调用next()才会执行到下一个yield const iteration = iterator.next(); //这里打印出来的结果看一下是&#123;value: Promise &#123;&lt;pending&gt;&#125;,done:false&#125; const promise = iteration.value; promise.then(x =&gt; &#123; const anotherIterator = iterator.next(x);//注意,iterator.next()的含义，一方面会将运算结果返回，另一方面，genetor会继续将下一个yield的任务抛出，仍然是一个iterator const anotherPromise = anotherIterator.value; anotherPromise.then(post =&gt; iterator.next(post)) //到此，因为iterator再也没有yield，所以不会再次返回iterator了，也不用调用next() &#125;) &#125; 至此，模拟的co方法已经实现了。 流程如下: run传入一个genetor并运行，获得一个iterator(generator()) 调用next()方法，获取到iteration,iteration的value是yield fetch(url)的结果，也即一个Promise。 yield返回出的任务，由外部执行和处理，结束后在返回,于是使用then方法。 处理后的结果为x，调用iterator.next(x)把x返回的同时，拿到了下一个yield的抛出的任务。 处理任务，得到post，并通过next(post)返回给genetor。 嗯，我拿到你们处理的结果了，下一次我遇到yield还给你们，反正我不会，我也不会学，这任务都是你们的。 也就是说，genetor的异步，就在于能将线程弹出，遇到yield后，交出线程。所以，我们做一个能够自动执行和触发genetor的执行器，就可以实现异步编程，而且看起来和同步的写法很相似。 这就是库co做的事情。 完善我们自己的co刚才只有两个yield，我们希望方法有通用性，我们写个递归，让它能不断的触发1234567891011function run(genetor) &#123; const iterator = genetor(); function autoRun(iteration) &#123; if(iteration.done) &#123;return iteration.value;&#125; const anotherPromise = iteration.value; anotherPromise.then(x =&gt; &#123; return autoRun(iterator.next(x)); &#125;) &#125; return autoRun(iterator.next());&#125; 好了，这样就完成了我们自己的简易版co函数。]]></content>
      <tags>
        <tag>前端面试</tag>
        <tag>JavaScript</tag>
        <tag>异步原理</tag>
        <tag>Generator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅尝辄止,React是如何工作的]]></title>
    <url>%2F2018%2F08%2F22%2F2018-08-22-how-react-works%2F</url>
    <content type="text"><![CDATA[大神们可以写出“深入浅出”系列，小白就写点”真·浅尝辄止”系列的吧，主要便于自己理解和巩固，毕竟一开始就上源码还是会头大滴，于是就准备浅尝辄止的了解下”React是如何工作的？” React是怎么工作的？ 你知道Diff算法吗 —xx面试官 How React.js worksVirtual Dom VS Browser DomReact除了是MVC框架，数据驱动页面的特点之外，核心的就是他很”快”。 按照普遍的说法：”因为直接操作DOM会带来重绘、回流等，带来巨大的性能损耗而导致渲染慢等问题。React使用了虚拟DOM，每次状态更新，React比较虚拟DOM的差异之后，再更改变化的内容，最后统一由React去修改真实DOM、完成页面的更新、渲染。” 上面这段话，是我们都会说的，那么一般到这里，面试官就问了：”什么是虚拟DOM，React是怎么进行比较的？Diff算法了解吗？”。之前是有点崩溃的，于是决定浅尝一下： 虚拟DOM是React的核心，它的本质是JavaScript对象； BrowserDOM(也就是页面真实DOM)就是Browser对象了。 DOM没什么好说的，主要说下虚拟DOM的一些特点： 本质是JS对象，代表着真实的DOM 比真实DOM的比较和操作快的多 每秒可创建200,000个虚拟DOM节点 每次setState或despatch一个action，都会创建一次全新的虚拟dom 前几点没什么好说的，注意第四点，也就是你每一个改动，每一个动作都会让React去根据当前的状态创建一个全新的Virtual DOM。 这里每当Virtual DOM生成，都打印了出来，可以看到，它代表着真实DOM，而每次生成全新的，也是为了能够比较old dom和new dom之前的差别。 Diff算法刚才提到了，React会抓取每个状态下的内容，生成一个全新的Virtual DOM，然后通过和前一个的比较，找出不同和差异。React的Diff算法有两个约定： 两个不同类型的元素，会产生两个不同的树 开发者，可以使用key关键字，告诉React哪些子元素在DOM下是稳定存在的、不变的。 第二点着重说一下，举个例子：比如真实DOM的ul标签下，有一系列的&lt;li&gt;标签，然而当你想要重新排列这个标签时，如果你给了每个标签一个key值，React在比较差异的时候，就能够知道”你还是你，只不过位置变化了”。 React除了要最快的找到差异外，还希望变化是最小的。如果加了key，react就会保留实例，而不像之前一样，完全创造一个全新的DOM。 来个更具体的： 1234 下一个状态后，序列变为 1243 对于我们来讲，其实就是调换了4和3的顺序。可是怎么让React知道，原来的那个3跑到了原来的4后面了呢？ 就是这个唯一的key起了作用。 相关面试题：为什么React中列表模板中要加入key Diff运算实例Diff在进行比较的时候，首先会比较两个根元素，当差异是类型的改变的时候，可能就要花更多的“功夫”了 不同类型的dom元素比如现在状态有这样的一个改变: 12345678&lt;div&gt; &lt;Counter /&gt;&lt;/div&gt;-----------&lt;span&gt; &lt;Counter /&gt;&lt;/span&gt; 可以看到，从&lt;div&gt;变成了&lt;span&gt;，这种类型的改变，带来的是直接对old tree的整体摧毁，包括子元素Counter。 所以旧的实例Counter会被完全摧毁后，创建一个新的实例来，显然这种效率是低下的 同类型dom元素当比较后发现两个是同类型的，那好办了，React会查看其属性的变化，然后直接修改属性，原来的实例都得意保留，从而使得渲染高效，比如： 123&lt;div className="before" title="stuff" /&gt;&lt;div className="after" title="stuff" /&gt; 除了className，包括style也是一样，增加、删除、修改都不会对整个 dom tree进行摧毁，而是属性的修改，保留其下面元素和节点 相同类型的组件元素与上面类似，相同类型的组件元素，子元素的实力会保持，不会摧毁。 当组件更新时，实例保持不变，以便在渲染之间保持状态。React更新底层组件实例的props以匹配新元素，并在底层实例上调用componentWillReceiveProps（）和componentWillUpdate（）。 接下来，调用render()方法，diff算法对前一个结果和新结果进行递归 key props如果前面对key的解释，还不够清除，这里用一个真正的实例来说明key的重要性吧。 场景一：在一个列表最后增加一个元素 12345678910&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;------&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt; &lt;li&gt;third&lt;/li&gt;&lt;/ul&gt; 可以看到，在这种情况下，React只需要在最后insert一个新元素即可，其他的都不需要变化，这个时候React是高效的,但是如果在场景二下: 场景二：在列表最前面插入一个元素 12345678910&lt;ul&gt; &lt;li&gt;Duke&lt;/li&gt; &lt;li&gt;Villanova&lt;/li&gt;&lt;/ul&gt;---&lt;ul&gt; &lt;li&gt;Connecticut&lt;/li&gt; &lt;li&gt;Duke&lt;/li&gt; &lt;li&gt;Villanova&lt;/li&gt;&lt;/ul&gt; 这对React可能就是灾难性的，因为React只知道前两个元素不同，因此会完全创新一个新的元素，最后导致三个元素都是重新创建的，这大大降低了效率。这个时候，key就排上用场了。当子元素有key时，React使用key将原始树中的子元素与后续树中的子元素相匹配。例如，在上面的低效示例中添加一个key可以使树转换更高效： 12345678910&lt;ul&gt; &lt;li key="2015"&gt;Duke&lt;/li&gt; &lt;li key="2016"&gt;Villanova&lt;/li&gt;&lt;/ul&gt;------&lt;ul&gt; &lt;li key="2014"&gt;Connecticut&lt;/li&gt; &lt;li key="2015"&gt;Duke&lt;/li&gt; &lt;li key="2016"&gt;Villanova&lt;/li&gt;&lt;/ul&gt; 这样，只有key值为2014的是新创建的，而2015和2016仅仅是移动了位置而已。 策略React是用什么策略来比较两颗tree之间的差异呢？这个策略是最核心的部分： 两个树的完全的 diff 算法是一个时间复杂度为 O(n^3) 的问题。但是在前端当中，你很少会跨越层级地移动DOM元素。所以 Virtual DOM 只会对同一个层级的元素进行对比： 上面的div只会和同一层级的div对比，第二层级的只会跟第二层级对比。这样算法复杂度就可以达到 O(n)。 深度优先遍历在实际代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记，然后记录差异 在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。 比如第上图中的1号节点p，有了变化，这样子就记录如下： 1patches[1] = [&#123;difference&#125;, &#123;difference&#125;...]//用数组存储新旧节点的差异 ok，那么差异类型呢，在上一节中已经说了，包括根元素的类型的不同分为两大类，然后根据不同的情况采取不同的更换策略。 最后，就是在真实DOM进行操作，apply这些差异，更新和渲染了。 为什么Redux 需要 reducers是纯函数？这又是一个很厉害的问题了，使用Redux的都知道，reducers会接收上一个state和action作为参数，然后返回一个新的state，这个新的state不能是在原来state基础上的修改。所以经常可以看到以下的写法： 123return Object.assign(...)//或者----------return &#123;...state,xx:xxx&#125; 其作用，都是为了返回一个全新的对象。 为什么reducers要求是纯函数(返回全新的对象，不影响原对象)? –某面试官 纯函数从本质上讲，纯函数的定义如下：不修改函数的输入值，依赖于外部状态（比如数据库，DOM和全局变量），同时对于任何相同的输入有着相同的输出结果。 举个例子，下面的add函数不修改变量a或b，同时不依赖外部状态，对于相同的输入始终返回相同的结果。 1const add = (a,b) =&gt; &#123;a + b&#125;; 这就是一个纯函数，结果对a、b没有任何影响，回头去看reducer，它符合纯函数的所有特征，所以就是一个纯函数 为什么必须是纯函数?先告诉你结果吧，如果在reducer中，在原来的state上进行操作，并返回的话，并不会让React重新渲染。 完全不会有任何变化！ 接下来看下Redux的源码： Redux接收一个给定的state（对象），然后通过循环将state的每一部分传递给每个对应的reducer。如果有发生任何改变，reducer将返回一个新的对象。如果不发生任何变化，reducer将返回旧的state。 Redux只通过比较新旧两个对象的存储位置来比较新旧两个对象是否相同。如果你在reducer内部直接修改旧的state对象的属性值，那么新的state和旧的state将都指向同一个对象。因此Redux认为没有任何改变，返回的state将为旧的state。 好了，也就是说，从源码的角度来讲，redux要求开发者必须让新的state是全新的对象。那么为什么非要这么麻烦开发者呢？ 请看下面的例子：尝试比较a和b是否相同 12345678910111213var a = &#123; name: 'jack', friend: ['sam','xiaoming','cunsi'], years: 12, ...//省略n项目&#125; var b = &#123; name: 'jack', friend: ['sam','xiaoming','cunsi'], years: 13, ...//省略n项目&#125; 思路是怎样的？我们需要遍历对象，如果对象的属性是数组，还需要进行递归遍历，去看内容是否一致、是否发生了变化。 这带来的性能损耗是非常巨大的。 有没有更好的办法？ 有！ 12//接上面的例子a === b //false 我不要进行深度比较，只是浅比较，引用值不一样(不是同一个对象),那就是不一样的。 这就是redux的reducer如此设计的原因了 参考资料1.为什么Redux需要reducers是纯函数 2.深度剖析：如何实现一个 Virtual DOM 算法 3.Learn how to code: how react.js works]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端开发</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试&笔试爬坑算法 Algorithm]]></title>
    <url>%2F2018%2F08%2F21%2F2018-08-21-front-end-interview-algorithm%2F</url>
    <content type="text"><![CDATA[终于来了，算法相关的。 其实个人理解，前端岗位对于算法的要求与其他IT岗位相比，是低得多的。 但是小白我经历了如蚂蚁金服、网易这样的大厂教做人之后，还是觉得，对于一些基本算法、思想的掌握还是必须的。 然后，就把自己遇到的、学到的算法相关的再总结一下，方便自己随时备战面试。 系列笔记： 1.VK的秋招前端奇遇记(一) 2.VK的秋招前端奇遇记(二) 3.VK的秋招前端奇遇记(三) 4.VK的秋招前端奇遇记(四) 5.番外篇：前端面试&amp;笔试算法 Algorithm 排序JS本身数组的sort方法，可以满足日常业务操作中很多的场景了，所以我认为这也是为什么基本面试会直接让写一个快速排序，因为好像其他排序方法在JS中似乎没什么意义了。 但是在拼多多的面试中，面试官还是让我手写选择排序 冒泡排序 和快速排序 的伪代码。 既然有机会总结，干脆就全部写一遍好了，从基本排序到高级排序来说。 基本排序算法基本排序的基本思想非常类似，重排列时用的技术基本都是一组嵌套的for循环: 外循环遍历数组的每一项，内循环则用于比较元素。 冒泡排序最笨最基本最经典点的方法，不管学什么语言，说到排序，第一个接触的就是它了吧。基本思想什么的太经典了，就不复数了，直接用例子说明过程吧： 1E A D B H 经过一次排列后，变成 1A E D B H 前两个元素互换了，接下来变成： 1A D E B H 第二个和第三个互换，继续： 1A D B E H 第三个和第四个互换，最后，第二个和第三个元素还会互换一次，得到最终的顺序为： 1A B D E H 好了，其实基本思想就是逐个的比较，下面就实现一下： 12345678910111213function bubleSort(arr) &#123; var len = arr.length; for (let outer = len ; outer &gt;= 2; outer--) &#123; for(let inner = 0; inner &lt;=outer - 1; inner++) &#123; if(arr[inner] &gt; arr[inner + 1]) &#123; let temp = arr[inner]; arr[inner] = arr[inner + 1]; arr[inner + 1] = temp; &#125; &#125; &#125; return arr;&#125; 这里有两点需要注意： 外层循环，从最大值开始递减，因为内层是两两比较，因此最外层当&gt;=2时即可停止； 内层是两两比较，从0开始，比较inner与inner+1，因此，临界条件是inner&lt;outer -1 在比较交换的时候，就是计算机中最经典的交换策略，用临时变量temp保存值，但是面试官问过我，ES6有没有简单的方法实现？ 有的，如下： 123arr2 = [1,2,3,4];[arr2[0],arr2[1]] = [arr2[1],arr2[0]] //ES6解构赋值console.log(arr2) // [2, 1, 3, 4] 所以，刚才的冒牌排序可以优化如下： 1234567891011function bubleSort(arr) &#123; var len = arr.length; for (let outer = len ; outer &gt;= 2; outer--) &#123; for(let inner = 0; inner &lt;=outer - 1; inner++) &#123; if(arr[inner] &gt; arr[inner + 1]) &#123; [arr[inner],arr[inner+1]] = [arr[inner+1],arr[inner]] &#125; &#125; &#125; return arr;&#125; 选择排序选择排序是从数组的开头开始，将第一个元素和其他元素作比较，检查完所有的元素后，最小的放在第一个位置，接下来再开始从第二个元素开始，重复以上一直到最后。 有了刚才的铺垫，我觉得不用再演示了，很简单嘛： 外层循环从0开始到length-1， 然后内层比较，最小的放开头，走你： 1234567891011function selectSort(arr) &#123; var len = arr.length; for(let i = 0 ;i &lt; len - 1; i++) &#123; for(let j = i ; j&lt;len; j++) &#123; if(arr[j] &lt; arr[i]) &#123; [arr[i],arr[j]] = [arr[j],arr[i]]; &#125; &#125; &#125; return arr&#125; 简单说两句： 外层循环的i表示第几轮，arr[i]就表示当前轮次最靠前(小)的位置； 内层从i开始，依次往后数，找到比开头小的，互换位置即可 结束，收工！！ 插入排序插入排序核心–扑克牌思想： 就想着自己在打扑克牌，接起来一张，放哪里无所谓，再接起来一张，比第一张小，放左边，继续接，可能是中间数，就插在中间….依次 其实每种算法，主要是理解其原理，至于写代码，都是在原理之上顺理成章的事情： 首先将待排序的第一个记录作为一个有序段 从第二个开始，到最后一个，依次和前面的有序段进行比较，确定插入位置 123456789101112function insertSort(arr) &#123; for(let i = 1; i &lt; arr.length; i++) &#123; //外循环从1开始，默认arr[0]是有序段 for(let j = i; j &gt; 0; j--) &#123; //j = i,将arr[j]依次插入有序段中 if(arr[j] &lt; arr[j-1]) &#123; [arr[j],arr[j-1]] = [arr[j-1],arr[j]]; &#125; else &#123; break; &#125; &#125; &#125; return arr;&#125; 分析： 注意这里两次循环中，i和j的含义： i是外循环，依次把后面的数插入前面的有序序列中，默认arr[0]为有序的，i就从1开始 j进来后，依次与前面队列的数进行比较，因为前面的序列是有序的，因此只需要循环比较、交换即可 注意这里的break，因为前面是都是有序的序列，所以如果当前要插入的值arr[j]大于或等于arr[j-1]，则无需继续比较，直接下一次循环就可以了。 时间复杂度乍一看，好像插入排序速度还不慢，但是要知道： 当序列正好逆序的时候，每次插入都要一次次交换，这个速度和冒泡排序是一样的，时间复杂度O(n²)； 当然运气好，前面是有序的，那时间复杂度就只有O(n)了，直接插入即可。 排序算法 平均时间复杂度 最坏时间复杂度 空间复杂度 是否稳定 冒泡排序 O(n²) O(n²) O(1) 是 选择排序 O(n²) O(n²) O(1) 不是 直接插入排序 O(n²) O(n²) O(1) 是 好了，这张表如何快速记忆呢？ 方法就是一开始写的基本排序算法 。 一开始就说到，基本思想就是两层循环嵌套，第一遍找元素O(n),第二遍找位置O(n)，所以这几种方法，时间复杂度就可以这么简便记忆啦! 高级排序算法如果所有排序都像上面的基本方法一样，那么对于大量数据的处理，将是灾难性的，老哥，只是让你排个序，你都用了O(n²)。 好吧，所以接下来这些高级排序算法，在大数据上，可以大大的减少复杂度。 快速排序快速排序可以说是对于前端最最最最重要的排序算法，没有之一了，面试官问到排序算法，快排的概率能有80%以上(我瞎统计的…信不信由你)。 所以快排是什么呢？ 快排是处理大数据最快的排序算法之一。它是一种分而治之的算法，通过递归的方式将数据依次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤直至所有数据都是有序的。 简单说： 找到一个数作为参考，比这个数字大的放在数字左边，比它小的放在右边； 然后分别再对左边和右变的序列做相同的操作: 选择一个基准元素，将列表分割成两个子序列； 对列表重新排序，将所有小于基准值的元素放在基准值前面，所有大于基准值的元素放在基准值的后面； 分别对较小元素的子序列和较大元素的子序列重复步骤1和2 12345678910111213141516function quickSort(arr) &#123; if(arr.length &lt;= 1) &#123; return arr; //递归出口 &#125; var left = [], right = [], current = arr.splice(0,1); //注意splice后，数组长度少了一个 for(let i = 0; i &lt; arr.length; i++) &#123; if(arr[i] &lt; current) &#123; left.push(arr[i]) //放在左边 &#125; else &#123; right.push(arr[i]) //放在右边 &#125; &#125; return quickSort(left).concat(current,quickSort(right)); //递归&#125; 希尔排序希尔排序是插入排序的改良算法，但是核心理念与插入算法又不同，它会先比较距离较远的元素，而非相邻的元素。文字太枯燥，还是看下面的动图吧： 在实现之前，先看下刚才插入排序怎么写的： 123456789101112function insertSort(arr) &#123; for(let i = 1; i &lt; arr.length - 1; i++) &#123; //外循环从1开始，默认arr[0]是有序段 for(let j = i; j &gt; 0; j--) &#123; //j = i,将arr[j]依次插入有序段中 if(arr[j] &lt; arr[j-1]) &#123; [arr[j],arr[j-1]] = [arr[j-1],arr[j]]; &#125; else &#123; continue; &#125; &#125; &#125; return arr;&#125; 现在，不同之处是在上面的基础上，让步长按照3、2、1来进行比较，相当于是三层循环和嵌套啦。 123456789101112131415161718insertSort(arr,[3,2,1]);function shellSort(arr,gap) &#123; console.log(arr)//为了方便观察过程，使用时去除 for(let i = 0; i&lt;gap.length; i++) &#123; //最外层循环，一次取不同的步长，步长需要预先给出 let n = gap[i]; //步长为n for(let j = i + n; j &lt; arr.length; j++) &#123; //接下类和插入排序一样，j循环依次取后面的数 for(let k = j; k &gt; 0; k-=n) &#123; //k循环进行比较，和直接插入的唯一区别是1变为了n if(arr[k] &lt; arr[k-n]) &#123; [arr[k],arr[k-n]] = [arr[k-n],arr[k]]; console.log(`当前序列为[$&#123;arr&#125;] \n 交换了$&#123;arr[k]&#125;和$&#123;arr[k-n]&#125;`)//为了观察过程 &#125; else &#123; continue; &#125; &#125; &#125; &#125; return arr;&#125; 直接看这个三层循环嵌套的内容，会稍显复杂，这也是为什么先把插入排序写在前面做一个对照。 其实三层循环的内两层完全就是一个插入排序，只不过原来插入排序间隔为1，而希尔排序的间隔是变换的n， 如果把n修改为1，就会发现是完全一样的了。 运行一下看看 123var arr = [3, 2, 45, 6, 55, 23, 5, 4, 8, 9, 19, 0];var gap = [3,2,1];console.log(shellSort(arr,gap)) 结果如下: 12345678910111213141516171819202122232425262728293031(12) [3, 2, 45, 6, 55, 23, 5, 4, 8, 9, 19, 0] //初始值当前序列为[3,2,23,6,55,45,5,4,8,9,19,0] 交换了45和23当前序列为[3,2,23,5,55,45,6,4,8,9,19,0] 交换了6和5当前序列为[3,2,23,5,4,45,6,55,8,9,19,0] 交换了55和4当前序列为[3,2,23,5,4,8,6,55,45,9,19,0] 交换了45和8当前序列为[3,2,8,5,4,23,6,55,45,9,19,0] 交换了23和8当前序列为[3,2,8,5,4,23,6,19,45,9,55,0] 交换了55和19当前序列为[3,2,8,5,4,23,6,19,0,9,55,45] 交换了45和0当前序列为[3,2,8,5,4,0,6,19,23,9,55,45] 交换了23和0当前序列为[3,2,0,5,4,8,6,19,23,9,55,45] 交换了8和0当前序列为[0,2,3,5,4,8,6,19,23,9,55,45] 交换了3和0当前序列为[0,2,3,5,4,8,6,9,23,19,55,45] 交换了19和9当前序列为[0,2,3,4,5,8,6,9,23,19,55,45] 交换了5和4当前序列为[0,2,3,4,5,6,8,9,23,19,55,45] 交换了8和6当前序列为[0,2,3,4,5,6,8,9,19,23,55,45] 交换了23和19当前序列为[0,2,3,4,5,6,8,9,19,23,45,55] 交换了55和45 时间复杂度总结wait？ 不是还有很多排序算法的吗？怎么不继续了？ 是的，其实排序是很深奥的问题，如果研究透各个方法的实现、性能等等，内容恐怕多到爆炸了…而且这个也主要是为前端常见算法 问题的总结，个人觉得到这里就差不多了 排序算法 平均时间复杂度 最坏时间复杂度 空间复杂度 是否稳定 冒泡排序 O(n²) O(n²) O(1) 是 选择排序 O(n²) O(n²) O(1) 不是 直接插入排序 O(n²) O(n²) O(1) 是 快速排序 O(nlogn) O(n²) O(logn) 不是 希尔排序 O(nlogn) O(n^s) O(1) 不是 是否稳定如果不考虑稳定性，快排似乎是接近完美的一种方法，但可惜它是不稳定的。 那什么是稳定性呢？ 通俗的讲有两个相同的数A和B，在排序之前A在B的前面，而经过排序之后，B跑到了A的前面，对于这种情况的发生，我们管他叫做排序的不稳定性，而快速排序在对存在相同数进行排序时就有可能发生这种情况。 12345/*比如对(5，3A，6，3B ) 进行排序，排序之前相同的数3A与3B，A在B的前面，经过排序之后会变成 （3B，3A，5，6）所以说快速排序是一个不稳定的排序/* 稳定性有什么意义？ 个人理解对于前端来说，比如我们熟知框架中的虚拟DOM的比较，我们对一个&lt;ul&gt;列表进行渲染，当数据改变后需要比较变化时，不稳定排序或操作将会使本身不需要变化的东西变化，导致重新渲染，带来性能的损耗。 辅助记忆 时间复杂度记忆 冒泡、选择、直接 排序需要两个for循环，每次只关注一个元素，平均时间复杂度为O(n²)(一遍找元素O(n)，一遍找位置O(n)） 快速、归并、希尔、堆基于二分思想，log以2为底，平均时间复杂度为O(nlogn)(一遍找元素O(n)，一遍找位置O(logn)) 稳定性记忆-“快希选堆”（快牺牲稳定性） 递归递归，其实就是自己调用自己。 很多时候我们自己觉得麻烦或者感觉 “想象不过来”，主要是自己和自己较真，因为交给递归，它自己会帮你完成需要做的。 递归步骤： 寻找出口，递归一定有一个出口，锁定出口，保证不会死循环 递归条件，符合递归条件，自己调用自己。 talk is cheap，show me code！ 斐波那契数列，每个语言讲递归都会从这个开始，但是既然搞前端，就搞点不一样的吧，从对象的深度克隆(deep clone)说起 Deep Clone ：实现对一个对象(object)的深度克隆 123456789101112131415161718//所谓深度克隆，就是当对象的某个属性值为object或array的时候，要获得一份copy，而不是直接拿到引用值function deepClone(origin,target) &#123; //origin是被克隆对象，target是我们获得copy var target = target || &#123;&#125;; //定义target for(var key in origin) &#123; //遍历原对象 if(origin.hasOwnProperty(key)) &#123; if(Array.isArray(origin[key])) &#123; //如果是数组 target[key] = []; deepClone(origin[key],target[key]) //递归 &#125; else if (typeof origin[key] === 'object' &amp;&amp; origin[key] !== null) &#123; target[key] = &#123;&#125;; deepClone(origin[key],target[key]) //递归 &#125; else &#123; target[key] = origin[key]; &#125; &#125; &#125; return target;&#125; 这个可以说是前端笔试/面试中经常经常遇到的问题了，思路是很清晰的： 出口： 遍历对象结束后return 递归条件： 遇到引用值Array 或 Object 剩下的事情，交给JS自己处理就好了，我们不用考虑内部的层层嵌套，想太多 实战例题接下来，列举一些自己在最近笔试、面试中遇到的，需要使用递归实现的问题 Q1：Array数组的flat方法实现(2018网易雷火&amp;伏羲前端秋招笔试)Array的方法flat很多浏览器还未能实现，请写一个flat方法，实现扁平化嵌套数组，如： 1234Arrayvar arr1 = [1, 2, [3, 4]];arr1.flat(); // [1, 2, 3, 4] 这个问题的实现思路和Deep Clone非常相似，这里实现如下： 1234567891011Array.prototype.flat = function() &#123; var arr = []; this.forEach((item,idx) =&gt; &#123; if(Array.isArray(item)) &#123; arr = arr.concat(item.flat()); //递归去处理数组元素 &#125; else &#123; arr.push(item) //非数组直接push进去 &#125; &#125;) return arr; //递归出口&#125; 好了，可以测试一下： 123arr = [[2],[[2,3],[2]],3,4]arr.flat()// [2, 2, 3, 2, 3, 4] 神秘力量的新解法 在评论区的一位小伙伴，提出了更好的办法，很简洁、方便，只用一句话就可以实现需求哦(不过你这样去解答一道网易的“编程题”,不觉得让人家有点难堪嘛~哈哈)123arr.prototype.flat = function() &#123; this.toString().split(',').map(item=&gt; +item )&#125; 好了，惊叹完之后，大概说下实现吧： toString方法，连接数组并返回一个字符串 &#39;2,2,3,2,3,4&#39; split方法分割字符串，变成数组[&#39;2&#39;,&#39;2&#39;,&#39;3&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;] map方法，将string映射成为number类型2,2,3,2,3,4 Q2 实现简易版的co，自动执行generator这个问题，详细的解释可以在我之前的文章(从Co剖析和解释generator的异步原理)去看一下，如果对ES6的iterator和generator不太了解的，可以跳过这个问题。 比如实现如下的功能:12345678const co = require('co');co(function *() &#123; const url = 'http://jasonplacerholder.typecoder.com/posts/1'; const response = yield fetch(url); const post = yield response.json(); const title = post.title; console.log('Title: ',title);&#125;) 剖析： 第一步找出口，执行器返回的iterator如果状态为done，代表结束，可以出去 递归条件： 取到下一个iterator，进行递归，自我调用 1234567891011function run(generat) &#123; const iterator = generat(); function autoRun(iteration) &#123; if(iteration.done) &#123;return iteration.value&#125; //出口 const anotherPromise = iteration.value; anoterPromise.then(x =&gt; &#123; return autoRun(iterator.next(x)) //递归条件 &#125;) &#125; return autoRun(iterator.next()) &#125; Q3. 爬楼梯问题有一楼梯共M级，刚开始时你在第一级，若每次只能跨上一级或二级，要走上第M级，共有多少种走法？ 分析： 这个问题要倒过来看，要到达n级楼梯，只有两种方式，从（n-1）级 或 （n-2）级到达的。所以可以用递推的思想去想这题，假设有一个数组s[n], 那么s[1] = 1（由于一开始就在第一级，只有一种方法）， s[2] = 1（只能从s[1]上去 没有其他方法）。 那么就可以推出s[3] ~ s[n]了。 下面继续模拟一下， s[3] = s[1] + s[2]， 因为只能从第一级跨两步， 或者第二级跨一步。 1234567function cStairs(n) &#123; if(n === 1 || n === 2) &#123; return 1; &#125; else &#123; return cStairs(n-1) + cStairs(n-2) &#125;&#125; 嗯嗯，没错呢，其实就是斐波纳契数列没跑了 Q4.二分查找二分查找，是在一个有序的序列里查找某一个值，与小时候玩的猜数字游戏非常相啦： 12345A: 0 ~ 100 猜一个数字B: 50A: 大了B: 25A: 对头，就是25 因此，思路也就非常清楚了，这里有递归和非递归两种写法，先说下递归的方法吧： 设定区间,low和high 找出口： 找到target，返回target； 否则寻找，当前次序没有找到，把区间缩小后递归 123456789101112function binaryFind(arr,target,low = 0,high = arr.length - 1) &#123; const n = Math.floor((low+high) /2); const cur = arr[n]; if(cur === target) &#123; return `找到了$&#123;target&#125;,在第$&#123;n+1&#125;个`; &#125; else if(cur &gt; target) &#123; return binaryFind(arr,target,low, n-1); &#125; else if (cur &lt; target) &#123; return binaryFind(arr,target,n+1,high); &#125; return -1;&#125; 接下来，使用循环来做一下二分查找，其实思路基本一致： 1234567891011121314151617function binaryFind(arr, target) &#123; var low = 0, high = arr.length - 1, mid; while (low &lt;= high) &#123; mid = Math.floor((low + high) / 2); if (target === arr[mid]) &#123; return `找到了$&#123;target&#125;,在第$&#123;mid + 1&#125;个` &#125; if (target &gt; arr[mid]) &#123; low = mid + 1; &#125; else if (target &lt; arr[mid]) &#123; high = mid - 1; &#125; &#125; return -1&#125; 二叉树和二叉查找树树的基本概念这里对基本概念就不详细复习了，在各大资料中有更详尽的介绍，这里就只简单介绍基本概念和术语，然后使用JavaScript实现一个二叉树，并封装其方法。 如图所示，一棵树最上面的几点称为根节点，如果一个节点下面连接多个节点，那么该节点成为父节点，它下面的节点称为子节点，一个节点可以有0个、1个或更多节点，没有子节点的节点叫叶子节点。 二叉树，是一种特殊的树，即子节点最多只有两个，这个限制可以使得写出高效的插入、删除、和查找数据。在二叉树中，子节点分别叫左节点和右节点。 二叉查找树二叉查找树是一种特殊的二叉树，相对较小的值保存在左节点中，较大的值保存在右节点中，这一特性使得查找的效率很高，对于数值型和非数值型数据，比如字母和字符串，都是如此。现在通过JS实现一个二叉查找树。 节点二叉树的最小元素是节点，所以先定义一个节点 123456function Node(data,left,right) &#123; this.left = left; this.right = right; this.data = data; this.show = () =&gt; &#123;return this.data&#125;&#125; 这个就是二叉树的最小结构单元 二叉树123function BST() &#123; this.root = null //初始化,root为null&#125; BST初始化时，只有一个根节点，且没有任何数据。 接下来，我们利用二叉查找树的规则，定义一个插入方法，这个方法的基本思想是: 如果BST.root === null ，那么就将节点作为根节点 如果BST.root !==null ，将插入节点进行一个比较，小于根节点，拿到左边的节点，否则拿右边，再次比较、递归。 这里就出现了递归了，因为，总是要把较小的放在靠左的分支。换言之 最左变的叶子节点是最小的数，最右的叶子节点是最大的数 12345678910111213141516171819202122232425function insert(data) &#123; var node = new Node(data,null,null); if(this.root === null) &#123; this.root = node &#125; else &#123; var current = this.root; var parent; while(true) &#123; parent = current; if(data &lt; current.data) &#123; current = current.left; //到左子树 if(current === null) &#123; //如果左子树为空，说明可以将node插入在这里 parent.left = node; break; //跳出while循环 &#125; &#125; else &#123; current = current.right; if(current === null) &#123; parent.right = node; break; &#125; &#125; &#125; &#125;&#125; 这里，是使用了一个循环方法，不断的去向子树寻找正确的位置。 循环和递归都有一个核心，就是找到出口，这里的出口就是当current 为null的时候，代表没有内容，可以插入。 接下来，将此方法写入BST即可: 1234function BST() &#123; this.root = null; this.insert = insert;&#125; 这样子，就可以使用二叉树这个自建的数据结构了: 123456var bst = new BST()；bst.insert(10);bst.insert(8);bst.insert(2);bst.insert(7);bst.insert(5); 但是这个时候，想要看树中的数据，不是那么清晰，所以接下来，就要用到遍历了。 二叉树的遍历我们知道，树的遍历主要包括 前序遍历 (根左右) 中序遍历 (左根右) 后序遍历 (左右根) 这个只是为了好记忆，我们拿下面的图做一个遍历 前序遍历: 56 22 10 30 81 77 92 中序遍历: 10 22 30 56 77 81 92 后序遍历: 10 30 22 77 92 81 56 这里发现了一些规律： 前序遍历，因为是根左右，所以最后一个一定是最大的； 第一个一定是root节点； 中序遍历，在查找二叉树中，一定是从小到大的顺序； 根节点56左边(10/22/30)的一定是左子树的，右边的(77/81/92)一定是右子树的。 后序遍历，根节点一定在最后 中序遍历的实现这里就又用到之前的递归了，中序遍历要求: 左！根！右 12345678910111213function inOrder(node) &#123; if(node !== null) &#123; //如果不是null，就一直查找左变，因此递归 inOrder(node.left); //递归结束，打印当前值 console.log(node.show()); //上一次递归已经把左边搞完了，右边 inOrder(node.right); &#125;&#125;//在刚才已有bst的基础上执行命令inOrder(bst.root); 通过递归，实现了中序遍历，上面打印出的结果如下: 12345257810 前序遍历&amp;后序遍历如果刚才的递归过程搞清楚，那这个就再简单不过了 12345678function preOrder(node) &#123; if(node !== null) &#123; //根左右 console.log(node.show()); preOrder(node.left); preOrder(node.right); &#125;&#125; ok,趁热打铁，就把后序遍历的方法也一并写入，如下: 12345678function postOrder(node) &#123; if(node !== null) &#123; //左右根 postOrder(node.left); postOrder(node.right); console.log(node.show()) &#125;&#125; 好了，可以去尝试两种方法打印出来的结果了: 12preOrder(bst.root);postOrder(bst.root); 二叉树的查找在二叉树这种数据结构中进行数据查找是最方便的，现在我们就对查找最小值、最大值和特定值进行一个梳理： 最小值： 最左子树的叶子节点 最大值： 最右子树的叶子节点 特定值： target与current进行比较，如果比current大，在current.right进行查找，反之类似。 清楚思路后，就动手来写： 1234567891011121314151617//最小值function getMin(bst) &#123; var current = bst.root; while(current.left !== null) &#123; current = current.left; &#125; return current.data;&#125;//最大值function getMax(bst) &#123; var current = bst.root; while(current.right !== null) &#123; current = current.right; &#125; return current.data;&#125; 最大、最小值都是非常简单的，下面主要看下如何通过 1234567891011121314function find(target,bst) &#123; var current = bst.root; while(current !== null) &#123; if(target === current.data) &#123; return true; &#125; else if(target &gt; current.data) &#123; current = current.right; &#125; else if(target &lt; current.data) &#123; current = current.left; &#125; &#125; return -1;&#125; 其实核心，仍然是通过一个循环和判断，来不断的向下去寻找，这里的思想其实和二分查找是有点类似的。 哇… 没想到今天去整理排序 花了这么久…嗯..然而这篇文章已经够长了 接下来我会把之前笔试遇到的题目和一些常用的算法问题，一一记录，前端很多算法都是和数组、字符串处理息息相关的，所以对正则表达式、数组常用方法的掌握也很重要，简单总结下知识点： 正则表达式 字符串相关方法 str.split() str.replace() str.match() reg.test() reg.exec() 数组方法 Array.map() 映射，有返回值，不改变数组本身 Array.forEach() 遍历，无返回值 Array.filter() 过滤，返回true时返回,false时不返回 Array.splice/slice/join等 for…of 遍历,iterator相关知识点 未完待续….内容会持续更新，最快的当然还是在github上，然后会同步到掘金，github传送门 参考资料 排序算法时间复杂度、空间复杂度、稳定性比较 算法学习记录–希尔排序 快速排序简单理解 数据结构与算法Javascript描述]]></content>
      <tags>
        <tag>前端面试</tag>
        <tag>JavaScript</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可能是最好的正则表达式教程的笔记]]></title>
    <url>%2F2018%2F08%2F15%2F2018-08-15-regular-expression%2F</url>
    <content type="text"><![CDATA[1.1. 基本语法通过一张图表来对正则表达式的基本进行一个回顾 single char quantifiers(位置) Column C \d 匹配数字 * 0个或者更多 ^一行的开头 \w 匹配word(数字、字母) + 1个或更多，至少1个 $一行的结尾 \W 匹配非word(数字、字母) ? 0个或1个,一个Optional \b 单词”结界”(word bounds) \s 匹配white space(包括空格、tab等) {min,max}出现次数在一个范围内 C3 \S 匹配非white space(包括空格、tab等) {n}匹配出现n次的 C3 . 匹配任何，任何的字符 B3 C3 1.1.1. single char假设你有一段字符如下： \w 将匹配所有word，当然，() - 等字符除外 \w\w\w 发现匹配的有’These are some phone numbers …’ 注意正则表达式是匹配一个连续串的规则，所以可以看到三个字母的单词可以匹配到，6个单词的也可以匹配到。 \s\s 匹配到一行中连续两个空格 quantifiers假设我们有这一段话： 12The colors of the rainbow have many colours and the rainbow does not have a single colour. 我们想把所有的颜色找出来colors colours colour 答案 colou?rs? 嗯，看起来很简单，很方便。 好了，现在想要匹配一行中的4个数字，或者一行中的5个字母等，这时候用quantifiers就非常方便了。 我现在想找5个字母组成的单词 \w{5}这样可以吗？嗯..不行的，看下它匹配的内容,如下:‘These are some phone numbers 915-555-1234…’的确，我们模板给的很简单，它只找一行中，连续出现5个字母的序列。所以现在改进一下好了 \w{5}\s为了能找到单词，所以我希望5个字母后，跟一个空格的序列，这样应该可以了吧，看下匹配情况：‘Theseare some phonenumbers915-555-1234…’嗯，是的，只有目前这些方法，是做不到的。 所以，我们需要第三个工具 “position” 1.1.2. position回到刚才的问题之前，先熟悉下^ $ 和 \b12345678This is somthingis abouta blahwordssequence of wordsHello andGoodBye and Go gogo! 来看下各种正则所匹配的内容 \w+这个应该毫无疑问，匹配所有的words ^\w+多了一个^，这样子，就只能匹配到每一行开头的单词了This is a words sequence Hello GoodBye Go \w+$这样就能匹配到每行的最后一个字母 回到刚才的问题 现在想找5个字母组成的单词 就变得很简单了，使用单词结界符\b 答案就是\b\w{5}\b 1.1.3. 找个电话号码吧最后，找一个刚才出现的电话号123-456-1231 用以上最基本的正则方法就是 \d{3}-\d{3}-\d{4}，这样就找到了。 但是有的时候，电话号码是123.456.1234 或者 (212)867-4233的结构怎么办呢？ 正则表达式中的或或者其他表达方式，下面一一来介绍。 1.2. 字符分类(char class)前面记录了最基本的方法，接下来说一下分类符[] 这个符号用来表示逻辑关系或，比如[abc]表示a或者b或c.[-.]表示符号-或者.号(注意这里，在[]中的.号代表的就是这个符号，但是如果在其外面，表示个匹配所有。 所以如果不在[]之中，想要匹配’.’，就要通过转意符号\.) 1.2.1. 分类的简单应用字符序列：1The lynk is quite a link don&apos;t you think? l nk l(nk 正则表达式：l[yi (]k 结果:1lynk link l nk l(nk 很容易理解的，就是表达或逻辑。 1.2.2. 匹配所有可能的电话号码好了，现在回到之前遗留的问题，有以下字段，请匹配所有可能的电话号码：123These are some phone numbers 915-134-3122. Also,you can call me at 643.123.1333 and of course,I&apos;m always reachable at (212)867-5509 好的，一步一步来，刚才我们使用\d{3}-\d{3}-\d{4}匹配了连字符的情况。现在我们可以很轻松的把.这种情况加进去了 第一步： \d{3}[-.]\d{3}[-.]\d{4} 第二步: 为了能够匹配括号，可以使用?来，因为这是一个option选择。所以最后就成了 \(?\d{3}[-.)]\d{3}[-.]\d{4} 这里还是要说明，在[]中，特殊字符不需要转义，可以直接使用，比如[.()],但是在外面，是需要转义的\( \.等 1.2.3. []的特殊语法刚才介绍了最简单和基本的功能，但是有些特殊的地方需要注意 -连接符不是第一个字符时[-.]的含义是连字符-或者点符.。 但是，如果当连字符不是第一个字符时，比如[a-z]，这就表示是从字母a到字符z。 []中的^^在之前介绍中，是表示一行开头，但是在[]中，有着不同的含义。[ab] 表示a或者b[^ab] 啥都行，只要不是a或b(anythings except a and b)，相当于取反 1.2.4. []和()除了使用[]表示或逻辑,()也是可以的。用法是(a|b)表示a或者b 比如下面的例子，匹配所有email123gaoyaqi411@126.com dyumc@google.net sam@sjtu.edu 思路： 首先要想我到底相匹配什么，这里我想匹配的是 任何一个以words开头的，一个或更多 \w+ 紧接着是一个@符号 \w+@ 接着有一个或者更多的words \w+@\w+ 接着一个.标点 \w+@\w+\. 接着一个com net 或 edu \w+@\w+\.(com|net|edu) 还是提醒注意第四步的\.转义符号 好了，这样几可以匹配以上的所有邮箱了。但是还有一个问题，因为邮箱用户名是可以有.的，比如`vincent.ko@126.com` 其实仍然很简单，修复如下：[\w.]+@\w+\.(com|net|edu) 1.2.5. 总结 []的作用，用英文表达就是”alternation”,表达一个或的逻辑； /[-.(]/ 在符号中的连字符-放在第一位表示连字符本身，如果放在中间，表示”从..到..”，比如[a-z]表示a-z [.)] 括号中的特殊符号不需要转义，就表示其本身 [^ab] 括号中的^表示非，anythings except a and b (a|b)也可表示选择，但是它有更强大的功能…. 所以，()的强大功能是什么呢？ 分组捕获，这对序列的替换、交换是很有帮助的。 后面一节进行学习记录 1.3. 分组捕获(capturing groups)什么是分组捕获，现在回到之前电话号码的例子12345678212-555-1234915-412-1333//我想要保留区号，把后面的电话号码变为通用性的👇👇👇👇👇👇👇👇👇👇👇👇212-xxx-xxxx915-xxx-xxxx 按照之前的做法\d{3}-\d{3}-\d{4},这种匹配的方式，是将整个电话号码作为一个组(group)匹配起来。 我们把212-555-1234这样的叫Group0。 这个时候，如果我们加了一个括号\d{3}-(\d{3})-\d{4}，那么匹配到的555就叫Group1。以此类推，如果有两个小括号\d{3}-(\d{3})-(\d{4})那么分组就是下面的情况：123212-555-1234 Group0555 Group11234 Group2 1.3.1. 选择分组现在组已经分好，那么如何选择已经匹配的分组？ 这里有两种方法，第一种使用$符号，比如$1 代表555,$2代表1234；第二种，使用\,比如\1代表555。两种的使用场景不一样，先讲$ 现在为了满足最开始的要求，我们可以这么做123reg: \(?(\d&#123;3&#125;)[-.)]\d&#123;3&#125;[-.]\d&#123;4&#125;replace: $1-xxx-xxxx ps: 这里可以直接用JS的replace函数进行操作，但是正则不是JS专属的，所以这里先介绍通用方法，之后对JS部分进行总结 1.3.2. 实景训练 现在有一个名单列表，但是姓和名称是反的，我需要把他交换过来1234shiffina, Danielshifafl, Daniellshquer, Danny... 实现方法:123reg: (\w+),\s(\w+)replace: $2 $1 注意：$0 是所有匹配到的，所以第一个加括号的是$1 匹配markdown中的link标签，并替换为html标签123[google](http://google.com)[itp](http://itp.nyu.edu)[Coding Rainbow](http://codingrainbow.com) 解析： 这道题有些坑，需要慢慢来。 看到这个，第一个想考虑匹配[google]这个东西，立马想到正则表达式\[.*\]。 这个是巨大的坑，在当前来看，它的确能正确匹配到上面的三条。 但是如果文本是这样的： 看到了，第一行的内容会全部匹配下来，而不能区分[google]和[test]。 之所以这样，是因为.是贪婪的，他表示所有，所有能匹配到的，所以当然也包括了]，一直到这一行的最后一个]，它才停止。 所以为了让它能正确匹配，需要去掉这种贪婪的属性。这里用到？ 。 当?放在了quantifiers符号后，表示去掉贪婪属性，匹配到终止条件，即可停下。 \[.*?\]这样子，就可以将[google]和[test]分开,效果如下： 接下来完成所有内容：123reg: \[(.*?)\]\((http.*?)\)replace: &lt;a href=&quot;$2&quot;&gt;$1&lt;/a&gt; 1.3.3. 使用\选择器$选择符是在替换的时候进行的标志或选择，但是如果在正则表达式本身，就要使用\选择了。比如以下的场景 12This is is a a dog , I think think this is is reallya a good good dog. Don&apos;t you you thinks so so ? 我们想要匹配比如is is so so这样连续的序列，就用到了下面的表达方式: (\w+)\s\1 效果: 嗯，差不多达到效果，但是有一些小的bug。比如第一句话This is is a 这个就匹配不准确，会把第一个This的后面字母匹配进去。这就用到第一节说的字符结界 \b了，就变成了\b(\w+)\s\1\b 好了，大功告成，就不贴效果图了，自行脑补就好了。 1.3.4. 总结 分组捕获，使用()进行数据分组，编号0代表整个匹配项，选择的分组从1号开始 选择器可以使用$1和\1，但是使用场景不同，\用在正则表达式自己身上 ?符号可以禁止贪婪属性，放在.*之后，表示一次匹配遇到重点就可以停止。否则将会一直向后匹配。 1.4. 在JavaScript中的应用在js中，主要的正则表达式都是涉及到string的应用。12var str = &quot;hello&quot;var r = /w+/ 这两个分别是string和reg的字面量创建方法。当要使用正则来进行操作的时候，使用了r.test()和str.match() 以及str.replace等方法。 1.4.1. reg.test()正则表达式本身有一个test的方法，这个方法只能测试是否包含，返回一个bool变量。12345678var r = /\d&#123;3&#125;/;var a = &apos;123&apos;;var b = &apos;123ABC&apos;;var c = &apos;abc&apos;;r.test(a) //truer.test(b) //truer.test(c) //false 嗯，这个很简单，而且用的实际不多，下面着重讲str上的一些方法。 1.4.2. str.match()与test()不同，不只是返回bool变量，它会返回你所匹配到的内容。123456var r = /compus/var reg = /w+/var s = "compus, I know something about you"r.test(s) //trues.match(r) //["compus"]s.match(reg) //["compus"] 等等，好像有点问题，为什么最后一个返回的也是”compus”？这不科学。 好吧，实际上，match()返回了第一个可以匹配的序列。想要实现之前的效果，就要用到JS里关于正则的几个flag 1.4.2.1. flag这个标志就在建立正则的时候就要有的，主要有三个 flag 含义 g 全部的，给我匹配全部的 i 忽略大小写 m 多行匹配 所以为了解决刚才的问题，只要这样子设置reg就可以了 1var reg = /w+/g 看下面一个练习1234567var str = "Here is a Phone Number 111-2313 and 133-2311"var r = /\d&#123;3&#125;[-.]\d&#123;4&#125;/var rg = /\d&#123;3&#125;[-.]d&#123;4&#125;/gconsole.log(str.match(r)); //["111-2313"]console.log(str.match(rg));//["111-2313","133-2311"] 嗯，找电话号码，是的，很方便。但是还有一个问题，刚才说的分组，那么match会返回分组吗？ 12345var sr = /(\d&#123;3&#125;)[-.]\d&#123;4&#125;/var srg = /(\d&#123;3&#125;)[-.]\d&#123;4&#125;/gconsole.log(str.match(sr)); //["111-2313","111"]console.log(str.match(srg)); //["111-2313","133-2311"] 所以结论是： 当使用了全局flagg的时候，不会返回分组，而是全部的匹配结果；如果没有使用g，会将匹配到的结果和分组以数组的形式返回。 那么如何实现全局的分组？ 1.4.3. reg.exec()从字面意思来看，正则表达式的执行方法。 这个方法可以实现匹配全局，并返回分组的结果。 reg.exec()每次调用，返回一个匹配的结果，匹配结果和分组以数组的形式返回，不断的调用即可返回下一个结果，直到返回null 1234567var str = "Here is a Phone Number 111-2313 and 133-2311" ;var srg = /(\d&#123;3&#125;)[-.]\d&#123;4&#125;/g;var result = srg.exec(str);while(result !== null) &#123; console.log(result); result = srg.exec(str);&#125; result包含的内容可能比想象中的多，它是一个数组，比如第一次执行，他的结果为：12["133-2311", "133", index: 36, input: "Here is a Phone Number 111-2313 and 133-2311" groups: undefined] 1.4.4. str.split现在来到了更强的功能上，先说下split，我们知道split是将字符串按照某个字符分隔开，比如有以下一段话，需要将其分割成单词。1var s = &quot;unicorns and rainbows And, Cupcakes&quot; 分割成单词，首先想到的是空格隔开，于是可以用下面方式实现1234var result = s.split(' ');var result1 = s.split(/\s/);//完全一样的效果//["unicorns", "and", "rainbows", "And,", "Cupcakes"] 嗯，这样体现不出来正则的强大，而且最主要的是没有实现要求。因为还有一个”And,”。所以要用正则了，匹配条件是逗号或者空格 123result = s.split(/[,\s]/);//["unicorns", "and", "rainbows", "And", "", "Cupcakes"] 结果仍然和需要的有出入，因为多了一个””。 我们并不是想让它分割的依据是逗号或者空格,依据应该是逗号或空格所在的连续序列。 在原来的基础上加一个+，改成/[,\s]+/，这个含义就是一个单独的逗号，或者一个单独的空格12result = s.split(/[,\s]+/);// ["unicorns", "and", "rainbows", "And", "Cupcakes"] 1.4.4.1. 单词分割好了，拓展一下，实现一个段落的单词分割，一个正则表达式就是1result = s.split(/[,.!?\s]+/) 当然，有个最简单的方法，我们可以这样去做1result = s.split(/\W+/); 接着，如果我们想将一个段落的句子都分隔开，一个可以实现的表达式就是1result = s.split(/[.,!?]+/) 最后，有一个小需求，就是在分割句子的同时，还想把相应的分隔符保留下来。12var s = "Hello,My name is Vincent. Nice to Meet you!What's your name? Haha." 这是一个小小的ponit，记住如果想要保留分隔符，只要给匹配的内容分组即可12var result = s.split(/([.,!?]+)/)//["Hello", ",", "My name is Vincent", ".", " Nice to Meet you", "!", "What's your name", "?", " Haha", ".", ""] 可以看到，这样就会把分隔符也存储起来。 1.4.5. str.replace()replace也是字符串的方法，它的基本用法是str.replace(reg,replace|function)，第一个参数是正则表达式，代表匹配的内容，第二个参数是替换的字符串或者一个回掉函数。 注意，replace不会修改原字符串，只是返回一个修改后的字符串;除此外，正则表达式如果没有使用g标志，也和match一样，只匹配/替换第一个 1.4.5.1. 最简单的替换 替换一个序列中的元音字母(aeiou)，将其替换成一个double。 比如x-&gt;xx 123var s = "Hello,My name is Vincent."var result = s.replace(/([aeiou])/g,"$1$1")//"Heelloo,My naamee iis Viinceent." 注意，第二个参数必须是字符串; 注意不要忘记加g 1.4.5.2. 牛x哄哄的function参数来了嗯，这才是最强大的地方，第二参数传入function，先看一个最简单的示例1234567891011121314var s = "Hello,My name is Vincent. What is your name?"var newStr = s.replace(/\b\w&#123;4&#125;\b/g,replacer)console.log(newStr)function replacer(match) &#123; console.log(match); return match.toUpperCase();&#125;/*nameWhatyournameHello,My NAME is Vincent. WHAT is YOUR NAME?*/ 所以，函数的参数是匹配到的内容，返回的是需要替换的内容。好了，基本示例解释了基本用法，那么之前讨论的分组怎么办？如何实现分组呢？123456//分组function replacer(match,group1,group2) &#123; console.log(group1); console.log(group2);&#125; 如果正则表达式分组处理，那么在回调函数中，函数的第二个、第三参数就是group1,group2。这样子，就可以做很多神奇的事情 1.4.5.3. 综合练习题 判断一个字符串中出现次数最多的字符，并统计次数 1234567var s = 'aaabbbcccaaabbbaaa';var a = s.split('').sort().join(""); //"aaaaaaaaabbbbbbccc"var ans = a.match(/(\w)\1+/g);ans.sort(function(a,b) &#123; return a.length - b.length;&#125;)console.log('ans is : ' + ans[ans.length]) 1.4.6. 总结 在js中，正则表达式字面量/reg/和字符串字面量&quot;str&quot;用于创建正则和字符串。其中正则上有两个方法reg.test()和reg.exec() reg.test(str)方法，返回布尔变量，用于指示是否有所匹配； reg.exec(str)有点类似与迭代器，每次执行，返回匹配结果和分组，直到返回为null结束。 字符串方法主要有str.match(reg),str.split(reg)和str.replace(reg,str|function) 三种方法。 match比较特殊，如果正则包含了分组，且没有g标志，则返回匹配内容和分组; 如果没有分组，且有g标志，返回所有匹配内容 split方法主要用于字符串分割，如果想要保存分隔符，记得将匹配内容分组(用小括号包起来) replace是最强大的方法，当使用回掉函数时，返回值就是替换值; 参数分别为匹配值 group1 group2…]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VK的秋招前端奇遇记(三)]]></title>
    <url>%2F2018%2F08%2F12%2F2018-08-12-VK-mistake-3%2F</url>
    <content type="text"><![CDATA[JavaScript总是给人以惊喜，学习不止，进步不断，今天继续补充JS容易搞错的几道笔试/面试题，为了秋招继续努力，欢迎一起为秋招努力的小伙伴共勉 系列笔记： 1.VK的秋招前端奇遇记(一) 2.VK的秋招前端奇遇记(二) 3.VK的秋招前端奇遇记(三) 4.VK的秋招前端奇遇记(四) 5.番外篇：前端面试&amp;笔试算法 Algorithm ”老生常错“的this与作用域相关Q1. 下面程序的输出结果是？1234567891011121314var length = 10;function fn() &#123; console.log(this.length);&#125;var obj = &#123; length: 5, method: function(fn) &#123; fn(); arguments[0](); &#125;&#125;;obj.method(fn, 1); output: 12102 这个我做错在第二个输出上，其实对this了解后就知道，第一个输出10应该是很显然的：虽然在程序执行时，使用了obj.method方法，让this指向了obj，但是真正的函数执行在函数体内部，也即当fn()执行的时候，this是指向window的，所以第一次执行结果是10 那么这里第二次执行arguments[0]为什么结果是2？ 分析下在method(fn,1)执行时，经历了什么： 首先两个参数fn和1会被放入arguments中，在arguments中第一个参数就是我们传入的函数；接下来fn执行，此时this没有绑定因此指向window，输出10。 然而到了arguments[0]()这一句，相当于把arguments[0]中的第一个参数拿来执行, 效果如下: 12arguments[0]() //执行,等同于下面的arguments.0() //当然这句话是不合法的，但是这样我们可以更清楚知道，this是指向arguments实例本身 arguments.length就是它本身的长度(arguments是一个类数组，具有length属性)，因此输出2 Q2. try..catch程序的输出结果12345678910(function () &#123; try &#123; throw new Error(); &#125; catch (x) &#123; var x = 1, y = 2; console.log(x); &#125; console.log(x); console.log(y);&#125;)(); 输出结果: 1231undefined2 我们都知道var是在预编译阶段会有一个变量提升，这种类型很容易解决，但是当遇到在catch(x)中与已有变量重名的情况，一定要区分两者之间的关系。 用变量提升的方法，把程序重写并分析如下： 123456789101112(function () &#123; var x,y; // 外部变量提升 try &#123; throw new Error(); &#125; catch (x/* 内部的x */) &#123; x = 1; //内部的x，和上面声明的x不是一回事！！ y = 2; //内部没有声明，作用域链向上找，外面的y console.log(x); //当然是1 &#125; console.log(x); //只声明，未赋值，undefined console.log(y); //就是2了&#125;)(); 这样子就很清晰，之后注意预编译的过程，把变量和函数定义进行提升后，进行分析，会清楚很多 Q3. 下面程序的输出123456var x = 21;var girl = function () &#123; console.log(x); var x = 20;&#125;;girl (); 输出： 1undefined 说实话，这个题目我没做错，我没做错，我没做错！ 因为和Q2一样，而且还没有Q2难，一句话解释就是： 函数内部变量提升。 相当于 1234567var x = 21;var girl = function() &#123; var x; console.log(x); // undefined x = 20;&#125;&#125; 那些诡异的边角知识Q1. 运算符考点： 下面程序输出是什么?12console.log(1 &lt; 2 &lt; 3);console.log(3 &gt; 2 &gt; 1); 输出: 12trueflase 第一个输出结果是好理解的，主要看下第二个为什么是false 核心在于js怎么去解析&lt;和&gt;运算符。 在JS中，这种运算符是从左向右运算的，所以3&gt;2&gt;1就被转换成了true&gt;1,而true的值是1，接着比较1&gt;1就返回false了。 Q2. typeof，下面输出结果是什么1console.log(typeof typeof 1); 答案是string 会输出string，这个题目不仅仅是typeof的考察，也是对js运算的一个考察。 在js中一般有两种操作 赋值操作，例如a = b 2&gt;3之类的，上面的题目提到过，是从左向右的顺序 取值操作， js问内存：有没有见过这个家伙？，比如console.log(a) typeof a 都属于这个类型，是从右向左的 因此，这个题就被分解为typeof 1返回&quot;number&quot;，注意是一个字符串。 接下来typeof &quot;number&quot;，返回string Q3. typeof undefined == typeof NULL输出结果是什么首先搞清楚两点： typeof undefined 输出是undefined typeof null输出是object 但是，另一方面，因为js对大小写敏感，null ≠ NULL，所以typeof NULL返回undefined` 结果是： true Q4. 递归设计。 实现一个函数，给该函数一个DOM节点，函数访问其所有子元素(所有子元素，不仅仅是直接子元素)，每次访问子元素的时候，并为其传一个callback。访问一个DOM tree，是一个经典的深度优先搜索的算法 1234567function Traverse(DOM,callback) &#123; callback(DOM); var list = DOM.children; Array.prototype.forEach.apply(list,(item)=&gt;&#123; Traverse(item,callback); //递归 &#125;)&#125;]]></content>
      <tags>
        <tag>前端面试</tag>
        <tag>JavaScript</tag>
        <tag>前端笔试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VK的秋招前端奇遇记(二)]]></title>
    <url>%2F2018%2F08%2F11%2F2018-08-11-VK-mistake-2%2F</url>
    <content type="text"><![CDATA[系列笔记： 1.VK的秋招前端奇遇记(一) 2.VK的秋招前端奇遇记(二) 3.VK的秋招前端奇遇记(三) 4.VK的秋招前端奇遇记(四) 5.番外篇：前端面试&amp;笔试算法 Algorithm JavaScript1. 数组的神奇变化请问以下输出是什么123456var arr1 = "john".split('');var arr2 = arr1.reverse();var arr3 = "jones".split('');arr2.push(arr3);console.log("array 1: length=" + arr1.length + " last=" + arr1.slice(-1));console.log("array 2: length=" + arr2.length + " last=" + arr2.slice(-1)); 答案：12"array 1: length=5 last=j,o,n,e,s""array 2: length=5 last=j,o,n,e,s" 是的，发现两个输出一样，先说这道题的核心，再好好想想吧 (1) 数组不是简单数据类型(值类型),会保存在堆中(heap)中，当使用var arr1 = arr2赋值时，只是浅拷贝，拿到了arr2的引用，这样带来的问题就是，修改arr1的时候arr2也会收到影响。 (2) arr1.push(arr2)，这就是为什么有一个函数叫concat，push会直接把整个数组push进去，而不会分开搞搞清楚以上两点，这个题基本上就解开了。 2.+ - 运算符之惑以下程序输出是什么？123456console.log(1 + "2" + "2");console.log(1 + +"2" + "2");console.log(1 + -"1" + "2");console.log(+"1" + "1" + "2");console.log( "A" - "B" + "2");console.log( "A" - "B" + 2); 答案：123456"122""32""02""112""NaN2"NaN 嗯，核心是以下几点，自己再细细思考 (1) - +会隐式转换为Number类型 (2) 当+ 作为运算符出现在String类型前时，会认为需要字符串拼接，因此会隐式转换为String (3) Number包含一个特殊的类型NaN,当对非数字进行Number转换时，会变为这个。 第一题： 第二条，认为需要字符串拼接 1被转换为1，答案122第二题： 注意到第二个2前面的+号，是符合第一条的，因此第二个2被转换为Number类型，答案为32第三题： 同理，答案02第五题： 运用(1)(3)，显然是NaN2，第六题同理 3.堆栈溢出之谜下面的代码将会造成栈溢出，请问如何优化，不改变原有逻辑12345678910var list = readHugeList();var nextListItem = function() &#123; var item = list.pop(); if (item) &#123; // process the list item... nextListItem(); &#125;&#125;; 答案：1234567var nextListItem = function() &#123; var item = list.pop(); if (item) &#123; // process the list item... setTimeout(nextListItem,0&#125;&#125;; 首先必须搞清楚，堆栈溢出的原因。 在JS中，不小心的操作或者编程习惯，很容易造成堆栈溢出，特别是进行回调或者循环的时候。 引用以下来说明溢出的原因： 原因是每次执行代码时，都会分配一定尺寸的栈空间（Windows系统中为1M），每次方法调用时都会在栈里储存一定信息（如参数、局部变量、返回值等等），这些信息再少也会占用一定空间，成千上万个此类空间累积起来，自然就超过线程的栈空间了。那么如何解决此类问题？ 这里介绍两个思路解决此问题： 异步 闭包 显然，这里就是使用的第一种方法，闭包。为什么使用setTimeout就可以解决问题？我们看下与没用之前的差别。如果没有使用setTimeout，那么函数将在大数据前不断的回调，直到最后走到重点，最初的函数才运行结束，释放内存。 但是如果使用了setTimeout，我们知道它是异步的，即使设置了时间为0，它也允许先执行下面的内容，可以释放堆栈，从而避免堆栈溢出的问题。换言之，加了setTimeout，nextListItem函数被压入事件队列，函数可以退出，因此每次会清空调用堆栈。 闭包 也是一样的道理，因为这道题要求不修改原有逻辑，第一种是最合适的答案，当然用闭包避免的方法就是返回出来一个函数12345678var nextListItem = function() &#123; var item = list.pop(); if (item) &#123; // process the list item... return nextListItem() &#125;&#125;; 当然，这样做会改变函数的调用方式，我们就需要不断的调用nextListItem()()()为了处理这个办法，可以对其进行进一步的封装12345678910111213141516var nextListItem = function() &#123; var item = list.pop(); if (item) &#123; // process the list item... return nextListItem() &#125;&#125;;function autoRun(fun) &#123; var value = nextListItem(); while(typeof value === 'function') &#123; value = nextListItem() &#125; return&#125; 这样，就解决堆栈溢出的问题。这里闭包的思路来源与堆栈溢出解决方案 4.你真的懂对象(Object)的key吗？下面函数的输出是什么？12345678var a=&#123;&#125;, b=&#123;key:'b'&#125;, c=&#123;key:'c'&#125;;a[b]=123;a[c]=456;console.log(a[b]); 答案：输出是这样的456，不是123，至少我有有点以外… 原因是什么呢？ 这里了解ES6新的数据类型map的应该就会意识到了，没错，对象的key值是只允许String类型的，这也是为什么引入了map数据类型了。 好了，那如果把一个对象作为key值，就会调用toString方法了。 Object.prototype.toString(obj)会得到什么呢？没错`[object Object]。 那所以12a[b] ==&gt; a[&quot;[object Object&quot;] = 123;a[b] ==&gt; a[&quot;[object Object&quot;] = 456; 答案，显而易见 5.回文判断请做一个回文判断的函数，判断是否是回文 答案： 这是一个很简单、很常规的方法。链表是最好的判断回文的方法，当然得益于JS数组的灵活方法，可以更容易实现。 这里主要考虑了一个健壮性的问题,多了一个正则来检测：1234function check(str) &#123; str = str.replace(/\W/g,'').toLowerCase(); return str === str.split('').reverse().join()&#125;]]></content>
      <tags>
        <tag>前端面试</tag>
        <tag>JavaScript</tag>
        <tag>前端笔试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VK的秋招前端奇遇记(一)]]></title>
    <url>%2F2018%2F08%2F10%2F2018-08-10-VK-mistake-1%2F</url>
    <content type="text"><![CDATA[这个系列主要是对自己秋招以来，笔试、面试过程中的问题进行记录和解决，希望自己能够”吃一堑长一智” 系列笔记： 1.VK的秋招前端奇遇记(一) 2.VK的秋招前端奇遇记(二) 3.VK的秋招前端奇遇记(三) 4.VK的秋招前端奇遇记(四) 5.番外篇：前端面试&amp;笔试算法 Algorithm 参考资料：37 Essential JavaScript Interview Questions有很多内容来自以上参考，真的可以说是非常经典了！ Css相关1. display:none与visibility:hidden的区别（2018拼多多前端笔试真题)答案：在视觉效果上，两者是相同的，但是对于操作dom上是不同的 。dispaly:none 会让dom的整个宽、高等相关位置元素失效，整个消失；visibility:hidden 只是让该元素不可见，但是width以及原有位置是不会改变的 javascript1. 基本问题1) 是否可以使用 typeof bar === &#39;object&#39;来检测bar是不是object类型，有和风险？答案： 有风险，js的基本数据类型有 String Number Boolean undefined null和一种复杂数据类型object(ES6新增了symbol)。 对于复杂数据类型object，其实typeof null返回的也是object，因为本质上null就是一个占位用的对象。另一方面，数组Array也不能用typeof检测数据类型，因为同样会返回object。 因此，如果想要检测bar是不是object，可以这样子：123console.log((bar !== null) &amp;&amp; (tiopnuiop[yuiop[]\\]poi456/ypeof bar ==='object'))//当然，如果认为function也是 object，可以用下面的语句console.log((bar !== nul)&amp;&amp; (typeof bar ==='object')||(typeof bar ==='function')) 除此以外，还有比如Array的情况，因为Array也会返回object，如果我们不像让Array被认为是Object，就必须真正的认清Array，人情Array的方法有：123console.log( bar instanceof Array) // 如果数组，返回trueconsole.log( Array.isArray(bar)) //ES5方法console.log( Ojbect.prototype.toString.call(arr) === '[object Array]') 2) 以下两个函数是否等价1234567891011121314function foo1()&#123; return &#123; bar: "hello" &#125;;&#125;function foo2()&#123; return &#123; bar: "hello" &#125;;&#125; 答案： 不等价！！注意，第二个函数返回的是undefined12console.log(foo1()); // &#123;bar : "hellp"&#125;console.log(foo2()); // undefined 这也是为什么函数返回对象时，或写大括号时，把{写在一边，因为第二个函数js会默认return后面返回的东西(是空),等价于123return undefined&#123;xxx&#125;//后面当然，当然是写了也白写 3) NaN是什么?它是什么类型？如何检测一个变量是不是NaN？答案： NaN即Not A Number，但实际上它是Number类型typeof NaN 将会返回Number。这个东西比较厉害，因为1NaN === NaN //false 你会发现，它自己都不等于它自己，因此判断变量是否是它，不能使用===。可以使用isNaN方法123//检查变量是否是nanisNaN(bar);Object.is(bar,NaN); //ES6方法，这个方法会修正JS中的一些小bug Object.is()方法，要求严格相等，且Object.is(NaN,NaN)会返回true 2.作用域相关问题以下程序的输出是什么:12345(function()&#123; var a = b = 3;&#125;)();console.log("a defined? " + (typeof a !== 'undefined'));console.log("b defined? " + (typeof b !== 'undefined')); 答案： a defined? false b defined? true 理解这道题的核心在于如何理解var a = b = 3这句话，实际上这句话等于12var a; b = 3; 这样子，实际上，b是声明在了全局变量中(编译器在预编译帮你声明了，然而在严格模式下是不行的)a是局部变量，所以在函数之外是没有定义的。 3.this&amp;对象&amp;数组1)下面程序输出是什么123456789101112131415161718192021var myObject = &#123; foo: "bar", func: function() &#123; var self = this; console.log("outer func: this.foo = " + this.foo); console.log("outer func: self.foo = " + self.foo); (function() &#123; console.log(this); console.log("inner func: this.foo = " + this.foo); console.log("inner func: self.foo = " + self.foo); &#125;()); &#125;&#125;;myObject.func();//答案outer func: this.foo = barouter func: serl.foo = barinner func: this.foo = undefinedinner func: self.foo = bar 分析： 搞清楚this的指向。记住以下几种规则 谁调用，this指向谁 xxx.fun() new一个对象，this指向实例本身var c = new fun() 使用call/apply/bind修改this指向。 看题目，outer func显然是第一种情况，谁调用，this指向谁，这个时候都是myOjbect。而在立即执行函数中，在这里this是没有进行绑定指向的，自然从属于window，所以这里this.foo是undefied 补充关于箭头函数的this12345678function a() &#123; return () =&gt; &#123; return () =&gt; &#123; console.log(this) &#125; &#125;&#125;console.log(a()()()) 注意：箭头函数其实是没有 this 的，这个函数中的 this 只取决于他外面的第一个不是箭头函数的函数的 this。在这个例子中，因为调用 a 符合前面代码中的第一个情况，所以 this 是 window。并且 this 一旦绑定了上下文，就不会被任何代码改变。 2)数组的filter，以下输出结果是什么(2018拼多多前端原题)12345678var arr = [1,2,3];arr[10] = 9;arr.filter((item)=&gt; &#123; return item === undefined?&#125;)//答案[] 解析： 是的，答案的确是[]，不是[undefined x 7]。首先，看下前两句执行后，arr是什么1234console.log(arr)//[1,2,3, emptyx7, 9]console.log(arr[5])//undefined 从上面结果可以看出，的确中间未定义的(显示为empty的是undefined)。那么，filter之后，不是应该返回为undefined的数据吗？ 是的，但是，当数组中都是undefined时，数组就是空，或者说[empty x 7] === [] 4. JS小数计算不准确的bug以下代码返回值是什么12345console.log(0.1 + 0.2);console.log(0.1 + 0.2 == 0.3);//答案: 0.30000000000000004 false 解析： 详细的解析见连接,这里说一下解决办法 0.1+0.2 != 0.312//解决办法parseFloat((0.1+0.2).toFixed(10)); 5. 算法/思路相关1) 讨论实现判断变量是否是整数的函数isInter(x)的实现答案： 在ES6中，是有现成的方法Number.isInteger可以使用的。如果自己实现，思路是什么呢12345678910//1 异或运算function isInter(x) &#123; return x ^ 0 === x&#125;//2 取整return Math.round(x) === x //同样可以用floor ceil//取余return (typeof x === 'number')&amp;&amp;(x % 1 === 0) 2) 写一个sum方法，可以实现以下两种调用方式12console.log(sum(2,3)) //5console.log(sum(2)(3)) //5 答案：12345678910111213141516171819202122//方法1var sum = function(x,y) &#123; if(y === undefined) &#123; return function(y) &#123; return x + y; &#125; &#125;else &#123; return x + y; &#125;&#125;//方法2var sum = function(x)&#123; if( arguments.length === 1) &#123; return function (y) &#123; return x + y; &#125; &#125; else &#123; console.log('here'); return arguments[0] + arguments[1]; &#125;&#125; 3） 使用递归的方法，将obj变为obj2的格式(拼多多2018前端笔试真题)1234567891011121314151617181920obj = [ &#123;id:1,parent:null&#125;, &#123;id:2,parent:1&#125;, &#123;id:3,parent:2&#125;]obj2 = &#123; obj:&#123; id: 1, parent: null, child: &#123; id: 2, parent: 1, child: &#123; id: ,3, parent: 2 &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>前端面试</tag>
        <tag>JavaScript</tag>
        <tag>前端笔试</tag>
      </tags>
  </entry>
</search>
